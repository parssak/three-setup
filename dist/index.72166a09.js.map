{"mappings":"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O;;;IAGTs4C;MACCriB;QACCj2B,OAAO;;MAERm2B;QACCn2B,WAAW4G,QAAQ,GAAG;;;IAGxB2xC;MACCniB;QACCp2B,OAAO;;MAERq2B;QACCr2B,OAAO;;MAERs2B;QACCt2B,OAAO;;;IAGTw4C;MACCjiB;QACCv2B,OAAO;;;IAGTy4C;MACCjiB;QACCx2B,OAAO;;;IAGT04C;MACC1hB;QACCh3B,OAAO;;;IAGT5O;MACCunD;QACC34C,OAAO;;MAER44C;QACC54C,OAAO;;MAER64C;QACC74C,OAAO;;MAER84C;QACC94C,WAAWi7B,MAAM;;;IAGnB+L;MACC+R;QACC/4C;;MAEDg5C;QACCh5C;;MAEDi5C;QACCj5C;QACAk5C;UACCr6B;UACA6V;;;MAGFykB;QACCn5C;QACAk5C;UACCE;UACAC;UACAC;UACAC;;;MAGFC;QACCx5C;;MAEDy5C;QACCz5C;;MAED05C;QACC15C;QACAk5C;UACCxkB;UACAxoC;UACA2yB;UACAlvB;UACAgqD;UACAC;UACAC;;;MAGFC;QACC95C;QACAk5C;UACCE;UACAC;UACAC;UACAC;;;MAGFQ;QACC/5C;;MAEDg6C;QACCh6C;;MAEDi6C;QACCj6C;QACAk5C;UACCxkB;UACAxoC;UACA2tD;UACAlqD;;;MAGFuqD;QACCl6C;QACAk5C;UACCE;UACAC;UACAC;UACAC;UACAY;UACAC;;;MAGFC;QACCr6C;;MAEDs6C;QACCt6C;;MAEDu6C;QACCv6C;QACAk5C;UACCr6B;UACA27B;UACAC;;;;MAIFC;QACC16C;QACAk5C;UACCxkB;UACAxoC;UACAuX;UACAC;;;MAGFi3C;QACC36C,OAAO;;MAER46C;QACC56C,OAAO;;;IAGT8Z;MACC69B;QACC33C,WAAWi7B,MAAM;;MAElBjJ;QACChyB,OAAO;;MAERka;QACCla,OAAO;;MAER+K;QACC/K,OAAO;;MAERjY;QACCiY,OAAO;;MAER01B;QACC11B,OAAO;;MAER43C;QACC53C,WAAWmL;;;IAGb2hC;MACC6K;QACC33C,WAAWi7B,MAAM;;MAElBjJ;QACChyB,OAAO;;MAER2G;QACC3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I;IACE,KAAK9hI,OAAO4wB,SAAS,KAAKqmB,UAAUorF,cAAc,KAAKprF,UAAUqrF;IACjE,KAAKtiI,OAAOkxB;IAEZ,KAAKv3C,SAASmgB,QAAQ,KAAKm9C,UAAUorF,aAAa,KAAKprF,UAAUqrF;IACjE,KAAK3oJ,SAASmzF,cAAc99F,OAAOuzJ;;;;;EAMrCntJ;IACE,KAAK6sJ,SAASvlI;IACd,KAAK/iB,SAASw5C,OAAO,KAAKp6C,OAAO,KAAKinB;;;;;;ACpE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["./node_modules/@parcel/runtime-browser-hmr/lib/HMRRuntime.js","./src/app.js","./node_modules/@parcel/transformer-js/lib/esmodule-helpers.js","./src/setup/index.js","./src/setup/Scene.js","../node_modules/three/build/three.js","./src/setup/CameraController.js","../node_modules/three-orbit-controls/index.js","./node_modules/uuid/index.js","./node_modules/uuid/v1.js","./node_modules/uuid/lib/rng-browser.js","./node_modules/uuid/lib/bytesToUuid.js","./node_modules/uuid/v4.js"],"sourcesContent":[null,null,null,null,null,"/**\n * @license\n * Copyright 2010-2021 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.THREE = {}));\n}(this, (function (exports) { 'use strict';\n\n\tconst REVISION = '129';\n\tconst MOUSE = {\n\t\tLEFT: 0,\n\t\tMIDDLE: 1,\n\t\tRIGHT: 2,\n\t\tROTATE: 0,\n\t\tDOLLY: 1,\n\t\tPAN: 2\n\t};\n\tconst TOUCH = {\n\t\tROTATE: 0,\n\t\tPAN: 1,\n\t\tDOLLY_PAN: 2,\n\t\tDOLLY_ROTATE: 3\n\t};\n\tconst CullFaceNone = 0;\n\tconst CullFaceBack = 1;\n\tconst CullFaceFront = 2;\n\tconst CullFaceFrontBack = 3;\n\tconst BasicShadowMap = 0;\n\tconst PCFShadowMap = 1;\n\tconst PCFSoftShadowMap = 2;\n\tconst VSMShadowMap = 3;\n\tconst FrontSide = 0;\n\tconst BackSide = 1;\n\tconst DoubleSide = 2;\n\tconst FlatShading = 1;\n\tconst SmoothShading = 2;\n\tconst NoBlending = 0;\n\tconst NormalBlending = 1;\n\tconst AdditiveBlending = 2;\n\tconst SubtractiveBlending = 3;\n\tconst MultiplyBlending = 4;\n\tconst CustomBlending = 5;\n\tconst AddEquation = 100;\n\tconst SubtractEquation = 101;\n\tconst ReverseSubtractEquation = 102;\n\tconst MinEquation = 103;\n\tconst MaxEquation = 104;\n\tconst ZeroFactor = 200;\n\tconst OneFactor = 201;\n\tconst SrcColorFactor = 202;\n\tconst OneMinusSrcColorFactor = 203;\n\tconst SrcAlphaFactor = 204;\n\tconst OneMinusSrcAlphaFactor = 205;\n\tconst DstAlphaFactor = 206;\n\tconst OneMinusDstAlphaFactor = 207;\n\tconst DstColorFactor = 208;\n\tconst OneMinusDstColorFactor = 209;\n\tconst SrcAlphaSaturateFactor = 210;\n\tconst NeverDepth = 0;\n\tconst AlwaysDepth = 1;\n\tconst LessDepth = 2;\n\tconst LessEqualDepth = 3;\n\tconst EqualDepth = 4;\n\tconst GreaterEqualDepth = 5;\n\tconst GreaterDepth = 6;\n\tconst NotEqualDepth = 7;\n\tconst MultiplyOperation = 0;\n\tconst MixOperation = 1;\n\tconst AddOperation = 2;\n\tconst NoToneMapping = 0;\n\tconst LinearToneMapping = 1;\n\tconst ReinhardToneMapping = 2;\n\tconst CineonToneMapping = 3;\n\tconst ACESFilmicToneMapping = 4;\n\tconst CustomToneMapping = 5;\n\tconst UVMapping = 300;\n\tconst CubeReflectionMapping = 301;\n\tconst CubeRefractionMapping = 302;\n\tconst EquirectangularReflectionMapping = 303;\n\tconst EquirectangularRefractionMapping = 304;\n\tconst CubeUVReflectionMapping = 306;\n\tconst CubeUVRefractionMapping = 307;\n\tconst RepeatWrapping = 1000;\n\tconst ClampToEdgeWrapping = 1001;\n\tconst MirroredRepeatWrapping = 1002;\n\tconst NearestFilter = 1003;\n\tconst NearestMipmapNearestFilter = 1004;\n\tconst NearestMipMapNearestFilter = 1004;\n\tconst NearestMipmapLinearFilter = 1005;\n\tconst NearestMipMapLinearFilter = 1005;\n\tconst LinearFilter = 1006;\n\tconst LinearMipmapNearestFilter = 1007;\n\tconst LinearMipMapNearestFilter = 1007;\n\tconst LinearMipmapLinearFilter = 1008;\n\tconst LinearMipMapLinearFilter = 1008;\n\tconst UnsignedByteType = 1009;\n\tconst ByteType = 1010;\n\tconst ShortType = 1011;\n\tconst UnsignedShortType = 1012;\n\tconst IntType = 1013;\n\tconst UnsignedIntType = 1014;\n\tconst FloatType = 1015;\n\tconst HalfFloatType = 1016;\n\tconst UnsignedShort4444Type = 1017;\n\tconst UnsignedShort5551Type = 1018;\n\tconst UnsignedShort565Type = 1019;\n\tconst UnsignedInt248Type = 1020;\n\tconst AlphaFormat = 1021;\n\tconst RGBFormat = 1022;\n\tconst RGBAFormat = 1023;\n\tconst LuminanceFormat = 1024;\n\tconst LuminanceAlphaFormat = 1025;\n\tconst RGBEFormat = RGBAFormat;\n\tconst DepthFormat = 1026;\n\tconst DepthStencilFormat = 1027;\n\tconst RedFormat = 1028;\n\tconst RedIntegerFormat = 1029;\n\tconst RGFormat = 1030;\n\tconst RGIntegerFormat = 1031;\n\tconst RGBIntegerFormat = 1032;\n\tconst RGBAIntegerFormat = 1033;\n\tconst RGB_S3TC_DXT1_Format = 33776;\n\tconst RGBA_S3TC_DXT1_Format = 33777;\n\tconst RGBA_S3TC_DXT3_Format = 33778;\n\tconst RGBA_S3TC_DXT5_Format = 33779;\n\tconst RGB_PVRTC_4BPPV1_Format = 35840;\n\tconst RGB_PVRTC_2BPPV1_Format = 35841;\n\tconst RGBA_PVRTC_4BPPV1_Format = 35842;\n\tconst RGBA_PVRTC_2BPPV1_Format = 35843;\n\tconst RGB_ETC1_Format = 36196;\n\tconst RGB_ETC2_Format = 37492;\n\tconst RGBA_ETC2_EAC_Format = 37496;\n\tconst RGBA_ASTC_4x4_Format = 37808;\n\tconst RGBA_ASTC_5x4_Format = 37809;\n\tconst RGBA_ASTC_5x5_Format = 37810;\n\tconst RGBA_ASTC_6x5_Format = 37811;\n\tconst RGBA_ASTC_6x6_Format = 37812;\n\tconst RGBA_ASTC_8x5_Format = 37813;\n\tconst RGBA_ASTC_8x6_Format = 37814;\n\tconst RGBA_ASTC_8x8_Format = 37815;\n\tconst RGBA_ASTC_10x5_Format = 37816;\n\tconst RGBA_ASTC_10x6_Format = 37817;\n\tconst RGBA_ASTC_10x8_Format = 37818;\n\tconst RGBA_ASTC_10x10_Format = 37819;\n\tconst RGBA_ASTC_12x10_Format = 37820;\n\tconst RGBA_ASTC_12x12_Format = 37821;\n\tconst RGBA_BPTC_Format = 36492;\n\tconst SRGB8_ALPHA8_ASTC_4x4_Format = 37840;\n\tconst SRGB8_ALPHA8_ASTC_5x4_Format = 37841;\n\tconst SRGB8_ALPHA8_ASTC_5x5_Format = 37842;\n\tconst SRGB8_ALPHA8_ASTC_6x5_Format = 37843;\n\tconst SRGB8_ALPHA8_ASTC_6x6_Format = 37844;\n\tconst SRGB8_ALPHA8_ASTC_8x5_Format = 37845;\n\tconst SRGB8_ALPHA8_ASTC_8x6_Format = 37846;\n\tconst SRGB8_ALPHA8_ASTC_8x8_Format = 37847;\n\tconst SRGB8_ALPHA8_ASTC_10x5_Format = 37848;\n\tconst SRGB8_ALPHA8_ASTC_10x6_Format = 37849;\n\tconst SRGB8_ALPHA8_ASTC_10x8_Format = 37850;\n\tconst SRGB8_ALPHA8_ASTC_10x10_Format = 37851;\n\tconst SRGB8_ALPHA8_ASTC_12x10_Format = 37852;\n\tconst SRGB8_ALPHA8_ASTC_12x12_Format = 37853;\n\tconst LoopOnce = 2200;\n\tconst LoopRepeat = 2201;\n\tconst LoopPingPong = 2202;\n\tconst InterpolateDiscrete = 2300;\n\tconst InterpolateLinear = 2301;\n\tconst InterpolateSmooth = 2302;\n\tconst ZeroCurvatureEnding = 2400;\n\tconst ZeroSlopeEnding = 2401;\n\tconst WrapAroundEnding = 2402;\n\tconst NormalAnimationBlendMode = 2500;\n\tconst AdditiveAnimationBlendMode = 2501;\n\tconst TrianglesDrawMode = 0;\n\tconst TriangleStripDrawMode = 1;\n\tconst TriangleFanDrawMode = 2;\n\tconst LinearEncoding = 3000;\n\tconst sRGBEncoding = 3001;\n\tconst GammaEncoding = 3007;\n\tconst RGBEEncoding = 3002;\n\tconst LogLuvEncoding = 3003;\n\tconst RGBM7Encoding = 3004;\n\tconst RGBM16Encoding = 3005;\n\tconst RGBDEncoding = 3006;\n\tconst BasicDepthPacking = 3200;\n\tconst RGBADepthPacking = 3201;\n\tconst TangentSpaceNormalMap = 0;\n\tconst ObjectSpaceNormalMap = 1;\n\tconst ZeroStencilOp = 0;\n\tconst KeepStencilOp = 7680;\n\tconst ReplaceStencilOp = 7681;\n\tconst IncrementStencilOp = 7682;\n\tconst DecrementStencilOp = 7683;\n\tconst IncrementWrapStencilOp = 34055;\n\tconst DecrementWrapStencilOp = 34056;\n\tconst InvertStencilOp = 5386;\n\tconst NeverStencilFunc = 512;\n\tconst LessStencilFunc = 513;\n\tconst EqualStencilFunc = 514;\n\tconst LessEqualStencilFunc = 515;\n\tconst GreaterStencilFunc = 516;\n\tconst NotEqualStencilFunc = 517;\n\tconst GreaterEqualStencilFunc = 518;\n\tconst AlwaysStencilFunc = 519;\n\tconst StaticDrawUsage = 35044;\n\tconst DynamicDrawUsage = 35048;\n\tconst StreamDrawUsage = 35040;\n\tconst StaticReadUsage = 35045;\n\tconst DynamicReadUsage = 35049;\n\tconst StreamReadUsage = 35041;\n\tconst StaticCopyUsage = 35046;\n\tconst DynamicCopyUsage = 35050;\n\tconst StreamCopyUsage = 35042;\n\tconst GLSL1 = '100';\n\tconst GLSL3 = '300 es';\n\n\t/**\n\t * https://github.com/mrdoob/eventdispatcher.js/\n\t */\n\tclass EventDispatcher {\n\t\taddEventListener(type, listener) {\n\t\t\tif (this._listeners === undefined) this._listeners = {};\n\t\t\tconst listeners = this._listeners;\n\n\t\t\tif (listeners[type] === undefined) {\n\t\t\t\tlisteners[type] = [];\n\t\t\t}\n\n\t\t\tif (listeners[type].indexOf(listener) === -1) {\n\t\t\t\tlisteners[type].push(listener);\n\t\t\t}\n\t\t}\n\n\t\thasEventListener(type, listener) {\n\t\t\tif (this._listeners === undefined) return false;\n\t\t\tconst listeners = this._listeners;\n\t\t\treturn listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;\n\t\t}\n\n\t\tremoveEventListener(type, listener) {\n\t\t\tif (this._listeners === undefined) return;\n\t\t\tconst listeners = this._listeners;\n\t\t\tconst listenerArray = listeners[type];\n\n\t\t\tif (listenerArray !== undefined) {\n\t\t\t\tconst index = listenerArray.indexOf(listener);\n\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tlistenerArray.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdispatchEvent(event) {\n\t\t\tif (this._listeners === undefined) return;\n\t\t\tconst listeners = this._listeners;\n\t\t\tconst listenerArray = listeners[event.type];\n\n\t\t\tif (listenerArray !== undefined) {\n\t\t\t\tevent.target = this; // Make a copy, in case listeners are removed while iterating.\n\n\t\t\t\tconst array = listenerArray.slice(0);\n\n\t\t\t\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\t\t\t\tarray[i].call(this, event);\n\t\t\t\t}\n\n\t\t\t\tevent.target = null;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tconst _lut = [];\n\n\tfor (let i = 0; i < 256; i++) {\n\t\t_lut[i] = (i < 16 ? '0' : '') + i.toString(16);\n\t}\n\n\tlet _seed = 1234567;\n\tconst DEG2RAD = Math.PI / 180;\n\tconst RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n\tfunction generateUUID() {\n\t\tconst d0 = Math.random() * 0xffffffff | 0;\n\t\tconst d1 = Math.random() * 0xffffffff | 0;\n\t\tconst d2 = Math.random() * 0xffffffff | 0;\n\t\tconst d3 = Math.random() * 0xffffffff | 0;\n\t\tconst uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.\n\n\t\treturn uuid.toUpperCase();\n\t}\n\n\tfunction clamp(value, min, max) {\n\t\treturn Math.max(min, Math.min(max, value));\n\t} // compute euclidian modulo of m % n\n\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\n\tfunction euclideanModulo(n, m) {\n\t\treturn (n % m + m) % m;\n\t} // Linear mapping from range <a1, a2> to range <b1, b2>\n\n\n\tfunction mapLinear(x, a1, a2, b1, b2) {\n\t\treturn b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n\t} // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\n\n\n\tfunction inverseLerp(x, y, value) {\n\t\tif (x !== y) {\n\t\t\treturn (value - x) / (y - x);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} // https://en.wikipedia.org/wiki/Linear_interpolation\n\n\n\tfunction lerp(x, y, t) {\n\t\treturn (1 - t) * x + t * y;\n\t} // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n\n\n\tfunction damp(x, y, lambda, dt) {\n\t\treturn lerp(x, y, 1 - Math.exp(-lambda * dt));\n\t} // https://www.desmos.com/calculator/vcsjnyz7x4\n\n\n\tfunction pingpong(x, length = 1) {\n\t\treturn length - Math.abs(euclideanModulo(x, length * 2) - length);\n\t} // http://en.wikipedia.org/wiki/Smoothstep\n\n\n\tfunction smoothstep(x, min, max) {\n\t\tif (x <= min) return 0;\n\t\tif (x >= max) return 1;\n\t\tx = (x - min) / (max - min);\n\t\treturn x * x * (3 - 2 * x);\n\t}\n\n\tfunction smootherstep(x, min, max) {\n\t\tif (x <= min) return 0;\n\t\tif (x >= max) return 1;\n\t\tx = (x - min) / (max - min);\n\t\treturn x * x * x * (x * (x * 6 - 15) + 10);\n\t} // Random integer from <low, high> interval\n\n\n\tfunction randInt(low, high) {\n\t\treturn low + Math.floor(Math.random() * (high - low + 1));\n\t} // Random float from <low, high> interval\n\n\n\tfunction randFloat(low, high) {\n\t\treturn low + Math.random() * (high - low);\n\t} // Random float from <-range/2, range/2> interval\n\n\n\tfunction randFloatSpread(range) {\n\t\treturn range * (0.5 - Math.random());\n\t} // Deterministic pseudo-random float in the interval [ 0, 1 ]\n\n\n\tfunction seededRandom(s) {\n\t\tif (s !== undefined) _seed = s % 2147483647; // Park-Miller algorithm\n\n\t\t_seed = _seed * 16807 % 2147483647;\n\t\treturn (_seed - 1) / 2147483646;\n\t}\n\n\tfunction degToRad(degrees) {\n\t\treturn degrees * DEG2RAD;\n\t}\n\n\tfunction radToDeg(radians) {\n\t\treturn radians * RAD2DEG;\n\t}\n\n\tfunction isPowerOfTwo(value) {\n\t\treturn (value & value - 1) === 0 && value !== 0;\n\t}\n\n\tfunction ceilPowerOfTwo(value) {\n\t\treturn Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n\t}\n\n\tfunction floorPowerOfTwo(value) {\n\t\treturn Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\n\t}\n\n\tfunction setQuaternionFromProperEuler(q, a, b, c, order) {\n\t\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\t\t// rotations are applied to the axes in the order specified by 'order'\n\t\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t\t// angles are in radians\n\t\tconst cos = Math.cos;\n\t\tconst sin = Math.sin;\n\t\tconst c2 = cos(b / 2);\n\t\tconst s2 = sin(b / 2);\n\t\tconst c13 = cos((a + c) / 2);\n\t\tconst s13 = sin((a + c) / 2);\n\t\tconst c1_3 = cos((a - c) / 2);\n\t\tconst s1_3 = sin((a - c) / 2);\n\t\tconst c3_1 = cos((c - a) / 2);\n\t\tconst s3_1 = sin((c - a) / 2);\n\n\t\tswitch (order) {\n\t\t\tcase 'XYX':\n\t\t\t\tq.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZY':\n\t\t\t\tq.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXZ':\n\t\t\t\tq.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZX':\n\t\t\t\tq.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXY':\n\t\t\t\tq.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYZ':\n\t\t\t\tq.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);\n\t\t}\n\t}\n\n\tvar MathUtils = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tDEG2RAD: DEG2RAD,\n\t\tRAD2DEG: RAD2DEG,\n\t\tgenerateUUID: generateUUID,\n\t\tclamp: clamp,\n\t\teuclideanModulo: euclideanModulo,\n\t\tmapLinear: mapLinear,\n\t\tinverseLerp: inverseLerp,\n\t\tlerp: lerp,\n\t\tdamp: damp,\n\t\tpingpong: pingpong,\n\t\tsmoothstep: smoothstep,\n\t\tsmootherstep: smootherstep,\n\t\trandInt: randInt,\n\t\trandFloat: randFloat,\n\t\trandFloatSpread: randFloatSpread,\n\t\tseededRandom: seededRandom,\n\t\tdegToRad: degToRad,\n\t\tradToDeg: radToDeg,\n\t\tisPowerOfTwo: isPowerOfTwo,\n\t\tceilPowerOfTwo: ceilPowerOfTwo,\n\t\tfloorPowerOfTwo: floorPowerOfTwo,\n\t\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler\n\t});\n\n\tclass Vector2 {\n\t\tconstructor(x = 0, y = 0) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tget width() {\n\t\t\treturn this.x;\n\t\t}\n\n\t\tset width(value) {\n\t\t\tthis.x = value;\n\t\t}\n\n\t\tget height() {\n\t\t\treturn this.y;\n\t\t}\n\n\t\tset height(value) {\n\t\t\tthis.y = value;\n\t\t}\n\n\t\tset(x, y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetScalar(scalar) {\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetX(x) {\n\t\t\tthis.x = x;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetY(y) {\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetComponent(index, value) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.x = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tthis.y = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetComponent(index) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn this.x;\n\n\t\t\t\tcase 1:\n\t\t\t\t\treturn this.y;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.x, this.y);\n\t\t}\n\n\t\tcopy(v) {\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tadd(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n\t\t\t\treturn this.addVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScalar(s) {\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\treturn this;\n\t\t}\n\n\t\taddVectors(a, b) {\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScaledVector(v, s) {\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsub(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n\t\t\t\treturn this.subVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubScalar(s) {\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubVectors(a, b) {\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(v) {\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(scalar) {\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tdivide(v) {\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tdivideScalar(scalar) {\n\t\t\treturn this.multiplyScalar(1 / scalar);\n\t\t}\n\n\t\tapplyMatrix3(m) {\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y;\n\t\t\tconst e = m.elements;\n\t\t\tthis.x = e[0] * x + e[3] * y + e[6];\n\t\t\tthis.y = e[1] * x + e[4] * y + e[7];\n\t\t\treturn this;\n\t\t}\n\n\t\tmin(v) {\n\t\t\tthis.x = Math.min(this.x, v.x);\n\t\t\tthis.y = Math.min(this.y, v.y);\n\t\t\treturn this;\n\t\t}\n\n\t\tmax(v) {\n\t\t\tthis.x = Math.max(this.x, v.x);\n\t\t\tthis.y = Math.max(this.y, v.y);\n\t\t\treturn this;\n\t\t}\n\n\t\tclamp(min, max) {\n\t\t\t// assumes min < max, componentwise\n\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\n\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampScalar(minVal, maxVal) {\n\t\t\tthis.x = Math.max(minVal, Math.min(maxVal, this.x));\n\t\t\tthis.y = Math.max(minVal, Math.min(maxVal, this.y));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampLength(min, max) {\n\t\t\tconst length = this.length();\n\t\t\treturn this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n\t\t}\n\n\t\tfloor() {\n\t\t\tthis.x = Math.floor(this.x);\n\t\t\tthis.y = Math.floor(this.y);\n\t\t\treturn this;\n\t\t}\n\n\t\tceil() {\n\t\t\tthis.x = Math.ceil(this.x);\n\t\t\tthis.y = Math.ceil(this.y);\n\t\t\treturn this;\n\t\t}\n\n\t\tround() {\n\t\t\tthis.x = Math.round(this.x);\n\t\t\tthis.y = Math.round(this.y);\n\t\t\treturn this;\n\t\t}\n\n\t\troundToZero() {\n\t\t\tthis.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n\t\t\tthis.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n\t\t\treturn this;\n\t\t}\n\n\t\tnegate() {\n\t\t\tthis.x = -this.x;\n\t\t\tthis.y = -this.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tdot(v) {\n\t\t\treturn this.x * v.x + this.y * v.y;\n\t\t}\n\n\t\tcross(v) {\n\t\t\treturn this.x * v.y - this.y * v.x;\n\t\t}\n\n\t\tlengthSq() {\n\t\t\treturn this.x * this.x + this.y * this.y;\n\t\t}\n\n\t\tlength() {\n\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t\t}\n\n\t\tmanhattanLength() {\n\t\t\treturn Math.abs(this.x) + Math.abs(this.y);\n\t\t}\n\n\t\tnormalize() {\n\t\t\treturn this.divideScalar(this.length() || 1);\n\t\t}\n\n\t\tangle() {\n\t\t\t// computes the angle in radians with respect to the positive x-axis\n\t\t\tconst angle = Math.atan2(-this.y, -this.x) + Math.PI;\n\t\t\treturn angle;\n\t\t}\n\n\t\tdistanceTo(v) {\n\t\t\treturn Math.sqrt(this.distanceToSquared(v));\n\t\t}\n\n\t\tdistanceToSquared(v) {\n\t\t\tconst dx = this.x - v.x,\n\t\t\t\t\t\tdy = this.y - v.y;\n\t\t\treturn dx * dx + dy * dy;\n\t\t}\n\n\t\tmanhattanDistanceTo(v) {\n\t\t\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n\t\t}\n\n\t\tsetLength(length) {\n\t\t\treturn this.normalize().multiplyScalar(length);\n\t\t}\n\n\t\tlerp(v, alpha) {\n\t\t\tthis.x += (v.x - this.x) * alpha;\n\t\t\tthis.y += (v.y - this.y) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerpVectors(v1, v2, alpha) {\n\t\t\tthis.x = v1.x + (v2.x - v1.x) * alpha;\n\t\t\tthis.y = v1.y + (v2.y - v1.y) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(v) {\n\t\t\treturn v.x === this.x && v.y === this.y;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tthis.x = array[offset];\n\t\t\tthis.y = array[offset + 1];\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this.x;\n\t\t\tarray[offset + 1] = this.y;\n\t\t\treturn array;\n\t\t}\n\n\t\tfromBufferAttribute(attribute, index, offset) {\n\t\t\tif (offset !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');\n\t\t\t}\n\n\t\t\tthis.x = attribute.getX(index);\n\t\t\tthis.y = attribute.getY(index);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateAround(center, angle) {\n\t\t\tconst c = Math.cos(angle),\n\t\t\t\t\t\ts = Math.sin(angle);\n\t\t\tconst x = this.x - center.x;\n\t\t\tconst y = this.y - center.y;\n\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\tthis.y = x * s + y * c + center.y;\n\t\t\treturn this;\n\t\t}\n\n\t\trandom() {\n\t\t\tthis.x = Math.random();\n\t\t\tthis.y = Math.random();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tVector2.prototype.isVector2 = true;\n\n\tclass Matrix3 {\n\t\tconstructor() {\n\t\t\tthis.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n\t\t\tif (arguments.length > 0) {\n\t\t\t\tconsole.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');\n\t\t\t}\n\t\t}\n\n\t\tset(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] = n11;\n\t\t\tte[1] = n21;\n\t\t\tte[2] = n31;\n\t\t\tte[3] = n12;\n\t\t\tte[4] = n22;\n\t\t\tte[5] = n32;\n\t\t\tte[6] = n13;\n\t\t\tte[7] = n23;\n\t\t\tte[8] = n33;\n\t\t\treturn this;\n\t\t}\n\n\t\tidentity() {\n\t\t\tthis.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(m) {\n\t\t\tconst te = this.elements;\n\t\t\tconst me = m.elements;\n\t\t\tte[0] = me[0];\n\t\t\tte[1] = me[1];\n\t\t\tte[2] = me[2];\n\t\t\tte[3] = me[3];\n\t\t\tte[4] = me[4];\n\t\t\tte[5] = me[5];\n\t\t\tte[6] = me[6];\n\t\t\tte[7] = me[7];\n\t\t\tte[8] = me[8];\n\t\t\treturn this;\n\t\t}\n\n\t\textractBasis(xAxis, yAxis, zAxis) {\n\t\t\txAxis.setFromMatrix3Column(this, 0);\n\t\t\tyAxis.setFromMatrix3Column(this, 1);\n\t\t\tzAxis.setFromMatrix3Column(this, 2);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromMatrix4(m) {\n\t\t\tconst me = m.elements;\n\t\t\tthis.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(m) {\n\t\t\treturn this.multiplyMatrices(this, m);\n\t\t}\n\n\t\tpremultiply(m) {\n\t\t\treturn this.multiplyMatrices(m, this);\n\t\t}\n\n\t\tmultiplyMatrices(a, b) {\n\t\t\tconst ae = a.elements;\n\t\t\tconst be = b.elements;\n\t\t\tconst te = this.elements;\n\t\t\tconst a11 = ae[0],\n\t\t\t\t\t\ta12 = ae[3],\n\t\t\t\t\t\ta13 = ae[6];\n\t\t\tconst a21 = ae[1],\n\t\t\t\t\t\ta22 = ae[4],\n\t\t\t\t\t\ta23 = ae[7];\n\t\t\tconst a31 = ae[2],\n\t\t\t\t\t\ta32 = ae[5],\n\t\t\t\t\t\ta33 = ae[8];\n\t\t\tconst b11 = be[0],\n\t\t\t\t\t\tb12 = be[3],\n\t\t\t\t\t\tb13 = be[6];\n\t\t\tconst b21 = be[1],\n\t\t\t\t\t\tb22 = be[4],\n\t\t\t\t\t\tb23 = be[7];\n\t\t\tconst b31 = be[2],\n\t\t\t\t\t\tb32 = be[5],\n\t\t\t\t\t\tb33 = be[8];\n\t\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\t\tte[3] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\t\tte[6] = a11 * b13 + a12 * b23 + a13 * b33;\n\t\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\t\tte[4] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\t\tte[7] = a21 * b13 + a22 * b23 + a23 * b33;\n\t\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\t\tte[5] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\t\tte[8] = a31 * b13 + a32 * b23 + a33 * b33;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(s) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] *= s;\n\t\t\tte[3] *= s;\n\t\t\tte[6] *= s;\n\t\t\tte[1] *= s;\n\t\t\tte[4] *= s;\n\t\t\tte[7] *= s;\n\t\t\tte[2] *= s;\n\t\t\tte[5] *= s;\n\t\t\tte[8] *= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tdeterminant() {\n\t\t\tconst te = this.elements;\n\t\t\tconst a = te[0],\n\t\t\t\t\t\tb = te[1],\n\t\t\t\t\t\tc = te[2],\n\t\t\t\t\t\td = te[3],\n\t\t\t\t\t\te = te[4],\n\t\t\t\t\t\tf = te[5],\n\t\t\t\t\t\tg = te[6],\n\t\t\t\t\t\th = te[7],\n\t\t\t\t\t\ti = te[8];\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\t\t}\n\n\t\tinvert() {\n\t\t\tconst te = this.elements,\n\t\t\t\t\t\tn11 = te[0],\n\t\t\t\t\t\tn21 = te[1],\n\t\t\t\t\t\tn31 = te[2],\n\t\t\t\t\t\tn12 = te[3],\n\t\t\t\t\t\tn22 = te[4],\n\t\t\t\t\t\tn32 = te[5],\n\t\t\t\t\t\tn13 = te[6],\n\t\t\t\t\t\tn23 = te[7],\n\t\t\t\t\t\tn33 = te[8],\n\t\t\t\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\t\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\t\t\t\tt13 = n23 * n12 - n22 * n13,\n\t\t\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\t\t\tif (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n\t\t\tconst detInv = 1 / det;\n\t\t\tte[0] = t11 * detInv;\n\t\t\tte[1] = (n31 * n23 - n33 * n21) * detInv;\n\t\t\tte[2] = (n32 * n21 - n31 * n22) * detInv;\n\t\t\tte[3] = t12 * detInv;\n\t\t\tte[4] = (n33 * n11 - n31 * n13) * detInv;\n\t\t\tte[5] = (n31 * n12 - n32 * n11) * detInv;\n\t\t\tte[6] = t13 * detInv;\n\t\t\tte[7] = (n21 * n13 - n23 * n11) * detInv;\n\t\t\tte[8] = (n22 * n11 - n21 * n12) * detInv;\n\t\t\treturn this;\n\t\t}\n\n\t\ttranspose() {\n\t\t\tlet tmp;\n\t\t\tconst m = this.elements;\n\t\t\ttmp = m[1];\n\t\t\tm[1] = m[3];\n\t\t\tm[3] = tmp;\n\t\t\ttmp = m[2];\n\t\t\tm[2] = m[6];\n\t\t\tm[6] = tmp;\n\t\t\ttmp = m[5];\n\t\t\tm[5] = m[7];\n\t\t\tm[7] = tmp;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetNormalMatrix(matrix4) {\n\t\t\treturn this.setFromMatrix4(matrix4).invert().transpose();\n\t\t}\n\n\t\ttransposeIntoArray(r) {\n\t\t\tconst m = this.elements;\n\t\t\tr[0] = m[0];\n\t\t\tr[1] = m[3];\n\t\t\tr[2] = m[6];\n\t\t\tr[3] = m[1];\n\t\t\tr[4] = m[4];\n\t\t\tr[5] = m[7];\n\t\t\tr[6] = m[2];\n\t\t\tr[7] = m[5];\n\t\t\tr[8] = m[8];\n\t\t\treturn this;\n\t\t}\n\n\t\tsetUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n\t\t\tconst c = Math.cos(rotation);\n\t\t\tconst s = Math.sin(rotation);\n\t\t\tthis.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tscale(sx, sy) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] *= sx;\n\t\t\tte[3] *= sx;\n\t\t\tte[6] *= sx;\n\t\t\tte[1] *= sy;\n\t\t\tte[4] *= sy;\n\t\t\tte[7] *= sy;\n\t\t\treturn this;\n\t\t}\n\n\t\trotate(theta) {\n\t\t\tconst c = Math.cos(theta);\n\t\t\tconst s = Math.sin(theta);\n\t\t\tconst te = this.elements;\n\t\t\tconst a11 = te[0],\n\t\t\t\t\t\ta12 = te[3],\n\t\t\t\t\t\ta13 = te[6];\n\t\t\tconst a21 = te[1],\n\t\t\t\t\t\ta22 = te[4],\n\t\t\t\t\t\ta23 = te[7];\n\t\t\tte[0] = c * a11 + s * a21;\n\t\t\tte[3] = c * a12 + s * a22;\n\t\t\tte[6] = c * a13 + s * a23;\n\t\t\tte[1] = -s * a11 + c * a21;\n\t\t\tte[4] = -s * a12 + c * a22;\n\t\t\tte[7] = -s * a13 + c * a23;\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(tx, ty) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] += tx * te[2];\n\t\t\tte[3] += tx * te[5];\n\t\t\tte[6] += tx * te[8];\n\t\t\tte[1] += ty * te[2];\n\t\t\tte[4] += ty * te[5];\n\t\t\tte[7] += ty * te[8];\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(matrix) {\n\t\t\tconst te = this.elements;\n\t\t\tconst me = matrix.elements;\n\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tif (te[i] !== me[i]) return false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.elements[i] = array[i + offset];\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tconst te = this.elements;\n\t\t\tarray[offset] = te[0];\n\t\t\tarray[offset + 1] = te[1];\n\t\t\tarray[offset + 2] = te[2];\n\t\t\tarray[offset + 3] = te[3];\n\t\t\tarray[offset + 4] = te[4];\n\t\t\tarray[offset + 5] = te[5];\n\t\t\tarray[offset + 6] = te[6];\n\t\t\tarray[offset + 7] = te[7];\n\t\t\tarray[offset + 8] = te[8];\n\t\t\treturn array;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().fromArray(this.elements);\n\t\t}\n\n\t}\n\n\tMatrix3.prototype.isMatrix3 = true;\n\n\tlet _canvas;\n\n\tclass ImageUtils {\n\t\tstatic getDataURL(image) {\n\t\t\tif (/^data:/i.test(image.src)) {\n\t\t\t\treturn image.src;\n\t\t\t}\n\n\t\t\tif (typeof HTMLCanvasElement == 'undefined') {\n\t\t\t\treturn image.src;\n\t\t\t}\n\n\t\t\tlet canvas;\n\n\t\t\tif (image instanceof HTMLCanvasElement) {\n\t\t\t\tcanvas = image;\n\t\t\t} else {\n\t\t\t\tif (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');\n\t\t\t\t_canvas.width = image.width;\n\t\t\t\t_canvas.height = image.height;\n\n\t\t\t\tconst context = _canvas.getContext('2d');\n\n\t\t\t\tif (image instanceof ImageData) {\n\t\t\t\t\tcontext.putImageData(image, 0, 0);\n\t\t\t\t} else {\n\t\t\t\t\tcontext.drawImage(image, 0, 0, image.width, image.height);\n\t\t\t\t}\n\n\t\t\t\tcanvas = _canvas;\n\t\t\t}\n\n\t\t\tif (canvas.width > 2048 || canvas.height > 2048) {\n\t\t\t\tconsole.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);\n\t\t\t\treturn canvas.toDataURL('image/jpeg', 0.6);\n\t\t\t} else {\n\t\t\t\treturn canvas.toDataURL('image/png');\n\t\t\t}\n\t\t}\n\n\t}\n\n\tlet textureId = 0;\n\n\tclass Texture extends EventDispatcher {\n\t\tconstructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {\n\t\t\tsuper();\n\t\t\tObject.defineProperty(this, 'id', {\n\t\t\t\tvalue: textureId++\n\t\t\t});\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.name = '';\n\t\t\tthis.image = image;\n\t\t\tthis.mipmaps = [];\n\t\t\tthis.mapping = mapping;\n\t\t\tthis.wrapS = wrapS;\n\t\t\tthis.wrapT = wrapT;\n\t\t\tthis.magFilter = magFilter;\n\t\t\tthis.minFilter = minFilter;\n\t\t\tthis.anisotropy = anisotropy;\n\t\t\tthis.format = format;\n\t\t\tthis.internalFormat = null;\n\t\t\tthis.type = type;\n\t\t\tthis.offset = new Vector2(0, 0);\n\t\t\tthis.repeat = new Vector2(1, 1);\n\t\t\tthis.center = new Vector2(0, 0);\n\t\t\tthis.rotation = 0;\n\t\t\tthis.matrixAutoUpdate = true;\n\t\t\tthis.matrix = new Matrix3();\n\t\t\tthis.generateMipmaps = true;\n\t\t\tthis.premultiplyAlpha = false;\n\t\t\tthis.flipY = true;\n\t\t\tthis.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\t\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t\t//\n\t\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t\t// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\n\t\t\tthis.encoding = encoding;\n\t\t\tthis.version = 0;\n\t\t\tthis.onUpdate = null;\n\t\t}\n\n\t\tupdateMatrix() {\n\t\t\tthis.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.name = source.name;\n\t\t\tthis.image = source.image;\n\t\t\tthis.mipmaps = source.mipmaps.slice(0);\n\t\t\tthis.mapping = source.mapping;\n\t\t\tthis.wrapS = source.wrapS;\n\t\t\tthis.wrapT = source.wrapT;\n\t\t\tthis.magFilter = source.magFilter;\n\t\t\tthis.minFilter = source.minFilter;\n\t\t\tthis.anisotropy = source.anisotropy;\n\t\t\tthis.format = source.format;\n\t\t\tthis.internalFormat = source.internalFormat;\n\t\t\tthis.type = source.type;\n\t\t\tthis.offset.copy(source.offset);\n\t\t\tthis.repeat.copy(source.repeat);\n\t\t\tthis.center.copy(source.center);\n\t\t\tthis.rotation = source.rotation;\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\tthis.matrix.copy(source.matrix);\n\t\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\t\tthis.flipY = source.flipY;\n\t\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\t\tthis.encoding = source.encoding;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst isRootObject = meta === undefined || typeof meta === 'string';\n\n\t\t\tif (!isRootObject && meta.textures[this.uuid] !== undefined) {\n\t\t\t\treturn meta.textures[this.uuid];\n\t\t\t}\n\n\t\t\tconst output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Texture',\n\t\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t\t},\n\t\t\t\tuuid: this.uuid,\n\t\t\t\tname: this.name,\n\t\t\t\tmapping: this.mapping,\n\t\t\t\trepeat: [this.repeat.x, this.repeat.y],\n\t\t\t\toffset: [this.offset.x, this.offset.y],\n\t\t\t\tcenter: [this.center.x, this.center.y],\n\t\t\t\trotation: this.rotation,\n\t\t\t\twrap: [this.wrapS, this.wrapT],\n\t\t\t\tformat: this.format,\n\t\t\t\ttype: this.type,\n\t\t\t\tencoding: this.encoding,\n\t\t\t\tminFilter: this.minFilter,\n\t\t\t\tmagFilter: this.magFilter,\n\t\t\t\tanisotropy: this.anisotropy,\n\t\t\t\tflipY: this.flipY,\n\t\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\t\tunpackAlignment: this.unpackAlignment\n\t\t\t};\n\n\t\t\tif (this.image !== undefined) {\n\t\t\t\t// TODO: Move to THREE.Image\n\t\t\t\tconst image = this.image;\n\n\t\t\t\tif (image.uuid === undefined) {\n\t\t\t\t\timage.uuid = generateUUID(); // UGH\n\t\t\t\t}\n\n\t\t\t\tif (!isRootObject && meta.images[image.uuid] === undefined) {\n\t\t\t\t\tlet url;\n\n\t\t\t\t\tif (Array.isArray(image)) {\n\t\t\t\t\t\t// process array of images e.g. CubeTexture\n\t\t\t\t\t\turl = [];\n\n\t\t\t\t\t\tfor (let i = 0, l = image.length; i < l; i++) {\n\t\t\t\t\t\t\t// check cube texture with data textures\n\t\t\t\t\t\t\tif (image[i].isDataTexture) {\n\t\t\t\t\t\t\t\turl.push(serializeImage(image[i].image));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\turl.push(serializeImage(image[i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// process single image\n\t\t\t\t\t\turl = serializeImage(image);\n\t\t\t\t\t}\n\n\t\t\t\t\tmeta.images[image.uuid] = {\n\t\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\t\turl: url\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\toutput.image = image.uuid;\n\t\t\t}\n\n\t\t\tif (!isRootObject) {\n\t\t\t\tmeta.textures[this.uuid] = output;\n\t\t\t}\n\n\t\t\treturn output;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'dispose'\n\t\t\t});\n\t\t}\n\n\t\ttransformUv(uv) {\n\t\t\tif (this.mapping !== UVMapping) return uv;\n\t\t\tuv.applyMatrix3(this.matrix);\n\n\t\t\tif (uv.x < 0 || uv.x > 1) {\n\t\t\t\tswitch (this.wrapS) {\n\t\t\t\t\tcase RepeatWrapping:\n\t\t\t\t\t\tuv.x = uv.x - Math.floor(uv.x);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\t\t\t\t\t\tif (Math.abs(Math.floor(uv.x) % 2) === 1) {\n\t\t\t\t\t\t\tuv.x = Math.ceil(uv.x) - uv.x;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor(uv.x);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (uv.y < 0 || uv.y > 1) {\n\t\t\t\tswitch (this.wrapT) {\n\t\t\t\t\tcase RepeatWrapping:\n\t\t\t\t\t\tuv.y = uv.y - Math.floor(uv.y);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\t\t\t\t\t\tif (Math.abs(Math.floor(uv.y) % 2) === 1) {\n\t\t\t\t\t\t\tuv.y = Math.ceil(uv.y) - uv.y;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor(uv.y);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.flipY) {\n\t\t\t\tuv.y = 1 - uv.y;\n\t\t\t}\n\n\t\t\treturn uv;\n\t\t}\n\n\t\tset needsUpdate(value) {\n\t\t\tif (value === true) this.version++;\n\t\t}\n\n\t}\n\n\tTexture.DEFAULT_IMAGE = undefined;\n\tTexture.DEFAULT_MAPPING = UVMapping;\n\tTexture.prototype.isTexture = true;\n\n\tfunction serializeImage(image) {\n\t\tif (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n\t\t\t// default images\n\t\t\treturn ImageUtils.getDataURL(image);\n\t\t} else {\n\t\t\tif (image.data) {\n\t\t\t\t// images of DataTexture\n\t\t\t\treturn {\n\t\t\t\t\tdata: Array.prototype.slice.call(image.data),\n\t\t\t\t\twidth: image.width,\n\t\t\t\t\theight: image.height,\n\t\t\t\t\ttype: image.data.constructor.name\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tconsole.warn('THREE.Texture: Unable to serialize Texture.');\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Vector4 {\n\t\tconstructor(x = 0, y = 0, z = 0, w = 1) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\t\t}\n\n\t\tget width() {\n\t\t\treturn this.z;\n\t\t}\n\n\t\tset width(value) {\n\t\t\tthis.z = value;\n\t\t}\n\n\t\tget height() {\n\t\t\treturn this.w;\n\t\t}\n\n\t\tset height(value) {\n\t\t\tthis.w = value;\n\t\t}\n\n\t\tset(x, y, z, w) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetScalar(scalar) {\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\t\t\tthis.w = scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetX(x) {\n\t\t\tthis.x = x;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetY(y) {\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetZ(z) {\n\t\t\tthis.z = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetW(w) {\n\t\t\tthis.w = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetComponent(index, value) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.x = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tthis.y = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.z = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\t\tthis.w = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetComponent(index) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn this.x;\n\n\t\t\t\tcase 1:\n\t\t\t\t\treturn this.y;\n\n\t\t\t\tcase 2:\n\t\t\t\t\treturn this.z;\n\n\t\t\t\tcase 3:\n\t\t\t\t\treturn this.w;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.x, this.y, this.z, this.w);\n\t\t}\n\n\t\tcopy(v) {\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\t\t\tthis.w = v.w !== undefined ? v.w : 1;\n\t\t\treturn this;\n\t\t}\n\n\t\tadd(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n\t\t\t\treturn this.addVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\t\t\tthis.w += v.w;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScalar(s) {\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\t\t\tthis.w += s;\n\t\t\treturn this;\n\t\t}\n\n\t\taddVectors(a, b) {\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\t\t\tthis.w = a.w + b.w;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScaledVector(v, s) {\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\t\t\tthis.w += v.w * s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsub(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n\t\t\t\treturn this.subVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\t\t\tthis.w -= v.w;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubScalar(s) {\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\t\t\tthis.w -= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubVectors(a, b) {\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\t\t\tthis.w = a.w - b.w;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(v) {\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\tthis.z *= v.z;\n\t\t\tthis.w *= v.w;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(scalar) {\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\t\t\tthis.w *= scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyMatrix4(m) {\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y,\n\t\t\t\t\t\tz = this.z,\n\t\t\t\t\t\tw = this.w;\n\t\t\tconst e = m.elements;\n\t\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n\t\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n\t\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n\t\t\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n\t\t\treturn this;\n\t\t}\n\n\t\tdivideScalar(scalar) {\n\t\t\treturn this.multiplyScalar(1 / scalar);\n\t\t}\n\n\t\tsetAxisAngleFromQuaternion(q) {\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\t\t\t// q is assumed to be normalized\n\t\t\tthis.w = 2 * Math.acos(q.w);\n\t\t\tconst s = Math.sqrt(1 - q.w * q.w);\n\n\t\t\tif (s < 0.0001) {\n\t\t\t\tthis.x = 1;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\t\t\t} else {\n\t\t\t\tthis.x = q.x / s;\n\t\t\t\tthis.y = q.y / s;\n\t\t\t\tthis.z = q.z / s;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetAxisAngleFromRotationMatrix(m) {\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\t\tlet angle, x, y, z; // variables for result\n\n\t\t\tconst epsilon = 0.01,\n\t\t\t\t\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\n\t\t\t\t\t\t// margin to distinguish between 0 and 180 degrees\n\t\t\tte = m.elements,\n\t\t\t\t\t\tm11 = te[0],\n\t\t\t\t\t\tm12 = te[4],\n\t\t\t\t\t\tm13 = te[8],\n\t\t\t\t\t\tm21 = te[1],\n\t\t\t\t\t\tm22 = te[5],\n\t\t\t\t\t\tm23 = te[9],\n\t\t\t\t\t\tm31 = te[2],\n\t\t\t\t\t\tm32 = te[6],\n\t\t\t\t\t\tm33 = te[10];\n\n\t\t\tif (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n\t\t\t\t// singularity found\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t\t// in leading diagonal and zero in other terms\n\t\t\t\tif (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\n\t\t\t\t\tthis.set(1, 0, 0, 0);\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\n\t\t\t\t} // otherwise this singularity is angle = 180\n\n\n\t\t\t\tangle = Math.PI;\n\t\t\t\tconst xx = (m11 + 1) / 2;\n\t\t\t\tconst yy = (m22 + 1) / 2;\n\t\t\t\tconst zz = (m33 + 1) / 2;\n\t\t\t\tconst xy = (m12 + m21) / 4;\n\t\t\t\tconst xz = (m13 + m31) / 4;\n\t\t\t\tconst yz = (m23 + m32) / 4;\n\n\t\t\t\tif (xx > yy && xx > zz) {\n\t\t\t\t\t// m11 is the largest diagonal term\n\t\t\t\t\tif (xx < epsilon) {\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0.707106781;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx = Math.sqrt(xx);\n\t\t\t\t\t\ty = xy / x;\n\t\t\t\t\t\tz = xz / x;\n\t\t\t\t\t}\n\t\t\t\t} else if (yy > zz) {\n\t\t\t\t\t// m22 is the largest diagonal term\n\t\t\t\t\tif (yy < epsilon) {\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\tz = 0.707106781;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty = Math.sqrt(yy);\n\t\t\t\t\t\tx = xy / y;\n\t\t\t\t\t\tz = yz / y;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// m33 is the largest diagonal term so base result on this\n\t\t\t\t\tif (zz < epsilon) {\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tz = Math.sqrt(zz);\n\t\t\t\t\t\tx = xz / z;\n\t\t\t\t\t\ty = yz / z;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.set(x, y, z, angle);\n\t\t\t\treturn this; // return 180 deg rotation\n\t\t\t} // as we have reached here there are no singularities so we can handle normally\n\n\n\t\t\tlet s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize\n\n\t\t\tif (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\t\tthis.x = (m32 - m23) / s;\n\t\t\tthis.y = (m13 - m31) / s;\n\t\t\tthis.z = (m21 - m12) / s;\n\t\t\tthis.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n\t\t\treturn this;\n\t\t}\n\n\t\tmin(v) {\n\t\t\tthis.x = Math.min(this.x, v.x);\n\t\t\tthis.y = Math.min(this.y, v.y);\n\t\t\tthis.z = Math.min(this.z, v.z);\n\t\t\tthis.w = Math.min(this.w, v.w);\n\t\t\treturn this;\n\t\t}\n\n\t\tmax(v) {\n\t\t\tthis.x = Math.max(this.x, v.x);\n\t\t\tthis.y = Math.max(this.y, v.y);\n\t\t\tthis.z = Math.max(this.z, v.z);\n\t\t\tthis.w = Math.max(this.w, v.w);\n\t\t\treturn this;\n\t\t}\n\n\t\tclamp(min, max) {\n\t\t\t// assumes min < max, componentwise\n\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\n\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\n\t\t\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\n\t\t\tthis.w = Math.max(min.w, Math.min(max.w, this.w));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampScalar(minVal, maxVal) {\n\t\t\tthis.x = Math.max(minVal, Math.min(maxVal, this.x));\n\t\t\tthis.y = Math.max(minVal, Math.min(maxVal, this.y));\n\t\t\tthis.z = Math.max(minVal, Math.min(maxVal, this.z));\n\t\t\tthis.w = Math.max(minVal, Math.min(maxVal, this.w));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampLength(min, max) {\n\t\t\tconst length = this.length();\n\t\t\treturn this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n\t\t}\n\n\t\tfloor() {\n\t\t\tthis.x = Math.floor(this.x);\n\t\t\tthis.y = Math.floor(this.y);\n\t\t\tthis.z = Math.floor(this.z);\n\t\t\tthis.w = Math.floor(this.w);\n\t\t\treturn this;\n\t\t}\n\n\t\tceil() {\n\t\t\tthis.x = Math.ceil(this.x);\n\t\t\tthis.y = Math.ceil(this.y);\n\t\t\tthis.z = Math.ceil(this.z);\n\t\t\tthis.w = Math.ceil(this.w);\n\t\t\treturn this;\n\t\t}\n\n\t\tround() {\n\t\t\tthis.x = Math.round(this.x);\n\t\t\tthis.y = Math.round(this.y);\n\t\t\tthis.z = Math.round(this.z);\n\t\t\tthis.w = Math.round(this.w);\n\t\t\treturn this;\n\t\t}\n\n\t\troundToZero() {\n\t\t\tthis.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n\t\t\tthis.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n\t\t\tthis.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n\t\t\tthis.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);\n\t\t\treturn this;\n\t\t}\n\n\t\tnegate() {\n\t\t\tthis.x = -this.x;\n\t\t\tthis.y = -this.y;\n\t\t\tthis.z = -this.z;\n\t\t\tthis.w = -this.w;\n\t\t\treturn this;\n\t\t}\n\n\t\tdot(v) {\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\t\t}\n\n\t\tlengthSq() {\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\t\t}\n\n\t\tlength() {\n\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n\t\t}\n\n\t\tmanhattanLength() {\n\t\t\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n\t\t}\n\n\t\tnormalize() {\n\t\t\treturn this.divideScalar(this.length() || 1);\n\t\t}\n\n\t\tsetLength(length) {\n\t\t\treturn this.normalize().multiplyScalar(length);\n\t\t}\n\n\t\tlerp(v, alpha) {\n\t\t\tthis.x += (v.x - this.x) * alpha;\n\t\t\tthis.y += (v.y - this.y) * alpha;\n\t\t\tthis.z += (v.z - this.z) * alpha;\n\t\t\tthis.w += (v.w - this.w) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerpVectors(v1, v2, alpha) {\n\t\t\tthis.x = v1.x + (v2.x - v1.x) * alpha;\n\t\t\tthis.y = v1.y + (v2.y - v1.y) * alpha;\n\t\t\tthis.z = v1.z + (v2.z - v1.z) * alpha;\n\t\t\tthis.w = v1.w + (v2.w - v1.w) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(v) {\n\t\t\treturn v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tthis.x = array[offset];\n\t\t\tthis.y = array[offset + 1];\n\t\t\tthis.z = array[offset + 2];\n\t\t\tthis.w = array[offset + 3];\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this.x;\n\t\t\tarray[offset + 1] = this.y;\n\t\t\tarray[offset + 2] = this.z;\n\t\t\tarray[offset + 3] = this.w;\n\t\t\treturn array;\n\t\t}\n\n\t\tfromBufferAttribute(attribute, index, offset) {\n\t\t\tif (offset !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');\n\t\t\t}\n\n\t\t\tthis.x = attribute.getX(index);\n\t\t\tthis.y = attribute.getY(index);\n\t\t\tthis.z = attribute.getZ(index);\n\t\t\tthis.w = attribute.getW(index);\n\t\t\treturn this;\n\t\t}\n\n\t\trandom() {\n\t\t\tthis.x = Math.random();\n\t\t\tthis.y = Math.random();\n\t\t\tthis.z = Math.random();\n\t\t\tthis.w = Math.random();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tVector4.prototype.isVector4 = true;\n\n\t/*\n\t In options, we can specify:\n\t * Texture parameters for an auto-generated target texture\n\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n\t*/\n\n\tclass WebGLRenderTarget extends EventDispatcher {\n\t\tconstructor(width, height, options) {\n\t\t\tsuper();\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.depth = 1;\n\t\t\tthis.scissor = new Vector4(0, 0, width, height);\n\t\t\tthis.scissorTest = false;\n\t\t\tthis.viewport = new Vector4(0, 0, width, height);\n\t\t\toptions = options || {};\n\t\t\tthis.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);\n\t\t\tthis.texture.image = {};\n\t\t\tthis.texture.image.width = width;\n\t\t\tthis.texture.image.height = height;\n\t\t\tthis.texture.image.depth = 1;\n\t\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\t\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;\n\t\t\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\t\t}\n\n\t\tsetTexture(texture) {\n\t\t\ttexture.image = {\n\t\t\t\twidth: this.width,\n\t\t\t\theight: this.height,\n\t\t\t\tdepth: this.depth\n\t\t\t};\n\t\t\tthis.texture = texture;\n\t\t}\n\n\t\tsetSize(width, height, depth = 1) {\n\t\t\tif (this.width !== width || this.height !== height || this.depth !== depth) {\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\t\t\t\tthis.depth = depth;\n\t\t\t\tthis.texture.image.width = width;\n\t\t\t\tthis.texture.image.height = height;\n\t\t\t\tthis.texture.image.depth = depth;\n\t\t\t\tthis.dispose();\n\t\t\t}\n\n\t\t\tthis.viewport.set(0, 0, width, height);\n\t\t\tthis.scissor.set(0, 0, width, height);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\t\t\tthis.depth = source.depth;\n\t\t\tthis.viewport.copy(source.viewport);\n\t\t\tthis.texture = source.texture.clone();\n\t\t\tthis.texture.image = { ...this.texture.image\n\t\t\t}; // See #20328.\n\n\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\tthis.depthTexture = source.depthTexture;\n\t\t\treturn this;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'dispose'\n\t\t\t});\n\t\t}\n\n\t}\n\n\tWebGLRenderTarget.prototype.isWebGLRenderTarget = true;\n\n\tclass WebGLMultipleRenderTargets extends WebGLRenderTarget {\n\t\tconstructor(width, height, count) {\n\t\t\tsuper(width, height);\n\t\t\tconst texture = this.texture;\n\t\t\tthis.texture = [];\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tthis.texture[i] = texture.clone();\n\t\t\t}\n\t\t}\n\n\t\tsetSize(width, height, depth = 1) {\n\t\t\tif (this.width !== width || this.height !== height || this.depth !== depth) {\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\t\t\t\tthis.depth = depth;\n\n\t\t\t\tfor (let i = 0, il = this.texture.length; i < il; i++) {\n\t\t\t\t\tthis.texture[i].image.width = width;\n\t\t\t\t\tthis.texture[i].image.height = height;\n\t\t\t\t\tthis.texture[i].image.depth = depth;\n\t\t\t\t}\n\n\t\t\t\tthis.dispose();\n\t\t\t}\n\n\t\t\tthis.viewport.set(0, 0, width, height);\n\t\t\tthis.scissor.set(0, 0, width, height);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.dispose();\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\t\t\tthis.depth = source.depth;\n\t\t\tthis.viewport.set(0, 0, this.width, this.height);\n\t\t\tthis.scissor.set(0, 0, this.width, this.height);\n\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\tthis.depthTexture = source.depthTexture;\n\t\t\tthis.texture.length = 0;\n\n\t\t\tfor (let i = 0, il = source.texture.length; i < il; i++) {\n\t\t\t\tthis.texture[i] = source.texture[i].clone();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tWebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;\n\n\tclass WebGLMultisampleRenderTarget extends WebGLRenderTarget {\n\t\tconstructor(width, height, options) {\n\t\t\tsuper(width, height, options);\n\t\t\tthis.samples = 4;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy.call(this, source);\n\t\t\tthis.samples = source.samples;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tWebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;\n\n\tclass Quaternion {\n\t\tconstructor(x = 0, y = 0, z = 0, w = 1) {\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._w = w;\n\t\t}\n\n\t\tstatic slerp(qa, qb, qm, t) {\n\t\t\tconsole.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');\n\t\t\treturn qm.slerpQuaternions(qa, qb, t);\n\t\t}\n\n\t\tstatic slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\t\t\tlet x0 = src0[srcOffset0 + 0],\n\t\t\t\t\ty0 = src0[srcOffset0 + 1],\n\t\t\t\t\tz0 = src0[srcOffset0 + 2],\n\t\t\t\t\tw0 = src0[srcOffset0 + 3];\n\t\t\tconst x1 = src1[srcOffset1 + 0],\n\t\t\t\t\t\ty1 = src1[srcOffset1 + 1],\n\t\t\t\t\t\tz1 = src1[srcOffset1 + 2],\n\t\t\t\t\t\tw1 = src1[srcOffset1 + 3];\n\n\t\t\tif (t === 0) {\n\t\t\t\tdst[dstOffset + 0] = x0;\n\t\t\t\tdst[dstOffset + 1] = y0;\n\t\t\t\tdst[dstOffset + 2] = z0;\n\t\t\t\tdst[dstOffset + 3] = w0;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (t === 1) {\n\t\t\t\tdst[dstOffset + 0] = x1;\n\t\t\t\tdst[dstOffset + 1] = y1;\n\t\t\t\tdst[dstOffset + 2] = z1;\n\t\t\t\tdst[dstOffset + 3] = w1;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n\t\t\t\tlet s = 1 - t;\n\t\t\t\tconst cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\t\t\t\t\t\tdir = cos >= 0 ? 1 : -1,\n\t\t\t\t\t\t\tsqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:\n\n\t\t\t\tif (sqrSin > Number.EPSILON) {\n\t\t\t\t\tconst sin = Math.sqrt(sqrSin),\n\t\t\t\t\t\t\t\tlen = Math.atan2(sin, cos * dir);\n\t\t\t\t\ts = Math.sin(s * len) / sin;\n\t\t\t\t\tt = Math.sin(t * len) / sin;\n\t\t\t\t}\n\n\t\t\t\tconst tDir = t * dir;\n\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\tw0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:\n\n\t\t\t\tif (s === 1 - t) {\n\t\t\t\t\tconst f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n\t\t\t\t\tx0 *= f;\n\t\t\t\t\ty0 *= f;\n\t\t\t\t\tz0 *= f;\n\t\t\t\t\tw0 *= f;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdst[dstOffset] = x0;\n\t\t\tdst[dstOffset + 1] = y0;\n\t\t\tdst[dstOffset + 2] = z0;\n\t\t\tdst[dstOffset + 3] = w0;\n\t\t}\n\n\t\tstatic multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n\t\t\tconst x0 = src0[srcOffset0];\n\t\t\tconst y0 = src0[srcOffset0 + 1];\n\t\t\tconst z0 = src0[srcOffset0 + 2];\n\t\t\tconst w0 = src0[srcOffset0 + 3];\n\t\t\tconst x1 = src1[srcOffset1];\n\t\t\tconst y1 = src1[srcOffset1 + 1];\n\t\t\tconst z1 = src1[srcOffset1 + 2];\n\t\t\tconst w1 = src1[srcOffset1 + 3];\n\t\t\tdst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n\t\t\tdst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n\t\t\tdst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n\t\t\tdst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\t\t\treturn dst;\n\t\t}\n\n\t\tget x() {\n\t\t\treturn this._x;\n\t\t}\n\n\t\tset x(value) {\n\t\t\tthis._x = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget y() {\n\t\t\treturn this._y;\n\t\t}\n\n\t\tset y(value) {\n\t\t\tthis._y = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget z() {\n\t\t\treturn this._z;\n\t\t}\n\n\t\tset z(value) {\n\t\t\tthis._z = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget w() {\n\t\t\treturn this._w;\n\t\t}\n\n\t\tset w(value) {\n\t\t\tthis._w = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tset(x, y, z, w) {\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._w = w;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this._x, this._y, this._z, this._w);\n\t\t}\n\n\t\tcopy(quaternion) {\n\t\t\tthis._x = quaternion.x;\n\t\t\tthis._y = quaternion.y;\n\t\t\tthis._z = quaternion.z;\n\t\t\tthis._w = quaternion.w;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromEuler(euler, update) {\n\t\t\tif (!(euler && euler.isEuler)) {\n\t\t\t\tthrow new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');\n\t\t\t}\n\n\t\t\tconst x = euler._x,\n\t\t\t\t\t\ty = euler._y,\n\t\t\t\t\t\tz = euler._z,\n\t\t\t\t\t\torder = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t//\tcontent/SpinCalc.m\n\n\t\t\tconst cos = Math.cos;\n\t\t\tconst sin = Math.sin;\n\t\t\tconst c1 = cos(x / 2);\n\t\t\tconst c2 = cos(y / 2);\n\t\t\tconst c3 = cos(z / 2);\n\t\t\tconst s1 = sin(x / 2);\n\t\t\tconst s2 = sin(y / 2);\n\t\t\tconst s3 = sin(z / 2);\n\n\t\t\tswitch (order) {\n\t\t\t\tcase 'XYZ':\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'YXZ':\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZXY':\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZYX':\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'YZX':\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'XZY':\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);\n\t\t\t}\n\n\t\t\tif (update !== false) this._onChangeCallback();\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromAxisAngle(axis, angle) {\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\t\t\t// assumes axis is normalized\n\t\t\tconst halfAngle = angle / 2,\n\t\t\t\t\t\ts = Math.sin(halfAngle);\n\t\t\tthis._x = axis.x * s;\n\t\t\tthis._y = axis.y * s;\n\t\t\tthis._z = axis.z * s;\n\t\t\tthis._w = Math.cos(halfAngle);\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromRotationMatrix(m) {\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\t\tconst te = m.elements,\n\t\t\t\t\t\tm11 = te[0],\n\t\t\t\t\t\tm12 = te[4],\n\t\t\t\t\t\tm13 = te[8],\n\t\t\t\t\t\tm21 = te[1],\n\t\t\t\t\t\tm22 = te[5],\n\t\t\t\t\t\tm23 = te[9],\n\t\t\t\t\t\tm31 = te[2],\n\t\t\t\t\t\tm32 = te[6],\n\t\t\t\t\t\tm33 = te[10],\n\t\t\t\t\t\ttrace = m11 + m22 + m33;\n\n\t\t\tif (trace > 0) {\n\t\t\t\tconst s = 0.5 / Math.sqrt(trace + 1.0);\n\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\tthis._x = (m32 - m23) * s;\n\t\t\t\tthis._y = (m13 - m31) * s;\n\t\t\t\tthis._z = (m21 - m12) * s;\n\t\t\t} else if (m11 > m22 && m11 > m33) {\n\t\t\t\tconst s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\t\t\t\tthis._w = (m32 - m23) / s;\n\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\tthis._y = (m12 + m21) / s;\n\t\t\t\tthis._z = (m13 + m31) / s;\n\t\t\t} else if (m22 > m33) {\n\t\t\t\tconst s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\t\t\t\tthis._w = (m13 - m31) / s;\n\t\t\t\tthis._x = (m12 + m21) / s;\n\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\tthis._z = (m23 + m32) / s;\n\t\t\t} else {\n\t\t\t\tconst s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\t\t\t\tthis._w = (m21 - m12) / s;\n\t\t\t\tthis._x = (m13 + m31) / s;\n\t\t\t\tthis._y = (m23 + m32) / s;\n\t\t\t\tthis._z = 0.25 * s;\n\t\t\t}\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromUnitVectors(vFrom, vTo) {\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\t\t\tlet r = vFrom.dot(vTo) + 1;\n\n\t\t\tif (r < Number.EPSILON) {\n\t\t\t\t// vFrom and vTo point in opposite directions\n\t\t\t\tr = 0;\n\n\t\t\t\tif (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n\t\t\t\t\tthis._x = -vFrom.y;\n\t\t\t\t\tthis._y = vFrom.x;\n\t\t\t\t\tthis._z = 0;\n\t\t\t\t\tthis._w = r;\n\t\t\t\t} else {\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = -vFrom.z;\n\t\t\t\t\tthis._z = vFrom.y;\n\t\t\t\t\tthis._w = r;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\t\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\t\t\tthis._w = r;\n\t\t\t}\n\n\t\t\treturn this.normalize();\n\t\t}\n\n\t\tangleTo(q) {\n\t\t\treturn 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\n\t\t}\n\n\t\trotateTowards(q, step) {\n\t\t\tconst angle = this.angleTo(q);\n\t\t\tif (angle === 0) return this;\n\t\t\tconst t = Math.min(1, step / angle);\n\t\t\tthis.slerp(q, t);\n\t\t\treturn this;\n\t\t}\n\n\t\tidentity() {\n\t\t\treturn this.set(0, 0, 0, 1);\n\t\t}\n\n\t\tinvert() {\n\t\t\t// quaternion is assumed to have unit length\n\t\t\treturn this.conjugate();\n\t\t}\n\n\t\tconjugate() {\n\t\t\tthis._x *= -1;\n\t\t\tthis._y *= -1;\n\t\t\tthis._z *= -1;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tdot(v) {\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\t\t}\n\n\t\tlengthSq() {\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\t\t}\n\n\t\tlength() {\n\t\t\treturn Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n\t\t}\n\n\t\tnormalize() {\n\t\t\tlet l = this.length();\n\n\t\t\tif (l === 0) {\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = 1;\n\t\t\t} else {\n\t\t\t\tl = 1 / l;\n\t\t\t\tthis._x = this._x * l;\n\t\t\t\tthis._y = this._y * l;\n\t\t\t\tthis._z = this._z * l;\n\t\t\t\tthis._w = this._w * l;\n\t\t\t}\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(q, p) {\n\t\t\tif (p !== undefined) {\n\t\t\t\tconsole.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');\n\t\t\t\treturn this.multiplyQuaternions(q, p);\n\t\t\t}\n\n\t\t\treturn this.multiplyQuaternions(this, q);\n\t\t}\n\n\t\tpremultiply(q) {\n\t\t\treturn this.multiplyQuaternions(q, this);\n\t\t}\n\n\t\tmultiplyQuaternions(a, b) {\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\t\t\tconst qax = a._x,\n\t\t\t\t\t\tqay = a._y,\n\t\t\t\t\t\tqaz = a._z,\n\t\t\t\t\t\tqaw = a._w;\n\t\t\tconst qbx = b._x,\n\t\t\t\t\t\tqby = b._y,\n\t\t\t\t\t\tqbz = b._z,\n\t\t\t\t\t\tqbw = b._w;\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tslerp(qb, t) {\n\t\t\tif (t === 0) return this;\n\t\t\tif (t === 1) return this.copy(qb);\n\t\t\tconst x = this._x,\n\t\t\t\t\t\ty = this._y,\n\t\t\t\t\t\tz = this._z,\n\t\t\t\t\t\tw = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\t\tlet cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\t\tif (cosHalfTheta < 0) {\n\t\t\t\tthis._w = -qb._w;\n\t\t\t\tthis._x = -qb._x;\n\t\t\t\tthis._y = -qb._y;\n\t\t\t\tthis._z = -qb._z;\n\t\t\t\tcosHalfTheta = -cosHalfTheta;\n\t\t\t} else {\n\t\t\t\tthis.copy(qb);\n\t\t\t}\n\n\t\t\tif (cosHalfTheta >= 1.0) {\n\t\t\t\tthis._w = w;\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tconst sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\t\tif (sqrSinHalfTheta <= Number.EPSILON) {\n\t\t\t\tconst s = 1 - t;\n\t\t\t\tthis._w = s * w + t * this._w;\n\t\t\t\tthis._x = s * x + t * this._x;\n\t\t\t\tthis._y = s * y + t * this._y;\n\t\t\t\tthis._z = s * z + t * this._z;\n\t\t\t\tthis.normalize();\n\n\t\t\t\tthis._onChangeCallback();\n\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tconst sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n\t\t\tconst halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n\t\t\tconst ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,\n\t\t\t\t\t\tratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n\t\t\tthis._w = w * ratioA + this._w * ratioB;\n\t\t\tthis._x = x * ratioA + this._x * ratioB;\n\t\t\tthis._y = y * ratioA + this._y * ratioB;\n\t\t\tthis._z = z * ratioA + this._z * ratioB;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tslerpQuaternions(qa, qb, t) {\n\t\t\tthis.copy(qa).slerp(qb, t);\n\t\t}\n\n\t\tequals(quaternion) {\n\t\t\treturn quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tthis._x = array[offset];\n\t\t\tthis._y = array[offset + 1];\n\t\t\tthis._z = array[offset + 2];\n\t\t\tthis._w = array[offset + 3];\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this._x;\n\t\t\tarray[offset + 1] = this._y;\n\t\t\tarray[offset + 2] = this._z;\n\t\t\tarray[offset + 3] = this._w;\n\t\t\treturn array;\n\t\t}\n\n\t\tfromBufferAttribute(attribute, index) {\n\t\t\tthis._x = attribute.getX(index);\n\t\t\tthis._y = attribute.getY(index);\n\t\t\tthis._z = attribute.getZ(index);\n\t\t\tthis._w = attribute.getW(index);\n\t\t\treturn this;\n\t\t}\n\n\t\t_onChange(callback) {\n\t\t\tthis._onChangeCallback = callback;\n\t\t\treturn this;\n\t\t}\n\n\t\t_onChangeCallback() {}\n\n\t}\n\n\tQuaternion.prototype.isQuaternion = true;\n\n\tclass Vector3 {\n\t\tconstructor(x = 0, y = 0, z = 0) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tset(x, y, z) {\n\t\t\tif (z === undefined) z = this.z; // sprite.scale.set(x,y)\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetScalar(scalar) {\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetX(x) {\n\t\t\tthis.x = x;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetY(y) {\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetZ(z) {\n\t\t\tthis.z = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetComponent(index, value) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.x = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tthis.y = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.z = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetComponent(index) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn this.x;\n\n\t\t\t\tcase 1:\n\t\t\t\t\treturn this.y;\n\n\t\t\t\tcase 2:\n\t\t\t\t\treturn this.z;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.x, this.y, this.z);\n\t\t}\n\n\t\tcopy(v) {\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tadd(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n\t\t\t\treturn this.addVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScalar(s) {\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\t\t\treturn this;\n\t\t}\n\n\t\taddVectors(a, b) {\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScaledVector(v, s) {\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsub(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n\t\t\t\treturn this.subVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubScalar(s) {\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubVectors(a, b) {\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');\n\t\t\t\treturn this.multiplyVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\tthis.z *= v.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(scalar) {\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyVectors(a, b) {\n\t\t\tthis.x = a.x * b.x;\n\t\t\tthis.y = a.y * b.y;\n\t\t\tthis.z = a.z * b.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyEuler(euler) {\n\t\t\tif (!(euler && euler.isEuler)) {\n\t\t\t\tconsole.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');\n\t\t\t}\n\n\t\t\treturn this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n\t\t}\n\n\t\tapplyAxisAngle(axis, angle) {\n\t\t\treturn this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n\t\t}\n\n\t\tapplyMatrix3(m) {\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y,\n\t\t\t\t\t\tz = this.z;\n\t\t\tconst e = m.elements;\n\t\t\tthis.x = e[0] * x + e[3] * y + e[6] * z;\n\t\t\tthis.y = e[1] * x + e[4] * y + e[7] * z;\n\t\t\tthis.z = e[2] * x + e[5] * y + e[8] * z;\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyNormalMatrix(m) {\n\t\t\treturn this.applyMatrix3(m).normalize();\n\t\t}\n\n\t\tapplyMatrix4(m) {\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y,\n\t\t\t\t\t\tz = this.z;\n\t\t\tconst e = m.elements;\n\t\t\tconst w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\n\t\t\tthis.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\n\t\t\tthis.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\n\t\t\tthis.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyQuaternion(q) {\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y,\n\t\t\t\t\t\tz = this.z;\n\t\t\tconst qx = q.x,\n\t\t\t\t\t\tqy = q.y,\n\t\t\t\t\t\tqz = q.z,\n\t\t\t\t\t\tqw = q.w; // calculate quat * vector\n\n\t\t\tconst ix = qw * x + qy * z - qz * y;\n\t\t\tconst iy = qw * y + qz * x - qx * z;\n\t\t\tconst iz = qw * z + qx * y - qy * x;\n\t\t\tconst iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n\t\t\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n\t\t\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n\t\t\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\t\t\treturn this;\n\t\t}\n\n\t\tproject(camera) {\n\t\t\treturn this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n\t\t}\n\n\t\tunproject(camera) {\n\t\t\treturn this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n\t\t}\n\n\t\ttransformDirection(m) {\n\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t// vector interpreted as a direction\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y,\n\t\t\t\t\t\tz = this.z;\n\t\t\tconst e = m.elements;\n\t\t\tthis.x = e[0] * x + e[4] * y + e[8] * z;\n\t\t\tthis.y = e[1] * x + e[5] * y + e[9] * z;\n\t\t\tthis.z = e[2] * x + e[6] * y + e[10] * z;\n\t\t\treturn this.normalize();\n\t\t}\n\n\t\tdivide(v) {\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\t\tthis.z /= v.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tdivideScalar(scalar) {\n\t\t\treturn this.multiplyScalar(1 / scalar);\n\t\t}\n\n\t\tmin(v) {\n\t\t\tthis.x = Math.min(this.x, v.x);\n\t\t\tthis.y = Math.min(this.y, v.y);\n\t\t\tthis.z = Math.min(this.z, v.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tmax(v) {\n\t\t\tthis.x = Math.max(this.x, v.x);\n\t\t\tthis.y = Math.max(this.y, v.y);\n\t\t\tthis.z = Math.max(this.z, v.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tclamp(min, max) {\n\t\t\t// assumes min < max, componentwise\n\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\n\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\n\t\t\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampScalar(minVal, maxVal) {\n\t\t\tthis.x = Math.max(minVal, Math.min(maxVal, this.x));\n\t\t\tthis.y = Math.max(minVal, Math.min(maxVal, this.y));\n\t\t\tthis.z = Math.max(minVal, Math.min(maxVal, this.z));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampLength(min, max) {\n\t\t\tconst length = this.length();\n\t\t\treturn this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n\t\t}\n\n\t\tfloor() {\n\t\t\tthis.x = Math.floor(this.x);\n\t\t\tthis.y = Math.floor(this.y);\n\t\t\tthis.z = Math.floor(this.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tceil() {\n\t\t\tthis.x = Math.ceil(this.x);\n\t\t\tthis.y = Math.ceil(this.y);\n\t\t\tthis.z = Math.ceil(this.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tround() {\n\t\t\tthis.x = Math.round(this.x);\n\t\t\tthis.y = Math.round(this.y);\n\t\t\tthis.z = Math.round(this.z);\n\t\t\treturn this;\n\t\t}\n\n\t\troundToZero() {\n\t\t\tthis.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n\t\t\tthis.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n\t\t\tthis.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tnegate() {\n\t\t\tthis.x = -this.x;\n\t\t\tthis.y = -this.y;\n\t\t\tthis.z = -this.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tdot(v) {\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\t\t} // TODO lengthSquared?\n\n\n\t\tlengthSq() {\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\t\t}\n\n\t\tlength() {\n\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n\t\t}\n\n\t\tmanhattanLength() {\n\t\t\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n\t\t}\n\n\t\tnormalize() {\n\t\t\treturn this.divideScalar(this.length() || 1);\n\t\t}\n\n\t\tsetLength(length) {\n\t\t\treturn this.normalize().multiplyScalar(length);\n\t\t}\n\n\t\tlerp(v, alpha) {\n\t\t\tthis.x += (v.x - this.x) * alpha;\n\t\t\tthis.y += (v.y - this.y) * alpha;\n\t\t\tthis.z += (v.z - this.z) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerpVectors(v1, v2, alpha) {\n\t\t\tthis.x = v1.x + (v2.x - v1.x) * alpha;\n\t\t\tthis.y = v1.y + (v2.y - v1.y) * alpha;\n\t\t\tthis.z = v1.z + (v2.z - v1.z) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tcross(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');\n\t\t\t\treturn this.crossVectors(v, w);\n\t\t\t}\n\n\t\t\treturn this.crossVectors(this, v);\n\t\t}\n\n\t\tcrossVectors(a, b) {\n\t\t\tconst ax = a.x,\n\t\t\t\t\t\tay = a.y,\n\t\t\t\t\t\taz = a.z;\n\t\t\tconst bx = b.x,\n\t\t\t\t\t\tby = b.y,\n\t\t\t\t\t\tbz = b.z;\n\t\t\tthis.x = ay * bz - az * by;\n\t\t\tthis.y = az * bx - ax * bz;\n\t\t\tthis.z = ax * by - ay * bx;\n\t\t\treturn this;\n\t\t}\n\n\t\tprojectOnVector(v) {\n\t\t\tconst denominator = v.lengthSq();\n\t\t\tif (denominator === 0) return this.set(0, 0, 0);\n\t\t\tconst scalar = v.dot(this) / denominator;\n\t\t\treturn this.copy(v).multiplyScalar(scalar);\n\t\t}\n\n\t\tprojectOnPlane(planeNormal) {\n\t\t\t_vector$c.copy(this).projectOnVector(planeNormal);\n\n\t\t\treturn this.sub(_vector$c);\n\t\t}\n\n\t\treflect(normal) {\n\t\t\t// reflect incident vector off plane orthogonal to normal\n\t\t\t// normal is assumed to have unit length\n\t\t\treturn this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\n\t\t}\n\n\t\tangleTo(v) {\n\t\t\tconst denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n\t\t\tif (denominator === 0) return Math.PI / 2;\n\t\t\tconst theta = this.dot(v) / denominator; // clamp, to handle numerical problems\n\n\t\t\treturn Math.acos(clamp(theta, -1, 1));\n\t\t}\n\n\t\tdistanceTo(v) {\n\t\t\treturn Math.sqrt(this.distanceToSquared(v));\n\t\t}\n\n\t\tdistanceToSquared(v) {\n\t\t\tconst dx = this.x - v.x,\n\t\t\t\t\t\tdy = this.y - v.y,\n\t\t\t\t\t\tdz = this.z - v.z;\n\t\t\treturn dx * dx + dy * dy + dz * dz;\n\t\t}\n\n\t\tmanhattanDistanceTo(v) {\n\t\t\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n\t\t}\n\n\t\tsetFromSpherical(s) {\n\t\t\treturn this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n\t\t}\n\n\t\tsetFromSphericalCoords(radius, phi, theta) {\n\t\t\tconst sinPhiRadius = Math.sin(phi) * radius;\n\t\t\tthis.x = sinPhiRadius * Math.sin(theta);\n\t\t\tthis.y = Math.cos(phi) * radius;\n\t\t\tthis.z = sinPhiRadius * Math.cos(theta);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromCylindrical(c) {\n\t\t\treturn this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n\t\t}\n\n\t\tsetFromCylindricalCoords(radius, theta, y) {\n\t\t\tthis.x = radius * Math.sin(theta);\n\t\t\tthis.y = y;\n\t\t\tthis.z = radius * Math.cos(theta);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromMatrixPosition(m) {\n\t\t\tconst e = m.elements;\n\t\t\tthis.x = e[12];\n\t\t\tthis.y = e[13];\n\t\t\tthis.z = e[14];\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromMatrixScale(m) {\n\t\t\tconst sx = this.setFromMatrixColumn(m, 0).length();\n\t\t\tconst sy = this.setFromMatrixColumn(m, 1).length();\n\t\t\tconst sz = this.setFromMatrixColumn(m, 2).length();\n\t\t\tthis.x = sx;\n\t\t\tthis.y = sy;\n\t\t\tthis.z = sz;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromMatrixColumn(m, index) {\n\t\t\treturn this.fromArray(m.elements, index * 4);\n\t\t}\n\n\t\tsetFromMatrix3Column(m, index) {\n\t\t\treturn this.fromArray(m.elements, index * 3);\n\t\t}\n\n\t\tequals(v) {\n\t\t\treturn v.x === this.x && v.y === this.y && v.z === this.z;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tthis.x = array[offset];\n\t\t\tthis.y = array[offset + 1];\n\t\t\tthis.z = array[offset + 2];\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this.x;\n\t\t\tarray[offset + 1] = this.y;\n\t\t\tarray[offset + 2] = this.z;\n\t\t\treturn array;\n\t\t}\n\n\t\tfromBufferAttribute(attribute, index, offset) {\n\t\t\tif (offset !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');\n\t\t\t}\n\n\t\t\tthis.x = attribute.getX(index);\n\t\t\tthis.y = attribute.getY(index);\n\t\t\tthis.z = attribute.getZ(index);\n\t\t\treturn this;\n\t\t}\n\n\t\trandom() {\n\t\t\tthis.x = Math.random();\n\t\t\tthis.y = Math.random();\n\t\t\tthis.z = Math.random();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tVector3.prototype.isVector3 = true;\n\n\tconst _vector$c = /*@__PURE__*/new Vector3();\n\n\tconst _quaternion$4 = /*@__PURE__*/new Quaternion();\n\n\tclass Box3 {\n\t\tconstructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\t\t}\n\n\t\tset(min, max) {\n\t\t\tthis.min.copy(min);\n\t\t\tthis.max.copy(max);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromArray(array) {\n\t\t\tlet minX = +Infinity;\n\t\t\tlet minY = +Infinity;\n\t\t\tlet minZ = +Infinity;\n\t\t\tlet maxX = -Infinity;\n\t\t\tlet maxY = -Infinity;\n\t\t\tlet maxZ = -Infinity;\n\n\t\t\tfor (let i = 0, l = array.length; i < l; i += 3) {\n\t\t\t\tconst x = array[i];\n\t\t\t\tconst y = array[i + 1];\n\t\t\t\tconst z = array[i + 2];\n\t\t\t\tif (x < minX) minX = x;\n\t\t\t\tif (y < minY) minY = y;\n\t\t\t\tif (z < minZ) minZ = z;\n\t\t\t\tif (x > maxX) maxX = x;\n\t\t\t\tif (y > maxY) maxY = y;\n\t\t\t\tif (z > maxZ) maxZ = z;\n\t\t\t}\n\n\t\t\tthis.min.set(minX, minY, minZ);\n\t\t\tthis.max.set(maxX, maxY, maxZ);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromBufferAttribute(attribute) {\n\t\t\tlet minX = +Infinity;\n\t\t\tlet minY = +Infinity;\n\t\t\tlet minZ = +Infinity;\n\t\t\tlet maxX = -Infinity;\n\t\t\tlet maxY = -Infinity;\n\t\t\tlet maxZ = -Infinity;\n\n\t\t\tfor (let i = 0, l = attribute.count; i < l; i++) {\n\t\t\t\tconst x = attribute.getX(i);\n\t\t\t\tconst y = attribute.getY(i);\n\t\t\t\tconst z = attribute.getZ(i);\n\t\t\t\tif (x < minX) minX = x;\n\t\t\t\tif (y < minY) minY = y;\n\t\t\t\tif (z < minZ) minZ = z;\n\t\t\t\tif (x > maxX) maxX = x;\n\t\t\t\tif (y > maxY) maxY = y;\n\t\t\t\tif (z > maxZ) maxZ = z;\n\t\t\t}\n\n\t\t\tthis.min.set(minX, minY, minZ);\n\t\t\tthis.max.set(maxX, maxY, maxZ);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromPoints(points) {\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor (let i = 0, il = points.length; i < il; i++) {\n\t\t\t\tthis.expandByPoint(points[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromCenterAndSize(center, size) {\n\t\t\tconst halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n\n\t\t\tthis.min.copy(center).sub(halfSize);\n\t\t\tthis.max.copy(center).add(halfSize);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromObject(object) {\n\t\t\tthis.makeEmpty();\n\t\t\treturn this.expandByObject(object);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(box) {\n\t\t\tthis.min.copy(box.min);\n\t\t\tthis.max.copy(box.max);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeEmpty() {\n\t\t\tthis.min.x = this.min.y = this.min.z = +Infinity;\n\t\t\tthis.max.x = this.max.y = this.max.z = -Infinity;\n\t\t\treturn this;\n\t\t}\n\n\t\tisEmpty() {\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\t\treturn this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n\t\t}\n\n\t\tgetCenter(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box3: .getCenter() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n\t\t}\n\n\t\tgetSize(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box3: .getSize() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n\t\t}\n\n\t\texpandByPoint(point) {\n\t\t\tthis.min.min(point);\n\t\t\tthis.max.max(point);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByVector(vector) {\n\t\t\tthis.min.sub(vector);\n\t\t\tthis.max.add(vector);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByScalar(scalar) {\n\t\t\tthis.min.addScalar(-scalar);\n\t\t\tthis.max.addScalar(scalar);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByObject(object) {\n\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t\t// accounting for both the object's, and children's, world transforms\n\t\t\tobject.updateWorldMatrix(false, false);\n\t\t\tconst geometry = object.geometry;\n\n\t\t\tif (geometry !== undefined) {\n\t\t\t\tif (geometry.boundingBox === null) {\n\t\t\t\t\tgeometry.computeBoundingBox();\n\t\t\t\t}\n\n\t\t\t\t_box$3.copy(geometry.boundingBox);\n\n\t\t\t\t_box$3.applyMatrix4(object.matrixWorld);\n\n\t\t\t\tthis.union(_box$3);\n\t\t\t}\n\n\t\t\tconst children = object.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tthis.expandByObject(children[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcontainsPoint(point) {\n\t\t\treturn point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;\n\t\t}\n\n\t\tcontainsBox(box) {\n\t\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n\t\t}\n\n\t\tgetParameter(point, target) {\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box3: .getParameter() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\t// using 6 splitting planes to rule out intersections.\n\t\t\treturn box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n\t\t}\n\n\t\tintersectsSphere(sphere) {\n\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\tthis.clampPoint(sphere.center, _vector$b); // If that point is inside the sphere, the AABB and sphere intersect.\n\n\t\t\treturn _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n\t\t}\n\n\t\tintersectsPlane(plane) {\n\t\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\t\t\tlet min, max;\n\n\t\t\tif (plane.normal.x > 0) {\n\t\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\t\tmax = plane.normal.x * this.max.x;\n\t\t\t} else {\n\t\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\t\tmax = plane.normal.x * this.min.x;\n\t\t\t}\n\n\t\t\tif (plane.normal.y > 0) {\n\t\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\t\tmax += plane.normal.y * this.max.y;\n\t\t\t} else {\n\t\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\t\tmax += plane.normal.y * this.min.y;\n\t\t\t}\n\n\t\t\tif (plane.normal.z > 0) {\n\t\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\t\tmax += plane.normal.z * this.max.z;\n\t\t\t} else {\n\t\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\t\tmax += plane.normal.z * this.min.z;\n\t\t\t}\n\n\t\t\treturn min <= -plane.constant && max >= -plane.constant;\n\t\t}\n\n\t\tintersectsTriangle(triangle) {\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t} // compute box center and extents\n\n\n\t\t\tthis.getCenter(_center);\n\n\t\t\t_extents.subVectors(this.max, _center); // translate triangle to aabb origin\n\n\n\t\t\t_v0$2.subVectors(triangle.a, _center);\n\n\t\t\t_v1$7.subVectors(triangle.b, _center);\n\n\t\t\t_v2$3.subVectors(triangle.c, _center); // compute edge vectors for triangle\n\n\n\t\t\t_f0.subVectors(_v1$7, _v0$2);\n\n\t\t\t_f1.subVectors(_v2$3, _v1$7);\n\n\t\t\t_f2.subVectors(_v0$2, _v2$3); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\n\n\t\t\tlet axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];\n\n\t\t\tif (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {\n\t\t\t\treturn false;\n\t\t\t} // test 3 face normals from the aabb\n\n\n\t\t\taxes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n\t\t\tif (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {\n\t\t\t\treturn false;\n\t\t\t} // finally testing the face normal of the triangle\n\t\t\t// use already existing triangle edge vectors here\n\n\n\t\t\t_triangleNormal.crossVectors(_f0, _f1);\n\n\t\t\taxes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n\t\t\treturn satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);\n\t\t}\n\n\t\tclampPoint(point, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box3: .clampPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.copy(point).clamp(this.min, this.max);\n\t\t}\n\n\t\tdistanceToPoint(point) {\n\t\t\tconst clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);\n\n\t\t\treturn clampedPoint.sub(point).length();\n\t\t}\n\n\t\tgetBoundingSphere(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.error('THREE.Box3: .getBoundingSphere() target is now required'); //target = new Sphere(); // removed to avoid cyclic dependency\n\t\t\t}\n\n\t\t\tthis.getCenter(target.center);\n\t\t\ttarget.radius = this.getSize(_vector$b).length() * 0.5;\n\t\t\treturn target;\n\t\t}\n\n\t\tintersect(box) {\n\t\t\tthis.min.max(box.min);\n\t\t\tthis.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\n\t\t\tif (this.isEmpty()) this.makeEmpty();\n\t\t\treturn this;\n\t\t}\n\n\t\tunion(box) {\n\t\t\tthis.min.min(box.min);\n\t\t\tthis.max.max(box.max);\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyMatrix4(matrix) {\n\t\t\t// transform of empty box is an empty box.\n\t\t\tif (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\n\t\t\t_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\n\n\n\t\t\t_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\n\n\n\t\t\t_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\n\n\n\t\t\t_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\n\n\n\t\t\t_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\n\n\n\t\t\t_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\n\n\n\t\t\t_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\n\n\n\t\t\t_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\n\n\n\t\t\tthis.setFromPoints(_points);\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(offset) {\n\t\t\tthis.min.add(offset);\n\t\t\tthis.max.add(offset);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(box) {\n\t\t\treturn box.min.equals(this.min) && box.max.equals(this.max);\n\t\t}\n\n\t}\n\n\tBox3.prototype.isBox3 = true;\n\tconst _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];\n\n\tconst _vector$b = /*@__PURE__*/new Vector3();\n\n\tconst _box$3 = /*@__PURE__*/new Box3(); // triangle centered vertices\n\n\n\tconst _v0$2 = /*@__PURE__*/new Vector3();\n\n\tconst _v1$7 = /*@__PURE__*/new Vector3();\n\n\tconst _v2$3 = /*@__PURE__*/new Vector3(); // triangle edge vectors\n\n\n\tconst _f0 = /*@__PURE__*/new Vector3();\n\n\tconst _f1 = /*@__PURE__*/new Vector3();\n\n\tconst _f2 = /*@__PURE__*/new Vector3();\n\n\tconst _center = /*@__PURE__*/new Vector3();\n\n\tconst _extents = /*@__PURE__*/new Vector3();\n\n\tconst _triangleNormal = /*@__PURE__*/new Vector3();\n\n\tconst _testAxis = /*@__PURE__*/new Vector3();\n\n\tfunction satForAxes(axes, v0, v1, v2, extents) {\n\t\tfor (let i = 0, j = axes.length - 3; i <= j; i += 3) {\n\t\t\t_testAxis.fromArray(axes, i); // project the aabb onto the seperating axis\n\n\n\t\t\tconst r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis\n\n\t\t\tconst p0 = v0.dot(_testAxis);\n\t\t\tconst p1 = v1.dot(_testAxis);\n\t\t\tconst p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r\n\n\t\t\tif (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n\t\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t\t// the axis is seperating and we can exit\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tconst _box$2 = /*@__PURE__*/new Box3();\n\n\tconst _v1$6 = /*@__PURE__*/new Vector3();\n\n\tconst _toFarthestPoint = /*@__PURE__*/new Vector3();\n\n\tconst _toPoint = /*@__PURE__*/new Vector3();\n\n\tclass Sphere {\n\t\tconstructor(center = new Vector3(), radius = -1) {\n\t\t\tthis.center = center;\n\t\t\tthis.radius = radius;\n\t\t}\n\n\t\tset(center, radius) {\n\t\t\tthis.center.copy(center);\n\t\t\tthis.radius = radius;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromPoints(points, optionalCenter) {\n\t\t\tconst center = this.center;\n\n\t\t\tif (optionalCenter !== undefined) {\n\t\t\t\tcenter.copy(optionalCenter);\n\t\t\t} else {\n\t\t\t\t_box$2.setFromPoints(points).getCenter(center);\n\t\t\t}\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor (let i = 0, il = points.length; i < il; i++) {\n\t\t\t\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n\t\t\t}\n\n\t\t\tthis.radius = Math.sqrt(maxRadiusSq);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(sphere) {\n\t\t\tthis.center.copy(sphere.center);\n\t\t\tthis.radius = sphere.radius;\n\t\t\treturn this;\n\t\t}\n\n\t\tisEmpty() {\n\t\t\treturn this.radius < 0;\n\t\t}\n\n\t\tmakeEmpty() {\n\t\t\tthis.center.set(0, 0, 0);\n\t\t\tthis.radius = -1;\n\t\t\treturn this;\n\t\t}\n\n\t\tcontainsPoint(point) {\n\t\t\treturn point.distanceToSquared(this.center) <= this.radius * this.radius;\n\t\t}\n\n\t\tdistanceToPoint(point) {\n\t\t\treturn point.distanceTo(this.center) - this.radius;\n\t\t}\n\n\t\tintersectsSphere(sphere) {\n\t\t\tconst radiusSum = this.radius + sphere.radius;\n\t\t\treturn sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\treturn box.intersectsSphere(this);\n\t\t}\n\n\t\tintersectsPlane(plane) {\n\t\t\treturn Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n\t\t}\n\n\t\tclampPoint(point, target) {\n\t\t\tconst deltaLengthSq = this.center.distanceToSquared(point);\n\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Sphere: .clampPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\ttarget.copy(point);\n\n\t\t\tif (deltaLengthSq > this.radius * this.radius) {\n\t\t\t\ttarget.sub(this.center).normalize();\n\t\t\t\ttarget.multiplyScalar(this.radius).add(this.center);\n\t\t\t}\n\n\t\t\treturn target;\n\t\t}\n\n\t\tgetBoundingBox(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Sphere: .getBoundingBox() target is now required');\n\t\t\t\ttarget = new Box3();\n\t\t\t}\n\n\t\t\tif (this.isEmpty()) {\n\t\t\t\t// Empty sphere produces empty bounding box\n\t\t\t\ttarget.makeEmpty();\n\t\t\t\treturn target;\n\t\t\t}\n\n\t\t\ttarget.set(this.center, this.center);\n\t\t\ttarget.expandByScalar(this.radius);\n\t\t\treturn target;\n\t\t}\n\n\t\tapplyMatrix4(matrix) {\n\t\t\tthis.center.applyMatrix4(matrix);\n\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(offset) {\n\t\t\tthis.center.add(offset);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByPoint(point) {\n\t\t\t// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671\n\t\t\t_toPoint.subVectors(point, this.center);\n\n\t\t\tconst lengthSq = _toPoint.lengthSq();\n\n\t\t\tif (lengthSq > this.radius * this.radius) {\n\t\t\t\tconst length = Math.sqrt(lengthSq);\n\t\t\t\tconst missingRadiusHalf = (length - this.radius) * 0.5; // Nudge this sphere towards the target point. Add half the missing distance to radius,\n\t\t\t\t// and the other half to position. This gives a tighter enclosure, instead of if\n\t\t\t\t// the whole missing distance were just added to radius.\n\n\t\t\t\tthis.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));\n\t\t\t\tthis.radius += missingRadiusHalf;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tunion(sphere) {\n\t\t\t// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769\n\t\t\t// To enclose another sphere into this sphere, we only need to enclose two points:\n\t\t\t// 1) Enclose the farthest point on the other sphere into this sphere.\n\t\t\t// 2) Enclose the opposite point of the farthest point into this sphere.\n\t\t\t_toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);\n\n\t\t\tthis.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));\n\t\t\tthis.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(sphere) {\n\t\t\treturn sphere.center.equals(this.center) && sphere.radius === this.radius;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tconst _vector$a = /*@__PURE__*/new Vector3();\n\n\tconst _segCenter = /*@__PURE__*/new Vector3();\n\n\tconst _segDir = /*@__PURE__*/new Vector3();\n\n\tconst _diff = /*@__PURE__*/new Vector3();\n\n\tconst _edge1 = /*@__PURE__*/new Vector3();\n\n\tconst _edge2 = /*@__PURE__*/new Vector3();\n\n\tconst _normal$1 = /*@__PURE__*/new Vector3();\n\n\tclass Ray {\n\t\tconstructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {\n\t\t\tthis.origin = origin;\n\t\t\tthis.direction = direction;\n\t\t}\n\n\t\tset(origin, direction) {\n\t\t\tthis.origin.copy(origin);\n\t\t\tthis.direction.copy(direction);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(ray) {\n\t\t\tthis.origin.copy(ray.origin);\n\t\t\tthis.direction.copy(ray.direction);\n\t\t\treturn this;\n\t\t}\n\n\t\tat(t, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Ray: .at() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.copy(this.direction).multiplyScalar(t).add(this.origin);\n\t\t}\n\n\t\tlookAt(v) {\n\t\t\tthis.direction.copy(v).sub(this.origin).normalize();\n\t\t\treturn this;\n\t\t}\n\n\t\trecast(t) {\n\t\t\tthis.origin.copy(this.at(t, _vector$a));\n\t\t\treturn this;\n\t\t}\n\n\t\tclosestPointToPoint(point, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Ray: .closestPointToPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\ttarget.subVectors(point, this.origin);\n\t\t\tconst directionDistance = target.dot(this.direction);\n\n\t\t\tif (directionDistance < 0) {\n\t\t\t\treturn target.copy(this.origin);\n\t\t\t}\n\n\t\t\treturn target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n\t\t}\n\n\t\tdistanceToPoint(point) {\n\t\t\treturn Math.sqrt(this.distanceSqToPoint(point));\n\t\t}\n\n\t\tdistanceSqToPoint(point) {\n\t\t\tconst directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction); // point behind the ray\n\n\n\t\t\tif (directionDistance < 0) {\n\t\t\t\treturn this.origin.distanceToSquared(point);\n\t\t\t}\n\n\t\t\t_vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n\n\t\t\treturn _vector$a.distanceToSquared(point);\n\t\t}\n\n\t\tdistanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t// defined by v0 and v1\n\t\t\t// It can also set two optional targets :\n\t\t\t// - The closest point on the ray\n\t\t\t// - The closest point on the segment\n\t\t\t_segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n\n\t\t\t_segDir.copy(v1).sub(v0).normalize();\n\n\t\t\t_diff.copy(this.origin).sub(_segCenter);\n\n\t\t\tconst segExtent = v0.distanceTo(v1) * 0.5;\n\t\t\tconst a01 = -this.direction.dot(_segDir);\n\n\t\t\tconst b0 = _diff.dot(this.direction);\n\n\t\t\tconst b1 = -_diff.dot(_segDir);\n\n\t\t\tconst c = _diff.lengthSq();\n\n\t\t\tconst det = Math.abs(1 - a01 * a01);\n\t\t\tlet s0, s1, sqrDist, extDet;\n\n\t\t\tif (det > 0) {\n\t\t\t\t// The ray and segment are not parallel.\n\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\textDet = segExtent * det;\n\n\t\t\t\tif (s0 >= 0) {\n\t\t\t\t\tif (s1 >= -extDet) {\n\t\t\t\t\t\tif (s1 <= extDet) {\n\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\t\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\tsqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// region 1\n\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\ts0 = Math.max(0, -(a01 * s1 + b0));\n\t\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// region 5\n\t\t\t\t\t\ts1 = -segExtent;\n\t\t\t\t\t\ts0 = Math.max(0, -(a01 * s1 + b0));\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (s1 <= -extDet) {\n\t\t\t\t\t\t// region 4\n\t\t\t\t\t\ts0 = Math.max(0, -(-a01 * segExtent + b0));\n\t\t\t\t\t\ts1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n\t\t\t\t\t} else if (s1 <= extDet) {\n\t\t\t\t\t\t// region 3\n\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\ts1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n\t\t\t\t\t\tsqrDist = s1 * (s1 + 2 * b1) + c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// region 2\n\t\t\t\t\t\ts0 = Math.max(0, -(a01 * segExtent + b0));\n\t\t\t\t\t\ts1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Ray and segment are parallel.\n\t\t\t\ts1 = a01 > 0 ? -segExtent : segExtent;\n\t\t\t\ts0 = Math.max(0, -(a01 * s1 + b0));\n\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n\t\t\t}\n\n\t\t\tif (optionalPointOnRay) {\n\t\t\t\toptionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\n\t\t\t}\n\n\t\t\tif (optionalPointOnSegment) {\n\t\t\t\toptionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);\n\t\t\t}\n\n\t\t\treturn sqrDist;\n\t\t}\n\n\t\tintersectSphere(sphere, target) {\n\t\t\t_vector$a.subVectors(sphere.center, this.origin);\n\n\t\t\tconst tca = _vector$a.dot(this.direction);\n\n\t\t\tconst d2 = _vector$a.dot(_vector$a) - tca * tca;\n\t\t\tconst radius2 = sphere.radius * sphere.radius;\n\t\t\tif (d2 > radius2) return null;\n\t\t\tconst thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere\n\n\t\t\tconst t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere\n\n\t\t\tconst t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null\n\n\t\t\tif (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t// in order to always return an intersect point that is in front of the ray.\n\n\t\t\tif (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0\n\n\t\t\treturn this.at(t0, target);\n\t\t}\n\n\t\tintersectsSphere(sphere) {\n\t\t\treturn this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n\t\t}\n\n\t\tdistanceToPlane(plane) {\n\t\t\tconst denominator = plane.normal.dot(this.direction);\n\n\t\t\tif (denominator === 0) {\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif (plane.distanceToPoint(this.origin) === 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t} // Null is preferable to undefined since undefined means.... it is undefined\n\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane\n\n\t\t\treturn t >= 0 ? t : null;\n\t\t}\n\n\t\tintersectPlane(plane, target) {\n\t\t\tconst t = this.distanceToPlane(plane);\n\n\t\t\tif (t === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn this.at(t, target);\n\t\t}\n\n\t\tintersectsPlane(plane) {\n\t\t\t// check if the ray lies on the plane first\n\t\t\tconst distToPoint = plane.distanceToPoint(this.origin);\n\n\t\t\tif (distToPoint === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst denominator = plane.normal.dot(this.direction);\n\n\t\t\tif (denominator * distToPoint < 0) {\n\t\t\t\treturn true;\n\t\t\t} // ray origin is behind the plane (and is pointing behind it)\n\n\n\t\t\treturn false;\n\t\t}\n\n\t\tintersectBox(box, target) {\n\t\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\t\t\tconst invdirx = 1 / this.direction.x,\n\t\t\t\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\t\t\t\tinvdirz = 1 / this.direction.z;\n\t\t\tconst origin = this.origin;\n\n\t\t\tif (invdirx >= 0) {\n\t\t\t\ttmin = (box.min.x - origin.x) * invdirx;\n\t\t\t\ttmax = (box.max.x - origin.x) * invdirx;\n\t\t\t} else {\n\t\t\t\ttmin = (box.max.x - origin.x) * invdirx;\n\t\t\t\ttmax = (box.min.x - origin.x) * invdirx;\n\t\t\t}\n\n\t\t\tif (invdiry >= 0) {\n\t\t\t\ttymin = (box.min.y - origin.y) * invdiry;\n\t\t\t\ttymax = (box.max.y - origin.y) * invdiry;\n\t\t\t} else {\n\t\t\t\ttymin = (box.max.y - origin.y) * invdiry;\n\t\t\t\ttymax = (box.min.y - origin.y) * invdiry;\n\t\t\t}\n\n\t\t\tif (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN\n\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\t\tif (tymin > tmin || tmin !== tmin) tmin = tymin;\n\t\t\tif (tymax < tmax || tmax !== tmax) tmax = tymax;\n\n\t\t\tif (invdirz >= 0) {\n\t\t\t\ttzmin = (box.min.z - origin.z) * invdirz;\n\t\t\t\ttzmax = (box.max.z - origin.z) * invdirz;\n\t\t\t} else {\n\t\t\t\ttzmin = (box.max.z - origin.z) * invdirz;\n\t\t\t\ttzmax = (box.min.z - origin.z) * invdirz;\n\t\t\t}\n\n\t\t\tif (tmin > tzmax || tzmin > tmax) return null;\n\t\t\tif (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n\t\t\tif (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)\n\n\t\t\tif (tmax < 0) return null;\n\t\t\treturn this.at(tmin >= 0 ? tmin : tmax, target);\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\treturn this.intersectBox(box, _vector$a) !== null;\n\t\t}\n\n\t\tintersectTriangle(a, b, c, backfaceCulling, target) {\n\t\t\t// Compute the offset origin, edges, and normal.\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\t\t\t_edge1.subVectors(b, a);\n\n\t\t\t_edge2.subVectors(c, a);\n\n\t\t\t_normal$1.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t//\t |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t//\t |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t//\t |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\n\n\t\t\tlet DdN = this.direction.dot(_normal$1);\n\t\t\tlet sign;\n\n\t\t\tif (DdN > 0) {\n\t\t\t\tif (backfaceCulling) return null;\n\t\t\t\tsign = 1;\n\t\t\t} else if (DdN < 0) {\n\t\t\t\tsign = -1;\n\t\t\t\tDdN = -DdN;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t_diff.subVectors(this.origin, a);\n\n\t\t\tconst DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection\n\n\t\t\tif (DdQxE2 < 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection\n\n\t\t\tif (DdE1xQ < 0) {\n\t\t\t\treturn null;\n\t\t\t} // b1+b2 > 1, no intersection\n\n\n\t\t\tif (DdQxE2 + DdE1xQ > DdN) {\n\t\t\t\treturn null;\n\t\t\t} // Line intersects triangle, check if ray does.\n\n\n\t\t\tconst QdN = -sign * _diff.dot(_normal$1); // t < 0, no intersection\n\n\n\t\t\tif (QdN < 0) {\n\t\t\t\treturn null;\n\t\t\t} // Ray intersects triangle.\n\n\n\t\t\treturn this.at(QdN / DdN, target);\n\t\t}\n\n\t\tapplyMatrix4(matrix4) {\n\t\t\tthis.origin.applyMatrix4(matrix4);\n\t\t\tthis.direction.transformDirection(matrix4);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(ray) {\n\t\t\treturn ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tclass Matrix4 {\n\t\tconstructor() {\n\t\t\tthis.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\n\t\t\tif (arguments.length > 0) {\n\t\t\t\tconsole.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');\n\t\t\t}\n\t\t}\n\n\t\tset(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] = n11;\n\t\t\tte[4] = n12;\n\t\t\tte[8] = n13;\n\t\t\tte[12] = n14;\n\t\t\tte[1] = n21;\n\t\t\tte[5] = n22;\n\t\t\tte[9] = n23;\n\t\t\tte[13] = n24;\n\t\t\tte[2] = n31;\n\t\t\tte[6] = n32;\n\t\t\tte[10] = n33;\n\t\t\tte[14] = n34;\n\t\t\tte[3] = n41;\n\t\t\tte[7] = n42;\n\t\t\tte[11] = n43;\n\t\t\tte[15] = n44;\n\t\t\treturn this;\n\t\t}\n\n\t\tidentity() {\n\t\t\tthis.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new Matrix4().fromArray(this.elements);\n\t\t}\n\n\t\tcopy(m) {\n\t\t\tconst te = this.elements;\n\t\t\tconst me = m.elements;\n\t\t\tte[0] = me[0];\n\t\t\tte[1] = me[1];\n\t\t\tte[2] = me[2];\n\t\t\tte[3] = me[3];\n\t\t\tte[4] = me[4];\n\t\t\tte[5] = me[5];\n\t\t\tte[6] = me[6];\n\t\t\tte[7] = me[7];\n\t\t\tte[8] = me[8];\n\t\t\tte[9] = me[9];\n\t\t\tte[10] = me[10];\n\t\t\tte[11] = me[11];\n\t\t\tte[12] = me[12];\n\t\t\tte[13] = me[13];\n\t\t\tte[14] = me[14];\n\t\t\tte[15] = me[15];\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyPosition(m) {\n\t\t\tconst te = this.elements,\n\t\t\t\t\t\tme = m.elements;\n\t\t\tte[12] = me[12];\n\t\t\tte[13] = me[13];\n\t\t\tte[14] = me[14];\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromMatrix3(m) {\n\t\t\tconst me = m.elements;\n\t\t\tthis.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\textractBasis(xAxis, yAxis, zAxis) {\n\t\t\txAxis.setFromMatrixColumn(this, 0);\n\t\t\tyAxis.setFromMatrixColumn(this, 1);\n\t\t\tzAxis.setFromMatrixColumn(this, 2);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeBasis(xAxis, yAxis, zAxis) {\n\t\t\tthis.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\textractRotation(m) {\n\t\t\t// this method does not support reflection matrices\n\t\t\tconst te = this.elements;\n\t\t\tconst me = m.elements;\n\n\t\t\tconst scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();\n\n\t\t\tconst scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();\n\n\t\t\tconst scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();\n\n\t\t\tte[0] = me[0] * scaleX;\n\t\t\tte[1] = me[1] * scaleX;\n\t\t\tte[2] = me[2] * scaleX;\n\t\t\tte[3] = 0;\n\t\t\tte[4] = me[4] * scaleY;\n\t\t\tte[5] = me[5] * scaleY;\n\t\t\tte[6] = me[6] * scaleY;\n\t\t\tte[7] = 0;\n\t\t\tte[8] = me[8] * scaleZ;\n\t\t\tte[9] = me[9] * scaleZ;\n\t\t\tte[10] = me[10] * scaleZ;\n\t\t\tte[11] = 0;\n\t\t\tte[12] = 0;\n\t\t\tte[13] = 0;\n\t\t\tte[14] = 0;\n\t\t\tte[15] = 1;\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationFromEuler(euler) {\n\t\t\tif (!(euler && euler.isEuler)) {\n\t\t\t\tconsole.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');\n\t\t\t}\n\n\t\t\tconst te = this.elements;\n\t\t\tconst x = euler.x,\n\t\t\t\t\t\ty = euler.y,\n\t\t\t\t\t\tz = euler.z;\n\t\t\tconst a = Math.cos(x),\n\t\t\t\t\t\tb = Math.sin(x);\n\t\t\tconst c = Math.cos(y),\n\t\t\t\t\t\td = Math.sin(y);\n\t\t\tconst e = Math.cos(z),\n\t\t\t\t\t\tf = Math.sin(z);\n\n\t\t\tif (euler.order === 'XYZ') {\n\t\t\t\tconst ae = a * e,\n\t\t\t\t\t\t\taf = a * f,\n\t\t\t\t\t\t\tbe = b * e,\n\t\t\t\t\t\t\tbf = b * f;\n\t\t\t\tte[0] = c * e;\n\t\t\t\tte[4] = -c * f;\n\t\t\t\tte[8] = d;\n\t\t\t\tte[1] = af + be * d;\n\t\t\t\tte[5] = ae - bf * d;\n\t\t\t\tte[9] = -b * c;\n\t\t\t\tte[2] = bf - ae * d;\n\t\t\t\tte[6] = be + af * d;\n\t\t\t\tte[10] = a * c;\n\t\t\t} else if (euler.order === 'YXZ') {\n\t\t\t\tconst ce = c * e,\n\t\t\t\t\t\t\tcf = c * f,\n\t\t\t\t\t\t\tde = d * e,\n\t\t\t\t\t\t\tdf = d * f;\n\t\t\t\tte[0] = ce + df * b;\n\t\t\t\tte[4] = de * b - cf;\n\t\t\t\tte[8] = a * d;\n\t\t\t\tte[1] = a * f;\n\t\t\t\tte[5] = a * e;\n\t\t\t\tte[9] = -b;\n\t\t\t\tte[2] = cf * b - de;\n\t\t\t\tte[6] = df + ce * b;\n\t\t\t\tte[10] = a * c;\n\t\t\t} else if (euler.order === 'ZXY') {\n\t\t\t\tconst ce = c * e,\n\t\t\t\t\t\t\tcf = c * f,\n\t\t\t\t\t\t\tde = d * e,\n\t\t\t\t\t\t\tdf = d * f;\n\t\t\t\tte[0] = ce - df * b;\n\t\t\t\tte[4] = -a * f;\n\t\t\t\tte[8] = de + cf * b;\n\t\t\t\tte[1] = cf + de * b;\n\t\t\t\tte[5] = a * e;\n\t\t\t\tte[9] = df - ce * b;\n\t\t\t\tte[2] = -a * d;\n\t\t\t\tte[6] = b;\n\t\t\t\tte[10] = a * c;\n\t\t\t} else if (euler.order === 'ZYX') {\n\t\t\t\tconst ae = a * e,\n\t\t\t\t\t\t\taf = a * f,\n\t\t\t\t\t\t\tbe = b * e,\n\t\t\t\t\t\t\tbf = b * f;\n\t\t\t\tte[0] = c * e;\n\t\t\t\tte[4] = be * d - af;\n\t\t\t\tte[8] = ae * d + bf;\n\t\t\t\tte[1] = c * f;\n\t\t\t\tte[5] = bf * d + ae;\n\t\t\t\tte[9] = af * d - be;\n\t\t\t\tte[2] = -d;\n\t\t\t\tte[6] = b * c;\n\t\t\t\tte[10] = a * c;\n\t\t\t} else if (euler.order === 'YZX') {\n\t\t\t\tconst ac = a * c,\n\t\t\t\t\t\t\tad = a * d,\n\t\t\t\t\t\t\tbc = b * c,\n\t\t\t\t\t\t\tbd = b * d;\n\t\t\t\tte[0] = c * e;\n\t\t\t\tte[4] = bd - ac * f;\n\t\t\t\tte[8] = bc * f + ad;\n\t\t\t\tte[1] = f;\n\t\t\t\tte[5] = a * e;\n\t\t\t\tte[9] = -b * e;\n\t\t\t\tte[2] = -d * e;\n\t\t\t\tte[6] = ad * f + bc;\n\t\t\t\tte[10] = ac - bd * f;\n\t\t\t} else if (euler.order === 'XZY') {\n\t\t\t\tconst ac = a * c,\n\t\t\t\t\t\t\tad = a * d,\n\t\t\t\t\t\t\tbc = b * c,\n\t\t\t\t\t\t\tbd = b * d;\n\t\t\t\tte[0] = c * e;\n\t\t\t\tte[4] = -f;\n\t\t\t\tte[8] = d * e;\n\t\t\t\tte[1] = ac * f + bd;\n\t\t\t\tte[5] = a * e;\n\t\t\t\tte[9] = ad * f - bc;\n\t\t\t\tte[2] = bc * f - ad;\n\t\t\t\tte[6] = b * e;\n\t\t\t\tte[10] = bd * f + ac;\n\t\t\t} // bottom row\n\n\n\t\t\tte[3] = 0;\n\t\t\tte[7] = 0;\n\t\t\tte[11] = 0; // last column\n\n\t\t\tte[12] = 0;\n\t\t\tte[13] = 0;\n\t\t\tte[14] = 0;\n\t\t\tte[15] = 1;\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationFromQuaternion(q) {\n\t\t\treturn this.compose(_zero, q, _one);\n\t\t}\n\n\t\tlookAt(eye, target, up) {\n\t\t\tconst te = this.elements;\n\n\t\t\t_z.subVectors(eye, target);\n\n\t\t\tif (_z.lengthSq() === 0) {\n\t\t\t\t// eye and target are in the same position\n\t\t\t\t_z.z = 1;\n\t\t\t}\n\n\t\t\t_z.normalize();\n\n\t\t\t_x.crossVectors(up, _z);\n\n\t\t\tif (_x.lengthSq() === 0) {\n\t\t\t\t// up and z are parallel\n\t\t\t\tif (Math.abs(up.z) === 1) {\n\t\t\t\t\t_z.x += 0.0001;\n\t\t\t\t} else {\n\t\t\t\t\t_z.z += 0.0001;\n\t\t\t\t}\n\n\t\t\t\t_z.normalize();\n\n\t\t\t\t_x.crossVectors(up, _z);\n\t\t\t}\n\n\t\t\t_x.normalize();\n\n\t\t\t_y.crossVectors(_z, _x);\n\n\t\t\tte[0] = _x.x;\n\t\t\tte[4] = _y.x;\n\t\t\tte[8] = _z.x;\n\t\t\tte[1] = _x.y;\n\t\t\tte[5] = _y.y;\n\t\t\tte[9] = _z.y;\n\t\t\tte[2] = _x.z;\n\t\t\tte[6] = _y.z;\n\t\t\tte[10] = _z.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(m, n) {\n\t\t\tif (n !== undefined) {\n\t\t\t\tconsole.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');\n\t\t\t\treturn this.multiplyMatrices(m, n);\n\t\t\t}\n\n\t\t\treturn this.multiplyMatrices(this, m);\n\t\t}\n\n\t\tpremultiply(m) {\n\t\t\treturn this.multiplyMatrices(m, this);\n\t\t}\n\n\t\tmultiplyMatrices(a, b) {\n\t\t\tconst ae = a.elements;\n\t\t\tconst be = b.elements;\n\t\t\tconst te = this.elements;\n\t\t\tconst a11 = ae[0],\n\t\t\t\t\t\ta12 = ae[4],\n\t\t\t\t\t\ta13 = ae[8],\n\t\t\t\t\t\ta14 = ae[12];\n\t\t\tconst a21 = ae[1],\n\t\t\t\t\t\ta22 = ae[5],\n\t\t\t\t\t\ta23 = ae[9],\n\t\t\t\t\t\ta24 = ae[13];\n\t\t\tconst a31 = ae[2],\n\t\t\t\t\t\ta32 = ae[6],\n\t\t\t\t\t\ta33 = ae[10],\n\t\t\t\t\t\ta34 = ae[14];\n\t\t\tconst a41 = ae[3],\n\t\t\t\t\t\ta42 = ae[7],\n\t\t\t\t\t\ta43 = ae[11],\n\t\t\t\t\t\ta44 = ae[15];\n\t\t\tconst b11 = be[0],\n\t\t\t\t\t\tb12 = be[4],\n\t\t\t\t\t\tb13 = be[8],\n\t\t\t\t\t\tb14 = be[12];\n\t\t\tconst b21 = be[1],\n\t\t\t\t\t\tb22 = be[5],\n\t\t\t\t\t\tb23 = be[9],\n\t\t\t\t\t\tb24 = be[13];\n\t\t\tconst b31 = be[2],\n\t\t\t\t\t\tb32 = be[6],\n\t\t\t\t\t\tb33 = be[10],\n\t\t\t\t\t\tb34 = be[14];\n\t\t\tconst b41 = be[3],\n\t\t\t\t\t\tb42 = be[7],\n\t\t\t\t\t\tb43 = be[11],\n\t\t\t\t\t\tb44 = be[15];\n\t\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\tte[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\tte[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\tte[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\t\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\tte[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\tte[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\tte[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\t\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\tte[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\tte[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\tte[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\t\t\tte[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\tte[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\tte[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\tte[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(s) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] *= s;\n\t\t\tte[4] *= s;\n\t\t\tte[8] *= s;\n\t\t\tte[12] *= s;\n\t\t\tte[1] *= s;\n\t\t\tte[5] *= s;\n\t\t\tte[9] *= s;\n\t\t\tte[13] *= s;\n\t\t\tte[2] *= s;\n\t\t\tte[6] *= s;\n\t\t\tte[10] *= s;\n\t\t\tte[14] *= s;\n\t\t\tte[3] *= s;\n\t\t\tte[7] *= s;\n\t\t\tte[11] *= s;\n\t\t\tte[15] *= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tdeterminant() {\n\t\t\tconst te = this.elements;\n\t\t\tconst n11 = te[0],\n\t\t\t\t\t\tn12 = te[4],\n\t\t\t\t\t\tn13 = te[8],\n\t\t\t\t\t\tn14 = te[12];\n\t\t\tconst n21 = te[1],\n\t\t\t\t\t\tn22 = te[5],\n\t\t\t\t\t\tn23 = te[9],\n\t\t\t\t\t\tn24 = te[13];\n\t\t\tconst n31 = te[2],\n\t\t\t\t\t\tn32 = te[6],\n\t\t\t\t\t\tn33 = te[10],\n\t\t\t\t\t\tn34 = te[14];\n\t\t\tconst n41 = te[3],\n\t\t\t\t\t\tn42 = te[7],\n\t\t\t\t\t\tn43 = te[11],\n\t\t\t\t\t\tn44 = te[15]; //TODO: make this more efficient\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\t\treturn n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n\t\t}\n\n\t\ttranspose() {\n\t\t\tconst te = this.elements;\n\t\t\tlet tmp;\n\t\t\ttmp = te[1];\n\t\t\tte[1] = te[4];\n\t\t\tte[4] = tmp;\n\t\t\ttmp = te[2];\n\t\t\tte[2] = te[8];\n\t\t\tte[8] = tmp;\n\t\t\ttmp = te[6];\n\t\t\tte[6] = te[9];\n\t\t\tte[9] = tmp;\n\t\t\ttmp = te[3];\n\t\t\tte[3] = te[12];\n\t\t\tte[12] = tmp;\n\t\t\ttmp = te[7];\n\t\t\tte[7] = te[13];\n\t\t\tte[13] = tmp;\n\t\t\ttmp = te[11];\n\t\t\tte[11] = te[14];\n\t\t\tte[14] = tmp;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetPosition(x, y, z) {\n\t\t\tconst te = this.elements;\n\n\t\t\tif (x.isVector3) {\n\t\t\t\tte[12] = x.x;\n\t\t\t\tte[13] = x.y;\n\t\t\t\tte[14] = x.z;\n\t\t\t} else {\n\t\t\t\tte[12] = x;\n\t\t\t\tte[13] = y;\n\t\t\t\tte[14] = z;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tinvert() {\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\tconst te = this.elements,\n\t\t\t\t\t\tn11 = te[0],\n\t\t\t\t\t\tn21 = te[1],\n\t\t\t\t\t\tn31 = te[2],\n\t\t\t\t\t\tn41 = te[3],\n\t\t\t\t\t\tn12 = te[4],\n\t\t\t\t\t\tn22 = te[5],\n\t\t\t\t\t\tn32 = te[6],\n\t\t\t\t\t\tn42 = te[7],\n\t\t\t\t\t\tn13 = te[8],\n\t\t\t\t\t\tn23 = te[9],\n\t\t\t\t\t\tn33 = te[10],\n\t\t\t\t\t\tn43 = te[11],\n\t\t\t\t\t\tn14 = te[12],\n\t\t\t\t\t\tn24 = te[13],\n\t\t\t\t\t\tn34 = te[14],\n\t\t\t\t\t\tn44 = te[15],\n\t\t\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\t\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\t\t\tif (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\t\t\tconst detInv = 1 / det;\n\t\t\tte[0] = t11 * detInv;\n\t\t\tte[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n\t\t\tte[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n\t\t\tte[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n\t\t\tte[4] = t12 * detInv;\n\t\t\tte[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n\t\t\tte[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n\t\t\tte[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n\t\t\tte[8] = t13 * detInv;\n\t\t\tte[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n\t\t\tte[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n\t\t\tte[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n\t\t\tte[12] = t14 * detInv;\n\t\t\tte[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n\t\t\tte[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n\t\t\tte[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n\t\t\treturn this;\n\t\t}\n\n\t\tscale(v) {\n\t\t\tconst te = this.elements;\n\t\t\tconst x = v.x,\n\t\t\t\t\t\ty = v.y,\n\t\t\t\t\t\tz = v.z;\n\t\t\tte[0] *= x;\n\t\t\tte[4] *= y;\n\t\t\tte[8] *= z;\n\t\t\tte[1] *= x;\n\t\t\tte[5] *= y;\n\t\t\tte[9] *= z;\n\t\t\tte[2] *= x;\n\t\t\tte[6] *= y;\n\t\t\tte[10] *= z;\n\t\t\tte[3] *= x;\n\t\t\tte[7] *= y;\n\t\t\tte[11] *= z;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetMaxScaleOnAxis() {\n\t\t\tconst te = this.elements;\n\t\t\tconst scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n\t\t\tconst scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n\t\t\tconst scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n\t\t\treturn Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n\t\t}\n\n\t\tmakeTranslation(x, y, z) {\n\t\t\tthis.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationX(theta) {\n\t\t\tconst c = Math.cos(theta),\n\t\t\t\t\t\ts = Math.sin(theta);\n\t\t\tthis.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationY(theta) {\n\t\t\tconst c = Math.cos(theta),\n\t\t\t\t\t\ts = Math.sin(theta);\n\t\t\tthis.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationZ(theta) {\n\t\t\tconst c = Math.cos(theta),\n\t\t\t\t\t\ts = Math.sin(theta);\n\t\t\tthis.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationAxis(axis, angle) {\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\t\t\tconst c = Math.cos(angle);\n\t\t\tconst s = Math.sin(angle);\n\t\t\tconst t = 1 - c;\n\t\t\tconst x = axis.x,\n\t\t\t\t\t\ty = axis.y,\n\t\t\t\t\t\tz = axis.z;\n\t\t\tconst tx = t * x,\n\t\t\t\t\t\tty = t * y;\n\t\t\tthis.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeScale(x, y, z) {\n\t\t\tthis.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeShear(xy, xz, yx, yz, zx, zy) {\n\t\t\tthis.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tcompose(position, quaternion, scale) {\n\t\t\tconst te = this.elements;\n\t\t\tconst x = quaternion._x,\n\t\t\t\t\t\ty = quaternion._y,\n\t\t\t\t\t\tz = quaternion._z,\n\t\t\t\t\t\tw = quaternion._w;\n\t\t\tconst x2 = x + x,\n\t\t\t\t\t\ty2 = y + y,\n\t\t\t\t\t\tz2 = z + z;\n\t\t\tconst xx = x * x2,\n\t\t\t\t\t\txy = x * y2,\n\t\t\t\t\t\txz = x * z2;\n\t\t\tconst yy = y * y2,\n\t\t\t\t\t\tyz = y * z2,\n\t\t\t\t\t\tzz = z * z2;\n\t\t\tconst wx = w * x2,\n\t\t\t\t\t\twy = w * y2,\n\t\t\t\t\t\twz = w * z2;\n\t\t\tconst sx = scale.x,\n\t\t\t\t\t\tsy = scale.y,\n\t\t\t\t\t\tsz = scale.z;\n\t\t\tte[0] = (1 - (yy + zz)) * sx;\n\t\t\tte[1] = (xy + wz) * sx;\n\t\t\tte[2] = (xz - wy) * sx;\n\t\t\tte[3] = 0;\n\t\t\tte[4] = (xy - wz) * sy;\n\t\t\tte[5] = (1 - (xx + zz)) * sy;\n\t\t\tte[6] = (yz + wx) * sy;\n\t\t\tte[7] = 0;\n\t\t\tte[8] = (xz + wy) * sz;\n\t\t\tte[9] = (yz - wx) * sz;\n\t\t\tte[10] = (1 - (xx + yy)) * sz;\n\t\t\tte[11] = 0;\n\t\t\tte[12] = position.x;\n\t\t\tte[13] = position.y;\n\t\t\tte[14] = position.z;\n\t\t\tte[15] = 1;\n\t\t\treturn this;\n\t\t}\n\n\t\tdecompose(position, quaternion, scale) {\n\t\t\tconst te = this.elements;\n\n\t\t\tlet sx = _v1$5.set(te[0], te[1], te[2]).length();\n\n\t\t\tconst sy = _v1$5.set(te[4], te[5], te[6]).length();\n\n\t\t\tconst sz = _v1$5.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale\n\n\n\t\t\tconst det = this.determinant();\n\t\t\tif (det < 0) sx = -sx;\n\t\t\tposition.x = te[12];\n\t\t\tposition.y = te[13];\n\t\t\tposition.z = te[14]; // scale the rotation part\n\n\t\t\t_m1$2.copy(this);\n\n\t\t\tconst invSX = 1 / sx;\n\t\t\tconst invSY = 1 / sy;\n\t\t\tconst invSZ = 1 / sz;\n\t\t\t_m1$2.elements[0] *= invSX;\n\t\t\t_m1$2.elements[1] *= invSX;\n\t\t\t_m1$2.elements[2] *= invSX;\n\t\t\t_m1$2.elements[4] *= invSY;\n\t\t\t_m1$2.elements[5] *= invSY;\n\t\t\t_m1$2.elements[6] *= invSY;\n\t\t\t_m1$2.elements[8] *= invSZ;\n\t\t\t_m1$2.elements[9] *= invSZ;\n\t\t\t_m1$2.elements[10] *= invSZ;\n\t\t\tquaternion.setFromRotationMatrix(_m1$2);\n\t\t\tscale.x = sx;\n\t\t\tscale.y = sy;\n\t\t\tscale.z = sz;\n\t\t\treturn this;\n\t\t}\n\n\t\tmakePerspective(left, right, top, bottom, near, far) {\n\t\t\tif (far === undefined) {\n\t\t\t\tconsole.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');\n\t\t\t}\n\n\t\t\tconst te = this.elements;\n\t\t\tconst x = 2 * near / (right - left);\n\t\t\tconst y = 2 * near / (top - bottom);\n\t\t\tconst a = (right + left) / (right - left);\n\t\t\tconst b = (top + bottom) / (top - bottom);\n\t\t\tconst c = -(far + near) / (far - near);\n\t\t\tconst d = -2 * far * near / (far - near);\n\t\t\tte[0] = x;\n\t\t\tte[4] = 0;\n\t\t\tte[8] = a;\n\t\t\tte[12] = 0;\n\t\t\tte[1] = 0;\n\t\t\tte[5] = y;\n\t\t\tte[9] = b;\n\t\t\tte[13] = 0;\n\t\t\tte[2] = 0;\n\t\t\tte[6] = 0;\n\t\t\tte[10] = c;\n\t\t\tte[14] = d;\n\t\t\tte[3] = 0;\n\t\t\tte[7] = 0;\n\t\t\tte[11] = -1;\n\t\t\tte[15] = 0;\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeOrthographic(left, right, top, bottom, near, far) {\n\t\t\tconst te = this.elements;\n\t\t\tconst w = 1.0 / (right - left);\n\t\t\tconst h = 1.0 / (top - bottom);\n\t\t\tconst p = 1.0 / (far - near);\n\t\t\tconst x = (right + left) * w;\n\t\t\tconst y = (top + bottom) * h;\n\t\t\tconst z = (far + near) * p;\n\t\t\tte[0] = 2 * w;\n\t\t\tte[4] = 0;\n\t\t\tte[8] = 0;\n\t\t\tte[12] = -x;\n\t\t\tte[1] = 0;\n\t\t\tte[5] = 2 * h;\n\t\t\tte[9] = 0;\n\t\t\tte[13] = -y;\n\t\t\tte[2] = 0;\n\t\t\tte[6] = 0;\n\t\t\tte[10] = -2 * p;\n\t\t\tte[14] = -z;\n\t\t\tte[3] = 0;\n\t\t\tte[7] = 0;\n\t\t\tte[11] = 0;\n\t\t\tte[15] = 1;\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(matrix) {\n\t\t\tconst te = this.elements;\n\t\t\tconst me = matrix.elements;\n\n\t\t\tfor (let i = 0; i < 16; i++) {\n\t\t\t\tif (te[i] !== me[i]) return false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tfor (let i = 0; i < 16; i++) {\n\t\t\t\tthis.elements[i] = array[i + offset];\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tconst te = this.elements;\n\t\t\tarray[offset] = te[0];\n\t\t\tarray[offset + 1] = te[1];\n\t\t\tarray[offset + 2] = te[2];\n\t\t\tarray[offset + 3] = te[3];\n\t\t\tarray[offset + 4] = te[4];\n\t\t\tarray[offset + 5] = te[5];\n\t\t\tarray[offset + 6] = te[6];\n\t\t\tarray[offset + 7] = te[7];\n\t\t\tarray[offset + 8] = te[8];\n\t\t\tarray[offset + 9] = te[9];\n\t\t\tarray[offset + 10] = te[10];\n\t\t\tarray[offset + 11] = te[11];\n\t\t\tarray[offset + 12] = te[12];\n\t\t\tarray[offset + 13] = te[13];\n\t\t\tarray[offset + 14] = te[14];\n\t\t\tarray[offset + 15] = te[15];\n\t\t\treturn array;\n\t\t}\n\n\t}\n\n\tMatrix4.prototype.isMatrix4 = true;\n\n\tconst _v1$5 = /*@__PURE__*/new Vector3();\n\n\tconst _m1$2 = /*@__PURE__*/new Matrix4();\n\n\tconst _zero = /*@__PURE__*/new Vector3(0, 0, 0);\n\n\tconst _one = /*@__PURE__*/new Vector3(1, 1, 1);\n\n\tconst _x = /*@__PURE__*/new Vector3();\n\n\tconst _y = /*@__PURE__*/new Vector3();\n\n\tconst _z = /*@__PURE__*/new Vector3();\n\n\tconst _matrix$1 = /*@__PURE__*/new Matrix4();\n\n\tconst _quaternion$3 = /*@__PURE__*/new Quaternion();\n\n\tclass Euler {\n\t\tconstructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._order = order;\n\t\t}\n\n\t\tget x() {\n\t\t\treturn this._x;\n\t\t}\n\n\t\tset x(value) {\n\t\t\tthis._x = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget y() {\n\t\t\treturn this._y;\n\t\t}\n\n\t\tset y(value) {\n\t\t\tthis._y = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget z() {\n\t\t\treturn this._z;\n\t\t}\n\n\t\tset z(value) {\n\t\t\tthis._z = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget order() {\n\t\t\treturn this._order;\n\t\t}\n\n\t\tset order(value) {\n\t\t\tthis._order = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tset(x, y, z, order) {\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._order = order || this._order;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this._x, this._y, this._z, this._order);\n\t\t}\n\n\t\tcopy(euler) {\n\t\t\tthis._x = euler._x;\n\t\t\tthis._y = euler._y;\n\t\t\tthis._z = euler._z;\n\t\t\tthis._order = euler._order;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromRotationMatrix(m, order, update) {\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\t\tconst te = m.elements;\n\t\t\tconst m11 = te[0],\n\t\t\t\t\t\tm12 = te[4],\n\t\t\t\t\t\tm13 = te[8];\n\t\t\tconst m21 = te[1],\n\t\t\t\t\t\tm22 = te[5],\n\t\t\t\t\t\tm23 = te[9];\n\t\t\tconst m31 = te[2],\n\t\t\t\t\t\tm32 = te[6],\n\t\t\t\t\t\tm33 = te[10];\n\t\t\torder = order || this._order;\n\n\t\t\tswitch (order) {\n\t\t\t\tcase 'XYZ':\n\t\t\t\t\tthis._y = Math.asin(clamp(m13, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m13) < 0.9999999) {\n\t\t\t\t\t\tthis._x = Math.atan2(-m23, m33);\n\t\t\t\t\t\tthis._z = Math.atan2(-m12, m11);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._x = Math.atan2(m32, m22);\n\t\t\t\t\t\tthis._z = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'YXZ':\n\t\t\t\t\tthis._x = Math.asin(-clamp(m23, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m23) < 0.9999999) {\n\t\t\t\t\t\tthis._y = Math.atan2(m13, m33);\n\t\t\t\t\t\tthis._z = Math.atan2(m21, m22);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._y = Math.atan2(-m31, m11);\n\t\t\t\t\t\tthis._z = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZXY':\n\t\t\t\t\tthis._x = Math.asin(clamp(m32, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m32) < 0.9999999) {\n\t\t\t\t\t\tthis._y = Math.atan2(-m31, m33);\n\t\t\t\t\t\tthis._z = Math.atan2(-m12, m22);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._y = 0;\n\t\t\t\t\t\tthis._z = Math.atan2(m21, m11);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZYX':\n\t\t\t\t\tthis._y = Math.asin(-clamp(m31, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m31) < 0.9999999) {\n\t\t\t\t\t\tthis._x = Math.atan2(m32, m33);\n\t\t\t\t\t\tthis._z = Math.atan2(m21, m11);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\tthis._z = Math.atan2(-m12, m22);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'YZX':\n\t\t\t\t\tthis._z = Math.asin(clamp(m21, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m21) < 0.9999999) {\n\t\t\t\t\t\tthis._x = Math.atan2(-m23, m22);\n\t\t\t\t\t\tthis._y = Math.atan2(-m31, m11);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\tthis._y = Math.atan2(m13, m33);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'XZY':\n\t\t\t\t\tthis._z = Math.asin(-clamp(m12, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m12) < 0.9999999) {\n\t\t\t\t\t\tthis._x = Math.atan2(m32, m22);\n\t\t\t\t\t\tthis._y = Math.atan2(m13, m11);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._x = Math.atan2(-m23, m33);\n\t\t\t\t\t\tthis._y = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);\n\t\t\t}\n\n\t\t\tthis._order = order;\n\t\t\tif (update !== false) this._onChangeCallback();\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromQuaternion(q, order, update) {\n\t\t\t_matrix$1.makeRotationFromQuaternion(q);\n\n\t\t\treturn this.setFromRotationMatrix(_matrix$1, order, update);\n\t\t}\n\n\t\tsetFromVector3(v, order) {\n\t\t\treturn this.set(v.x, v.y, v.z, order || this._order);\n\t\t}\n\n\t\treorder(newOrder) {\n\t\t\t// WARNING: this discards revolution information -bhouston\n\t\t\t_quaternion$3.setFromEuler(this);\n\n\t\t\treturn this.setFromQuaternion(_quaternion$3, newOrder);\n\t\t}\n\n\t\tequals(euler) {\n\t\t\treturn euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n\t\t}\n\n\t\tfromArray(array) {\n\t\t\tthis._x = array[0];\n\t\t\tthis._y = array[1];\n\t\t\tthis._z = array[2];\n\t\t\tif (array[3] !== undefined) this._order = array[3];\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this._x;\n\t\t\tarray[offset + 1] = this._y;\n\t\t\tarray[offset + 2] = this._z;\n\t\t\tarray[offset + 3] = this._order;\n\t\t\treturn array;\n\t\t}\n\n\t\ttoVector3(optionalResult) {\n\t\t\tif (optionalResult) {\n\t\t\t\treturn optionalResult.set(this._x, this._y, this._z);\n\t\t\t} else {\n\t\t\t\treturn new Vector3(this._x, this._y, this._z);\n\t\t\t}\n\t\t}\n\n\t\t_onChange(callback) {\n\t\t\tthis._onChangeCallback = callback;\n\t\t\treturn this;\n\t\t}\n\n\t\t_onChangeCallback() {}\n\n\t}\n\n\tEuler.prototype.isEuler = true;\n\tEuler.DefaultOrder = 'XYZ';\n\tEuler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];\n\n\tclass Layers {\n\t\tconstructor() {\n\t\t\tthis.mask = 1 | 0;\n\t\t}\n\n\t\tset(channel) {\n\t\t\tthis.mask = 1 << channel | 0;\n\t\t}\n\n\t\tenable(channel) {\n\t\t\tthis.mask |= 1 << channel | 0;\n\t\t}\n\n\t\tenableAll() {\n\t\t\tthis.mask = 0xffffffff | 0;\n\t\t}\n\n\t\ttoggle(channel) {\n\t\t\tthis.mask ^= 1 << channel | 0;\n\t\t}\n\n\t\tdisable(channel) {\n\t\t\tthis.mask &= ~(1 << channel | 0);\n\t\t}\n\n\t\tdisableAll() {\n\t\t\tthis.mask = 0;\n\t\t}\n\n\t\ttest(layers) {\n\t\t\treturn (this.mask & layers.mask) !== 0;\n\t\t}\n\n\t}\n\n\tlet _object3DId = 0;\n\n\tconst _v1$4 = /*@__PURE__*/new Vector3();\n\n\tconst _q1 = /*@__PURE__*/new Quaternion();\n\n\tconst _m1$1 = /*@__PURE__*/new Matrix4();\n\n\tconst _target = /*@__PURE__*/new Vector3();\n\n\tconst _position$3 = /*@__PURE__*/new Vector3();\n\n\tconst _scale$2 = /*@__PURE__*/new Vector3();\n\n\tconst _quaternion$2 = /*@__PURE__*/new Quaternion();\n\n\tconst _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);\n\n\tconst _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);\n\n\tconst _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);\n\n\tconst _addedEvent = {\n\t\ttype: 'added'\n\t};\n\tconst _removedEvent = {\n\t\ttype: 'removed'\n\t};\n\n\tclass Object3D extends EventDispatcher {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tObject.defineProperty(this, 'id', {\n\t\t\t\tvalue: _object3DId++\n\t\t\t});\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Object3D';\n\t\t\tthis.parent = null;\n\t\t\tthis.children = [];\n\t\t\tthis.up = Object3D.DefaultUp.clone();\n\t\t\tconst position = new Vector3();\n\t\t\tconst rotation = new Euler();\n\t\t\tconst quaternion = new Quaternion();\n\t\t\tconst scale = new Vector3(1, 1, 1);\n\n\t\t\tfunction onRotationChange() {\n\t\t\t\tquaternion.setFromEuler(rotation, false);\n\t\t\t}\n\n\t\t\tfunction onQuaternionChange() {\n\t\t\t\trotation.setFromQuaternion(quaternion, undefined, false);\n\t\t\t}\n\n\t\t\trotation._onChange(onRotationChange);\n\n\t\t\tquaternion._onChange(onQuaternionChange);\n\n\t\t\tObject.defineProperties(this, {\n\t\t\t\tposition: {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: position\n\t\t\t\t},\n\t\t\t\trotation: {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: rotation\n\t\t\t\t},\n\t\t\t\tquaternion: {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: quaternion\n\t\t\t\t},\n\t\t\t\tscale: {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: scale\n\t\t\t\t},\n\t\t\t\tmodelViewMatrix: {\n\t\t\t\t\tvalue: new Matrix4()\n\t\t\t\t},\n\t\t\t\tnormalMatrix: {\n\t\t\t\t\tvalue: new Matrix3()\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.matrix = new Matrix4();\n\t\t\tthis.matrixWorld = new Matrix4();\n\t\t\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\t\t\tthis.layers = new Layers();\n\t\t\tthis.visible = true;\n\t\t\tthis.castShadow = false;\n\t\t\tthis.receiveShadow = false;\n\t\t\tthis.frustumCulled = true;\n\t\t\tthis.renderOrder = 0;\n\t\t\tthis.animations = [];\n\t\t\tthis.userData = {};\n\t\t}\n\n\t\tonBeforeRender() {}\n\n\t\tonAfterRender() {}\n\n\t\tapplyMatrix4(matrix) {\n\t\t\tif (this.matrixAutoUpdate) this.updateMatrix();\n\t\t\tthis.matrix.premultiply(matrix);\n\t\t\tthis.matrix.decompose(this.position, this.quaternion, this.scale);\n\t\t}\n\n\t\tapplyQuaternion(q) {\n\t\t\tthis.quaternion.premultiply(q);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetRotationFromAxisAngle(axis, angle) {\n\t\t\t// assumes axis is normalized\n\t\t\tthis.quaternion.setFromAxisAngle(axis, angle);\n\t\t}\n\n\t\tsetRotationFromEuler(euler) {\n\t\t\tthis.quaternion.setFromEuler(euler, true);\n\t\t}\n\n\t\tsetRotationFromMatrix(m) {\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\t\tthis.quaternion.setFromRotationMatrix(m);\n\t\t}\n\n\t\tsetRotationFromQuaternion(q) {\n\t\t\t// assumes q is normalized\n\t\t\tthis.quaternion.copy(q);\n\t\t}\n\n\t\trotateOnAxis(axis, angle) {\n\t\t\t// rotate object on axis in object space\n\t\t\t// axis is assumed to be normalized\n\t\t\t_q1.setFromAxisAngle(axis, angle);\n\n\t\t\tthis.quaternion.multiply(_q1);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateOnWorldAxis(axis, angle) {\n\t\t\t// rotate object on axis in world space\n\t\t\t// axis is assumed to be normalized\n\t\t\t// method assumes no rotated parent\n\t\t\t_q1.setFromAxisAngle(axis, angle);\n\n\t\t\tthis.quaternion.premultiply(_q1);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateX(angle) {\n\t\t\treturn this.rotateOnAxis(_xAxis, angle);\n\t\t}\n\n\t\trotateY(angle) {\n\t\t\treturn this.rotateOnAxis(_yAxis, angle);\n\t\t}\n\n\t\trotateZ(angle) {\n\t\t\treturn this.rotateOnAxis(_zAxis, angle);\n\t\t}\n\n\t\ttranslateOnAxis(axis, distance) {\n\t\t\t// translate object by distance along axis in object space\n\t\t\t// axis is assumed to be normalized\n\t\t\t_v1$4.copy(axis).applyQuaternion(this.quaternion);\n\n\t\t\tthis.position.add(_v1$4.multiplyScalar(distance));\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslateX(distance) {\n\t\t\treturn this.translateOnAxis(_xAxis, distance);\n\t\t}\n\n\t\ttranslateY(distance) {\n\t\t\treturn this.translateOnAxis(_yAxis, distance);\n\t\t}\n\n\t\ttranslateZ(distance) {\n\t\t\treturn this.translateOnAxis(_zAxis, distance);\n\t\t}\n\n\t\tlocalToWorld(vector) {\n\t\t\treturn vector.applyMatrix4(this.matrixWorld);\n\t\t}\n\n\t\tworldToLocal(vector) {\n\t\t\treturn vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());\n\t\t}\n\n\t\tlookAt(x, y, z) {\n\t\t\t// This method does not support objects having non-uniformly-scaled parent(s)\n\t\t\tif (x.isVector3) {\n\t\t\t\t_target.copy(x);\n\t\t\t} else {\n\t\t\t\t_target.set(x, y, z);\n\t\t\t}\n\n\t\t\tconst parent = this.parent;\n\t\t\tthis.updateWorldMatrix(true, false);\n\n\t\t\t_position$3.setFromMatrixPosition(this.matrixWorld);\n\n\t\t\tif (this.isCamera || this.isLight) {\n\t\t\t\t_m1$1.lookAt(_position$3, _target, this.up);\n\t\t\t} else {\n\t\t\t\t_m1$1.lookAt(_target, _position$3, this.up);\n\t\t\t}\n\n\t\t\tthis.quaternion.setFromRotationMatrix(_m1$1);\n\n\t\t\tif (parent) {\n\t\t\t\t_m1$1.extractRotation(parent.matrixWorld);\n\n\t\t\t\t_q1.setFromRotationMatrix(_m1$1);\n\n\t\t\t\tthis.quaternion.premultiply(_q1.invert());\n\t\t\t}\n\t\t}\n\n\t\tadd(object) {\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\t\t\tthis.add(arguments[i]);\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (object === this) {\n\t\t\t\tconsole.error('THREE.Object3D.add: object can\\'t be added as a child of itself.', object);\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (object && object.isObject3D) {\n\t\t\t\tif (object.parent !== null) {\n\t\t\t\t\tobject.parent.remove(object);\n\t\t\t\t}\n\n\t\t\t\tobject.parent = this;\n\t\t\t\tthis.children.push(object);\n\t\t\t\tobject.dispatchEvent(_addedEvent);\n\t\t\t} else {\n\t\t\t\tconsole.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tremove(object) {\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\t\t\tthis.remove(arguments[i]);\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tconst index = this.children.indexOf(object);\n\n\t\t\tif (index !== -1) {\n\t\t\t\tobject.parent = null;\n\t\t\t\tthis.children.splice(index, 1);\n\t\t\t\tobject.dispatchEvent(_removedEvent);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tremoveFromParent() {\n\t\t\tconst parent = this.parent;\n\n\t\t\tif (parent !== null) {\n\t\t\t\tparent.remove(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclear() {\n\t\t\tfor (let i = 0; i < this.children.length; i++) {\n\t\t\t\tconst object = this.children[i];\n\t\t\t\tobject.parent = null;\n\t\t\t\tobject.dispatchEvent(_removedEvent);\n\t\t\t}\n\n\t\t\tthis.children.length = 0;\n\t\t\treturn this;\n\t\t}\n\n\t\tattach(object) {\n\t\t\t// adds object as a child of this, while maintaining the object's world transform\n\t\t\tthis.updateWorldMatrix(true, false);\n\n\t\t\t_m1$1.copy(this.matrixWorld).invert();\n\n\t\t\tif (object.parent !== null) {\n\t\t\t\tobject.parent.updateWorldMatrix(true, false);\n\n\t\t\t\t_m1$1.multiply(object.parent.matrixWorld);\n\t\t\t}\n\n\t\t\tobject.applyMatrix4(_m1$1);\n\t\t\tthis.add(object);\n\t\t\tobject.updateWorldMatrix(false, true);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetObjectById(id) {\n\t\t\treturn this.getObjectByProperty('id', id);\n\t\t}\n\n\t\tgetObjectByName(name) {\n\t\t\treturn this.getObjectByProperty('name', name);\n\t\t}\n\n\t\tgetObjectByProperty(name, value) {\n\t\t\tif (this[name] === value) return this;\n\n\t\t\tfor (let i = 0, l = this.children.length; i < l; i++) {\n\t\t\t\tconst child = this.children[i];\n\t\t\t\tconst object = child.getObjectByProperty(name, value);\n\n\t\t\t\tif (object !== undefined) {\n\t\t\t\t\treturn object;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\tgetWorldPosition(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Object3D: .getWorldPosition() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tthis.updateWorldMatrix(true, false);\n\t\t\treturn target.setFromMatrixPosition(this.matrixWorld);\n\t\t}\n\n\t\tgetWorldQuaternion(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Object3D: .getWorldQuaternion() target is now required');\n\t\t\t\ttarget = new Quaternion();\n\t\t\t}\n\n\t\t\tthis.updateWorldMatrix(true, false);\n\t\t\tthis.matrixWorld.decompose(_position$3, target, _scale$2);\n\t\t\treturn target;\n\t\t}\n\n\t\tgetWorldScale(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Object3D: .getWorldScale() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tthis.updateWorldMatrix(true, false);\n\t\t\tthis.matrixWorld.decompose(_position$3, _quaternion$2, target);\n\t\t\treturn target;\n\t\t}\n\n\t\tgetWorldDirection(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Object3D: .getWorldDirection() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tthis.updateWorldMatrix(true, false);\n\t\t\tconst e = this.matrixWorld.elements;\n\t\t\treturn target.set(e[8], e[9], e[10]).normalize();\n\t\t}\n\n\t\traycast() {}\n\n\t\ttraverse(callback) {\n\t\t\tcallback(this);\n\t\t\tconst children = this.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tchildren[i].traverse(callback);\n\t\t\t}\n\t\t}\n\n\t\ttraverseVisible(callback) {\n\t\t\tif (this.visible === false) return;\n\t\t\tcallback(this);\n\t\t\tconst children = this.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tchildren[i].traverseVisible(callback);\n\t\t\t}\n\t\t}\n\n\t\ttraverseAncestors(callback) {\n\t\t\tconst parent = this.parent;\n\n\t\t\tif (parent !== null) {\n\t\t\t\tcallback(parent);\n\t\t\t\tparent.traverseAncestors(callback);\n\t\t\t}\n\t\t}\n\n\t\tupdateMatrix() {\n\t\t\tthis.matrix.compose(this.position, this.quaternion, this.scale);\n\t\t\tthis.matrixWorldNeedsUpdate = true;\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tif (this.matrixAutoUpdate) this.updateMatrix();\n\n\t\t\tif (this.matrixWorldNeedsUpdate || force) {\n\t\t\t\tif (this.parent === null) {\n\t\t\t\t\tthis.matrixWorld.copy(this.matrix);\n\t\t\t\t} else {\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n\t\t\t\t}\n\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\t\t\t\tforce = true;\n\t\t\t} // update children\n\n\n\t\t\tconst children = this.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tchildren[i].updateMatrixWorld(force);\n\t\t\t}\n\t\t}\n\n\t\tupdateWorldMatrix(updateParents, updateChildren) {\n\t\t\tconst parent = this.parent;\n\n\t\t\tif (updateParents === true && parent !== null) {\n\t\t\t\tparent.updateWorldMatrix(true, false);\n\t\t\t}\n\n\t\t\tif (this.matrixAutoUpdate) this.updateMatrix();\n\n\t\t\tif (this.parent === null) {\n\t\t\t\tthis.matrixWorld.copy(this.matrix);\n\t\t\t} else {\n\t\t\t\tthis.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n\t\t\t} // update children\n\n\n\t\t\tif (updateChildren === true) {\n\t\t\t\tconst children = this.children;\n\n\t\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tchildren[i].updateWorldMatrix(false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\t// meta is a string when called from JSON.stringify\n\t\t\tconst isRootObject = meta === undefined || typeof meta === 'string';\n\t\t\tconst output = {}; // meta is a hash used to collect geometries, materials.\n\t\t\t// not providing it implies that this is the root object\n\t\t\t// being serialized.\n\n\t\t\tif (isRootObject) {\n\t\t\t\t// initialize meta obj\n\t\t\t\tmeta = {\n\t\t\t\t\tgeometries: {},\n\t\t\t\t\tmaterials: {},\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {},\n\t\t\t\t\tshapes: {},\n\t\t\t\t\tskeletons: {},\n\t\t\t\t\tanimations: {}\n\t\t\t\t};\n\t\t\t\toutput.metadata = {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Object',\n\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t};\n\t\t\t} // standard Object3D serialization\n\n\n\t\t\tconst object = {};\n\t\t\tobject.uuid = this.uuid;\n\t\t\tobject.type = this.type;\n\t\t\tif (this.name !== '') object.name = this.name;\n\t\t\tif (this.castShadow === true) object.castShadow = true;\n\t\t\tif (this.receiveShadow === true) object.receiveShadow = true;\n\t\t\tif (this.visible === false) object.visible = false;\n\t\t\tif (this.frustumCulled === false) object.frustumCulled = false;\n\t\t\tif (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n\t\t\tif (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;\n\t\t\tobject.layers = this.layers.mask;\n\t\t\tobject.matrix = this.matrix.toArray();\n\t\t\tif (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties\n\n\t\t\tif (this.isInstancedMesh) {\n\t\t\t\tobject.type = 'InstancedMesh';\n\t\t\t\tobject.count = this.count;\n\t\t\t\tobject.instanceMatrix = this.instanceMatrix.toJSON();\n\t\t\t\tif (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();\n\t\t\t} //\n\n\n\t\t\tfunction serialize(library, element) {\n\t\t\t\tif (library[element.uuid] === undefined) {\n\t\t\t\t\tlibrary[element.uuid] = element.toJSON(meta);\n\t\t\t\t}\n\n\t\t\t\treturn element.uuid;\n\t\t\t}\n\n\t\t\tif (this.isMesh || this.isLine || this.isPoints) {\n\t\t\t\tobject.geometry = serialize(meta.geometries, this.geometry);\n\t\t\t\tconst parameters = this.geometry.parameters;\n\n\t\t\t\tif (parameters !== undefined && parameters.shapes !== undefined) {\n\t\t\t\t\tconst shapes = parameters.shapes;\n\n\t\t\t\t\tif (Array.isArray(shapes)) {\n\t\t\t\t\t\tfor (let i = 0, l = shapes.length; i < l; i++) {\n\t\t\t\t\t\t\tconst shape = shapes[i];\n\t\t\t\t\t\t\tserialize(meta.shapes, shape);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tserialize(meta.shapes, shapes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isSkinnedMesh) {\n\t\t\t\tobject.bindMode = this.bindMode;\n\t\t\t\tobject.bindMatrix = this.bindMatrix.toArray();\n\n\t\t\t\tif (this.skeleton !== undefined) {\n\t\t\t\t\tserialize(meta.skeletons, this.skeleton);\n\t\t\t\t\tobject.skeleton = this.skeleton.uuid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.material !== undefined) {\n\t\t\t\tif (Array.isArray(this.material)) {\n\t\t\t\t\tconst uuids = [];\n\n\t\t\t\t\tfor (let i = 0, l = this.material.length; i < l; i++) {\n\t\t\t\t\t\tuuids.push(serialize(meta.materials, this.material[i]));\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.material = uuids;\n\t\t\t\t} else {\n\t\t\t\t\tobject.material = serialize(meta.materials, this.material);\n\t\t\t\t}\n\t\t\t} //\n\n\n\t\t\tif (this.children.length > 0) {\n\t\t\t\tobject.children = [];\n\n\t\t\t\tfor (let i = 0; i < this.children.length; i++) {\n\t\t\t\t\tobject.children.push(this.children[i].toJSON(meta).object);\n\t\t\t\t}\n\t\t\t} //\n\n\n\t\t\tif (this.animations.length > 0) {\n\t\t\t\tobject.animations = [];\n\n\t\t\t\tfor (let i = 0; i < this.animations.length; i++) {\n\t\t\t\t\tconst animation = this.animations[i];\n\t\t\t\t\tobject.animations.push(serialize(meta.animations, animation));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isRootObject) {\n\t\t\t\tconst geometries = extractFromCache(meta.geometries);\n\t\t\t\tconst materials = extractFromCache(meta.materials);\n\t\t\t\tconst textures = extractFromCache(meta.textures);\n\t\t\t\tconst images = extractFromCache(meta.images);\n\t\t\t\tconst shapes = extractFromCache(meta.shapes);\n\t\t\t\tconst skeletons = extractFromCache(meta.skeletons);\n\t\t\t\tconst animations = extractFromCache(meta.animations);\n\t\t\t\tif (geometries.length > 0) output.geometries = geometries;\n\t\t\t\tif (materials.length > 0) output.materials = materials;\n\t\t\t\tif (textures.length > 0) output.textures = textures;\n\t\t\t\tif (images.length > 0) output.images = images;\n\t\t\t\tif (shapes.length > 0) output.shapes = shapes;\n\t\t\t\tif (skeletons.length > 0) output.skeletons = skeletons;\n\t\t\t\tif (animations.length > 0) output.animations = animations;\n\t\t\t}\n\n\t\t\toutput.object = object;\n\t\t\treturn output; // extract data from the cache hash\n\t\t\t// remove metadata on each item\n\t\t\t// and return as array\n\n\t\t\tfunction extractFromCache(cache) {\n\t\t\t\tconst values = [];\n\n\t\t\t\tfor (const key in cache) {\n\t\t\t\t\tconst data = cache[key];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push(data);\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\n\t\tclone(recursive) {\n\t\t\treturn new this.constructor().copy(this, recursive);\n\t\t}\n\n\t\tcopy(source, recursive = true) {\n\t\t\tthis.name = source.name;\n\t\t\tthis.up.copy(source.up);\n\t\t\tthis.position.copy(source.position);\n\t\t\tthis.rotation.order = source.rotation.order;\n\t\t\tthis.quaternion.copy(source.quaternion);\n\t\t\tthis.scale.copy(source.scale);\n\t\t\tthis.matrix.copy(source.matrix);\n\t\t\tthis.matrixWorld.copy(source.matrixWorld);\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\t\t\tthis.layers.mask = source.layers.mask;\n\t\t\tthis.visible = source.visible;\n\t\t\tthis.castShadow = source.castShadow;\n\t\t\tthis.receiveShadow = source.receiveShadow;\n\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\tthis.renderOrder = source.renderOrder;\n\t\t\tthis.userData = JSON.parse(JSON.stringify(source.userData));\n\n\t\t\tif (recursive === true) {\n\t\t\t\tfor (let i = 0; i < source.children.length; i++) {\n\t\t\t\t\tconst child = source.children[i];\n\t\t\t\t\tthis.add(child.clone());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tObject3D.DefaultUp = new Vector3(0, 1, 0);\n\tObject3D.DefaultMatrixAutoUpdate = true;\n\tObject3D.prototype.isObject3D = true;\n\n\tconst _vector1 = /*@__PURE__*/new Vector3();\n\n\tconst _vector2$1 = /*@__PURE__*/new Vector3();\n\n\tconst _normalMatrix = /*@__PURE__*/new Matrix3();\n\n\tclass Plane {\n\t\tconstructor(normal = new Vector3(1, 0, 0), constant = 0) {\n\t\t\t// normal is assumed to be normalized\n\t\t\tthis.normal = normal;\n\t\t\tthis.constant = constant;\n\t\t}\n\n\t\tset(normal, constant) {\n\t\t\tthis.normal.copy(normal);\n\t\t\tthis.constant = constant;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetComponents(x, y, z, w) {\n\t\t\tthis.normal.set(x, y, z);\n\t\t\tthis.constant = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromNormalAndCoplanarPoint(normal, point) {\n\t\t\tthis.normal.copy(normal);\n\t\t\tthis.constant = -point.dot(this.normal);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromCoplanarPoints(a, b, c) {\n\t\t\tconst normal = _vector1.subVectors(c, b).cross(_vector2$1.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\n\t\t\tthis.setFromNormalAndCoplanarPoint(normal, a);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(plane) {\n\t\t\tthis.normal.copy(plane.normal);\n\t\t\tthis.constant = plane.constant;\n\t\t\treturn this;\n\t\t}\n\n\t\tnormalize() {\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\t\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\t\tthis.normal.multiplyScalar(inverseNormalLength);\n\t\t\tthis.constant *= inverseNormalLength;\n\t\t\treturn this;\n\t\t}\n\n\t\tnegate() {\n\t\t\tthis.constant *= -1;\n\t\t\tthis.normal.negate();\n\t\t\treturn this;\n\t\t}\n\n\t\tdistanceToPoint(point) {\n\t\t\treturn this.normal.dot(point) + this.constant;\n\t\t}\n\n\t\tdistanceToSphere(sphere) {\n\t\t\treturn this.distanceToPoint(sphere.center) - sphere.radius;\n\t\t}\n\n\t\tprojectPoint(point, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Plane: .projectPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);\n\t\t}\n\n\t\tintersectLine(line, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Plane: .intersectLine() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tconst direction = line.delta(_vector1);\n\t\t\tconst denominator = this.normal.dot(direction);\n\n\t\t\tif (denominator === 0) {\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif (this.distanceToPoint(line.start) === 0) {\n\t\t\t\t\treturn target.copy(line.start);\n\t\t\t\t} // Unsure if this is the correct method to handle this case.\n\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst t = -(line.start.dot(this.normal) + this.constant) / denominator;\n\n\t\t\tif (t < 0 || t > 1) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn target.copy(direction).multiplyScalar(t).add(line.start);\n\t\t}\n\n\t\tintersectsLine(line) {\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\t\t\tconst startSign = this.distanceToPoint(line.start);\n\t\t\tconst endSign = this.distanceToPoint(line.end);\n\t\t\treturn startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\treturn box.intersectsPlane(this);\n\t\t}\n\n\t\tintersectsSphere(sphere) {\n\t\t\treturn sphere.intersectsPlane(this);\n\t\t}\n\n\t\tcoplanarPoint(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Plane: .coplanarPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.copy(this.normal).multiplyScalar(-this.constant);\n\t\t}\n\n\t\tapplyMatrix4(matrix, optionalNormalMatrix) {\n\t\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n\n\t\t\tconst referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n\t\t\tconst normal = this.normal.applyMatrix3(normalMatrix).normalize();\n\t\t\tthis.constant = -referencePoint.dot(normal);\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(offset) {\n\t\t\tthis.constant -= offset.dot(this.normal);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(plane) {\n\t\t\treturn plane.normal.equals(this.normal) && plane.constant === this.constant;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tPlane.prototype.isPlane = true;\n\n\tconst _v0$1 = /*@__PURE__*/new Vector3();\n\n\tconst _v1$3 = /*@__PURE__*/new Vector3();\n\n\tconst _v2$2 = /*@__PURE__*/new Vector3();\n\n\tconst _v3$1 = /*@__PURE__*/new Vector3();\n\n\tconst _vab = /*@__PURE__*/new Vector3();\n\n\tconst _vac = /*@__PURE__*/new Vector3();\n\n\tconst _vbc = /*@__PURE__*/new Vector3();\n\n\tconst _vap = /*@__PURE__*/new Vector3();\n\n\tconst _vbp = /*@__PURE__*/new Vector3();\n\n\tconst _vcp = /*@__PURE__*/new Vector3();\n\n\tclass Triangle {\n\t\tconstructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tstatic getNormal(a, b, c, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Triangle: .getNormal() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\ttarget.subVectors(c, b);\n\n\t\t\t_v0$1.subVectors(a, b);\n\n\t\t\ttarget.cross(_v0$1);\n\t\t\tconst targetLengthSq = target.lengthSq();\n\n\t\t\tif (targetLengthSq > 0) {\n\t\t\t\treturn target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n\t\t\t}\n\n\t\t\treturn target.set(0, 0, 0);\n\t\t} // static/instance method to calculate barycentric coordinates\n\t\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\n\n\t\tstatic getBarycoord(point, a, b, c, target) {\n\t\t\t_v0$1.subVectors(c, a);\n\n\t\t\t_v1$3.subVectors(b, a);\n\n\t\t\t_v2$2.subVectors(point, a);\n\n\t\t\tconst dot00 = _v0$1.dot(_v0$1);\n\n\t\t\tconst dot01 = _v0$1.dot(_v1$3);\n\n\t\t\tconst dot02 = _v0$1.dot(_v2$2);\n\n\t\t\tconst dot11 = _v1$3.dot(_v1$3);\n\n\t\t\tconst dot12 = _v1$3.dot(_v2$2);\n\n\t\t\tconst denom = dot00 * dot11 - dot01 * dot01;\n\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Triangle: .getBarycoord() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t} // collinear or singular triangle\n\n\n\t\t\tif (denom === 0) {\n\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\treturn target.set(-2, -1, -1);\n\t\t\t}\n\n\t\t\tconst invDenom = 1 / denom;\n\t\t\tconst u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n\t\t\tconst v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1\n\n\t\t\treturn target.set(1 - u - v, v, u);\n\t\t}\n\n\t\tstatic containsPoint(point, a, b, c) {\n\t\t\tthis.getBarycoord(point, a, b, c, _v3$1);\n\t\t\treturn _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;\n\t\t}\n\n\t\tstatic getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {\n\t\t\tthis.getBarycoord(point, p1, p2, p3, _v3$1);\n\t\t\ttarget.set(0, 0);\n\t\t\ttarget.addScaledVector(uv1, _v3$1.x);\n\t\t\ttarget.addScaledVector(uv2, _v3$1.y);\n\t\t\ttarget.addScaledVector(uv3, _v3$1.z);\n\t\t\treturn target;\n\t\t}\n\n\t\tstatic isFrontFacing(a, b, c, direction) {\n\t\t\t_v0$1.subVectors(c, b);\n\n\t\t\t_v1$3.subVectors(a, b); // strictly front facing\n\n\n\t\t\treturn _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;\n\t\t}\n\n\t\tset(a, b, c) {\n\t\t\tthis.a.copy(a);\n\t\t\tthis.b.copy(b);\n\t\t\tthis.c.copy(c);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromPointsAndIndices(points, i0, i1, i2) {\n\t\t\tthis.a.copy(points[i0]);\n\t\t\tthis.b.copy(points[i1]);\n\t\t\tthis.c.copy(points[i2]);\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(triangle) {\n\t\t\tthis.a.copy(triangle.a);\n\t\t\tthis.b.copy(triangle.b);\n\t\t\tthis.c.copy(triangle.c);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetArea() {\n\t\t\t_v0$1.subVectors(this.c, this.b);\n\n\t\t\t_v1$3.subVectors(this.a, this.b);\n\n\t\t\treturn _v0$1.cross(_v1$3).length() * 0.5;\n\t\t}\n\n\t\tgetMidpoint(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Triangle: .getMidpoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n\t\t}\n\n\t\tgetNormal(target) {\n\t\t\treturn Triangle.getNormal(this.a, this.b, this.c, target);\n\t\t}\n\n\t\tgetPlane(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Triangle: .getPlane() target is now required');\n\t\t\t\ttarget = new Plane();\n\t\t\t}\n\n\t\t\treturn target.setFromCoplanarPoints(this.a, this.b, this.c);\n\t\t}\n\n\t\tgetBarycoord(point, target) {\n\t\t\treturn Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n\t\t}\n\n\t\tgetUV(point, uv1, uv2, uv3, target) {\n\t\t\treturn Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);\n\t\t}\n\n\t\tcontainsPoint(point) {\n\t\t\treturn Triangle.containsPoint(point, this.a, this.b, this.c);\n\t\t}\n\n\t\tisFrontFacing(direction) {\n\t\t\treturn Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\treturn box.intersectsTriangle(this);\n\t\t}\n\n\t\tclosestPointToPoint(p, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Triangle: .closestPointToPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tconst a = this.a,\n\t\t\t\t\t\tb = this.b,\n\t\t\t\t\t\tc = this.c;\n\t\t\tlet v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t\t_vab.subVectors(b, a);\n\n\t\t\t_vac.subVectors(c, a);\n\n\t\t\t_vap.subVectors(p, a);\n\n\t\t\tconst d1 = _vab.dot(_vap);\n\n\t\t\tconst d2 = _vac.dot(_vap);\n\n\t\t\tif (d1 <= 0 && d2 <= 0) {\n\t\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\t\treturn target.copy(a);\n\t\t\t}\n\n\t\t\t_vbp.subVectors(p, b);\n\n\t\t\tconst d3 = _vab.dot(_vbp);\n\n\t\t\tconst d4 = _vac.dot(_vbp);\n\n\t\t\tif (d3 >= 0 && d4 <= d3) {\n\t\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\t\treturn target.copy(b);\n\t\t\t}\n\n\t\t\tconst vc = d1 * d4 - d3 * d2;\n\n\t\t\tif (vc <= 0 && d1 >= 0 && d3 <= 0) {\n\t\t\t\tv = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)\n\n\t\t\t\treturn target.copy(a).addScaledVector(_vab, v);\n\t\t\t}\n\n\t\t\t_vcp.subVectors(p, c);\n\n\t\t\tconst d5 = _vab.dot(_vcp);\n\n\t\t\tconst d6 = _vac.dot(_vcp);\n\n\t\t\tif (d6 >= 0 && d5 <= d6) {\n\t\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\t\treturn target.copy(c);\n\t\t\t}\n\n\t\t\tconst vb = d5 * d2 - d1 * d6;\n\n\t\t\tif (vb <= 0 && d2 >= 0 && d6 <= 0) {\n\t\t\t\tw = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)\n\n\t\t\t\treturn target.copy(a).addScaledVector(_vac, w);\n\t\t\t}\n\n\t\t\tconst va = d3 * d6 - d5 * d4;\n\n\t\t\tif (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n\t\t\t\t_vbc.subVectors(c, b);\n\n\t\t\t\tw = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)\n\n\t\t\t\treturn target.copy(b).addScaledVector(_vbc, w); // edge region of BC\n\t\t\t} // face region\n\n\n\t\t\tconst denom = 1 / (va + vb + vc); // u = va * denom\n\n\t\t\tv = vb * denom;\n\t\t\tw = vc * denom;\n\t\t\treturn target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n\t\t}\n\n\t\tequals(triangle) {\n\t\t\treturn triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n\t\t}\n\n\t}\n\n\tlet materialId = 0;\n\n\tclass Material extends EventDispatcher {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tObject.defineProperty(this, 'id', {\n\t\t\t\tvalue: materialId++\n\t\t\t});\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Material';\n\t\t\tthis.fog = true;\n\t\t\tthis.blending = NormalBlending;\n\t\t\tthis.side = FrontSide;\n\t\t\tthis.vertexColors = false;\n\t\t\tthis.opacity = 1;\n\t\t\tthis.transparent = false;\n\t\t\tthis.blendSrc = SrcAlphaFactor;\n\t\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\t\tthis.blendEquation = AddEquation;\n\t\t\tthis.blendSrcAlpha = null;\n\t\t\tthis.blendDstAlpha = null;\n\t\t\tthis.blendEquationAlpha = null;\n\t\t\tthis.depthFunc = LessEqualDepth;\n\t\t\tthis.depthTest = true;\n\t\t\tthis.depthWrite = true;\n\t\t\tthis.stencilWriteMask = 0xff;\n\t\t\tthis.stencilFunc = AlwaysStencilFunc;\n\t\t\tthis.stencilRef = 0;\n\t\t\tthis.stencilFuncMask = 0xff;\n\t\t\tthis.stencilFail = KeepStencilOp;\n\t\t\tthis.stencilZFail = KeepStencilOp;\n\t\t\tthis.stencilZPass = KeepStencilOp;\n\t\t\tthis.stencilWrite = false;\n\t\t\tthis.clippingPlanes = null;\n\t\t\tthis.clipIntersection = false;\n\t\t\tthis.clipShadows = false;\n\t\t\tthis.shadowSide = null;\n\t\t\tthis.colorWrite = true;\n\t\t\tthis.precision = null; // override the renderer's default precision for this material\n\n\t\t\tthis.polygonOffset = false;\n\t\t\tthis.polygonOffsetFactor = 0;\n\t\t\tthis.polygonOffsetUnits = 0;\n\t\t\tthis.dithering = false;\n\t\t\tthis.alphaTest = 0;\n\t\t\tthis.alphaToCoverage = false;\n\t\t\tthis.premultipliedAlpha = false;\n\t\t\tthis.visible = true;\n\t\t\tthis.toneMapped = true;\n\t\t\tthis.userData = {};\n\t\t\tthis.version = 0;\n\t\t}\n\n\t\tonBuild()\n\t\t/* shaderobject, renderer */\n\t\t{}\n\n\t\tonBeforeCompile()\n\t\t/* shaderobject, renderer */\n\t\t{}\n\n\t\tcustomProgramCacheKey() {\n\t\t\treturn this.onBeforeCompile.toString();\n\t\t}\n\n\t\tsetValues(values) {\n\t\t\tif (values === undefined) return;\n\n\t\t\tfor (const key in values) {\n\t\t\t\tconst newValue = values[key];\n\n\t\t\t\tif (newValue === undefined) {\n\t\t\t\t\tconsole.warn('THREE.Material: \\'' + key + '\\' parameter is undefined.');\n\t\t\t\t\tcontinue;\n\t\t\t\t} // for backward compatability if shading is set in the constructor\n\n\n\t\t\t\tif (key === 'shading') {\n\t\t\t\t\tconsole.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');\n\t\t\t\t\tthis.flatShading = newValue === FlatShading ? true : false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst currentValue = this[key];\n\n\t\t\t\tif (currentValue === undefined) {\n\t\t\t\t\tconsole.warn('THREE.' + this.type + ': \\'' + key + '\\' is not a property of this material.');\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (currentValue && currentValue.isColor) {\n\t\t\t\t\tcurrentValue.set(newValue);\n\t\t\t\t} else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {\n\t\t\t\t\tcurrentValue.copy(newValue);\n\t\t\t\t} else {\n\t\t\t\t\tthis[key] = newValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst isRoot = meta === undefined || typeof meta === 'string';\n\n\t\t\tif (isRoot) {\n\t\t\t\tmeta = {\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Material',\n\t\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t\t}\n\t\t\t}; // standard Material serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif (this.name !== '') data.name = this.name;\n\t\t\tif (this.color && this.color.isColor) data.color = this.color.getHex();\n\t\t\tif (this.roughness !== undefined) data.roughness = this.roughness;\n\t\t\tif (this.metalness !== undefined) data.metalness = this.metalness;\n\t\t\tif (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();\n\t\t\tif (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();\n\t\t\tif (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;\n\t\t\tif (this.specular && this.specular.isColor) data.specular = this.specular.getHex();\n\t\t\tif (this.shininess !== undefined) data.shininess = this.shininess;\n\t\t\tif (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;\n\t\t\tif (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;\n\n\t\t\tif (this.clearcoatMap && this.clearcoatMap.isTexture) {\n\t\t\t\tdata.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;\n\t\t\t}\n\n\t\t\tif (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n\t\t\t\tdata.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n\t\t\t}\n\n\t\t\tif (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {\n\t\t\t\tdata.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;\n\t\t\t\tdata.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n\t\t\t}\n\n\t\t\tif (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n\t\t\tif (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;\n\t\t\tif (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n\n\t\t\tif (this.lightMap && this.lightMap.isTexture) {\n\t\t\t\tdata.lightMap = this.lightMap.toJSON(meta).uuid;\n\t\t\t\tdata.lightMapIntensity = this.lightMapIntensity;\n\t\t\t}\n\n\t\t\tif (this.aoMap && this.aoMap.isTexture) {\n\t\t\t\tdata.aoMap = this.aoMap.toJSON(meta).uuid;\n\t\t\t\tdata.aoMapIntensity = this.aoMapIntensity;\n\t\t\t}\n\n\t\t\tif (this.bumpMap && this.bumpMap.isTexture) {\n\t\t\t\tdata.bumpMap = this.bumpMap.toJSON(meta).uuid;\n\t\t\t\tdata.bumpScale = this.bumpScale;\n\t\t\t}\n\n\t\t\tif (this.normalMap && this.normalMap.isTexture) {\n\t\t\t\tdata.normalMap = this.normalMap.toJSON(meta).uuid;\n\t\t\t\tdata.normalMapType = this.normalMapType;\n\t\t\t\tdata.normalScale = this.normalScale.toArray();\n\t\t\t}\n\n\t\t\tif (this.displacementMap && this.displacementMap.isTexture) {\n\t\t\t\tdata.displacementMap = this.displacementMap.toJSON(meta).uuid;\n\t\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\t\tdata.displacementBias = this.displacementBias;\n\t\t\t}\n\n\t\t\tif (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\n\t\t\tif (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\n\t\t\tif (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\n\t\t\tif (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;\n\n\t\t\tif (this.envMap && this.envMap.isTexture) {\n\t\t\t\tdata.envMap = this.envMap.toJSON(meta).uuid;\n\t\t\t\tif (this.combine !== undefined) data.combine = this.combine;\n\t\t\t}\n\n\t\t\tif (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;\n\t\t\tif (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;\n\t\t\tif (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;\n\n\t\t\tif (this.gradientMap && this.gradientMap.isTexture) {\n\t\t\t\tdata.gradientMap = this.gradientMap.toJSON(meta).uuid;\n\t\t\t}\n\n\t\t\tif (this.transmission !== undefined) data.transmission = this.transmission;\n\t\t\tif (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;\n\t\t\tif (this.thickness !== undefined) data.thickness = this.thickness;\n\t\t\tif (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;\n\t\t\tif (this.attenuationDistance !== undefined) data.attenuationDistance = this.attenuationDistance;\n\t\t\tif (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();\n\t\t\tif (this.size !== undefined) data.size = this.size;\n\t\t\tif (this.shadowSide !== null) data.shadowSide = this.shadowSide;\n\t\t\tif (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;\n\t\t\tif (this.blending !== NormalBlending) data.blending = this.blending;\n\t\t\tif (this.side !== FrontSide) data.side = this.side;\n\t\t\tif (this.vertexColors) data.vertexColors = true;\n\t\t\tif (this.opacity < 1) data.opacity = this.opacity;\n\t\t\tif (this.transparent === true) data.transparent = this.transparent;\n\t\t\tdata.depthFunc = this.depthFunc;\n\t\t\tdata.depthTest = this.depthTest;\n\t\t\tdata.depthWrite = this.depthWrite;\n\t\t\tdata.colorWrite = this.colorWrite;\n\t\t\tdata.stencilWrite = this.stencilWrite;\n\t\t\tdata.stencilWriteMask = this.stencilWriteMask;\n\t\t\tdata.stencilFunc = this.stencilFunc;\n\t\t\tdata.stencilRef = this.stencilRef;\n\t\t\tdata.stencilFuncMask = this.stencilFuncMask;\n\t\t\tdata.stencilFail = this.stencilFail;\n\t\t\tdata.stencilZFail = this.stencilZFail;\n\t\t\tdata.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)\n\n\t\t\tif (this.rotation && this.rotation !== 0) data.rotation = this.rotation;\n\t\t\tif (this.polygonOffset === true) data.polygonOffset = true;\n\t\t\tif (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;\n\t\t\tif (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;\n\t\t\tif (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;\n\t\t\tif (this.dashSize !== undefined) data.dashSize = this.dashSize;\n\t\t\tif (this.gapSize !== undefined) data.gapSize = this.gapSize;\n\t\t\tif (this.scale !== undefined) data.scale = this.scale;\n\t\t\tif (this.dithering === true) data.dithering = true;\n\t\t\tif (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n\t\t\tif (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;\n\t\t\tif (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\t\tif (this.wireframe === true) data.wireframe = this.wireframe;\n\t\t\tif (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\t\tif (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;\n\t\t\tif (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;\n\t\t\tif (this.morphTargets === true) data.morphTargets = true;\n\t\t\tif (this.morphNormals === true) data.morphNormals = true;\n\t\t\tif (this.flatShading === true) data.flatShading = this.flatShading;\n\t\t\tif (this.visible === false) data.visible = false;\n\t\t\tif (this.toneMapped === false) data.toneMapped = false;\n\t\t\tif (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON\n\n\t\t\tfunction extractFromCache(cache) {\n\t\t\t\tconst values = [];\n\n\t\t\t\tfor (const key in cache) {\n\t\t\t\t\tconst data = cache[key];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push(data);\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t}\n\n\t\t\tif (isRoot) {\n\t\t\t\tconst textures = extractFromCache(meta.textures);\n\t\t\t\tconst images = extractFromCache(meta.images);\n\t\t\t\tif (textures.length > 0) data.textures = textures;\n\t\t\t\tif (images.length > 0) data.images = images;\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.name = source.name;\n\t\t\tthis.fog = source.fog;\n\t\t\tthis.blending = source.blending;\n\t\t\tthis.side = source.side;\n\t\t\tthis.vertexColors = source.vertexColors;\n\t\t\tthis.opacity = source.opacity;\n\t\t\tthis.transparent = source.transparent;\n\t\t\tthis.blendSrc = source.blendSrc;\n\t\t\tthis.blendDst = source.blendDst;\n\t\t\tthis.blendEquation = source.blendEquation;\n\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\t\t\tthis.depthFunc = source.depthFunc;\n\t\t\tthis.depthTest = source.depthTest;\n\t\t\tthis.depthWrite = source.depthWrite;\n\t\t\tthis.stencilWriteMask = source.stencilWriteMask;\n\t\t\tthis.stencilFunc = source.stencilFunc;\n\t\t\tthis.stencilRef = source.stencilRef;\n\t\t\tthis.stencilFuncMask = source.stencilFuncMask;\n\t\t\tthis.stencilFail = source.stencilFail;\n\t\t\tthis.stencilZFail = source.stencilZFail;\n\t\t\tthis.stencilZPass = source.stencilZPass;\n\t\t\tthis.stencilWrite = source.stencilWrite;\n\t\t\tconst srcPlanes = source.clippingPlanes;\n\t\t\tlet dstPlanes = null;\n\n\t\t\tif (srcPlanes !== null) {\n\t\t\t\tconst n = srcPlanes.length;\n\t\t\t\tdstPlanes = new Array(n);\n\n\t\t\t\tfor (let i = 0; i !== n; ++i) {\n\t\t\t\t\tdstPlanes[i] = srcPlanes[i].clone();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.clippingPlanes = dstPlanes;\n\t\t\tthis.clipIntersection = source.clipIntersection;\n\t\t\tthis.clipShadows = source.clipShadows;\n\t\t\tthis.shadowSide = source.shadowSide;\n\t\t\tthis.colorWrite = source.colorWrite;\n\t\t\tthis.precision = source.precision;\n\t\t\tthis.polygonOffset = source.polygonOffset;\n\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\t\t\tthis.dithering = source.dithering;\n\t\t\tthis.alphaTest = source.alphaTest;\n\t\t\tthis.alphaToCoverage = source.alphaToCoverage;\n\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\t\t\tthis.visible = source.visible;\n\t\t\tthis.toneMapped = source.toneMapped;\n\t\t\tthis.userData = JSON.parse(JSON.stringify(source.userData));\n\t\t\treturn this;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'dispose'\n\t\t\t});\n\t\t}\n\n\t\tset needsUpdate(value) {\n\t\t\tif (value === true) this.version++;\n\t\t}\n\n\t}\n\n\tMaterial.prototype.isMaterial = true;\n\n\tconst _colorKeywords = {\n\t\t'aliceblue': 0xF0F8FF,\n\t\t'antiquewhite': 0xFAEBD7,\n\t\t'aqua': 0x00FFFF,\n\t\t'aquamarine': 0x7FFFD4,\n\t\t'azure': 0xF0FFFF,\n\t\t'beige': 0xF5F5DC,\n\t\t'bisque': 0xFFE4C4,\n\t\t'black': 0x000000,\n\t\t'blanchedalmond': 0xFFEBCD,\n\t\t'blue': 0x0000FF,\n\t\t'blueviolet': 0x8A2BE2,\n\t\t'brown': 0xA52A2A,\n\t\t'burlywood': 0xDEB887,\n\t\t'cadetblue': 0x5F9EA0,\n\t\t'chartreuse': 0x7FFF00,\n\t\t'chocolate': 0xD2691E,\n\t\t'coral': 0xFF7F50,\n\t\t'cornflowerblue': 0x6495ED,\n\t\t'cornsilk': 0xFFF8DC,\n\t\t'crimson': 0xDC143C,\n\t\t'cyan': 0x00FFFF,\n\t\t'darkblue': 0x00008B,\n\t\t'darkcyan': 0x008B8B,\n\t\t'darkgoldenrod': 0xB8860B,\n\t\t'darkgray': 0xA9A9A9,\n\t\t'darkgreen': 0x006400,\n\t\t'darkgrey': 0xA9A9A9,\n\t\t'darkkhaki': 0xBDB76B,\n\t\t'darkmagenta': 0x8B008B,\n\t\t'darkolivegreen': 0x556B2F,\n\t\t'darkorange': 0xFF8C00,\n\t\t'darkorchid': 0x9932CC,\n\t\t'darkred': 0x8B0000,\n\t\t'darksalmon': 0xE9967A,\n\t\t'darkseagreen': 0x8FBC8F,\n\t\t'darkslateblue': 0x483D8B,\n\t\t'darkslategray': 0x2F4F4F,\n\t\t'darkslategrey': 0x2F4F4F,\n\t\t'darkturquoise': 0x00CED1,\n\t\t'darkviolet': 0x9400D3,\n\t\t'deeppink': 0xFF1493,\n\t\t'deepskyblue': 0x00BFFF,\n\t\t'dimgray': 0x696969,\n\t\t'dimgrey': 0x696969,\n\t\t'dodgerblue': 0x1E90FF,\n\t\t'firebrick': 0xB22222,\n\t\t'floralwhite': 0xFFFAF0,\n\t\t'forestgreen': 0x228B22,\n\t\t'fuchsia': 0xFF00FF,\n\t\t'gainsboro': 0xDCDCDC,\n\t\t'ghostwhite': 0xF8F8FF,\n\t\t'gold': 0xFFD700,\n\t\t'goldenrod': 0xDAA520,\n\t\t'gray': 0x808080,\n\t\t'green': 0x008000,\n\t\t'greenyellow': 0xADFF2F,\n\t\t'grey': 0x808080,\n\t\t'honeydew': 0xF0FFF0,\n\t\t'hotpink': 0xFF69B4,\n\t\t'indianred': 0xCD5C5C,\n\t\t'indigo': 0x4B0082,\n\t\t'ivory': 0xFFFFF0,\n\t\t'khaki': 0xF0E68C,\n\t\t'lavender': 0xE6E6FA,\n\t\t'lavenderblush': 0xFFF0F5,\n\t\t'lawngreen': 0x7CFC00,\n\t\t'lemonchiffon': 0xFFFACD,\n\t\t'lightblue': 0xADD8E6,\n\t\t'lightcoral': 0xF08080,\n\t\t'lightcyan': 0xE0FFFF,\n\t\t'lightgoldenrodyellow': 0xFAFAD2,\n\t\t'lightgray': 0xD3D3D3,\n\t\t'lightgreen': 0x90EE90,\n\t\t'lightgrey': 0xD3D3D3,\n\t\t'lightpink': 0xFFB6C1,\n\t\t'lightsalmon': 0xFFA07A,\n\t\t'lightseagreen': 0x20B2AA,\n\t\t'lightskyblue': 0x87CEFA,\n\t\t'lightslategray': 0x778899,\n\t\t'lightslategrey': 0x778899,\n\t\t'lightsteelblue': 0xB0C4DE,\n\t\t'lightyellow': 0xFFFFE0,\n\t\t'lime': 0x00FF00,\n\t\t'limegreen': 0x32CD32,\n\t\t'linen': 0xFAF0E6,\n\t\t'magenta': 0xFF00FF,\n\t\t'maroon': 0x800000,\n\t\t'mediumaquamarine': 0x66CDAA,\n\t\t'mediumblue': 0x0000CD,\n\t\t'mediumorchid': 0xBA55D3,\n\t\t'mediumpurple': 0x9370DB,\n\t\t'mediumseagreen': 0x3CB371,\n\t\t'mediumslateblue': 0x7B68EE,\n\t\t'mediumspringgreen': 0x00FA9A,\n\t\t'mediumturquoise': 0x48D1CC,\n\t\t'mediumvioletred': 0xC71585,\n\t\t'midnightblue': 0x191970,\n\t\t'mintcream': 0xF5FFFA,\n\t\t'mistyrose': 0xFFE4E1,\n\t\t'moccasin': 0xFFE4B5,\n\t\t'navajowhite': 0xFFDEAD,\n\t\t'navy': 0x000080,\n\t\t'oldlace': 0xFDF5E6,\n\t\t'olive': 0x808000,\n\t\t'olivedrab': 0x6B8E23,\n\t\t'orange': 0xFFA500,\n\t\t'orangered': 0xFF4500,\n\t\t'orchid': 0xDA70D6,\n\t\t'palegoldenrod': 0xEEE8AA,\n\t\t'palegreen': 0x98FB98,\n\t\t'paleturquoise': 0xAFEEEE,\n\t\t'palevioletred': 0xDB7093,\n\t\t'papayawhip': 0xFFEFD5,\n\t\t'peachpuff': 0xFFDAB9,\n\t\t'peru': 0xCD853F,\n\t\t'pink': 0xFFC0CB,\n\t\t'plum': 0xDDA0DD,\n\t\t'powderblue': 0xB0E0E6,\n\t\t'purple': 0x800080,\n\t\t'rebeccapurple': 0x663399,\n\t\t'red': 0xFF0000,\n\t\t'rosybrown': 0xBC8F8F,\n\t\t'royalblue': 0x4169E1,\n\t\t'saddlebrown': 0x8B4513,\n\t\t'salmon': 0xFA8072,\n\t\t'sandybrown': 0xF4A460,\n\t\t'seagreen': 0x2E8B57,\n\t\t'seashell': 0xFFF5EE,\n\t\t'sienna': 0xA0522D,\n\t\t'silver': 0xC0C0C0,\n\t\t'skyblue': 0x87CEEB,\n\t\t'slateblue': 0x6A5ACD,\n\t\t'slategray': 0x708090,\n\t\t'slategrey': 0x708090,\n\t\t'snow': 0xFFFAFA,\n\t\t'springgreen': 0x00FF7F,\n\t\t'steelblue': 0x4682B4,\n\t\t'tan': 0xD2B48C,\n\t\t'teal': 0x008080,\n\t\t'thistle': 0xD8BFD8,\n\t\t'tomato': 0xFF6347,\n\t\t'turquoise': 0x40E0D0,\n\t\t'violet': 0xEE82EE,\n\t\t'wheat': 0xF5DEB3,\n\t\t'white': 0xFFFFFF,\n\t\t'whitesmoke': 0xF5F5F5,\n\t\t'yellow': 0xFFFF00,\n\t\t'yellowgreen': 0x9ACD32\n\t};\n\tconst _hslA = {\n\t\th: 0,\n\t\ts: 0,\n\t\tl: 0\n\t};\n\tconst _hslB = {\n\t\th: 0,\n\t\ts: 0,\n\t\tl: 0\n\t};\n\n\tfunction hue2rgb(p, q, t) {\n\t\tif (t < 0) t += 1;\n\t\tif (t > 1) t -= 1;\n\t\tif (t < 1 / 6) return p + (q - p) * 6 * t;\n\t\tif (t < 1 / 2) return q;\n\t\tif (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n\t\treturn p;\n\t}\n\n\tfunction SRGBToLinear(c) {\n\t\treturn c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n\t}\n\n\tfunction LinearToSRGB(c) {\n\t\treturn c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n\t}\n\n\tclass Color {\n\t\tconstructor(r, g, b) {\n\t\t\tif (g === undefined && b === undefined) {\n\t\t\t\t// r is THREE.Color, hex or string\n\t\t\t\treturn this.set(r);\n\t\t\t}\n\n\t\t\treturn this.setRGB(r, g, b);\n\t\t}\n\n\t\tset(value) {\n\t\t\tif (value && value.isColor) {\n\t\t\t\tthis.copy(value);\n\t\t\t} else if (typeof value === 'number') {\n\t\t\t\tthis.setHex(value);\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\tthis.setStyle(value);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetScalar(scalar) {\n\t\t\tthis.r = scalar;\n\t\t\tthis.g = scalar;\n\t\t\tthis.b = scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetHex(hex) {\n\t\t\thex = Math.floor(hex);\n\t\t\tthis.r = (hex >> 16 & 255) / 255;\n\t\t\tthis.g = (hex >> 8 & 255) / 255;\n\t\t\tthis.b = (hex & 255) / 255;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetRGB(r, g, b) {\n\t\t\tthis.r = r;\n\t\t\tthis.g = g;\n\t\t\tthis.b = b;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetHSL(h, s, l) {\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\th = euclideanModulo(h, 1);\n\t\t\ts = clamp(s, 0, 1);\n\t\t\tl = clamp(l, 0, 1);\n\n\t\t\tif (s === 0) {\n\t\t\t\tthis.r = this.g = this.b = l;\n\t\t\t} else {\n\t\t\t\tconst p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n\t\t\t\tconst q = 2 * l - p;\n\t\t\t\tthis.r = hue2rgb(q, p, h + 1 / 3);\n\t\t\t\tthis.g = hue2rgb(q, p, h);\n\t\t\t\tthis.b = hue2rgb(q, p, h - 1 / 3);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetStyle(style) {\n\t\t\tfunction handleAlpha(string) {\n\t\t\t\tif (string === undefined) return;\n\n\t\t\t\tif (parseFloat(string) < 1) {\n\t\t\t\t\tconsole.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet m;\n\n\t\t\tif (m = /^((?:rgb|hsl)a?)\\(([^\\)]*)\\)/.exec(style)) {\n\t\t\t\t// rgb / hsl\n\t\t\t\tlet color;\n\t\t\t\tconst name = m[1];\n\t\t\t\tconst components = m[2];\n\n\t\t\t\tswitch (name) {\n\t\t\t\t\tcase 'rgb':\n\t\t\t\t\tcase 'rgba':\n\t\t\t\t\t\tif (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min(255, parseInt(color[1], 10)) / 255;\n\t\t\t\t\t\t\tthis.g = Math.min(255, parseInt(color[2], 10)) / 255;\n\t\t\t\t\t\t\tthis.b = Math.min(255, parseInt(color[3], 10)) / 255;\n\t\t\t\t\t\t\thandleAlpha(color[4]);\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min(100, parseInt(color[1], 10)) / 100;\n\t\t\t\t\t\t\tthis.g = Math.min(100, parseInt(color[2], 10)) / 100;\n\t\t\t\t\t\t\tthis.b = Math.min(100, parseInt(color[3], 10)) / 100;\n\t\t\t\t\t\t\thandleAlpha(color[4]);\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'hsl':\n\t\t\t\t\tcase 'hsla':\n\t\t\t\t\t\tif (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\t\tconst h = parseFloat(color[1]) / 360;\n\t\t\t\t\t\t\tconst s = parseInt(color[2], 10) / 100;\n\t\t\t\t\t\t\tconst l = parseInt(color[3], 10) / 100;\n\t\t\t\t\t\t\thandleAlpha(color[4]);\n\t\t\t\t\t\t\treturn this.setHSL(h, s, l);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {\n\t\t\t\t// hex color\n\t\t\t\tconst hex = m[1];\n\t\t\t\tconst size = hex.length;\n\n\t\t\t\tif (size === 3) {\n\t\t\t\t\t// #ff0\n\t\t\t\t\tthis.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\n\t\t\t\t\tthis.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\n\t\t\t\t\tthis.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\n\t\t\t\t\treturn this;\n\t\t\t\t} else if (size === 6) {\n\t\t\t\t\t// #ff0000\n\t\t\t\t\tthis.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\n\t\t\t\t\tthis.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\n\t\t\t\t\tthis.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (style && style.length > 0) {\n\t\t\t\treturn this.setColorName(style);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetColorName(style) {\n\t\t\t// color keywords\n\t\t\tconst hex = _colorKeywords[style.toLowerCase()];\n\n\t\t\tif (hex !== undefined) {\n\t\t\t\t// red\n\t\t\t\tthis.setHex(hex);\n\t\t\t} else {\n\t\t\t\t// unknown color\n\t\t\t\tconsole.warn('THREE.Color: Unknown color ' + style);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.r, this.g, this.b);\n\t\t}\n\n\t\tcopy(color) {\n\t\t\tthis.r = color.r;\n\t\t\tthis.g = color.g;\n\t\t\tthis.b = color.b;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyGammaToLinear(color, gammaFactor = 2.0) {\n\t\t\tthis.r = Math.pow(color.r, gammaFactor);\n\t\t\tthis.g = Math.pow(color.g, gammaFactor);\n\t\t\tthis.b = Math.pow(color.b, gammaFactor);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyLinearToGamma(color, gammaFactor = 2.0) {\n\t\t\tconst safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;\n\t\t\tthis.r = Math.pow(color.r, safeInverse);\n\t\t\tthis.g = Math.pow(color.g, safeInverse);\n\t\t\tthis.b = Math.pow(color.b, safeInverse);\n\t\t\treturn this;\n\t\t}\n\n\t\tconvertGammaToLinear(gammaFactor) {\n\t\t\tthis.copyGammaToLinear(this, gammaFactor);\n\t\t\treturn this;\n\t\t}\n\n\t\tconvertLinearToGamma(gammaFactor) {\n\t\t\tthis.copyLinearToGamma(this, gammaFactor);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopySRGBToLinear(color) {\n\t\t\tthis.r = SRGBToLinear(color.r);\n\t\t\tthis.g = SRGBToLinear(color.g);\n\t\t\tthis.b = SRGBToLinear(color.b);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyLinearToSRGB(color) {\n\t\t\tthis.r = LinearToSRGB(color.r);\n\t\t\tthis.g = LinearToSRGB(color.g);\n\t\t\tthis.b = LinearToSRGB(color.b);\n\t\t\treturn this;\n\t\t}\n\n\t\tconvertSRGBToLinear() {\n\t\t\tthis.copySRGBToLinear(this);\n\t\t\treturn this;\n\t\t}\n\n\t\tconvertLinearToSRGB() {\n\t\t\tthis.copyLinearToSRGB(this);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetHex() {\n\t\t\treturn this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;\n\t\t}\n\n\t\tgetHexString() {\n\t\t\treturn ('000000' + this.getHex().toString(16)).slice(-6);\n\t\t}\n\n\t\tgetHSL(target) {\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Color: .getHSL() target is now required');\n\t\t\t\ttarget = {\n\t\t\t\t\th: 0,\n\t\t\t\t\ts: 0,\n\t\t\t\t\tl: 0\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst r = this.r,\n\t\t\t\t\t\tg = this.g,\n\t\t\t\t\t\tb = this.b;\n\t\t\tconst max = Math.max(r, g, b);\n\t\t\tconst min = Math.min(r, g, b);\n\t\t\tlet hue, saturation;\n\t\t\tconst lightness = (min + max) / 2.0;\n\n\t\t\tif (min === max) {\n\t\t\t\thue = 0;\n\t\t\t\tsaturation = 0;\n\t\t\t} else {\n\t\t\t\tconst delta = max - min;\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\n\n\t\t\t\tswitch (max) {\n\t\t\t\t\tcase r:\n\t\t\t\t\t\thue = (g - b) / delta + (g < b ? 6 : 0);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase g:\n\t\t\t\t\t\thue = (b - r) / delta + 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase b:\n\t\t\t\t\t\thue = (r - g) / delta + 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\thue /= 6;\n\t\t\t}\n\n\t\t\ttarget.h = hue;\n\t\t\ttarget.s = saturation;\n\t\t\ttarget.l = lightness;\n\t\t\treturn target;\n\t\t}\n\n\t\tgetStyle() {\n\t\t\treturn 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';\n\t\t}\n\n\t\toffsetHSL(h, s, l) {\n\t\t\tthis.getHSL(_hslA);\n\t\t\t_hslA.h += h;\n\t\t\t_hslA.s += s;\n\t\t\t_hslA.l += l;\n\t\t\tthis.setHSL(_hslA.h, _hslA.s, _hslA.l);\n\t\t\treturn this;\n\t\t}\n\n\t\tadd(color) {\n\t\t\tthis.r += color.r;\n\t\t\tthis.g += color.g;\n\t\t\tthis.b += color.b;\n\t\t\treturn this;\n\t\t}\n\n\t\taddColors(color1, color2) {\n\t\t\tthis.r = color1.r + color2.r;\n\t\t\tthis.g = color1.g + color2.g;\n\t\t\tthis.b = color1.b + color2.b;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScalar(s) {\n\t\t\tthis.r += s;\n\t\t\tthis.g += s;\n\t\t\tthis.b += s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsub(color) {\n\t\t\tthis.r = Math.max(0, this.r - color.r);\n\t\t\tthis.g = Math.max(0, this.g - color.g);\n\t\t\tthis.b = Math.max(0, this.b - color.b);\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(color) {\n\t\t\tthis.r *= color.r;\n\t\t\tthis.g *= color.g;\n\t\t\tthis.b *= color.b;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(s) {\n\t\t\tthis.r *= s;\n\t\t\tthis.g *= s;\n\t\t\tthis.b *= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerp(color, alpha) {\n\t\t\tthis.r += (color.r - this.r) * alpha;\n\t\t\tthis.g += (color.g - this.g) * alpha;\n\t\t\tthis.b += (color.b - this.b) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerpColors(color1, color2, alpha) {\n\t\t\tthis.r = color1.r + (color2.r - color1.r) * alpha;\n\t\t\tthis.g = color1.g + (color2.g - color1.g) * alpha;\n\t\t\tthis.b = color1.b + (color2.b - color1.b) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerpHSL(color, alpha) {\n\t\t\tthis.getHSL(_hslA);\n\t\t\tcolor.getHSL(_hslB);\n\t\t\tconst h = lerp(_hslA.h, _hslB.h, alpha);\n\t\t\tconst s = lerp(_hslA.s, _hslB.s, alpha);\n\t\t\tconst l = lerp(_hslA.l, _hslB.l, alpha);\n\t\t\tthis.setHSL(h, s, l);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(c) {\n\t\t\treturn c.r === this.r && c.g === this.g && c.b === this.b;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tthis.r = array[offset];\n\t\t\tthis.g = array[offset + 1];\n\t\t\tthis.b = array[offset + 2];\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this.r;\n\t\t\tarray[offset + 1] = this.g;\n\t\t\tarray[offset + 2] = this.b;\n\t\t\treturn array;\n\t\t}\n\n\t\tfromBufferAttribute(attribute, index) {\n\t\t\tthis.r = attribute.getX(index);\n\t\t\tthis.g = attribute.getY(index);\n\t\t\tthis.b = attribute.getZ(index);\n\n\t\t\tif (attribute.normalized === true) {\n\t\t\t\t// assuming Uint8Array\n\t\t\t\tthis.r /= 255;\n\t\t\t\tthis.g /= 255;\n\t\t\t\tthis.b /= 255;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\treturn this.getHex();\n\t\t}\n\n\t}\n\n\tColor.NAMES = _colorKeywords;\n\tColor.prototype.isColor = true;\n\tColor.prototype.r = 1;\n\tColor.prototype.g = 1;\n\tColor.prototype.b = 1;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\tlightMap: new THREE.Texture( <Image> ),\n\t *\tlightMapIntensity: <float>\n\t *\n\t *\taoMap: new THREE.Texture( <Image> ),\n\t *\taoMapIntensity: <float>\n\t *\n\t *\tspecularMap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tenvMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *\tcombine: THREE.Multiply,\n\t *\treflectivity: <float>,\n\t *\trefractionRatio: <float>,\n\t *\n\t *\tdepthTest: <bool>,\n\t *\tdepthWrite: <bool>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tmorphTargets: <bool>\n\t * }\n\t */\n\n\tclass MeshBasicMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshBasicMaterial';\n\t\t\tthis.color = new Color(0xffffff); // emissive\n\n\t\t\tthis.map = null;\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\t\tthis.specularMap = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.map = source.map;\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\t\tthis.specularMap = source.specularMap;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\n\tconst _vector$9 = /*@__PURE__*/new Vector3();\n\n\tconst _vector2 = /*@__PURE__*/new Vector2();\n\n\tclass BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tif (Array.isArray(array)) {\n\t\t\t\tthrow new TypeError('THREE.BufferAttribute: array should be a Typed Array.');\n\t\t\t}\n\n\t\t\tthis.name = '';\n\t\t\tthis.array = array;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\t\tthis.normalized = normalized === true;\n\t\t\tthis.usage = StaticDrawUsage;\n\t\t\tthis.updateRange = {\n\t\t\t\toffset: 0,\n\t\t\t\tcount: -1\n\t\t\t};\n\t\t\tthis.version = 0;\n\t\t}\n\n\t\tonUploadCallback() {}\n\n\t\tset needsUpdate(value) {\n\t\t\tif (value === true) this.version++;\n\t\t}\n\n\t\tsetUsage(value) {\n\t\t\tthis.usage = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.name = source.name;\n\t\t\tthis.array = new source.array.constructor(source.array);\n\t\t\tthis.itemSize = source.itemSize;\n\t\t\tthis.count = source.count;\n\t\t\tthis.normalized = source.normalized;\n\t\t\tthis.usage = source.usage;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyAt(index1, attribute, index2) {\n\t\t\tindex1 *= this.itemSize;\n\t\t\tindex2 *= attribute.itemSize;\n\n\t\t\tfor (let i = 0, l = this.itemSize; i < l; i++) {\n\t\t\t\tthis.array[index1 + i] = attribute.array[index2 + i];\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyArray(array) {\n\t\t\tthis.array.set(array);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyColorsArray(colors) {\n\t\t\tconst array = this.array;\n\t\t\tlet offset = 0;\n\n\t\t\tfor (let i = 0, l = colors.length; i < l; i++) {\n\t\t\t\tlet color = colors[i];\n\n\t\t\t\tif (color === undefined) {\n\t\t\t\t\tconsole.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);\n\t\t\t\t\tcolor = new Color();\n\t\t\t\t}\n\n\t\t\t\tarray[offset++] = color.r;\n\t\t\t\tarray[offset++] = color.g;\n\t\t\t\tarray[offset++] = color.b;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyVector2sArray(vectors) {\n\t\t\tconst array = this.array;\n\t\t\tlet offset = 0;\n\n\t\t\tfor (let i = 0, l = vectors.length; i < l; i++) {\n\t\t\t\tlet vector = vectors[i];\n\n\t\t\t\tif (vector === undefined) {\n\t\t\t\t\tconsole.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);\n\t\t\t\t\tvector = new Vector2();\n\t\t\t\t}\n\n\t\t\t\tarray[offset++] = vector.x;\n\t\t\t\tarray[offset++] = vector.y;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyVector3sArray(vectors) {\n\t\t\tconst array = this.array;\n\t\t\tlet offset = 0;\n\n\t\t\tfor (let i = 0, l = vectors.length; i < l; i++) {\n\t\t\t\tlet vector = vectors[i];\n\n\t\t\t\tif (vector === undefined) {\n\t\t\t\t\tconsole.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);\n\t\t\t\t\tvector = new Vector3();\n\t\t\t\t}\n\n\t\t\t\tarray[offset++] = vector.x;\n\t\t\t\tarray[offset++] = vector.y;\n\t\t\t\tarray[offset++] = vector.z;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyVector4sArray(vectors) {\n\t\t\tconst array = this.array;\n\t\t\tlet offset = 0;\n\n\t\t\tfor (let i = 0, l = vectors.length; i < l; i++) {\n\t\t\t\tlet vector = vectors[i];\n\n\t\t\t\tif (vector === undefined) {\n\t\t\t\t\tconsole.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);\n\t\t\t\t\tvector = new Vector4();\n\t\t\t\t}\n\n\t\t\t\tarray[offset++] = vector.x;\n\t\t\t\tarray[offset++] = vector.y;\n\t\t\t\tarray[offset++] = vector.z;\n\t\t\t\tarray[offset++] = vector.w;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyMatrix3(m) {\n\t\t\tif (this.itemSize === 2) {\n\t\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t\t_vector2.fromBufferAttribute(this, i);\n\n\t\t\t\t\t_vector2.applyMatrix3(m);\n\n\t\t\t\t\tthis.setXY(i, _vector2.x, _vector2.y);\n\t\t\t\t}\n\t\t\t} else if (this.itemSize === 3) {\n\t\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t\t_vector$9.fromBufferAttribute(this, i);\n\n\t\t\t\t\t_vector$9.applyMatrix3(m);\n\n\t\t\t\t\tthis.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyMatrix4(m) {\n\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t_vector$9.x = this.getX(i);\n\t\t\t\t_vector$9.y = this.getY(i);\n\t\t\t\t_vector$9.z = this.getZ(i);\n\n\t\t\t\t_vector$9.applyMatrix4(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyNormalMatrix(m) {\n\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t_vector$9.x = this.getX(i);\n\t\t\t\t_vector$9.y = this.getY(i);\n\t\t\t\t_vector$9.z = this.getZ(i);\n\n\t\t\t\t_vector$9.applyNormalMatrix(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttransformDirection(m) {\n\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t_vector$9.x = this.getX(i);\n\t\t\t\t_vector$9.y = this.getY(i);\n\t\t\t\t_vector$9.z = this.getZ(i);\n\n\t\t\t\t_vector$9.transformDirection(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tset(value, offset = 0) {\n\t\t\tthis.array.set(value, offset);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetX(index) {\n\t\t\treturn this.array[index * this.itemSize];\n\t\t}\n\n\t\tsetX(index, x) {\n\t\t\tthis.array[index * this.itemSize] = x;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetY(index) {\n\t\t\treturn this.array[index * this.itemSize + 1];\n\t\t}\n\n\t\tsetY(index, y) {\n\t\t\tthis.array[index * this.itemSize + 1] = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetZ(index) {\n\t\t\treturn this.array[index * this.itemSize + 2];\n\t\t}\n\n\t\tsetZ(index, z) {\n\t\t\tthis.array[index * this.itemSize + 2] = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetW(index) {\n\t\t\treturn this.array[index * this.itemSize + 3];\n\t\t}\n\n\t\tsetW(index, w) {\n\t\t\tthis.array[index * this.itemSize + 3] = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetXY(index, x, y) {\n\t\t\tindex *= this.itemSize;\n\t\t\tthis.array[index + 0] = x;\n\t\t\tthis.array[index + 1] = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetXYZ(index, x, y, z) {\n\t\t\tindex *= this.itemSize;\n\t\t\tthis.array[index + 0] = x;\n\t\t\tthis.array[index + 1] = y;\n\t\t\tthis.array[index + 2] = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetXYZW(index, x, y, z, w) {\n\t\t\tindex *= this.itemSize;\n\t\t\tthis.array[index + 0] = x;\n\t\t\tthis.array[index + 1] = y;\n\t\t\tthis.array[index + 2] = z;\n\t\t\tthis.array[index + 3] = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tonUpload(callback) {\n\t\t\tthis.onUploadCallback = callback;\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.array, this.itemSize).copy(this);\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = {\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call(this.array),\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\t\t\tif (this.name !== '') data.name = this.name;\n\t\t\tif (this.usage !== StaticDrawUsage) data.usage = this.usage;\n\t\t\tif (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tBufferAttribute.prototype.isBufferAttribute = true; //\n\n\tclass Int8BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Int8Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Uint8BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Uint8Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Uint8ClampedBufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Uint8ClampedArray(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Int16BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Int16Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Uint16BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Uint16Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Int32BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Int32Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Uint32BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Uint32Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Float16BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Uint16Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tFloat16BufferAttribute.prototype.isFloat16BufferAttribute = true;\n\n\tclass Float32BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Float32Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Float64BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Float64Array(array), itemSize, normalized);\n\t\t}\n\n\t} //\n\n\tfunction arrayMax(array) {\n\t\tif (array.length === 0) return -Infinity;\n\t\tlet max = array[0];\n\n\t\tfor (let i = 1, l = array.length; i < l; ++i) {\n\t\t\tif (array[i] > max) max = array[i];\n\t\t}\n\n\t\treturn max;\n\t}\n\n\tconst TYPED_ARRAYS = {\n\t\tInt8Array: Int8Array,\n\t\tUint8Array: Uint8Array,\n\t\tUint8ClampedArray: Uint8ClampedArray,\n\t\tInt16Array: Int16Array,\n\t\tUint16Array: Uint16Array,\n\t\tInt32Array: Int32Array,\n\t\tUint32Array: Uint32Array,\n\t\tFloat32Array: Float32Array,\n\t\tFloat64Array: Float64Array\n\t};\n\n\tfunction getTypedArray(type, buffer) {\n\t\treturn new TYPED_ARRAYS[type](buffer);\n\t}\n\n\tlet _id = 0;\n\n\tconst _m1 = /*@__PURE__*/new Matrix4();\n\n\tconst _obj = /*@__PURE__*/new Object3D();\n\n\tconst _offset = /*@__PURE__*/new Vector3();\n\n\tconst _box$1 = /*@__PURE__*/new Box3();\n\n\tconst _boxMorphTargets = /*@__PURE__*/new Box3();\n\n\tconst _vector$8 = /*@__PURE__*/new Vector3();\n\n\tclass BufferGeometry extends EventDispatcher {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tObject.defineProperty(this, 'id', {\n\t\t\t\tvalue: _id++\n\t\t\t});\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'BufferGeometry';\n\t\t\tthis.index = null;\n\t\t\tthis.attributes = {};\n\t\t\tthis.morphAttributes = {};\n\t\t\tthis.morphTargetsRelative = false;\n\t\t\tthis.groups = [];\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\t\t\tthis.drawRange = {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: Infinity\n\t\t\t};\n\t\t\tthis.userData = {};\n\t\t}\n\n\t\tgetIndex() {\n\t\t\treturn this.index;\n\t\t}\n\n\t\tsetIndex(index) {\n\t\t\tif (Array.isArray(index)) {\n\t\t\t\tthis.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n\t\t\t} else {\n\t\t\t\tthis.index = index;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetAttribute(name) {\n\t\t\treturn this.attributes[name];\n\t\t}\n\n\t\tsetAttribute(name, attribute) {\n\t\t\tthis.attributes[name] = attribute;\n\t\t\treturn this;\n\t\t}\n\n\t\tdeleteAttribute(name) {\n\t\t\tdelete this.attributes[name];\n\t\t\treturn this;\n\t\t}\n\n\t\thasAttribute(name) {\n\t\t\treturn this.attributes[name] !== undefined;\n\t\t}\n\n\t\taddGroup(start, count, materialIndex = 0) {\n\t\t\tthis.groups.push({\n\t\t\t\tstart: start,\n\t\t\t\tcount: count,\n\t\t\t\tmaterialIndex: materialIndex\n\t\t\t});\n\t\t}\n\n\t\tclearGroups() {\n\t\t\tthis.groups = [];\n\t\t}\n\n\t\tsetDrawRange(start, count) {\n\t\t\tthis.drawRange.start = start;\n\t\t\tthis.drawRange.count = count;\n\t\t}\n\n\t\tapplyMatrix4(matrix) {\n\t\t\tconst position = this.attributes.position;\n\n\t\t\tif (position !== undefined) {\n\t\t\t\tposition.applyMatrix4(matrix);\n\t\t\t\tposition.needsUpdate = true;\n\t\t\t}\n\n\t\t\tconst normal = this.attributes.normal;\n\n\t\t\tif (normal !== undefined) {\n\t\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\t\t\t\tnormal.applyNormalMatrix(normalMatrix);\n\t\t\t\tnormal.needsUpdate = true;\n\t\t\t}\n\n\t\t\tconst tangent = this.attributes.tangent;\n\n\t\t\tif (tangent !== undefined) {\n\t\t\t\ttangent.transformDirection(matrix);\n\t\t\t\ttangent.needsUpdate = true;\n\t\t\t}\n\n\t\t\tif (this.boundingBox !== null) {\n\t\t\t\tthis.computeBoundingBox();\n\t\t\t}\n\n\t\t\tif (this.boundingSphere !== null) {\n\t\t\t\tthis.computeBoundingSphere();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyQuaternion(q) {\n\t\t\t_m1.makeRotationFromQuaternion(q);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateX(angle) {\n\t\t\t// rotate geometry around world x-axis\n\t\t\t_m1.makeRotationX(angle);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateY(angle) {\n\t\t\t// rotate geometry around world y-axis\n\t\t\t_m1.makeRotationY(angle);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateZ(angle) {\n\t\t\t// rotate geometry around world z-axis\n\t\t\t_m1.makeRotationZ(angle);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(x, y, z) {\n\t\t\t// translate geometry\n\t\t\t_m1.makeTranslation(x, y, z);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\tscale(x, y, z) {\n\t\t\t// scale geometry\n\t\t\t_m1.makeScale(x, y, z);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\tlookAt(vector) {\n\t\t\t_obj.lookAt(vector);\n\n\t\t\t_obj.updateMatrix();\n\n\t\t\tthis.applyMatrix4(_obj.matrix);\n\t\t\treturn this;\n\t\t}\n\n\t\tcenter() {\n\t\t\tthis.computeBoundingBox();\n\t\t\tthis.boundingBox.getCenter(_offset).negate();\n\t\t\tthis.translate(_offset.x, _offset.y, _offset.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromPoints(points) {\n\t\t\tconst position = [];\n\n\t\t\tfor (let i = 0, l = points.length; i < l; i++) {\n\t\t\t\tconst point = points[i];\n\t\t\t\tposition.push(point.x, point.y, point.z || 0);\n\t\t\t}\n\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(position, 3));\n\t\t\treturn this;\n\t\t}\n\n\t\tcomputeBoundingBox() {\n\t\t\tif (this.boundingBox === null) {\n\t\t\t\tthis.boundingBox = new Box3();\n\t\t\t}\n\n\t\t\tconst position = this.attributes.position;\n\t\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\t\tif (position && position.isGLBufferAttribute) {\n\t\t\t\tconsole.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n\t\t\t\tthis.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (position !== undefined) {\n\t\t\t\tthis.boundingBox.setFromBufferAttribute(position); // process morph attributes if present\n\n\t\t\t\tif (morphAttributesPosition) {\n\t\t\t\t\tfor (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n\t\t\t\t\t\tconst morphAttribute = morphAttributesPosition[i];\n\n\t\t\t\t\t\t_box$1.setFromBufferAttribute(morphAttribute);\n\n\t\t\t\t\t\tif (this.morphTargetsRelative) {\n\t\t\t\t\t\t\t_vector$8.addVectors(this.boundingBox.min, _box$1.min);\n\n\t\t\t\t\t\t\tthis.boundingBox.expandByPoint(_vector$8);\n\n\t\t\t\t\t\t\t_vector$8.addVectors(this.boundingBox.max, _box$1.max);\n\n\t\t\t\t\t\t\tthis.boundingBox.expandByPoint(_vector$8);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.boundingBox.expandByPoint(_box$1.min);\n\t\t\t\t\t\t\tthis.boundingBox.expandByPoint(_box$1.max);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.boundingBox.makeEmpty();\n\t\t\t}\n\n\t\t\tif (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n\t\t\t\tconsole.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n\t\t\t}\n\t\t}\n\n\t\tcomputeBoundingSphere() {\n\t\t\tif (this.boundingSphere === null) {\n\t\t\t\tthis.boundingSphere = new Sphere();\n\t\t\t}\n\n\t\t\tconst position = this.attributes.position;\n\t\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\t\tif (position && position.isGLBufferAttribute) {\n\t\t\t\tconsole.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n\t\t\t\tthis.boundingSphere.set(new Vector3(), Infinity);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (position) {\n\t\t\t\t// first, find the center of the bounding sphere\n\t\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t\t_box$1.setFromBufferAttribute(position); // process morph attributes if present\n\n\n\t\t\t\tif (morphAttributesPosition) {\n\t\t\t\t\tfor (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n\t\t\t\t\t\tconst morphAttribute = morphAttributesPosition[i];\n\n\t\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute(morphAttribute);\n\n\t\t\t\t\t\tif (this.morphTargetsRelative) {\n\t\t\t\t\t\t\t_vector$8.addVectors(_box$1.min, _boxMorphTargets.min);\n\n\t\t\t\t\t\t\t_box$1.expandByPoint(_vector$8);\n\n\t\t\t\t\t\t\t_vector$8.addVectors(_box$1.max, _boxMorphTargets.max);\n\n\t\t\t\t\t\t\t_box$1.expandByPoint(_vector$8);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_box$1.expandByPoint(_boxMorphTargets.min);\n\n\t\t\t\t\t\t\t_box$1.expandByPoint(_boxMorphTargets.max);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t_box$1.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\n\t\t\t\tlet maxRadiusSq = 0;\n\n\t\t\t\tfor (let i = 0, il = position.count; i < il; i++) {\n\t\t\t\t\t_vector$8.fromBufferAttribute(position, i);\n\n\t\t\t\t\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n\t\t\t\t} // process morph attributes if present\n\n\n\t\t\t\tif (morphAttributesPosition) {\n\t\t\t\t\tfor (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n\t\t\t\t\t\tconst morphAttribute = morphAttributesPosition[i];\n\t\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\t\tfor (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n\t\t\t\t\t\t\t_vector$8.fromBufferAttribute(morphAttribute, j);\n\n\t\t\t\t\t\t\tif (morphTargetsRelative) {\n\t\t\t\t\t\t\t\t_offset.fromBufferAttribute(position, j);\n\n\t\t\t\t\t\t\t\t_vector$8.add(_offset);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n\t\t\t\tif (isNaN(this.boundingSphere.radius)) {\n\t\t\t\t\tconsole.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcomputeFaceNormals() {// backwards compatibility\n\t\t}\n\n\t\tcomputeTangents() {\n\t\t\tconst index = this.index;\n\t\t\tconst attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html\n\t\t\t// (per vertex tangents)\n\n\t\t\tif (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {\n\t\t\t\tconsole.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst indices = index.array;\n\t\t\tconst positions = attributes.position.array;\n\t\t\tconst normals = attributes.normal.array;\n\t\t\tconst uvs = attributes.uv.array;\n\t\t\tconst nVertices = positions.length / 3;\n\n\t\t\tif (attributes.tangent === undefined) {\n\t\t\t\tthis.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));\n\t\t\t}\n\n\t\t\tconst tangents = attributes.tangent.array;\n\t\t\tconst tan1 = [],\n\t\t\t\t\t\ttan2 = [];\n\n\t\t\tfor (let i = 0; i < nVertices; i++) {\n\t\t\t\ttan1[i] = new Vector3();\n\t\t\t\ttan2[i] = new Vector3();\n\t\t\t}\n\n\t\t\tconst vA = new Vector3(),\n\t\t\t\t\t\tvB = new Vector3(),\n\t\t\t\t\t\tvC = new Vector3(),\n\t\t\t\t\t\tuvA = new Vector2(),\n\t\t\t\t\t\tuvB = new Vector2(),\n\t\t\t\t\t\tuvC = new Vector2(),\n\t\t\t\t\t\tsdir = new Vector3(),\n\t\t\t\t\t\ttdir = new Vector3();\n\n\t\t\tfunction handleTriangle(a, b, c) {\n\t\t\t\tvA.fromArray(positions, a * 3);\n\t\t\t\tvB.fromArray(positions, b * 3);\n\t\t\t\tvC.fromArray(positions, c * 3);\n\t\t\t\tuvA.fromArray(uvs, a * 2);\n\t\t\t\tuvB.fromArray(uvs, b * 2);\n\t\t\t\tuvC.fromArray(uvs, c * 2);\n\t\t\t\tvB.sub(vA);\n\t\t\t\tvC.sub(vA);\n\t\t\t\tuvB.sub(uvA);\n\t\t\t\tuvC.sub(uvA);\n\t\t\t\tconst r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\t\tif (!isFinite(r)) return;\n\t\t\t\tsdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n\t\t\t\ttdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n\t\t\t\ttan1[a].add(sdir);\n\t\t\t\ttan1[b].add(sdir);\n\t\t\t\ttan1[c].add(sdir);\n\t\t\t\ttan2[a].add(tdir);\n\t\t\t\ttan2[b].add(tdir);\n\t\t\t\ttan2[c].add(tdir);\n\t\t\t}\n\n\t\t\tlet groups = this.groups;\n\n\t\t\tif (groups.length === 0) {\n\t\t\t\tgroups = [{\n\t\t\t\t\tstart: 0,\n\t\t\t\t\tcount: indices.length\n\t\t\t\t}];\n\t\t\t}\n\n\t\t\tfor (let i = 0, il = groups.length; i < il; ++i) {\n\t\t\t\tconst group = groups[i];\n\t\t\t\tconst start = group.start;\n\t\t\t\tconst count = group.count;\n\n\t\t\t\tfor (let j = start, jl = start + count; j < jl; j += 3) {\n\t\t\t\t\thandleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst tmp = new Vector3(),\n\t\t\t\t\t\ttmp2 = new Vector3();\n\t\t\tconst n = new Vector3(),\n\t\t\t\t\t\tn2 = new Vector3();\n\n\t\t\tfunction handleVertex(v) {\n\t\t\t\tn.fromArray(normals, v * 3);\n\t\t\t\tn2.copy(n);\n\t\t\t\tconst t = tan1[v]; // Gram-Schmidt orthogonalize\n\n\t\t\t\ttmp.copy(t);\n\t\t\t\ttmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness\n\n\t\t\t\ttmp2.crossVectors(n2, t);\n\t\t\t\tconst test = tmp2.dot(tan2[v]);\n\t\t\t\tconst w = test < 0.0 ? -1.0 : 1.0;\n\t\t\t\ttangents[v * 4] = tmp.x;\n\t\t\t\ttangents[v * 4 + 1] = tmp.y;\n\t\t\t\ttangents[v * 4 + 2] = tmp.z;\n\t\t\t\ttangents[v * 4 + 3] = w;\n\t\t\t}\n\n\t\t\tfor (let i = 0, il = groups.length; i < il; ++i) {\n\t\t\t\tconst group = groups[i];\n\t\t\t\tconst start = group.start;\n\t\t\t\tconst count = group.count;\n\n\t\t\t\tfor (let j = start, jl = start + count; j < jl; j += 3) {\n\t\t\t\t\thandleVertex(indices[j + 0]);\n\t\t\t\t\thandleVertex(indices[j + 1]);\n\t\t\t\t\thandleVertex(indices[j + 2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcomputeVertexNormals() {\n\t\t\tconst index = this.index;\n\t\t\tconst positionAttribute = this.getAttribute('position');\n\n\t\t\tif (positionAttribute !== undefined) {\n\t\t\t\tlet normalAttribute = this.getAttribute('normal');\n\n\t\t\t\tif (normalAttribute === undefined) {\n\t\t\t\t\tnormalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n\t\t\t\t\tthis.setAttribute('normal', normalAttribute);\n\t\t\t\t} else {\n\t\t\t\t\t// reset existing normals to zero\n\t\t\t\t\tfor (let i = 0, il = normalAttribute.count; i < il; i++) {\n\t\t\t\t\t\tnormalAttribute.setXYZ(i, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst pA = new Vector3(),\n\t\t\t\t\t\t\tpB = new Vector3(),\n\t\t\t\t\t\t\tpC = new Vector3();\n\t\t\t\tconst nA = new Vector3(),\n\t\t\t\t\t\t\tnB = new Vector3(),\n\t\t\t\t\t\t\tnC = new Vector3();\n\t\t\t\tconst cb = new Vector3(),\n\t\t\t\t\t\t\tab = new Vector3(); // indexed elements\n\n\t\t\t\tif (index) {\n\t\t\t\t\tfor (let i = 0, il = index.count; i < il; i += 3) {\n\t\t\t\t\t\tconst vA = index.getX(i + 0);\n\t\t\t\t\t\tconst vB = index.getX(i + 1);\n\t\t\t\t\t\tconst vC = index.getX(i + 2);\n\t\t\t\t\t\tpA.fromBufferAttribute(positionAttribute, vA);\n\t\t\t\t\t\tpB.fromBufferAttribute(positionAttribute, vB);\n\t\t\t\t\t\tpC.fromBufferAttribute(positionAttribute, vC);\n\t\t\t\t\t\tcb.subVectors(pC, pB);\n\t\t\t\t\t\tab.subVectors(pA, pB);\n\t\t\t\t\t\tcb.cross(ab);\n\t\t\t\t\t\tnA.fromBufferAttribute(normalAttribute, vA);\n\t\t\t\t\t\tnB.fromBufferAttribute(normalAttribute, vB);\n\t\t\t\t\t\tnC.fromBufferAttribute(normalAttribute, vC);\n\t\t\t\t\t\tnA.add(cb);\n\t\t\t\t\t\tnB.add(cb);\n\t\t\t\t\t\tnC.add(cb);\n\t\t\t\t\t\tnormalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n\t\t\t\t\t\tnormalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n\t\t\t\t\t\tnormalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\t\t\t\t\tfor (let i = 0, il = positionAttribute.count; i < il; i += 3) {\n\t\t\t\t\t\tpA.fromBufferAttribute(positionAttribute, i + 0);\n\t\t\t\t\t\tpB.fromBufferAttribute(positionAttribute, i + 1);\n\t\t\t\t\t\tpC.fromBufferAttribute(positionAttribute, i + 2);\n\t\t\t\t\t\tcb.subVectors(pC, pB);\n\t\t\t\t\t\tab.subVectors(pA, pB);\n\t\t\t\t\t\tcb.cross(ab);\n\t\t\t\t\t\tnormalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);\n\t\t\t\t\t\tnormalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);\n\t\t\t\t\t\tnormalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.normalizeNormals();\n\t\t\t\tnormalAttribute.needsUpdate = true;\n\t\t\t}\n\t\t}\n\n\t\tmerge(geometry, offset) {\n\t\t\tif (!(geometry && geometry.isBufferGeometry)) {\n\t\t\t\tconsole.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (offset === undefined) {\n\t\t\t\toffset = 0;\n\t\t\t\tconsole.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');\n\t\t\t}\n\n\t\t\tconst attributes = this.attributes;\n\n\t\t\tfor (const key in attributes) {\n\t\t\t\tif (geometry.attributes[key] === undefined) continue;\n\t\t\t\tconst attribute1 = attributes[key];\n\t\t\t\tconst attributeArray1 = attribute1.array;\n\t\t\t\tconst attribute2 = geometry.attributes[key];\n\t\t\t\tconst attributeArray2 = attribute2.array;\n\t\t\t\tconst attributeOffset = attribute2.itemSize * offset;\n\t\t\t\tconst length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);\n\n\t\t\t\tfor (let i = 0, j = attributeOffset; i < length; i++, j++) {\n\t\t\t\t\tattributeArray1[j] = attributeArray2[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tnormalizeNormals() {\n\t\t\tconst normals = this.attributes.normal;\n\n\t\t\tfor (let i = 0, il = normals.count; i < il; i++) {\n\t\t\t\t_vector$8.fromBufferAttribute(normals, i);\n\n\t\t\t\t_vector$8.normalize();\n\n\t\t\t\tnormals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);\n\t\t\t}\n\t\t}\n\n\t\ttoNonIndexed() {\n\t\t\tfunction convertBufferAttribute(attribute, indices) {\n\t\t\t\tconst array = attribute.array;\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst normalized = attribute.normalized;\n\t\t\t\tconst array2 = new array.constructor(indices.length * itemSize);\n\t\t\t\tlet index = 0,\n\t\t\t\t\t\tindex2 = 0;\n\n\t\t\t\tfor (let i = 0, l = indices.length; i < l; i++) {\n\t\t\t\t\tindex = indices[i] * itemSize;\n\n\t\t\t\t\tfor (let j = 0; j < itemSize; j++) {\n\t\t\t\t\t\tarray2[index2++] = array[index++];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new BufferAttribute(array2, itemSize, normalized);\n\t\t\t} //\n\n\n\t\t\tif (this.index === null) {\n\t\t\t\tconsole.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tconst geometry2 = new BufferGeometry();\n\t\t\tconst indices = this.index.array;\n\t\t\tconst attributes = this.attributes; // attributes\n\n\t\t\tfor (const name in attributes) {\n\t\t\t\tconst attribute = attributes[name];\n\t\t\t\tconst newAttribute = convertBufferAttribute(attribute, indices);\n\t\t\t\tgeometry2.setAttribute(name, newAttribute);\n\t\t\t} // morph attributes\n\n\n\t\t\tconst morphAttributes = this.morphAttributes;\n\n\t\t\tfor (const name in morphAttributes) {\n\t\t\t\tconst morphArray = [];\n\t\t\t\tconst morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\t\tfor (let i = 0, il = morphAttribute.length; i < il; i++) {\n\t\t\t\t\tconst attribute = morphAttribute[i];\n\t\t\t\t\tconst newAttribute = convertBufferAttribute(attribute, indices);\n\t\t\t\t\tmorphArray.push(newAttribute);\n\t\t\t\t}\n\n\t\t\t\tgeometry2.morphAttributes[name] = morphArray;\n\t\t\t}\n\n\t\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative; // groups\n\n\t\t\tconst groups = this.groups;\n\n\t\t\tfor (let i = 0, l = groups.length; i < l; i++) {\n\t\t\t\tconst group = groups[i];\n\t\t\t\tgeometry2.addGroup(group.start, group.count, group.materialIndex);\n\t\t\t}\n\n\t\t\treturn geometry2;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t\t}\n\t\t\t}; // standard BufferGeometry serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif (this.name !== '') data.name = this.name;\n\t\t\tif (Object.keys(this.userData).length > 0) data.userData = this.userData;\n\n\t\t\tif (this.parameters !== undefined) {\n\t\t\t\tconst parameters = this.parameters;\n\n\t\t\t\tfor (const key in parameters) {\n\t\t\t\t\tif (parameters[key] !== undefined) data[key] = parameters[key];\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\t\t\t} // for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\n\t\t\tdata.data = {\n\t\t\t\tattributes: {}\n\t\t\t};\n\t\t\tconst index = this.index;\n\n\t\t\tif (index !== null) {\n\t\t\t\tdata.data.index = {\n\t\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\t\tarray: Array.prototype.slice.call(index.array)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst attributes = this.attributes;\n\n\t\t\tfor (const key in attributes) {\n\t\t\t\tconst attribute = attributes[key];\n\t\t\t\tdata.data.attributes[key] = attribute.toJSON(data.data);\n\t\t\t}\n\n\t\t\tconst morphAttributes = {};\n\t\t\tlet hasMorphAttributes = false;\n\n\t\t\tfor (const key in this.morphAttributes) {\n\t\t\t\tconst attributeArray = this.morphAttributes[key];\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor (let i = 0, il = attributeArray.length; i < il; i++) {\n\t\t\t\t\tconst attribute = attributeArray[i];\n\t\t\t\t\tarray.push(attribute.toJSON(data.data));\n\t\t\t\t}\n\n\t\t\t\tif (array.length > 0) {\n\t\t\t\t\tmorphAttributes[key] = array;\n\t\t\t\t\thasMorphAttributes = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasMorphAttributes) {\n\t\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\t\t\t}\n\n\t\t\tconst groups = this.groups;\n\n\t\t\tif (groups.length > 0) {\n\t\t\t\tdata.data.groups = JSON.parse(JSON.stringify(groups));\n\t\t\t}\n\n\t\t\tconst boundingSphere = this.boundingSphere;\n\n\t\t\tif (boundingSphere !== null) {\n\t\t\t\tdata.data.boundingSphere = {\n\t\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\t\tradius: boundingSphere.radius\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tclone() {\n\t\t\t/*\n\t\t\t // Handle primitives\n\t\t\t\t const parameters = this.parameters;\n\t\t\t\t if ( parameters !== undefined ) {\n\t\t\t\t const values = [];\n\t\t\t\t for ( const key in parameters ) {\n\t\t\t\t values.push( parameters[ key ] );\n\t\t\t\t }\n\t\t\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t\t this.constructor.apply( geometry, values );\n\t\t\t return geometry;\n\t\t\t\t }\n\t\t\t\t return new this.constructor().copy( this );\n\t\t\t */\n\t\t\treturn new BufferGeometry().copy(this);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\t// reset\n\t\t\tthis.index = null;\n\t\t\tthis.attributes = {};\n\t\t\tthis.morphAttributes = {};\n\t\t\tthis.groups = [];\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null; // used for storing cloned, shared data\n\n\t\t\tconst data = {}; // name\n\n\t\t\tthis.name = source.name; // index\n\n\t\t\tconst index = source.index;\n\n\t\t\tif (index !== null) {\n\t\t\t\tthis.setIndex(index.clone(data));\n\t\t\t} // attributes\n\n\n\t\t\tconst attributes = source.attributes;\n\n\t\t\tfor (const name in attributes) {\n\t\t\t\tconst attribute = attributes[name];\n\t\t\t\tthis.setAttribute(name, attribute.clone(data));\n\t\t\t} // morph attributes\n\n\n\t\t\tconst morphAttributes = source.morphAttributes;\n\n\t\t\tfor (const name in morphAttributes) {\n\t\t\t\tconst array = [];\n\t\t\t\tconst morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\t\tfor (let i = 0, l = morphAttribute.length; i < l; i++) {\n\t\t\t\t\tarray.push(morphAttribute[i].clone(data));\n\t\t\t\t}\n\n\t\t\t\tthis.morphAttributes[name] = array;\n\t\t\t}\n\n\t\t\tthis.morphTargetsRelative = source.morphTargetsRelative; // groups\n\n\t\t\tconst groups = source.groups;\n\n\t\t\tfor (let i = 0, l = groups.length; i < l; i++) {\n\t\t\t\tconst group = groups[i];\n\t\t\t\tthis.addGroup(group.start, group.count, group.materialIndex);\n\t\t\t} // bounding box\n\n\n\t\t\tconst boundingBox = source.boundingBox;\n\n\t\t\tif (boundingBox !== null) {\n\t\t\t\tthis.boundingBox = boundingBox.clone();\n\t\t\t} // bounding sphere\n\n\n\t\t\tconst boundingSphere = source.boundingSphere;\n\n\t\t\tif (boundingSphere !== null) {\n\t\t\t\tthis.boundingSphere = boundingSphere.clone();\n\t\t\t} // draw range\n\n\n\t\t\tthis.drawRange.start = source.drawRange.start;\n\t\t\tthis.drawRange.count = source.drawRange.count; // user data\n\n\t\t\tthis.userData = source.userData;\n\t\t\treturn this;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'dispose'\n\t\t\t});\n\t\t}\n\n\t}\n\n\tBufferGeometry.prototype.isBufferGeometry = true;\n\n\tconst _inverseMatrix$2 = /*@__PURE__*/new Matrix4();\n\n\tconst _ray$2 = /*@__PURE__*/new Ray();\n\n\tconst _sphere$3 = /*@__PURE__*/new Sphere();\n\n\tconst _vA$1 = /*@__PURE__*/new Vector3();\n\n\tconst _vB$1 = /*@__PURE__*/new Vector3();\n\n\tconst _vC$1 = /*@__PURE__*/new Vector3();\n\n\tconst _tempA = /*@__PURE__*/new Vector3();\n\n\tconst _tempB = /*@__PURE__*/new Vector3();\n\n\tconst _tempC = /*@__PURE__*/new Vector3();\n\n\tconst _morphA = /*@__PURE__*/new Vector3();\n\n\tconst _morphB = /*@__PURE__*/new Vector3();\n\n\tconst _morphC = /*@__PURE__*/new Vector3();\n\n\tconst _uvA$1 = /*@__PURE__*/new Vector2();\n\n\tconst _uvB$1 = /*@__PURE__*/new Vector2();\n\n\tconst _uvC$1 = /*@__PURE__*/new Vector2();\n\n\tconst _intersectionPoint = /*@__PURE__*/new Vector3();\n\n\tconst _intersectionPointWorld = /*@__PURE__*/new Vector3();\n\n\tclass Mesh extends Object3D {\n\t\tconstructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Mesh';\n\t\t\tthis.geometry = geometry;\n\t\t\tthis.material = material;\n\t\t\tthis.updateMorphTargets();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\n\t\t\tif (source.morphTargetInfluences !== undefined) {\n\t\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\t\t\t}\n\n\t\t\tif (source.morphTargetDictionary !== undefined) {\n\t\t\t\tthis.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n\t\t\t}\n\n\t\t\tthis.material = source.material;\n\t\t\tthis.geometry = source.geometry;\n\t\t\treturn this;\n\t\t}\n\n\t\tupdateMorphTargets() {\n\t\t\tconst geometry = this.geometry;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\t\tconst keys = Object.keys(morphAttributes);\n\n\t\t\t\tif (keys.length > 0) {\n\t\t\t\t\tconst morphAttribute = morphAttributes[keys[0]];\n\n\t\t\t\t\tif (morphAttribute !== undefined) {\n\t\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\t\tfor (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n\t\t\t\t\t\t\tconst name = morphAttribute[m].name || String(m);\n\t\t\t\t\t\t\tthis.morphTargetInfluences.push(0);\n\t\t\t\t\t\t\tthis.morphTargetDictionary[name] = m;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\t\tif (morphTargets !== undefined && morphTargets.length > 0) {\n\t\t\t\t\tconsole.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst material = this.material;\n\t\t\tconst matrixWorld = this.matrixWorld;\n\t\t\tif (material === undefined) return; // Checking boundingSphere distance to ray\n\n\t\t\tif (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n\t\t\t_sphere$3.copy(geometry.boundingSphere);\n\n\t\t\t_sphere$3.applyMatrix4(matrixWorld);\n\n\t\t\tif (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //\n\n\t\t\t_inverseMatrix$2.copy(matrixWorld).invert();\n\n\t\t\t_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2); // Check boundingBox before continuing\n\n\n\t\t\tif (geometry.boundingBox !== null) {\n\t\t\t\tif (_ray$2.intersectsBox(geometry.boundingBox) === false) return;\n\t\t\t}\n\n\t\t\tlet intersection;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\t\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\t\t\tconst uv = geometry.attributes.uv;\n\t\t\t\tconst uv2 = geometry.attributes.uv2;\n\t\t\t\tconst groups = geometry.groups;\n\t\t\t\tconst drawRange = geometry.drawRange;\n\n\t\t\t\tif (index !== null) {\n\t\t\t\t\t// indexed buffer geometry\n\t\t\t\t\tif (Array.isArray(material)) {\n\t\t\t\t\t\tfor (let i = 0, il = groups.length; i < il; i++) {\n\t\t\t\t\t\t\tconst group = groups[i];\n\t\t\t\t\t\t\tconst groupMaterial = material[group.materialIndex];\n\t\t\t\t\t\t\tconst start = Math.max(group.start, drawRange.start);\n\t\t\t\t\t\t\tconst end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\t\t\tfor (let j = start, jl = end; j < jl; j += 3) {\n\t\t\t\t\t\t\t\tconst a = index.getX(j);\n\t\t\t\t\t\t\t\tconst b = index.getX(j + 1);\n\t\t\t\t\t\t\t\tconst c = index.getX(j + 2);\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n\t\t\t\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics\n\n\t\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\t\tintersects.push(intersection);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\t\tconst end = Math.min(index.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\t\tfor (let i = start, il = end; i < il; i += 3) {\n\t\t\t\t\t\t\tconst a = index.getX(i);\n\t\t\t\t\t\t\tconst b = index.getX(i + 1);\n\t\t\t\t\t\t\tconst c = index.getX(i + 2);\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n\t\t\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics\n\n\t\t\t\t\t\t\t\tintersects.push(intersection);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (position !== undefined) {\n\t\t\t\t\t// non-indexed buffer geometry\n\t\t\t\t\tif (Array.isArray(material)) {\n\t\t\t\t\t\tfor (let i = 0, il = groups.length; i < il; i++) {\n\t\t\t\t\t\t\tconst group = groups[i];\n\t\t\t\t\t\t\tconst groupMaterial = material[group.materialIndex];\n\t\t\t\t\t\t\tconst start = Math.max(group.start, drawRange.start);\n\t\t\t\t\t\t\tconst end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\t\t\tfor (let j = start, jl = end; j < jl; j += 3) {\n\t\t\t\t\t\t\t\tconst a = j;\n\t\t\t\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\t\t\t\tconst c = j + 2;\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n\t\t\t\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics\n\n\t\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\t\tintersects.push(intersection);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\t\tconst end = Math.min(position.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\t\tfor (let i = start, il = end; i < il; i += 3) {\n\t\t\t\t\t\t\tconst a = i;\n\t\t\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\t\t\tconst c = i + 2;\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n\t\t\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics\n\n\t\t\t\t\t\t\t\tintersects.push(intersection);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (geometry.isGeometry) {\n\t\t\t\tconsole.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t}\n\t\t}\n\n\t}\n\n\tMesh.prototype.isMesh = true;\n\n\tfunction checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {\n\t\tlet intersect;\n\n\t\tif (material.side === BackSide) {\n\t\t\tintersect = ray.intersectTriangle(pC, pB, pA, true, point);\n\t\t} else {\n\t\t\tintersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);\n\t\t}\n\n\t\tif (intersect === null) return null;\n\n\t\t_intersectionPointWorld.copy(point);\n\n\t\t_intersectionPointWorld.applyMatrix4(object.matrixWorld);\n\n\t\tconst distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n\t\tif (distance < raycaster.near || distance > raycaster.far) return null;\n\t\treturn {\n\t\t\tdistance: distance,\n\t\t\tpoint: _intersectionPointWorld.clone(),\n\t\t\tobject: object\n\t\t};\n\t}\n\n\tfunction checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {\n\t\t_vA$1.fromBufferAttribute(position, a);\n\n\t\t_vB$1.fromBufferAttribute(position, b);\n\n\t\t_vC$1.fromBufferAttribute(position, c);\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif (material.morphTargets && morphPosition && morphInfluences) {\n\t\t\t_morphA.set(0, 0, 0);\n\n\t\t\t_morphB.set(0, 0, 0);\n\n\t\t\t_morphC.set(0, 0, 0);\n\n\t\t\tfor (let i = 0, il = morphPosition.length; i < il; i++) {\n\t\t\t\tconst influence = morphInfluences[i];\n\t\t\t\tconst morphAttribute = morphPosition[i];\n\t\t\t\tif (influence === 0) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute(morphAttribute, a);\n\n\t\t\t\t_tempB.fromBufferAttribute(morphAttribute, b);\n\n\t\t\t\t_tempC.fromBufferAttribute(morphAttribute, c);\n\n\t\t\t\tif (morphTargetsRelative) {\n\t\t\t\t\t_morphA.addScaledVector(_tempA, influence);\n\n\t\t\t\t\t_morphB.addScaledVector(_tempB, influence);\n\n\t\t\t\t\t_morphC.addScaledVector(_tempC, influence);\n\t\t\t\t} else {\n\t\t\t\t\t_morphA.addScaledVector(_tempA.sub(_vA$1), influence);\n\n\t\t\t\t\t_morphB.addScaledVector(_tempB.sub(_vB$1), influence);\n\n\t\t\t\t\t_morphC.addScaledVector(_tempC.sub(_vC$1), influence);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_vA$1.add(_morphA);\n\n\t\t\t_vB$1.add(_morphB);\n\n\t\t\t_vC$1.add(_morphC);\n\t\t}\n\n\t\tif (object.isSkinnedMesh) {\n\t\t\tobject.boneTransform(a, _vA$1);\n\t\t\tobject.boneTransform(b, _vB$1);\n\t\t\tobject.boneTransform(c, _vC$1);\n\t\t}\n\n\t\tconst intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);\n\n\t\tif (intersection) {\n\t\t\tif (uv) {\n\t\t\t\t_uvA$1.fromBufferAttribute(uv, a);\n\n\t\t\t\t_uvB$1.fromBufferAttribute(uv, b);\n\n\t\t\t\t_uvC$1.fromBufferAttribute(uv, c);\n\n\t\t\t\tintersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());\n\t\t\t}\n\n\t\t\tif (uv2) {\n\t\t\t\t_uvA$1.fromBufferAttribute(uv2, a);\n\n\t\t\t\t_uvB$1.fromBufferAttribute(uv2, b);\n\n\t\t\t\t_uvC$1.fromBufferAttribute(uv2, c);\n\n\t\t\t\tintersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());\n\t\t\t}\n\n\t\t\tconst face = {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tnormal: new Vector3(),\n\t\t\t\tmaterialIndex: 0\n\t\t\t};\n\t\t\tTriangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);\n\t\t\tintersection.face = face;\n\t\t}\n\n\t\treturn intersection;\n\t}\n\n\tclass BoxGeometry extends BufferGeometry {\n\t\tconstructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {\n\t\t\tsuper();\n\t\t\tthis.type = 'BoxGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepth: depth,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tdepthSegments: depthSegments\n\t\t\t};\n\t\t\tconst scope = this; // segments\n\n\t\t\twidthSegments = Math.floor(widthSegments);\n\t\t\theightSegments = Math.floor(heightSegments);\n\t\t\tdepthSegments = Math.floor(depthSegments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tlet numberOfVertices = 0;\n\t\t\tlet groupStart = 0; // build each side of the box geometry\n\n\t\t\tbuildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px\n\n\t\t\tbuildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx\n\n\t\t\tbuildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py\n\n\t\t\tbuildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny\n\n\t\t\tbuildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz\n\n\t\t\tbuildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz\n\t\t\t// build geometry\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n\t\t\tfunction buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {\n\t\t\t\tconst segmentWidth = width / gridX;\n\t\t\t\tconst segmentHeight = height / gridY;\n\t\t\t\tconst widthHalf = width / 2;\n\t\t\t\tconst heightHalf = height / 2;\n\t\t\t\tconst depthHalf = depth / 2;\n\t\t\t\tconst gridX1 = gridX + 1;\n\t\t\t\tconst gridY1 = gridY + 1;\n\t\t\t\tlet vertexCounter = 0;\n\t\t\t\tlet groupCount = 0;\n\t\t\t\tconst vector = new Vector3(); // generate vertices, normals and uvs\n\n\t\t\t\tfor (let iy = 0; iy < gridY1; iy++) {\n\t\t\t\t\tconst y = iy * segmentHeight - heightHalf;\n\n\t\t\t\t\tfor (let ix = 0; ix < gridX1; ix++) {\n\t\t\t\t\t\tconst x = ix * segmentWidth - widthHalf; // set values to correct vector component\n\n\t\t\t\t\t\tvector[u] = x * udir;\n\t\t\t\t\t\tvector[v] = y * vdir;\n\t\t\t\t\t\tvector[w] = depthHalf; // now apply vector to vertex buffer\n\n\t\t\t\t\t\tvertices.push(vector.x, vector.y, vector.z); // set values to correct vector component\n\n\t\t\t\t\t\tvector[u] = 0;\n\t\t\t\t\t\tvector[v] = 0;\n\t\t\t\t\t\tvector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer\n\n\t\t\t\t\t\tnormals.push(vector.x, vector.y, vector.z); // uvs\n\n\t\t\t\t\t\tuvs.push(ix / gridX);\n\t\t\t\t\t\tuvs.push(1 - iy / gridY); // counters\n\n\t\t\t\t\t\tvertexCounter += 1;\n\t\t\t\t\t}\n\t\t\t\t} // indices\n\t\t\t\t// 1. you need three indices to draw a single face\n\t\t\t\t// 2. a single segment consists of two faces\n\t\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\n\t\t\t\tfor (let iy = 0; iy < gridY; iy++) {\n\t\t\t\t\tfor (let ix = 0; ix < gridX; ix++) {\n\t\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * (iy + 1);\n\t\t\t\t\t\tconst c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);\n\t\t\t\t\t\tconst d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces\n\n\t\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\t\tindices.push(b, c, d); // increase counter\n\n\t\t\t\t\t\tgroupCount += 6;\n\t\t\t\t\t}\n\t\t\t\t} // add a group to the geometry. this will ensure multi material support\n\n\n\t\t\t\tscope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups\n\n\t\t\t\tgroupStart += groupCount; // update total number of vertices\n\n\t\t\t\tnumberOfVertices += vertexCounter;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Uniform Utilities\n\t */\n\tfunction cloneUniforms(src) {\n\t\tconst dst = {};\n\n\t\tfor (const u in src) {\n\t\t\tdst[u] = {};\n\n\t\t\tfor (const p in src[u]) {\n\t\t\t\tconst property = src[u][p];\n\n\t\t\t\tif (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {\n\t\t\t\t\tdst[u][p] = property.clone();\n\t\t\t\t} else if (Array.isArray(property)) {\n\t\t\t\t\tdst[u][p] = property.slice();\n\t\t\t\t} else {\n\t\t\t\t\tdst[u][p] = property;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dst;\n\t}\n\tfunction mergeUniforms(uniforms) {\n\t\tconst merged = {};\n\n\t\tfor (let u = 0; u < uniforms.length; u++) {\n\t\t\tconst tmp = cloneUniforms(uniforms[u]);\n\n\t\t\tfor (const p in tmp) {\n\t\t\t\tmerged[p] = tmp[p];\n\t\t\t}\n\t\t}\n\n\t\treturn merged;\n\t} // Legacy\n\n\tconst UniformsUtils = {\n\t\tclone: cloneUniforms,\n\t\tmerge: mergeUniforms\n\t};\n\n\tvar default_vertex = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\n\n\tvar default_fragment = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\n\n\t/**\n\t * parameters = {\n\t *\tdefines: { \"label\" : \"value\" },\n\t *\tuniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n\t *\n\t *\tfragmentShader: <string>,\n\t *\tvertexShader: <string>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tlights: <bool>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>\n\t * }\n\t */\n\n\tclass ShaderMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ShaderMaterial';\n\t\t\tthis.defines = {};\n\t\t\tthis.uniforms = {};\n\t\t\tthis.vertexShader = default_vertex;\n\t\t\tthis.fragmentShader = default_fragment;\n\t\t\tthis.linewidth = 1;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.fog = false; // set to use scene fog\n\n\t\t\tthis.lights = false; // set to use scene lights\n\n\t\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\t\tthis.morphTargets = false; // set to use morph targets\n\n\t\t\tthis.morphNormals = false; // set to use morph normals\n\n\t\t\tthis.extensions = {\n\t\t\t\tderivatives: false,\n\t\t\t\t// set to use derivatives\n\t\t\t\tfragDepth: false,\n\t\t\t\t// set to use fragment depth values\n\t\t\t\tdrawBuffers: false,\n\t\t\t\t// set to use draw buffers\n\t\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\n\t\t\t}; // When rendered geometry doesn't include these attributes but the material does,\n\t\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\n\t\t\tthis.defaultAttributeValues = {\n\t\t\t\t'color': [1, 1, 1],\n\t\t\t\t'uv': [0, 0],\n\t\t\t\t'uv2': [0, 0]\n\t\t\t};\n\t\t\tthis.index0AttributeName = undefined;\n\t\t\tthis.uniformsNeedUpdate = false;\n\t\t\tthis.glslVersion = null;\n\n\t\t\tif (parameters !== undefined) {\n\t\t\t\tif (parameters.attributes !== undefined) {\n\t\t\t\t\tconsole.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');\n\t\t\t\t}\n\n\t\t\t\tthis.setValues(parameters);\n\t\t\t}\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.fragmentShader = source.fragmentShader;\n\t\t\tthis.vertexShader = source.vertexShader;\n\t\t\tthis.uniforms = cloneUniforms(source.uniforms);\n\t\t\tthis.defines = Object.assign({}, source.defines);\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.lights = source.lights;\n\t\t\tthis.clipping = source.clipping;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\tthis.extensions = Object.assign({}, source.extensions);\n\t\t\tthis.glslVersion = source.glslVersion;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.glslVersion = this.glslVersion;\n\t\t\tdata.uniforms = {};\n\n\t\t\tfor (const name in this.uniforms) {\n\t\t\t\tconst uniform = this.uniforms[name];\n\t\t\t\tconst value = uniform.value;\n\n\t\t\t\tif (value && value.isTexture) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 't',\n\t\t\t\t\t\tvalue: value.toJSON(meta).uuid\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isColor) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'c',\n\t\t\t\t\t\tvalue: value.getHex()\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isVector2) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'v2',\n\t\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isVector3) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'v3',\n\t\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isVector4) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'v4',\n\t\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isMatrix3) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'm3',\n\t\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isMatrix4) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'm4',\n\t\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t}; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Object.keys(this.defines).length > 0) data.defines = this.defines;\n\t\t\tdata.vertexShader = this.vertexShader;\n\t\t\tdata.fragmentShader = this.fragmentShader;\n\t\t\tconst extensions = {};\n\n\t\t\tfor (const key in this.extensions) {\n\t\t\t\tif (this.extensions[key] === true) extensions[key] = true;\n\t\t\t}\n\n\t\t\tif (Object.keys(extensions).length > 0) data.extensions = extensions;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tShaderMaterial.prototype.isShaderMaterial = true;\n\n\tclass Camera extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'Camera';\n\t\t\tthis.matrixWorldInverse = new Matrix4();\n\t\t\tthis.projectionMatrix = new Matrix4();\n\t\t\tthis.projectionMatrixInverse = new Matrix4();\n\t\t}\n\n\t\tcopy(source, recursive) {\n\t\t\tsuper.copy(source, recursive);\n\t\t\tthis.matrixWorldInverse.copy(source.matrixWorldInverse);\n\t\t\tthis.projectionMatrix.copy(source.projectionMatrix);\n\t\t\tthis.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetWorldDirection(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Camera: .getWorldDirection() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tthis.updateWorldMatrix(true, false);\n\t\t\tconst e = this.matrixWorld.elements;\n\t\t\treturn target.set(-e[8], -e[9], -e[10]).normalize();\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t\tthis.matrixWorldInverse.copy(this.matrixWorld).invert();\n\t\t}\n\n\t\tupdateWorldMatrix(updateParents, updateChildren) {\n\t\t\tsuper.updateWorldMatrix(updateParents, updateChildren);\n\t\t\tthis.matrixWorldInverse.copy(this.matrixWorld).invert();\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tCamera.prototype.isCamera = true;\n\n\tclass PerspectiveCamera extends Camera {\n\t\tconstructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {\n\t\t\tsuper();\n\t\t\tthis.type = 'PerspectiveCamera';\n\t\t\tthis.fov = fov;\n\t\t\tthis.zoom = 1;\n\t\t\tthis.near = near;\n\t\t\tthis.far = far;\n\t\t\tthis.focus = 10;\n\t\t\tthis.aspect = aspect;\n\t\t\tthis.view = null;\n\t\t\tthis.filmGauge = 35; // width of the film (default in millimeters)\n\n\t\t\tthis.filmOffset = 0; // horizontal film offset (same unit as gauge)\n\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tcopy(source, recursive) {\n\t\t\tsuper.copy(source, recursive);\n\t\t\tthis.fov = source.fov;\n\t\t\tthis.zoom = source.zoom;\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\t\t\tthis.focus = source.focus;\n\t\t\tthis.aspect = source.aspect;\n\t\t\tthis.view = source.view === null ? null : Object.assign({}, source.view);\n\t\t\tthis.filmGauge = source.filmGauge;\n\t\t\tthis.filmOffset = source.filmOffset;\n\t\t\treturn this;\n\t\t}\n\t\t/**\n\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t\t *\n\t\t * The default film gauge is 35, so that the focal length can be specified for\n\t\t * a 35mm (full frame) camera.\n\t\t *\n\t\t * Values for focal length and film gauge must have the same unit.\n\t\t */\n\n\n\t\tsetFocalLength(focalLength) {\n\t\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n\t\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\t\t\tthis.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\t\t/**\n\t\t * Calculates the focal length from the current .fov and .filmGauge.\n\t\t */\n\n\n\t\tgetFocalLength() {\n\t\t\tconst vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);\n\t\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\t\t}\n\n\t\tgetEffectiveFOV() {\n\t\t\treturn RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);\n\t\t}\n\n\t\tgetFilmWidth() {\n\t\t\t// film not completely covered in portrait format (aspect < 1)\n\t\t\treturn this.filmGauge * Math.min(this.aspect, 1);\n\t\t}\n\n\t\tgetFilmHeight() {\n\t\t\t// film not completely covered in landscape format (aspect > 1)\n\t\t\treturn this.filmGauge / Math.max(this.aspect, 1);\n\t\t}\n\t\t/**\n\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t\t * multi-monitor/multi-machine setups.\n\t\t *\n\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t\t * the monitors are in grid like this\n\t\t *\n\t\t *\t +---+---+---+\n\t\t *\t | A | B | C |\n\t\t *\t +---+---+---+\n\t\t *\t | D | E | F |\n\t\t *\t +---+---+---+\n\t\t *\n\t\t * then for each monitor you would call it like this\n\t\t *\n\t\t *\t const w = 1920;\n\t\t *\t const h = 1080;\n\t\t *\t const fullWidth = w * 3;\n\t\t *\t const fullHeight = h * 2;\n\t\t *\n\t\t *\t --A--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t\t *\t --B--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t\t *\t --C--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t\t *\t --D--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t\t *\t --E--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t\t *\t --F--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t\t *\n\t\t *\t Note there is no reason monitors have to be the same size or in a grid.\n\t\t */\n\n\n\t\tsetViewOffset(fullWidth, fullHeight, x, y, width, height) {\n\t\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\t\tif (this.view === null) {\n\t\t\t\tthis.view = {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tfullWidth: 1,\n\t\t\t\t\tfullHeight: 1,\n\t\t\t\t\toffsetX: 0,\n\t\t\t\t\toffsetY: 0,\n\t\t\t\t\twidth: 1,\n\t\t\t\t\theight: 1\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis.view.enabled = true;\n\t\t\tthis.view.fullWidth = fullWidth;\n\t\t\tthis.view.fullHeight = fullHeight;\n\t\t\tthis.view.offsetX = x;\n\t\t\tthis.view.offsetY = y;\n\t\t\tthis.view.width = width;\n\t\t\tthis.view.height = height;\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tclearViewOffset() {\n\t\t\tif (this.view !== null) {\n\t\t\t\tthis.view.enabled = false;\n\t\t\t}\n\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tupdateProjectionMatrix() {\n\t\t\tconst near = this.near;\n\t\t\tlet top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;\n\t\t\tlet height = 2 * top;\n\t\t\tlet width = this.aspect * height;\n\t\t\tlet left = -0.5 * width;\n\t\t\tconst view = this.view;\n\n\t\t\tif (this.view !== null && this.view.enabled) {\n\t\t\t\tconst fullWidth = view.fullWidth,\n\t\t\t\t\t\t\tfullHeight = view.fullHeight;\n\t\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\t\twidth *= view.width / fullWidth;\n\t\t\t\theight *= view.height / fullHeight;\n\t\t\t}\n\n\t\t\tconst skew = this.filmOffset;\n\t\t\tif (skew !== 0) left += near * skew / this.getFilmWidth();\n\t\t\tthis.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);\n\t\t\tthis.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.object.fov = this.fov;\n\t\t\tdata.object.zoom = this.zoom;\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\t\t\tdata.object.focus = this.focus;\n\t\t\tdata.object.aspect = this.aspect;\n\t\t\tif (this.view !== null) data.object.view = Object.assign({}, this.view);\n\t\t\tdata.object.filmGauge = this.filmGauge;\n\t\t\tdata.object.filmOffset = this.filmOffset;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tPerspectiveCamera.prototype.isPerspectiveCamera = true;\n\n\tconst fov = 90,\n\t\t\t\taspect = 1;\n\n\tclass CubeCamera extends Object3D {\n\t\tconstructor(near, far, renderTarget) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CubeCamera';\n\n\t\t\tif (renderTarget.isWebGLCubeRenderTarget !== true) {\n\t\t\t\tconsole.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.renderTarget = renderTarget;\n\t\t\tconst cameraPX = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraPX.layers = this.layers;\n\t\t\tcameraPX.up.set(0, -1, 0);\n\t\t\tcameraPX.lookAt(new Vector3(1, 0, 0));\n\t\t\tthis.add(cameraPX);\n\t\t\tconst cameraNX = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraNX.layers = this.layers;\n\t\t\tcameraNX.up.set(0, -1, 0);\n\t\t\tcameraNX.lookAt(new Vector3(-1, 0, 0));\n\t\t\tthis.add(cameraNX);\n\t\t\tconst cameraPY = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraPY.layers = this.layers;\n\t\t\tcameraPY.up.set(0, 0, 1);\n\t\t\tcameraPY.lookAt(new Vector3(0, 1, 0));\n\t\t\tthis.add(cameraPY);\n\t\t\tconst cameraNY = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraNY.layers = this.layers;\n\t\t\tcameraNY.up.set(0, 0, -1);\n\t\t\tcameraNY.lookAt(new Vector3(0, -1, 0));\n\t\t\tthis.add(cameraNY);\n\t\t\tconst cameraPZ = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraPZ.layers = this.layers;\n\t\t\tcameraPZ.up.set(0, -1, 0);\n\t\t\tcameraPZ.lookAt(new Vector3(0, 0, 1));\n\t\t\tthis.add(cameraPZ);\n\t\t\tconst cameraNZ = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraNZ.layers = this.layers;\n\t\t\tcameraNZ.up.set(0, -1, 0);\n\t\t\tcameraNZ.lookAt(new Vector3(0, 0, -1));\n\t\t\tthis.add(cameraNZ);\n\t\t}\n\n\t\tupdate(renderer, scene) {\n\t\t\tif (this.parent === null) this.updateMatrixWorld();\n\t\t\tconst renderTarget = this.renderTarget;\n\t\t\tconst [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\t\trenderer.xr.enabled = false;\n\t\t\tconst generateMipmaps = renderTarget.texture.generateMipmaps;\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\t\t\trenderer.setRenderTarget(renderTarget, 0);\n\t\t\trenderer.render(scene, cameraPX);\n\t\t\trenderer.setRenderTarget(renderTarget, 1);\n\t\t\trenderer.render(scene, cameraNX);\n\t\t\trenderer.setRenderTarget(renderTarget, 2);\n\t\t\trenderer.render(scene, cameraPY);\n\t\t\trenderer.setRenderTarget(renderTarget, 3);\n\t\t\trenderer.render(scene, cameraNY);\n\t\t\trenderer.setRenderTarget(renderTarget, 4);\n\t\t\trenderer.render(scene, cameraPZ);\n\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\t\t\trenderer.setRenderTarget(renderTarget, 5);\n\t\t\trenderer.render(scene, cameraNZ);\n\t\t\trenderer.setRenderTarget(currentRenderTarget);\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t}\n\n\t}\n\n\tclass CubeTexture extends Texture {\n\t\tconstructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {\n\t\t\timages = images !== undefined ? images : [];\n\t\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\t\t\tformat = format !== undefined ? format : RGBFormat;\n\t\t\tsuper(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding); // Why CubeTexture._needsFlipEnvMap is necessary:\n\t\t\t//\n\t\t\t// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n\t\t\t// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n\t\t\t// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n\t\t\t// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n\t\t\t// and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)\n\t\t\t// when using WebGLCubeRenderTarget.texture as a cube texture.\n\n\t\t\tthis._needsFlipEnvMap = true;\n\t\t\tthis.flipY = false;\n\t\t}\n\n\t\tget images() {\n\t\t\treturn this.image;\n\t\t}\n\n\t\tset images(value) {\n\t\t\tthis.image = value;\n\t\t}\n\n\t}\n\n\tCubeTexture.prototype.isCubeTexture = true;\n\n\tclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n\t\tconstructor(size, options, dummy) {\n\t\t\tif (Number.isInteger(options)) {\n\t\t\t\tconsole.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');\n\t\t\t\toptions = dummy;\n\t\t\t}\n\n\t\t\tsuper(size, size, options);\n\t\t\toptions = options || {};\n\t\t\tthis.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);\n\t\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\t\t\tthis.texture._needsFlipEnvMap = false;\n\t\t}\n\n\t\tfromEquirectangularTexture(renderer, texture) {\n\t\t\tthis.texture.type = texture.type;\n\t\t\tthis.texture.format = RGBAFormat; // see #18859\n\n\t\t\tthis.texture.encoding = texture.encoding;\n\t\t\tthis.texture.generateMipmaps = texture.generateMipmaps;\n\t\t\tthis.texture.minFilter = texture.minFilter;\n\t\t\tthis.texture.magFilter = texture.magFilter;\n\t\t\tconst shader = {\n\t\t\t\tuniforms: {\n\t\t\t\t\ttEquirect: {\n\t\t\t\t\t\tvalue: null\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tvertexShader:\n\t\t\t\t/* glsl */\n\t\t\t\t`\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n\t\t\t\tfragmentShader:\n\t\t\t\t/* glsl */\n\t\t\t\t`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n\t\t\t};\n\t\t\tconst geometry = new BoxGeometry(5, 5, 5);\n\t\t\tconst material = new ShaderMaterial({\n\t\t\t\tname: 'CubemapFromEquirect',\n\t\t\t\tuniforms: cloneUniforms(shader.uniforms),\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\t\tside: BackSide,\n\t\t\t\tblending: NoBlending\n\t\t\t});\n\t\t\tmaterial.uniforms.tEquirect.value = texture;\n\t\t\tconst mesh = new Mesh(geometry, material);\n\t\t\tconst currentMinFilter = texture.minFilter; // Avoid blurred poles\n\n\t\t\tif (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;\n\t\t\tconst camera = new CubeCamera(1, 10, this);\n\t\t\tcamera.update(renderer, mesh);\n\t\t\ttexture.minFilter = currentMinFilter;\n\t\t\tmesh.geometry.dispose();\n\t\t\tmesh.material.dispose();\n\t\t\treturn this;\n\t\t}\n\n\t\tclear(renderer, color, depth, stencil) {\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\trenderer.setRenderTarget(this, i);\n\t\t\t\trenderer.clear(color, depth, stencil);\n\t\t\t}\n\n\t\t\trenderer.setRenderTarget(currentRenderTarget);\n\t\t}\n\n\t}\n\n\tWebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;\n\n\tconst _sphere$2 = /*@__PURE__*/new Sphere();\n\n\tconst _vector$7 = /*@__PURE__*/new Vector3();\n\n\tclass Frustum {\n\t\tconstructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {\n\t\t\tthis.planes = [p0, p1, p2, p3, p4, p5];\n\t\t}\n\n\t\tset(p0, p1, p2, p3, p4, p5) {\n\t\t\tconst planes = this.planes;\n\t\t\tplanes[0].copy(p0);\n\t\t\tplanes[1].copy(p1);\n\t\t\tplanes[2].copy(p2);\n\t\t\tplanes[3].copy(p3);\n\t\t\tplanes[4].copy(p4);\n\t\t\tplanes[5].copy(p5);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(frustum) {\n\t\t\tconst planes = this.planes;\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tplanes[i].copy(frustum.planes[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromProjectionMatrix(m) {\n\t\t\tconst planes = this.planes;\n\t\t\tconst me = m.elements;\n\t\t\tconst me0 = me[0],\n\t\t\t\t\t\tme1 = me[1],\n\t\t\t\t\t\tme2 = me[2],\n\t\t\t\t\t\tme3 = me[3];\n\t\t\tconst me4 = me[4],\n\t\t\t\t\t\tme5 = me[5],\n\t\t\t\t\t\tme6 = me[6],\n\t\t\t\t\t\tme7 = me[7];\n\t\t\tconst me8 = me[8],\n\t\t\t\t\t\tme9 = me[9],\n\t\t\t\t\t\tme10 = me[10],\n\t\t\t\t\t\tme11 = me[11];\n\t\t\tconst me12 = me[12],\n\t\t\t\t\t\tme13 = me[13],\n\t\t\t\t\t\tme14 = me[14],\n\t\t\t\t\t\tme15 = me[15];\n\t\t\tplanes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\n\t\t\tplanes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\n\t\t\tplanes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\n\t\t\tplanes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\n\t\t\tplanes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\n\t\t\tplanes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\n\t\t\treturn this;\n\t\t}\n\n\t\tintersectsObject(object) {\n\t\t\tconst geometry = object.geometry;\n\t\t\tif (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n\t\t\t_sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);\n\n\t\t\treturn this.intersectsSphere(_sphere$2);\n\t\t}\n\n\t\tintersectsSprite(sprite) {\n\t\t\t_sphere$2.center.set(0, 0, 0);\n\n\t\t\t_sphere$2.radius = 0.7071067811865476;\n\n\t\t\t_sphere$2.applyMatrix4(sprite.matrixWorld);\n\n\t\t\treturn this.intersectsSphere(_sphere$2);\n\t\t}\n\n\t\tintersectsSphere(sphere) {\n\t\t\tconst planes = this.planes;\n\t\t\tconst center = sphere.center;\n\t\t\tconst negRadius = -sphere.radius;\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tconst distance = planes[i].distanceToPoint(center);\n\n\t\t\t\tif (distance < negRadius) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\tconst planes = this.planes;\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tconst plane = planes[i]; // corner at max distance\n\n\t\t\t\t_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\t_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\t_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\tif (plane.distanceToPoint(_vector$7) < 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tcontainsPoint(point) {\n\t\t\tconst planes = this.planes;\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tif (planes[i].distanceToPoint(point) < 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tfunction WebGLAnimation() {\n\t\tlet context = null;\n\t\tlet isAnimating = false;\n\t\tlet animationLoop = null;\n\t\tlet requestId = null;\n\n\t\tfunction onAnimationFrame(time, frame) {\n\t\t\tanimationLoop(time, frame);\n\t\t\trequestId = context.requestAnimationFrame(onAnimationFrame);\n\t\t}\n\n\t\treturn {\n\t\t\tstart: function () {\n\t\t\t\tif (isAnimating === true) return;\n\t\t\t\tif (animationLoop === null) return;\n\t\t\t\trequestId = context.requestAnimationFrame(onAnimationFrame);\n\t\t\t\tisAnimating = true;\n\t\t\t},\n\t\t\tstop: function () {\n\t\t\t\tcontext.cancelAnimationFrame(requestId);\n\t\t\t\tisAnimating = false;\n\t\t\t},\n\t\t\tsetAnimationLoop: function (callback) {\n\t\t\t\tanimationLoop = callback;\n\t\t\t},\n\t\t\tsetContext: function (value) {\n\t\t\t\tcontext = value;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction WebGLAttributes(gl, capabilities) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\t\tconst buffers = new WeakMap();\n\n\t\tfunction createBuffer(attribute, bufferType) {\n\t\t\tconst array = attribute.array;\n\t\t\tconst usage = attribute.usage;\n\t\t\tconst buffer = gl.createBuffer();\n\t\t\tgl.bindBuffer(bufferType, buffer);\n\t\t\tgl.bufferData(bufferType, array, usage);\n\t\t\tattribute.onUploadCallback();\n\t\t\tlet type = gl.FLOAT;\n\n\t\t\tif (array instanceof Float32Array) {\n\t\t\t\ttype = gl.FLOAT;\n\t\t\t} else if (array instanceof Float64Array) {\n\t\t\t\tconsole.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');\n\t\t\t} else if (array instanceof Uint16Array) {\n\t\t\t\tif (attribute.isFloat16BufferAttribute) {\n\t\t\t\t\tif (isWebGL2) {\n\t\t\t\t\t\ttype = gl.HALF_FLOAT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\t\t\t\t}\n\t\t\t} else if (array instanceof Int16Array) {\n\t\t\t\ttype = gl.SHORT;\n\t\t\t} else if (array instanceof Uint32Array) {\n\t\t\t\ttype = gl.UNSIGNED_INT;\n\t\t\t} else if (array instanceof Int32Array) {\n\t\t\t\ttype = gl.INT;\n\t\t\t} else if (array instanceof Int8Array) {\n\t\t\t\ttype = gl.BYTE;\n\t\t\t} else if (array instanceof Uint8Array) {\n\t\t\t\ttype = gl.UNSIGNED_BYTE;\n\t\t\t} else if (array instanceof Uint8ClampedArray) {\n\t\t\t\ttype = gl.UNSIGNED_BYTE;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tbuffer: buffer,\n\t\t\t\ttype: type,\n\t\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\t\tversion: attribute.version\n\t\t\t};\n\t\t}\n\n\t\tfunction updateBuffer(buffer, attribute, bufferType) {\n\t\t\tconst array = attribute.array;\n\t\t\tconst updateRange = attribute.updateRange;\n\t\t\tgl.bindBuffer(bufferType, buffer);\n\n\t\t\tif (updateRange.count === -1) {\n\t\t\t\t// Not using update ranges\n\t\t\t\tgl.bufferSubData(bufferType, 0, array);\n\t\t\t} else {\n\t\t\t\tif (isWebGL2) {\n\t\t\t\t\tgl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);\n\t\t\t\t} else {\n\t\t\t\t\tgl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));\n\t\t\t\t}\n\n\t\t\t\tupdateRange.count = -1; // reset range\n\t\t\t}\n\t\t} //\n\n\n\t\tfunction get(attribute) {\n\t\t\tif (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n\t\t\treturn buffers.get(attribute);\n\t\t}\n\n\t\tfunction remove(attribute) {\n\t\t\tif (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n\t\t\tconst data = buffers.get(attribute);\n\n\t\t\tif (data) {\n\t\t\t\tgl.deleteBuffer(data.buffer);\n\t\t\t\tbuffers.delete(attribute);\n\t\t\t}\n\t\t}\n\n\t\tfunction update(attribute, bufferType) {\n\t\t\tif (attribute.isGLBufferAttribute) {\n\t\t\t\tconst cached = buffers.get(attribute);\n\n\t\t\t\tif (!cached || cached.version < attribute.version) {\n\t\t\t\t\tbuffers.set(attribute, {\n\t\t\t\t\t\tbuffer: attribute.buffer,\n\t\t\t\t\t\ttype: attribute.type,\n\t\t\t\t\t\tbytesPerElement: attribute.elementSize,\n\t\t\t\t\t\tversion: attribute.version\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n\t\t\tconst data = buffers.get(attribute);\n\n\t\t\tif (data === undefined) {\n\t\t\t\tbuffers.set(attribute, createBuffer(attribute, bufferType));\n\t\t\t} else if (data.version < attribute.version) {\n\t\t\t\tupdateBuffer(data.buffer, attribute, bufferType);\n\t\t\t\tdata.version = attribute.version;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tremove: remove,\n\t\t\tupdate: update\n\t\t};\n\t}\n\n\tclass PlaneGeometry extends BufferGeometry {\n\t\tconstructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {\n\t\t\tsuper();\n\t\t\tthis.type = 'PlaneGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments\n\t\t\t};\n\t\t\tconst width_half = width / 2;\n\t\t\tconst height_half = height / 2;\n\t\t\tconst gridX = Math.floor(widthSegments);\n\t\t\tconst gridY = Math.floor(heightSegments);\n\t\t\tconst gridX1 = gridX + 1;\n\t\t\tconst gridY1 = gridY + 1;\n\t\t\tconst segment_width = width / gridX;\n\t\t\tconst segment_height = height / gridY; //\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = [];\n\n\t\t\tfor (let iy = 0; iy < gridY1; iy++) {\n\t\t\t\tconst y = iy * segment_height - height_half;\n\n\t\t\t\tfor (let ix = 0; ix < gridX1; ix++) {\n\t\t\t\t\tconst x = ix * segment_width - width_half;\n\t\t\t\t\tvertices.push(x, -y, 0);\n\t\t\t\t\tnormals.push(0, 0, 1);\n\t\t\t\t\tuvs.push(ix / gridX);\n\t\t\t\t\tuvs.push(1 - iy / gridY);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let iy = 0; iy < gridY; iy++) {\n\t\t\t\tfor (let ix = 0; ix < gridX; ix++) {\n\t\t\t\t\tconst a = ix + gridX1 * iy;\n\t\t\t\t\tconst b = ix + gridX1 * (iy + 1);\n\t\t\t\t\tconst c = ix + 1 + gridX1 * (iy + 1);\n\t\t\t\t\tconst d = ix + 1 + gridX1 * iy;\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\";\n\n\tvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\n\tvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\";\n\n\tvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\";\n\n\tvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\n\tvar begin_vertex = \"vec3 transformed = vec3( position );\";\n\n\tvar beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif\";\n\n\tvar bsdfs = \"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\tif( cutoffDistance > 0.0 ) {\\n\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t}\\n\\treturn distanceFalloff;\\n#else\\n\\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t}\\n\\treturn 1.0;\\n#endif\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\\n\\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\\n\\treturn Fr * fresnel + F0;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\treturn specularColor * brdf.x + brdf.y;\\n}\\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\tvec3 FssEss = F * brdf.x + brdf.y;\\n\\tfloat Ess = brdf.x + brdf.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n#if defined( USE_SHEEN )\\nfloat D_Charlie(float roughness, float NoH) {\\n\\tfloat invAlpha = 1.0 / roughness;\\n\\tfloat cos2h = NoH * NoH;\\n\\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\\n}\\nfloat V_Neubelt(float NoV, float NoL) {\\n\\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\\n}\\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\\n\\tvec3 N = geometry.normal;\\n\\tvec3 V = geometry.viewDir;\\n\\tvec3 H = normalize( V + L );\\n\\tfloat dotNH = saturate( dot( N, H ) );\\n\\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\\n}\\n#endif\";\n\n\tvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\";\n\n\tvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\";\n\n\tvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\";\n\n\tvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n#endif\";\n\n\tvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvClipPosition = - mvPosition.xyz;\\n#endif\";\n\n\tvar color_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tdiffuseColor *= vColor;\\n#elif defined( USE_COLOR )\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\n\tvar color_pars_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\n\tvar color_pars_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\n\tvar color_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvColor = vec4( 1.0 );\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvColor = vec3( 1.0 );\\n#endif\\n#ifdef USE_COLOR\\n\\tvColor *= color;\\n#endif\\n#ifdef USE_INSTANCING_COLOR\\n\\tvColor.xyz *= instanceColor.xyz;\\n#endif\";\n\n\tvar common = \"#define PI 3.141592653589793\\n#define PI2 6.283185307179586\\n#define PI_HALF 1.5707963267948966\\n#define RECIPROCAL_PI 0.3183098861837907\\n#define RECIPROCAL_PI2 0.15915494309189535\\n#define EPSILON 1e-6\\n#ifndef saturate\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\n#ifdef HIGH_PRECISION\\n\\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\\n#else\\n\\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\\n\\tfloat precisionSafeLength( vec3 v ) {\\n\\t\\tfloat maxComponent = max3( abs( v ) );\\n\\t\\treturn length( v / maxComponent ) * maxComponent;\\n\\t}\\n#endif\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n#ifdef CLEARCOAT\\n\\tvec3 clearcoatNormal;\\n#endif\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\\nbool isPerspectiveMatrix( mat4 m ) {\\n\\treturn m[ 2 ][ 3 ] == - 1.0;\\n}\\nvec2 equirectUv( in vec3 dir ) {\\n\\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\treturn vec2( u, v );\\n}\";\n\n\tvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t#define cubeUV_maxMipLevel 8.0\\n\\t#define cubeUV_minMipLevel 4.0\\n\\t#define cubeUV_maxTileSize 256.0\\n\\t#define cubeUV_minTileSize 16.0\\n\\tfloat getFace( vec3 direction ) {\\n\\t\\tvec3 absDirection = abs( direction );\\n\\t\\tfloat face = - 1.0;\\n\\t\\tif ( absDirection.x > absDirection.z ) {\\n\\t\\t\\tif ( absDirection.x > absDirection.y )\\n\\t\\t\\t\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t} else {\\n\\t\\t\\tif ( absDirection.z > absDirection.y )\\n\\t\\t\\t\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t}\\n\\t\\treturn face;\\n\\t}\\n\\tvec2 getUV( vec3 direction, float face ) {\\n\\t\\tvec2 uv;\\n\\t\\tif ( face == 0.0 ) {\\n\\t\\t\\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 1.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\\n\\t\\t} else if ( face == 2.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\\n\\t\\t} else if ( face == 3.0 ) {\\n\\t\\t\\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 4.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\\n\\t\\t} else {\\n\\t\\t\\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\\n\\t\\t}\\n\\t\\treturn 0.5 * ( uv + 1.0 );\\n\\t}\\n\\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\\n\\t\\tfloat face = getFace( direction );\\n\\t\\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\\n\\t\\tmipInt = max( mipInt, cubeUV_minMipLevel );\\n\\t\\tfloat faceSize = exp2( mipInt );\\n\\t\\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\\n\\t\\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\\n\\t\\tvec2 f = fract( uv );\\n\\t\\tuv += 0.5 - f;\\n\\t\\tif ( face > 2.0 ) {\\n\\t\\t\\tuv.y += faceSize;\\n\\t\\t\\tface -= 3.0;\\n\\t\\t}\\n\\t\\tuv.x += face * faceSize;\\n\\t\\tif ( mipInt < cubeUV_maxMipLevel ) {\\n\\t\\t\\tuv.y += 2.0 * cubeUV_maxTileSize;\\n\\t\\t}\\n\\t\\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\\n\\t\\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\\n\\t\\tuv *= texelSize;\\n\\t\\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.x += texelSize;\\n\\t\\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.y += texelSize;\\n\\t\\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.x -= texelSize;\\n\\t\\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tvec3 tm = mix( tl, tr, f.x );\\n\\t\\tvec3 bm = mix( bl, br, f.x );\\n\\t\\treturn mix( tm, bm, f.y );\\n\\t}\\n\\t#define r0 1.0\\n\\t#define v0 0.339\\n\\t#define m0 - 2.0\\n\\t#define r1 0.8\\n\\t#define v1 0.276\\n\\t#define m1 - 1.0\\n\\t#define r4 0.4\\n\\t#define v4 0.046\\n\\t#define m4 2.0\\n\\t#define r5 0.305\\n\\t#define v5 0.016\\n\\t#define m5 3.0\\n\\t#define r6 0.21\\n\\t#define v6 0.0038\\n\\t#define m6 4.0\\n\\tfloat roughnessToMip( float roughness ) {\\n\\t\\tfloat mip = 0.0;\\n\\t\\tif ( roughness >= r1 ) {\\n\\t\\t\\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\\n\\t\\t} else if ( roughness >= r4 ) {\\n\\t\\t\\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\\n\\t\\t} else if ( roughness >= r5 ) {\\n\\t\\t\\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\\n\\t\\t} else if ( roughness >= r6 ) {\\n\\t\\t\\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\\n\\t\\t} else {\\n\\t\\t\\tmip = - 2.0 * log2( 1.16 * roughness );\\t\\t}\\n\\t\\treturn mip;\\n\\t}\\n\\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\\n\\t\\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\\n\\t\\tfloat mipF = fract( mip );\\n\\t\\tfloat mipInt = floor( mip );\\n\\t\\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\\n\\t\\tif ( mipF == 0.0 ) {\\n\\t\\t\\treturn vec4( color0, 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\\n\\t\\t\\treturn vec4( mix( color0, color1, mipF ), 1.0 );\\n\\t\\t}\\n\\t}\\n#endif\";\n\n\tvar defaultnormal_vertex = \"vec3 transformedNormal = objectNormal;\\n#ifdef USE_INSTANCING\\n\\tmat3 m = mat3( instanceMatrix );\\n\\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\\n\\ttransformedNormal = m * transformedNormal;\\n#endif\\ntransformedNormal = normalMatrix * transformedNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#ifdef FLIP_SIDED\\n\\t\\ttransformedTangent = - transformedTangent;\\n\\t#endif\\n#endif\";\n\n\tvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\";\n\n\tvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\\n#endif\";\n\n\tvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\";\n\n\tvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\";\n\n\tvar encodings_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\";\n\n\tvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value ) {\\n\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\n\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract( Le );\\n\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}\";\n\n\tvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvec3 cameraToFrag;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\t#ifndef ENVMAP_TYPE_CUBE_UV\\n\\t\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#endif\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\";\n\n\tvar envmap_common_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float envMapIntensity;\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\t\\n#endif\";\n\n\tvar envmap_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float reflectivity;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\";\n\n\tvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\t\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\";\n\n\tvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\n\tvar fog_vertex = \"#ifdef USE_FOG\\n\\tfogDepth = - mvPosition.z;\\n#endif\";\n\n\tvar fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float fogDepth;\\n#endif\";\n\n\tvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\";\n\n\tvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\n\tvar gradientmap_pars_fragment = \"#ifdef USE_GRADIENTMAP\\n\\tuniform sampler2D gradientMap;\\n#endif\\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\tfloat dotNL = dot( normal, lightDirection );\\n\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t#ifdef USE_GRADIENTMAP\\n\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t#else\\n\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t#endif\\n}\";\n\n\tvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n#endif\";\n\n\tvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\n\tvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\nvIndirectFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n\\tvIndirectBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\\n#ifdef DOUBLE_SIDED\\n\\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\\n\\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\";\n\n\tvar lights_pars_begin = \"uniform bool receiveShadow;\\nuniform vec3 ambientLightColor;\\nuniform vec3 lightProbe[ 9 ];\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\\n\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\";\n\n\tvar envmap_physical_pars_fragment = \"#if defined( USE_ENVMAP )\\n\\t#ifdef ENVMAP_MODE_REFRACTION\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -viewDir, normal );\\n\\t\\t\\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\";\n\n\tvar lights_toon_fragment = \"ToonMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\";\n\n\tvar lights_toon_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct ToonMaterial {\\n\\tvec3 diffuseColor;\\n};\\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Toon\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Toon\\n#define Material_LightProbeLOD( material )\\t(0)\";\n\n\tvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\";\n\n\tvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3 diffuseColor;\\n\\tvec3 specularColor;\\n\\tfloat specularShininess;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\";\n\n\tvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\\n#ifdef REFLECTIVITY\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), rawDiffuseColor, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), rawDiffuseColor, metalnessFactor );\\n#endif\\n#ifdef CLEARCOAT\\n\\tmaterial.clearcoat = clearcoat;\\n\\tmaterial.clearcoatRoughness = clearcoatRoughness;\\n\\t#ifdef USE_CLEARCOATMAP\\n\\t\\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\t\\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\\n\\t#endif\\n\\tmaterial.clearcoat = saturate( material.clearcoat );\\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\\n\\tmaterial.clearcoatRoughness += geometryRoughness;\\n\\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\\n#endif\\n#ifdef USE_SHEEN\\n\\tmaterial.sheenColor = sheen;\\n#endif\";\n\n\tvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat specularRoughness;\\n\\tvec3 specularColor;\\n#ifdef CLEARCOAT\\n\\tfloat clearcoat;\\n\\tfloat clearcoatRoughness;\\n#endif\\n#ifdef USE_SHEEN\\n\\tvec3 sheenColor;\\n#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(\t\t0, 1,\t\t0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifdef CLEARCOAT\\n\\t\\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\\n\\t\\tvec3 ccIrradiance = ccDotNL * directLight.color;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tccIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\\n\\t\\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\\n\\t#else\\n\\t\\tfloat clearcoatDHR = 0.0;\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\\n\\t\\t\\tmaterial.specularRoughness,\\n\\t\\t\\tdirectLight.direction,\\n\\t\\t\\tgeometry,\\n\\t\\t\\tmaterial.sheenColor\\n\\t\\t);\\n\\t#else\\n\\t\\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\\n\\t#endif\\n\\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifdef CLEARCOAT\\n\\t\\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\\n\\t\\tfloat ccDotNL = ccDotNV;\\n\\t\\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\\n\\t#else\\n\\t\\tfloat clearcoatDHR = 0.0;\\n\\t#endif\\n\\tfloat clearcoatInv = 1.0 - clearcoatDHR;\\n\\tvec3 singleScattering = vec3( 0.0 );\\n\\tvec3 multiScattering = vec3( 0.0 );\\n\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\\n\\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\\n\\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\\n\\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\\n\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\";\n\n\tvar lights_fragment_begin = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n#ifdef CLEARCOAT\\n\\tgeometry.clearcoatNormal = clearcoatNormal;\\n#endif\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow = pointLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow = spotLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 iblIrradiance = vec3( 0.0 );\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearcoatRadiance = vec3( 0.0 );\\n#endif\";\n\n\tvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\t\\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\\n\\t#ifdef CLEARCOAT\\n\\t\\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\\n\\t#endif\\n#endif\";\n\n\tvar lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\\n#endif\";\n\n\tvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\n\n\tvar logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n\\tvarying float vIsPerspective;\\n#endif\";\n\n\tvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t\\tvarying float vIsPerspective;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif\";\n\n\tvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t\\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\\n\\t#else\\n\\t\\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\\n\\t\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\t\\tgl_Position.z *= gl_Position.w;\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\n\tvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\";\n\n\tvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\";\n\n\tvar map_particle_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n#endif\\n#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\\n#endif\";\n\n\tvar map_particle_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tuniform mat3 uvTransform;\\n#endif\\n#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\n\tvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\";\n\n\tvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\n\tvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal *= morphTargetBaseInfluence;\\n\\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\\n#endif\";\n\n\tvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\tuniform float morphTargetBaseInfluence;\\n\\t#ifndef USE_MORPHNORMALS\\n\\t\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\t\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\n\tvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed *= morphTargetBaseInfluence;\\n\\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\\n\\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\\n\\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\\n\\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\t\\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\\n\\t\\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\\n\\t\\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\\n\\t\\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\";\n\n\tvar normal_fragment_begin = \"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\\n#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\t#ifdef USE_TANGENT\\n\\t\\tvec3 tangent = normalize( vTangent );\\n\\t\\tvec3 bitangent = normalize( vBitangent );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\ttangent = tangent * faceDirection;\\n\\t\\t\\tbitangent = bitangent * faceDirection;\\n\\t\\t#endif\\n\\t\\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\\n\\t\\t\\tmat3 vTBN = mat3( tangent, bitangent, normal );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\nvec3 geometryNormal = normal;\";\n\n\tvar normal_fragment_maps = \"#ifdef OBJECTSPACE_NORMALMAP\\n\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t#ifdef FLIP_SIDED\\n\\t\\tnormal = - normal;\\n\\t#endif\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\tnormal = normalize( normalMatrix * normal );\\n#elif defined( TANGENTSPACE_NORMALMAP )\\n\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tmapN.xy *= normalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tnormal = normalize( vTBN * mapN );\\n\\t#else\\n\\t\\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\\n#endif\";\n\n\tvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\n\\tuniform mat3 normalMatrix;\\n#endif\\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\\n\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 N = surf_norm;\\n\\t\\tvec3 q1perp = cross( q1, N );\\n\\t\\tvec3 q0perp = cross( N, q0 );\\n\\t\\tvec3 T = q1perp * st0.x + q0perp * st1.x;\\n\\t\\tvec3 B = q1perp * st0.y + q0perp * st1.y;\\n\\t\\tfloat det = max( dot( T, T ), dot( B, B ) );\\n\\t\\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\\n\\t\\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\\n\\t}\\n#endif\";\n\n\tvar clearcoat_normal_fragment_begin = \"#ifdef CLEARCOAT\\n\\tvec3 clearcoatNormal = geometryNormal;\\n#endif\";\n\n\tvar clearcoat_normal_fragment_maps = \"#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tclearcoatMapN.xy *= clearcoatNormalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\\n\\t#else\\n\\t\\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\\n\\t#endif\\n#endif\";\n\n\tvar clearcoat_pars_fragment = \"#ifdef USE_CLEARCOATMAP\\n\\tuniform sampler2D clearcoatMap;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform sampler2D clearcoatRoughnessMap;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform sampler2D clearcoatNormalMap;\\n\\tuniform vec2 clearcoatNormalScale;\\n#endif\";\n\n\tvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nvec4 pack2HalfToRGBA( vec2 v ) {\\n\\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\\n\\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\\n}\\nvec2 unpackRGBATo2Half( vec4 v ) {\\n\\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\";\n\n\tvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\";\n\n\tvar project_vertex = \"vec4 mvPosition = vec4( transformed, 1.0 );\\n#ifdef USE_INSTANCING\\n\\tmvPosition = instanceMatrix * mvPosition;\\n#endif\\nmvPosition = modelViewMatrix * mvPosition;\\ngl_Position = projectionMatrix * mvPosition;\";\n\n\tvar dithering_fragment = \"#ifdef DITHERING\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\";\n\n\tvar dithering_pars_fragment = \"#ifdef DITHERING\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\";\n\n\tvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\";\n\n\tvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\n\tvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\\n\\t\\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\\n\\t}\\n\\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\\n\\t\\tfloat occlusion = 1.0;\\n\\t\\tvec2 distribution = texture2DDistribution( shadow, uv );\\n\\t\\tfloat hard_shadow = step( compare , distribution.x );\\n\\t\\tif (hard_shadow != 1.0 ) {\\n\\t\\t\\tfloat distance = compare - distribution.x ;\\n\\t\\t\\tfloat variance = max( 0.00000, distribution.y * distribution.y );\\n\\t\\t\\tfloat softness_probability = variance / (variance + distance * distance );\\t\\t\\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\\t\\t\\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\\n\\t\\t}\\n\\t\\treturn occlusion;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx2 = dx0 / 2.0;\\n\\t\\t\\tfloat dy2 = dy0 / 2.0;\\n\\t\\t\\tfloat dx3 = dx1 / 2.0;\\n\\t\\t\\tfloat dy3 = dy1 / 2.0;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 17.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx = texelSize.x;\\n\\t\\t\\tfloat dy = texelSize.y;\\n\\t\\t\\tvec2 uv = shadowCoord.xy;\\n\\t\\t\\tvec2 f = fract( uv * shadowMapSize + 0.5 );\\n\\t\\t\\tuv -= f * texelSize;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t\tf.x ),\\n\\t\\t\\t\\t\\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t\tf.x ),\\n\\t\\t\\t\\t\\t f.y )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\";\n\n\tvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n#endif\";\n\n\tvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\tvec4 shadowWorldPosition;\\n\\t#endif\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\";\n\n\tvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tspotLight = spotLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tpointLight = pointLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\";\n\n\tvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\n\tvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform highp sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\n\tvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\";\n\n\tvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif\";\n\n\tvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\n\tvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\n\tvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\";\n\n\tvar tonemapping_pars_fragment = \"#ifndef saturate\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 RRTAndODTFit( vec3 v ) {\\n\\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\\n\\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\\n\\treturn a / b;\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tconst mat3 ACESInputMat = mat3(\\n\\t\\tvec3( 0.59719, 0.07600, 0.02840 ),\\t\\tvec3( 0.35458, 0.90834, 0.13383 ),\\n\\t\\tvec3( 0.04823, 0.01566, 0.83777 )\\n\\t);\\n\\tconst mat3 ACESOutputMat = mat3(\\n\\t\\tvec3(\t1.60475, -0.10208, -0.00327 ),\\t\\tvec3( -0.53108,\t1.10813, -0.07276 ),\\n\\t\\tvec3( -0.07367, -0.00605,\t1.07602 )\\n\\t);\\n\\tcolor *= toneMappingExposure / 0.6;\\n\\tcolor = ACESInputMat * color;\\n\\tcolor = RRTAndODTFit( color );\\n\\tcolor = ACESOutputMat * color;\\n\\treturn saturate( color );\\n}\\nvec3 CustomToneMapping( vec3 color ) { return color; }\";\n\n\tvar transmission_fragment = \"#ifdef USE_TRANSMISSION\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSNMAP\\n\\t\\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\\n\\t#endif\\n\\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\\n\\tvec3 v = normalize( cameraPosition - pos );\\n\\tvec3 viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n\\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\\n\\tvec3 f0 = vec3( pow( ior - 1.0, 2.0 ) / pow( ior + 1.0, 2.0 ) );\\n\\tvec3 f90 = vec3( 1.0 );\\n\\tvec3 f_transmission = totalTransmission * getIBLVolumeRefraction(\\n\\t\\tnormal, v, viewDir, roughnessFactor, diffuseColor.rgb, f0, f90,\\n\\t\\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\\n\\t\\tattenuationColor, attenuationDistance);\\n\\tdiffuseColor.rgb = mix( diffuseColor.rgb, f_transmission, totalTransmission );\\n#endif\";\n\n\tvar transmission_pars_fragment = \"#ifdef USE_TRANSMISSION\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\tuniform sampler2D transmissionMap;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tuniform sampler2D thicknessMap;\\n\\t#endif\\n\\tuniform vec2 transmissionSamplerSize;\\n\\tuniform sampler2D transmissionSamplerMap;\\n\\tuniform mat4 modelMatrix;\\n\\tuniform mat4 projectionMatrix;\\n\\tvarying vec4 vWorldPosition;\\n\\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\\n\\t\\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\\n\\t\\tvec3 modelScale;\\n\\t\\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\\n\\t\\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\\n\\t\\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\\n\\t\\treturn normalize(refractionVector) * thickness * modelScale;\\n\\t}\\n\\tfloat applyIorToRoughness(float roughness, float ior) {\\n\\t\\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\\n\\t}\\n\\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\\n\\t\\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\\n\\t\\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\\n\\t}\\n\\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\\n\\t\\tif (attenuationDistance == 0.0) {\\n\\t\\t\\treturn radiance;\\n\\t\\t} else {\\n\\t\\t\\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\\n\\t\\t\\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\\t\\t\\treturn transmittance * radiance;\\n\\t\\t}\\n\\t}\\n\\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, vec3 viewDir, float perceptualRoughness, vec3 baseColor, vec3 f0, vec3 f90,\\n\\t\\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec3 attenuationColor, float attenuationDistance) {\\n\\t\\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\\n\\t\\tvec3 refractedRayExit = position + transmissionRay;\\n\\t\\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\\n\\t\\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\\t\\trefractionCoords += 1.0;\\n\\t\\trefractionCoords /= 2.0;\\n\\t\\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\\n\\t\\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\\n\\t\\tfloat NdotV = saturate(dot(n, viewDir));\\n\\t\\tvec2 brdf = integrateSpecularBRDF(NdotV, perceptualRoughness);\\n\\t\\tvec3 specularColor = f0 * brdf.x + f90 * brdf.y;\\n\\t\\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\\n\\t}\\n#endif\";\n\n\tvar uv_pars_fragment = \"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\\n\\tvarying vec2 vUv;\\n#endif\";\n\n\tvar uv_pars_vertex = \"#ifdef USE_UV\\n\\t#ifdef UVS_VERTEX_ONLY\\n\\t\\tvec2 vUv;\\n\\t#else\\n\\t\\tvarying vec2 vUv;\\n\\t#endif\\n\\tuniform mat3 uvTransform;\\n#endif\";\n\n\tvar uv_vertex = \"#ifdef USE_UV\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\";\n\n\tvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n\tvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n\\tuniform mat3 uv2Transform;\\n#endif\";\n\n\tvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\\n#endif\";\n\n\tvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\\n\\tvec4 worldPosition = vec4( transformed, 1.0 );\\n\\t#ifdef USE_INSTANCING\\n\\t\\tworldPosition = instanceMatrix * worldPosition;\\n\\t#endif\\n\\tworldPosition = modelMatrix * worldPosition;\\n#endif\";\n\n\tvar background_frag = \"uniform sampler2D t2D;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\n\tvar background_vert = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\";\n\n\tvar cube_frag = \"#include <envmap_common_pars_fragment>\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\n#include <cube_uv_reflection_fragment>\\nvoid main() {\\n\\tvec3 vReflect = vWorldDirection;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = envColor;\\n\\tgl_FragColor.a *= opacity;\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\n\tvar cube_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\n\n\tvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( fragCoordZ );\\n\\t#endif\\n}\";\n\n\tvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvHighPrecisionZW = gl_Position.zw;\\n}\";\n\n\tvar distanceRGBA_frag = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\";\n\n\tvar distanceRGBA_vert = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\";\n\n\tvar equirect_frag = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV = equirectUv( direction );\\n\\tvec4 texColor = texture2D( tEquirect, sampleUV );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\n\tvar equirect_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\";\n\n\tvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\n\tvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvLineDistance = scale * lineDistance;\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\n\\t\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\t\\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vIndirectFront;\\n\\t#endif\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar meshmatcap_frag = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t\\tmatcapColor = matcapTexelToLinear( matcapColor );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshmatcap_vert = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#ifndef FLAT_SHADED\\n\\t\\tvNormal = normalize( transformedNormal );\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n}\";\n\n\tvar meshtoon_frag = \"#define TOON\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_toon_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_toon_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshtoon_vert = \"#define TOON\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar meshphysical_frag = \"#define STANDARD\\n#ifdef PHYSICAL\\n\\t#define REFLECTIVITY\\n\\t#define CLEARCOAT\\n#endif\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifdef USE_TRANSMISSION\\n\\tuniform float transmission;\\n\\tuniform float thickness;\\n\\tuniform vec3 attenuationColor;\\n\\tuniform float attenuationDistance;\\n#endif\\n#ifdef REFLECTIVITY\\n\\tuniform float reflectivity;\\n#endif\\n#ifdef CLEARCOAT\\n\\tuniform float clearcoat;\\n\\tuniform float clearcoatRoughness;\\n#endif\\n#ifdef USE_SHEEN\\n\\tuniform vec3 sheen;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <bsdfs>\\n#include <transmission_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <clearcoat_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#ifdef USE_TRANSMISSION\\n\\t\\tfloat totalTransmission = transmission;\\n\\t\\tfloat thicknessFactor = thickness;\\n\\t#endif\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <clearcoat_normal_fragment_begin>\\n\\t#include <clearcoat_normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\tvec3 rawDiffuseColor = diffuseColor.rgb;\\n\\t#include <transmission_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshphysical_vert = \"#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#ifdef USE_TRANSMISSION\\n\\tvarying vec4 vWorldPosition;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n#ifdef USE_TRANSMISSION\\n\\tvWorldPosition = worldPosition;\\n#endif\\n}\";\n\n\tvar normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\";\n\n\tvar normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\";\n\n\tvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\n\tvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar shadow_frag = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\n\tvar shadow_vert = \"#include <common>\\n#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar sprite_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\n\tvar sprite_vert = \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tconst ShaderChunk = {\n\t\talphamap_fragment: alphamap_fragment,\n\t\talphamap_pars_fragment: alphamap_pars_fragment,\n\t\talphatest_fragment: alphatest_fragment,\n\t\taomap_fragment: aomap_fragment,\n\t\taomap_pars_fragment: aomap_pars_fragment,\n\t\tbegin_vertex: begin_vertex,\n\t\tbeginnormal_vertex: beginnormal_vertex,\n\t\tbsdfs: bsdfs,\n\t\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\t\tclipping_planes_fragment: clipping_planes_fragment,\n\t\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\t\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\t\tclipping_planes_vertex: clipping_planes_vertex,\n\t\tcolor_fragment: color_fragment,\n\t\tcolor_pars_fragment: color_pars_fragment,\n\t\tcolor_pars_vertex: color_pars_vertex,\n\t\tcolor_vertex: color_vertex,\n\t\tcommon: common,\n\t\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\t\tdefaultnormal_vertex: defaultnormal_vertex,\n\t\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\t\tdisplacementmap_vertex: displacementmap_vertex,\n\t\temissivemap_fragment: emissivemap_fragment,\n\t\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\t\tencodings_fragment: encodings_fragment,\n\t\tencodings_pars_fragment: encodings_pars_fragment,\n\t\tenvmap_fragment: envmap_fragment,\n\t\tenvmap_common_pars_fragment: envmap_common_pars_fragment,\n\t\tenvmap_pars_fragment: envmap_pars_fragment,\n\t\tenvmap_pars_vertex: envmap_pars_vertex,\n\t\tenvmap_physical_pars_fragment: envmap_physical_pars_fragment,\n\t\tenvmap_vertex: envmap_vertex,\n\t\tfog_vertex: fog_vertex,\n\t\tfog_pars_vertex: fog_pars_vertex,\n\t\tfog_fragment: fog_fragment,\n\t\tfog_pars_fragment: fog_pars_fragment,\n\t\tgradientmap_pars_fragment: gradientmap_pars_fragment,\n\t\tlightmap_fragment: lightmap_fragment,\n\t\tlightmap_pars_fragment: lightmap_pars_fragment,\n\t\tlights_lambert_vertex: lights_lambert_vertex,\n\t\tlights_pars_begin: lights_pars_begin,\n\t\tlights_toon_fragment: lights_toon_fragment,\n\t\tlights_toon_pars_fragment: lights_toon_pars_fragment,\n\t\tlights_phong_fragment: lights_phong_fragment,\n\t\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\t\tlights_physical_fragment: lights_physical_fragment,\n\t\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\t\tlights_fragment_begin: lights_fragment_begin,\n\t\tlights_fragment_maps: lights_fragment_maps,\n\t\tlights_fragment_end: lights_fragment_end,\n\t\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\t\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\t\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\t\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\t\tmap_fragment: map_fragment,\n\t\tmap_pars_fragment: map_pars_fragment,\n\t\tmap_particle_fragment: map_particle_fragment,\n\t\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\t\tmetalnessmap_fragment: metalnessmap_fragment,\n\t\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\t\tmorphnormal_vertex: morphnormal_vertex,\n\t\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\t\tmorphtarget_vertex: morphtarget_vertex,\n\t\tnormal_fragment_begin: normal_fragment_begin,\n\t\tnormal_fragment_maps: normal_fragment_maps,\n\t\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\t\tclearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,\n\t\tclearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,\n\t\tclearcoat_pars_fragment: clearcoat_pars_fragment,\n\t\tpacking: packing,\n\t\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\t\tproject_vertex: project_vertex,\n\t\tdithering_fragment: dithering_fragment,\n\t\tdithering_pars_fragment: dithering_pars_fragment,\n\t\troughnessmap_fragment: roughnessmap_fragment,\n\t\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\t\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\t\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\t\tshadowmap_vertex: shadowmap_vertex,\n\t\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\t\tskinbase_vertex: skinbase_vertex,\n\t\tskinning_pars_vertex: skinning_pars_vertex,\n\t\tskinning_vertex: skinning_vertex,\n\t\tskinnormal_vertex: skinnormal_vertex,\n\t\tspecularmap_fragment: specularmap_fragment,\n\t\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\t\ttonemapping_fragment: tonemapping_fragment,\n\t\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\t\ttransmission_fragment: transmission_fragment,\n\t\ttransmission_pars_fragment: transmission_pars_fragment,\n\t\tuv_pars_fragment: uv_pars_fragment,\n\t\tuv_pars_vertex: uv_pars_vertex,\n\t\tuv_vertex: uv_vertex,\n\t\tuv2_pars_fragment: uv2_pars_fragment,\n\t\tuv2_pars_vertex: uv2_pars_vertex,\n\t\tuv2_vertex: uv2_vertex,\n\t\tworldpos_vertex: worldpos_vertex,\n\t\tbackground_frag: background_frag,\n\t\tbackground_vert: background_vert,\n\t\tcube_frag: cube_frag,\n\t\tcube_vert: cube_vert,\n\t\tdepth_frag: depth_frag,\n\t\tdepth_vert: depth_vert,\n\t\tdistanceRGBA_frag: distanceRGBA_frag,\n\t\tdistanceRGBA_vert: distanceRGBA_vert,\n\t\tequirect_frag: equirect_frag,\n\t\tequirect_vert: equirect_vert,\n\t\tlinedashed_frag: linedashed_frag,\n\t\tlinedashed_vert: linedashed_vert,\n\t\tmeshbasic_frag: meshbasic_frag,\n\t\tmeshbasic_vert: meshbasic_vert,\n\t\tmeshlambert_frag: meshlambert_frag,\n\t\tmeshlambert_vert: meshlambert_vert,\n\t\tmeshmatcap_frag: meshmatcap_frag,\n\t\tmeshmatcap_vert: meshmatcap_vert,\n\t\tmeshtoon_frag: meshtoon_frag,\n\t\tmeshtoon_vert: meshtoon_vert,\n\t\tmeshphong_frag: meshphong_frag,\n\t\tmeshphong_vert: meshphong_vert,\n\t\tmeshphysical_frag: meshphysical_frag,\n\t\tmeshphysical_vert: meshphysical_vert,\n\t\tnormal_frag: normal_frag,\n\t\tnormal_vert: normal_vert,\n\t\tpoints_frag: points_frag,\n\t\tpoints_vert: points_vert,\n\t\tshadow_frag: shadow_frag,\n\t\tshadow_vert: shadow_vert,\n\t\tsprite_frag: sprite_frag,\n\t\tsprite_vert: sprite_vert\n\t};\n\n\t/**\n\t * Uniforms library for shared webgl shaders\n\t */\n\n\tconst UniformsLib = {\n\t\tcommon: {\n\t\t\tdiffuse: {\n\t\t\t\tvalue: new Color(0xffffff)\n\t\t\t},\n\t\t\topacity: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\tmap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tuvTransform: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t},\n\t\t\tuv2Transform: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t},\n\t\t\talphaMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tspecularmap: {\n\t\t\tspecularMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tenvmap: {\n\t\t\tenvMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tflipEnvMap: {\n\t\t\t\tvalue: -1\n\t\t\t},\n\t\t\treflectivity: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\trefractionRatio: {\n\t\t\t\tvalue: 0.98\n\t\t\t},\n\t\t\tmaxMipLevel: {\n\t\t\t\tvalue: 0\n\t\t\t}\n\t\t},\n\t\taomap: {\n\t\t\taoMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\taoMapIntensity: {\n\t\t\t\tvalue: 1\n\t\t\t}\n\t\t},\n\t\tlightmap: {\n\t\t\tlightMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tlightMapIntensity: {\n\t\t\t\tvalue: 1\n\t\t\t}\n\t\t},\n\t\temissivemap: {\n\t\t\temissiveMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tbumpmap: {\n\t\t\tbumpMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tbumpScale: {\n\t\t\t\tvalue: 1\n\t\t\t}\n\t\t},\n\t\tnormalmap: {\n\t\t\tnormalMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tnormalScale: {\n\t\t\t\tvalue: new Vector2(1, 1)\n\t\t\t}\n\t\t},\n\t\tdisplacementmap: {\n\t\t\tdisplacementMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tdisplacementScale: {\n\t\t\t\tvalue: 1\n\t\t\t},\n\t\t\tdisplacementBias: {\n\t\t\t\tvalue: 0\n\t\t\t}\n\t\t},\n\t\troughnessmap: {\n\t\t\troughnessMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tmetalnessmap: {\n\t\t\tmetalnessMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tgradientmap: {\n\t\t\tgradientMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tfog: {\n\t\t\tfogDensity: {\n\t\t\t\tvalue: 0.00025\n\t\t\t},\n\t\t\tfogNear: {\n\t\t\t\tvalue: 1\n\t\t\t},\n\t\t\tfogFar: {\n\t\t\t\tvalue: 2000\n\t\t\t},\n\t\t\tfogColor: {\n\t\t\t\tvalue: new Color(0xffffff)\n\t\t\t}\n\t\t},\n\t\tlights: {\n\t\t\tambientLightColor: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tlightProbe: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tdirectionalLights: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tcolor: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdirectionalLightShadows: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowNormalBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdirectionalShadowMap: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tdirectionalShadowMatrix: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tspotLights: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tdistance: {},\n\t\t\t\t\tconeCos: {},\n\t\t\t\t\tpenumbraCos: {},\n\t\t\t\t\tdecay: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tspotLightShadows: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowNormalBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tspotShadowMap: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tspotShadowMatrix: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tpointLights: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\tdecay: {},\n\t\t\t\t\tdistance: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tpointLightShadows: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowNormalBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {},\n\t\t\t\t\tshadowCameraNear: {},\n\t\t\t\t\tshadowCameraFar: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tpointShadowMap: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tpointShadowMatrix: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\themisphereLights: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tskyColor: {},\n\t\t\t\t\tgroundColor: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n\t\t\trectAreaLights: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\twidth: {},\n\t\t\t\t\theight: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tltc_1: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tltc_2: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tpoints: {\n\t\t\tdiffuse: {\n\t\t\t\tvalue: new Color(0xffffff)\n\t\t\t},\n\t\t\topacity: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\tsize: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\tmap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\talphaMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tuvTransform: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t},\n\t\tsprite: {\n\t\t\tdiffuse: {\n\t\t\t\tvalue: new Color(0xffffff)\n\t\t\t},\n\t\t\topacity: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\tcenter: {\n\t\t\t\tvalue: new Vector2(0.5, 0.5)\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tvalue: 0.0\n\t\t\t},\n\t\t\tmap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\talphaMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tuvTransform: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t}\n\t};\n\n\tconst ShaderLib = {\n\t\tbasic: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),\n\t\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\t\t},\n\t\tlambert: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {\n\t\t\t\temissive: {\n\t\t\t\t\tvalue: new Color(0x000000)\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\t\t},\n\t\tphong: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {\n\t\t\t\temissive: {\n\t\t\t\t\tvalue: new Color(0x000000)\n\t\t\t\t},\n\t\t\t\tspecular: {\n\t\t\t\t\tvalue: new Color(0x111111)\n\t\t\t\t},\n\t\t\t\tshininess: {\n\t\t\t\t\tvalue: 30\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphong_frag\n\t\t},\n\t\tstandard: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {\n\t\t\t\temissive: {\n\t\t\t\t\tvalue: new Color(0x000000)\n\t\t\t\t},\n\t\t\t\troughness: {\n\t\t\t\t\tvalue: 1.0\n\t\t\t\t},\n\t\t\t\tmetalness: {\n\t\t\t\t\tvalue: 0.0\n\t\t\t\t},\n\t\t\t\tenvMapIntensity: {\n\t\t\t\t\tvalue: 1\n\t\t\t\t} // temporary\n\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\t\t},\n\t\ttoon: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {\n\t\t\t\temissive: {\n\t\t\t\t\tvalue: new Color(0x000000)\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.meshtoon_vert,\n\t\t\tfragmentShader: ShaderChunk.meshtoon_frag\n\t\t},\n\t\tmatcap: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {\n\t\t\t\tmatcap: {\n\t\t\t\t\tvalue: null\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.meshmatcap_vert,\n\t\t\tfragmentShader: ShaderChunk.meshmatcap_frag\n\t\t},\n\t\tpoints: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),\n\t\t\tvertexShader: ShaderChunk.points_vert,\n\t\t\tfragmentShader: ShaderChunk.points_frag\n\t\t},\n\t\tdashed: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {\n\t\t\t\tscale: {\n\t\t\t\t\tvalue: 1\n\t\t\t\t},\n\t\t\t\tdashSize: {\n\t\t\t\t\tvalue: 1\n\t\t\t\t},\n\t\t\t\ttotalSize: {\n\t\t\t\t\tvalue: 2\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\t\tfragmentShader: ShaderChunk.linedashed_frag\n\t\t},\n\t\tdepth: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),\n\t\t\tvertexShader: ShaderChunk.depth_vert,\n\t\t\tfragmentShader: ShaderChunk.depth_frag\n\t\t},\n\t\tnormal: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {\n\t\t\t\topacity: {\n\t\t\t\t\tvalue: 1.0\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.normal_vert,\n\t\t\tfragmentShader: ShaderChunk.normal_frag\n\t\t},\n\t\tsprite: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),\n\t\t\tvertexShader: ShaderChunk.sprite_vert,\n\t\t\tfragmentShader: ShaderChunk.sprite_frag\n\t\t},\n\t\tbackground: {\n\t\t\tuniforms: {\n\t\t\t\tuvTransform: {\n\t\t\t\t\tvalue: new Matrix3()\n\t\t\t\t},\n\t\t\t\tt2D: {\n\t\t\t\t\tvalue: null\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: ShaderChunk.background_vert,\n\t\t\tfragmentShader: ShaderChunk.background_frag\n\t\t},\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\t\tcube: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.envmap, {\n\t\t\t\topacity: {\n\t\t\t\t\tvalue: 1.0\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.cube_vert,\n\t\t\tfragmentShader: ShaderChunk.cube_frag\n\t\t},\n\t\tequirect: {\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: {\n\t\t\t\t\tvalue: null\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\t\tfragmentShader: ShaderChunk.equirect_frag\n\t\t},\n\t\tdistanceRGBA: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {\n\t\t\t\treferencePosition: {\n\t\t\t\t\tvalue: new Vector3()\n\t\t\t\t},\n\t\t\t\tnearDistance: {\n\t\t\t\t\tvalue: 1\n\t\t\t\t},\n\t\t\t\tfarDistance: {\n\t\t\t\t\tvalue: 1000\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\t\t},\n\t\tshadow: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {\n\t\t\t\tcolor: {\n\t\t\t\t\tvalue: new Color(0x00000)\n\t\t\t\t},\n\t\t\t\topacity: {\n\t\t\t\t\tvalue: 1.0\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.shadow_vert,\n\t\t\tfragmentShader: ShaderChunk.shadow_frag\n\t\t}\n\t};\n\tShaderLib.physical = {\n\t\tuniforms: mergeUniforms([ShaderLib.standard.uniforms, {\n\t\t\tclearcoat: {\n\t\t\t\tvalue: 0\n\t\t\t},\n\t\t\tclearcoatMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tclearcoatRoughness: {\n\t\t\t\tvalue: 0\n\t\t\t},\n\t\t\tclearcoatRoughnessMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tclearcoatNormalScale: {\n\t\t\t\tvalue: new Vector2(1, 1)\n\t\t\t},\n\t\t\tclearcoatNormalMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tsheen: {\n\t\t\t\tvalue: new Color(0x000000)\n\t\t\t},\n\t\t\ttransmission: {\n\t\t\t\tvalue: 0\n\t\t\t},\n\t\t\ttransmissionMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\ttransmissionSamplerSize: {\n\t\t\t\tvalue: new Vector2()\n\t\t\t},\n\t\t\ttransmissionSamplerMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tthickness: {\n\t\t\t\tvalue: 0\n\t\t\t},\n\t\t\tthicknessMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tattenuationDistance: {\n\t\t\t\tvalue: 0\n\t\t\t},\n\t\t\tattenuationColor: {\n\t\t\t\tvalue: new Color(0x000000)\n\t\t\t}\n\t\t}]),\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\t};\n\n\tfunction WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {\n\t\tconst clearColor = new Color(0x000000);\n\t\tlet clearAlpha = 0;\n\t\tlet planeMesh;\n\t\tlet boxMesh;\n\t\tlet currentBackground = null;\n\t\tlet currentBackgroundVersion = 0;\n\t\tlet currentTonemapping = null;\n\n\t\tfunction render(renderList, scene) {\n\t\t\tlet forceClear = false;\n\t\t\tlet background = scene.isScene === true ? scene.background : null;\n\n\t\t\tif (background && background.isTexture) {\n\t\t\t\tbackground = cubemaps.get(background);\n\t\t\t} // Ignore background in AR\n\t\t\t// TODO: Reconsider this.\n\n\n\t\t\tconst xr = renderer.xr;\n\t\t\tconst session = xr.getSession && xr.getSession();\n\n\t\t\tif (session && session.environmentBlendMode === 'additive') {\n\t\t\t\tbackground = null;\n\t\t\t}\n\n\t\t\tif (background === null) {\n\t\t\t\tsetClear(clearColor, clearAlpha);\n\t\t\t} else if (background && background.isColor) {\n\t\t\t\tsetClear(background, 1);\n\t\t\t\tforceClear = true;\n\t\t\t}\n\n\t\t\tif (renderer.autoClear || forceClear) {\n\t\t\t\trenderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n\t\t\t}\n\n\t\t\tif (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {\n\t\t\t\tif (boxMesh === undefined) {\n\t\t\t\t\tboxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({\n\t\t\t\t\t\tname: 'BackgroundCubeMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms(ShaderLib.cube.uniforms),\n\t\t\t\t\t\tvertexShader: ShaderLib.cube.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.cube.fragmentShader,\n\t\t\t\t\t\tside: BackSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t}));\n\t\t\t\t\tboxMesh.geometry.deleteAttribute('normal');\n\t\t\t\t\tboxMesh.geometry.deleteAttribute('uv');\n\n\t\t\t\t\tboxMesh.onBeforeRender = function (renderer, scene, camera) {\n\t\t\t\t\t\tthis.matrixWorld.copyPosition(camera.matrixWorld);\n\t\t\t\t\t}; // enable code injection for non-built-in material\n\n\n\t\t\t\t\tObject.defineProperty(boxMesh.material, 'envMap', {\n\t\t\t\t\t\tget: function () {\n\t\t\t\t\t\t\treturn this.uniforms.envMap.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tobjects.update(boxMesh);\n\t\t\t\t}\n\n\t\t\t\tboxMesh.material.uniforms.envMap.value = background;\n\t\t\t\tboxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;\n\n\t\t\t\tif (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n\t\t\t\t\tboxMesh.material.needsUpdate = true;\n\t\t\t\t\tcurrentBackground = background;\n\t\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\t\t\t\t} // push to the pre-sorted opaque render list\n\n\n\t\t\t\trenderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);\n\t\t\t} else if (background && background.isTexture) {\n\t\t\t\tif (planeMesh === undefined) {\n\t\t\t\t\tplaneMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({\n\t\t\t\t\t\tname: 'BackgroundMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms(ShaderLib.background.uniforms),\n\t\t\t\t\t\tvertexShader: ShaderLib.background.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.background.fragmentShader,\n\t\t\t\t\t\tside: FrontSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t}));\n\t\t\t\t\tplaneMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material\n\n\t\t\t\t\tObject.defineProperty(planeMesh.material, 'map', {\n\t\t\t\t\t\tget: function () {\n\t\t\t\t\t\t\treturn this.uniforms.t2D.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tobjects.update(planeMesh);\n\t\t\t\t}\n\n\t\t\t\tplaneMesh.material.uniforms.t2D.value = background;\n\n\t\t\t\tif (background.matrixAutoUpdate === true) {\n\t\t\t\t\tbackground.updateMatrix();\n\t\t\t\t}\n\n\t\t\t\tplaneMesh.material.uniforms.uvTransform.value.copy(background.matrix);\n\n\t\t\t\tif (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n\t\t\t\t\tplaneMesh.material.needsUpdate = true;\n\t\t\t\t\tcurrentBackground = background;\n\t\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\t\t\t\t} // push to the pre-sorted opaque render list\n\n\n\t\t\t\trenderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);\n\t\t\t}\n\t\t}\n\n\t\tfunction setClear(color, alpha) {\n\t\t\tstate.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);\n\t\t}\n\n\t\treturn {\n\t\t\tgetClearColor: function () {\n\t\t\t\treturn clearColor;\n\t\t\t},\n\t\t\tsetClearColor: function (color, alpha = 1) {\n\t\t\t\tclearColor.set(color);\n\t\t\t\tclearAlpha = alpha;\n\t\t\t\tsetClear(clearColor, clearAlpha);\n\t\t\t},\n\t\t\tgetClearAlpha: function () {\n\t\t\t\treturn clearAlpha;\n\t\t\t},\n\t\t\tsetClearAlpha: function (alpha) {\n\t\t\t\tclearAlpha = alpha;\n\t\t\t\tsetClear(clearColor, clearAlpha);\n\t\t\t},\n\t\t\trender: render\n\t\t};\n\t}\n\n\tfunction WebGLBindingStates(gl, extensions, attributes, capabilities) {\n\t\tconst maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n\t\tconst extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');\n\t\tconst vaoAvailable = capabilities.isWebGL2 || extension !== null;\n\t\tconst bindingStates = {};\n\t\tconst defaultState = createBindingState(null);\n\t\tlet currentState = defaultState;\n\n\t\tfunction setup(object, material, program, geometry, index) {\n\t\t\tlet updateBuffers = false;\n\n\t\t\tif (vaoAvailable) {\n\t\t\t\tconst state = getBindingState(geometry, program, material);\n\n\t\t\t\tif (currentState !== state) {\n\t\t\t\t\tcurrentState = state;\n\t\t\t\t\tbindVertexArrayObject(currentState.object);\n\t\t\t\t}\n\n\t\t\t\tupdateBuffers = needsUpdate(geometry, index);\n\t\t\t\tif (updateBuffers) saveCache(geometry, index);\n\t\t\t} else {\n\t\t\t\tconst wireframe = material.wireframe === true;\n\n\t\t\t\tif (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {\n\t\t\t\t\tcurrentState.geometry = geometry.id;\n\t\t\t\t\tcurrentState.program = program.id;\n\t\t\t\t\tcurrentState.wireframe = wireframe;\n\t\t\t\t\tupdateBuffers = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (object.isInstancedMesh === true) {\n\t\t\t\tupdateBuffers = true;\n\t\t\t}\n\n\t\t\tif (index !== null) {\n\t\t\t\tattributes.update(index, gl.ELEMENT_ARRAY_BUFFER);\n\t\t\t}\n\n\t\t\tif (updateBuffers) {\n\t\t\t\tsetupVertexAttributes(object, material, program, geometry);\n\n\t\t\t\tif (index !== null) {\n\t\t\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction createVertexArrayObject() {\n\t\t\tif (capabilities.isWebGL2) return gl.createVertexArray();\n\t\t\treturn extension.createVertexArrayOES();\n\t\t}\n\n\t\tfunction bindVertexArrayObject(vao) {\n\t\t\tif (capabilities.isWebGL2) return gl.bindVertexArray(vao);\n\t\t\treturn extension.bindVertexArrayOES(vao);\n\t\t}\n\n\t\tfunction deleteVertexArrayObject(vao) {\n\t\t\tif (capabilities.isWebGL2) return gl.deleteVertexArray(vao);\n\t\t\treturn extension.deleteVertexArrayOES(vao);\n\t\t}\n\n\t\tfunction getBindingState(geometry, program, material) {\n\t\t\tconst wireframe = material.wireframe === true;\n\t\t\tlet programMap = bindingStates[geometry.id];\n\n\t\t\tif (programMap === undefined) {\n\t\t\t\tprogramMap = {};\n\t\t\t\tbindingStates[geometry.id] = programMap;\n\t\t\t}\n\n\t\t\tlet stateMap = programMap[program.id];\n\n\t\t\tif (stateMap === undefined) {\n\t\t\t\tstateMap = {};\n\t\t\t\tprogramMap[program.id] = stateMap;\n\t\t\t}\n\n\t\t\tlet state = stateMap[wireframe];\n\n\t\t\tif (state === undefined) {\n\t\t\t\tstate = createBindingState(createVertexArrayObject());\n\t\t\t\tstateMap[wireframe] = state;\n\t\t\t}\n\n\t\t\treturn state;\n\t\t}\n\n\t\tfunction createBindingState(vao) {\n\t\t\tconst newAttributes = [];\n\t\t\tconst enabledAttributes = [];\n\t\t\tconst attributeDivisors = [];\n\n\t\t\tfor (let i = 0; i < maxVertexAttributes; i++) {\n\t\t\t\tnewAttributes[i] = 0;\n\t\t\t\tenabledAttributes[i] = 0;\n\t\t\t\tattributeDivisors[i] = 0;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t// for backward compatibility on non-VAO support browser\n\t\t\t\tgeometry: null,\n\t\t\t\tprogram: null,\n\t\t\t\twireframe: false,\n\t\t\t\tnewAttributes: newAttributes,\n\t\t\t\tenabledAttributes: enabledAttributes,\n\t\t\t\tattributeDivisors: attributeDivisors,\n\t\t\t\tobject: vao,\n\t\t\t\tattributes: {},\n\t\t\t\tindex: null\n\t\t\t};\n\t\t}\n\n\t\tfunction needsUpdate(geometry, index) {\n\t\t\tconst cachedAttributes = currentState.attributes;\n\t\t\tconst geometryAttributes = geometry.attributes;\n\t\t\tlet attributesNum = 0;\n\n\t\t\tfor (const key in geometryAttributes) {\n\t\t\t\tconst cachedAttribute = cachedAttributes[key];\n\t\t\t\tconst geometryAttribute = geometryAttributes[key];\n\t\t\t\tif (cachedAttribute === undefined) return true;\n\t\t\t\tif (cachedAttribute.attribute !== geometryAttribute) return true;\n\t\t\t\tif (cachedAttribute.data !== geometryAttribute.data) return true;\n\t\t\t\tattributesNum++;\n\t\t\t}\n\n\t\t\tif (currentState.attributesNum !== attributesNum) return true;\n\t\t\tif (currentState.index !== index) return true;\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction saveCache(geometry, index) {\n\t\t\tconst cache = {};\n\t\t\tconst attributes = geometry.attributes;\n\t\t\tlet attributesNum = 0;\n\n\t\t\tfor (const key in attributes) {\n\t\t\t\tconst attribute = attributes[key];\n\t\t\t\tconst data = {};\n\t\t\t\tdata.attribute = attribute;\n\n\t\t\t\tif (attribute.data) {\n\t\t\t\t\tdata.data = attribute.data;\n\t\t\t\t}\n\n\t\t\t\tcache[key] = data;\n\t\t\t\tattributesNum++;\n\t\t\t}\n\n\t\t\tcurrentState.attributes = cache;\n\t\t\tcurrentState.attributesNum = attributesNum;\n\t\t\tcurrentState.index = index;\n\t\t}\n\n\t\tfunction initAttributes() {\n\t\t\tconst newAttributes = currentState.newAttributes;\n\n\t\t\tfor (let i = 0, il = newAttributes.length; i < il; i++) {\n\t\t\t\tnewAttributes[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfunction enableAttribute(attribute) {\n\t\t\tenableAttributeAndDivisor(attribute, 0);\n\t\t}\n\n\t\tfunction enableAttributeAndDivisor(attribute, meshPerAttribute) {\n\t\t\tconst newAttributes = currentState.newAttributes;\n\t\t\tconst enabledAttributes = currentState.enabledAttributes;\n\t\t\tconst attributeDivisors = currentState.attributeDivisors;\n\t\t\tnewAttributes[attribute] = 1;\n\n\t\t\tif (enabledAttributes[attribute] === 0) {\n\t\t\t\tgl.enableVertexAttribArray(attribute);\n\t\t\t\tenabledAttributes[attribute] = 1;\n\t\t\t}\n\n\t\t\tif (attributeDivisors[attribute] !== meshPerAttribute) {\n\t\t\t\tconst extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');\n\t\t\t\textension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);\n\t\t\t\tattributeDivisors[attribute] = meshPerAttribute;\n\t\t\t}\n\t\t}\n\n\t\tfunction disableUnusedAttributes() {\n\t\t\tconst newAttributes = currentState.newAttributes;\n\t\t\tconst enabledAttributes = currentState.enabledAttributes;\n\n\t\t\tfor (let i = 0, il = enabledAttributes.length; i < il; i++) {\n\t\t\t\tif (enabledAttributes[i] !== newAttributes[i]) {\n\t\t\t\t\tgl.disableVertexAttribArray(i);\n\t\t\t\t\tenabledAttributes[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction vertexAttribPointer(index, size, type, normalized, stride, offset) {\n\t\t\tif (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {\n\t\t\t\tgl.vertexAttribIPointer(index, size, type, stride, offset);\n\t\t\t} else {\n\t\t\t\tgl.vertexAttribPointer(index, size, type, normalized, stride, offset);\n\t\t\t}\n\t\t}\n\n\t\tfunction setupVertexAttributes(object, material, program, geometry) {\n\t\t\tif (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {\n\t\t\t\tif (extensions.get('ANGLE_instanced_arrays') === null) return;\n\t\t\t}\n\n\t\t\tinitAttributes();\n\t\t\tconst geometryAttributes = geometry.attributes;\n\t\t\tconst programAttributes = program.getAttributes();\n\t\t\tconst materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\t\tfor (const name in programAttributes) {\n\t\t\t\tconst programAttribute = programAttributes[name];\n\n\t\t\t\tif (programAttribute >= 0) {\n\t\t\t\t\tconst geometryAttribute = geometryAttributes[name];\n\n\t\t\t\t\tif (geometryAttribute !== undefined) {\n\t\t\t\t\t\tconst normalized = geometryAttribute.normalized;\n\t\t\t\t\t\tconst size = geometryAttribute.itemSize;\n\t\t\t\t\t\tconst attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore\n\n\t\t\t\t\t\tif (attribute === undefined) continue;\n\t\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\t\tconst bytesPerElement = attribute.bytesPerElement;\n\n\t\t\t\t\t\tif (geometryAttribute.isInterleavedBufferAttribute) {\n\t\t\t\t\t\t\tconst data = geometryAttribute.data;\n\t\t\t\t\t\t\tconst stride = data.stride;\n\t\t\t\t\t\t\tconst offset = geometryAttribute.offset;\n\n\t\t\t\t\t\t\tif (data && data.isInstancedInterleavedBuffer) {\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute, data.meshPerAttribute);\n\n\t\t\t\t\t\t\t\tif (geometry._maxInstanceCount === undefined) {\n\t\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = data.meshPerAttribute * data.count;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tenableAttribute(programAttribute);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t\t\t\t\t\tvertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (geometryAttribute.isInstancedBufferAttribute) {\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);\n\n\t\t\t\t\t\t\t\tif (geometry._maxInstanceCount === undefined) {\n\t\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tenableAttribute(programAttribute);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t\t\t\t\t\tvertexAttribPointer(programAttribute, size, type, normalized, 0, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (name === 'instanceMatrix') {\n\t\t\t\t\t\tconst attribute = attributes.get(object.instanceMatrix); // TODO Attribute may not be available on context restore\n\n\t\t\t\t\t\tif (attribute === undefined) continue;\n\t\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute + 0, 1);\n\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute + 1, 1);\n\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute + 2, 1);\n\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute + 3, 1);\n\t\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t\t\t\t\tgl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);\n\t\t\t\t\t\tgl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);\n\t\t\t\t\t\tgl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);\n\t\t\t\t\t\tgl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);\n\t\t\t\t\t} else if (name === 'instanceColor') {\n\t\t\t\t\t\tconst attribute = attributes.get(object.instanceColor); // TODO Attribute may not be available on context restore\n\n\t\t\t\t\t\tif (attribute === undefined) continue;\n\t\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute, 1);\n\t\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t\t\t\t\tgl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);\n\t\t\t\t\t} else if (materialDefaultAttributeValues !== undefined) {\n\t\t\t\t\t\tconst value = materialDefaultAttributeValues[name];\n\n\t\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\t\tswitch (value.length) {\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tgl.vertexAttrib2fv(programAttribute, value);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tgl.vertexAttrib3fv(programAttribute, value);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tgl.vertexAttrib4fv(programAttribute, value);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tgl.vertexAttrib1fv(programAttribute, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdisableUnusedAttributes();\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\treset();\n\n\t\t\tfor (const geometryId in bindingStates) {\n\t\t\t\tconst programMap = bindingStates[geometryId];\n\n\t\t\t\tfor (const programId in programMap) {\n\t\t\t\t\tconst stateMap = programMap[programId];\n\n\t\t\t\t\tfor (const wireframe in stateMap) {\n\t\t\t\t\t\tdeleteVertexArrayObject(stateMap[wireframe].object);\n\t\t\t\t\t\tdelete stateMap[wireframe];\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete programMap[programId];\n\t\t\t\t}\n\n\t\t\t\tdelete bindingStates[geometryId];\n\t\t\t}\n\t\t}\n\n\t\tfunction releaseStatesOfGeometry(geometry) {\n\t\t\tif (bindingStates[geometry.id] === undefined) return;\n\t\t\tconst programMap = bindingStates[geometry.id];\n\n\t\t\tfor (const programId in programMap) {\n\t\t\t\tconst stateMap = programMap[programId];\n\n\t\t\t\tfor (const wireframe in stateMap) {\n\t\t\t\t\tdeleteVertexArrayObject(stateMap[wireframe].object);\n\t\t\t\t\tdelete stateMap[wireframe];\n\t\t\t\t}\n\n\t\t\t\tdelete programMap[programId];\n\t\t\t}\n\n\t\t\tdelete bindingStates[geometry.id];\n\t\t}\n\n\t\tfunction releaseStatesOfProgram(program) {\n\t\t\tfor (const geometryId in bindingStates) {\n\t\t\t\tconst programMap = bindingStates[geometryId];\n\t\t\t\tif (programMap[program.id] === undefined) continue;\n\t\t\t\tconst stateMap = programMap[program.id];\n\n\t\t\t\tfor (const wireframe in stateMap) {\n\t\t\t\t\tdeleteVertexArrayObject(stateMap[wireframe].object);\n\t\t\t\t\tdelete stateMap[wireframe];\n\t\t\t\t}\n\n\t\t\t\tdelete programMap[program.id];\n\t\t\t}\n\t\t}\n\n\t\tfunction reset() {\n\t\t\tresetDefaultState();\n\t\t\tif (currentState === defaultState) return;\n\t\t\tcurrentState = defaultState;\n\t\t\tbindVertexArrayObject(currentState.object);\n\t\t} // for backward-compatilibity\n\n\n\t\tfunction resetDefaultState() {\n\t\t\tdefaultState.geometry = null;\n\t\t\tdefaultState.program = null;\n\t\t\tdefaultState.wireframe = false;\n\t\t}\n\n\t\treturn {\n\t\t\tsetup: setup,\n\t\t\treset: reset,\n\t\t\tresetDefaultState: resetDefaultState,\n\t\t\tdispose: dispose,\n\t\t\treleaseStatesOfGeometry: releaseStatesOfGeometry,\n\t\t\treleaseStatesOfProgram: releaseStatesOfProgram,\n\t\t\tinitAttributes: initAttributes,\n\t\t\tenableAttribute: enableAttribute,\n\t\t\tdisableUnusedAttributes: disableUnusedAttributes\n\t\t};\n\t}\n\n\tfunction WebGLBufferRenderer(gl, extensions, info, capabilities) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\t\tlet mode;\n\n\t\tfunction setMode(value) {\n\t\t\tmode = value;\n\t\t}\n\n\t\tfunction render(start, count) {\n\t\t\tgl.drawArrays(mode, start, count);\n\t\t\tinfo.update(count, mode, 1);\n\t\t}\n\n\t\tfunction renderInstances(start, count, primcount) {\n\t\t\tif (primcount === 0) return;\n\t\t\tlet extension, methodName;\n\n\t\t\tif (isWebGL2) {\n\t\t\t\textension = gl;\n\t\t\t\tmethodName = 'drawArraysInstanced';\n\t\t\t} else {\n\t\t\t\textension = extensions.get('ANGLE_instanced_arrays');\n\t\t\t\tmethodName = 'drawArraysInstancedANGLE';\n\n\t\t\t\tif (extension === null) {\n\t\t\t\t\tconsole.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\textension[methodName](mode, start, count, primcount);\n\t\t\tinfo.update(count, mode, primcount);\n\t\t} //\n\n\n\t\tthis.setMode = setMode;\n\t\tthis.render = render;\n\t\tthis.renderInstances = renderInstances;\n\t}\n\n\tfunction WebGLCapabilities(gl, extensions, parameters) {\n\t\tlet maxAnisotropy;\n\n\t\tfunction getMaxAnisotropy() {\n\t\t\tif (maxAnisotropy !== undefined) return maxAnisotropy;\n\n\t\t\tif (extensions.has('EXT_texture_filter_anisotropic') === true) {\n\t\t\t\tconst extension = extensions.get('EXT_texture_filter_anisotropic');\n\t\t\t\tmaxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n\t\t\t} else {\n\t\t\t\tmaxAnisotropy = 0;\n\t\t\t}\n\n\t\t\treturn maxAnisotropy;\n\t\t}\n\n\t\tfunction getMaxPrecision(precision) {\n\t\t\tif (precision === 'highp') {\n\t\t\t\tif (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {\n\t\t\t\t\treturn 'highp';\n\t\t\t\t}\n\n\t\t\t\tprecision = 'mediump';\n\t\t\t}\n\n\t\t\tif (precision === 'mediump') {\n\t\t\t\tif (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {\n\t\t\t\t\treturn 'mediump';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 'lowp';\n\t\t}\n\t\t/* eslint-disable no-undef */\n\n\n\t\tconst isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;\n\t\t/* eslint-enable no-undef */\n\n\t\tlet precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\t\tconst maxPrecision = getMaxPrecision(precision);\n\n\t\tif (maxPrecision !== precision) {\n\t\t\tconsole.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');\n\t\t\tprecision = maxPrecision;\n\t\t}\n\n\t\tconst drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');\n\t\tconst logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n\t\tconst maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\t\tconst maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n\t\tconst maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n\t\tconst maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n\t\tconst maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n\t\tconst maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n\t\tconst maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);\n\t\tconst maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n\t\tconst vertexTextures = maxVertexTextures > 0;\n\t\tconst floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');\n\t\tconst floatVertexTextures = vertexTextures && floatFragmentTextures;\n\t\tconst maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;\n\t\treturn {\n\t\t\tisWebGL2: isWebGL2,\n\t\t\tdrawBuffers: drawBuffers,\n\t\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\t\tgetMaxPrecision: getMaxPrecision,\n\t\t\tprecision: precision,\n\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\t\t\tmaxTextures: maxTextures,\n\t\t\tmaxVertexTextures: maxVertexTextures,\n\t\t\tmaxTextureSize: maxTextureSize,\n\t\t\tmaxCubemapSize: maxCubemapSize,\n\t\t\tmaxAttributes: maxAttributes,\n\t\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\t\tmaxVaryings: maxVaryings,\n\t\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\t\t\tvertexTextures: vertexTextures,\n\t\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\t\tfloatVertexTextures: floatVertexTextures,\n\t\t\tmaxSamples: maxSamples\n\t\t};\n\t}\n\n\tfunction WebGLClipping(properties) {\n\t\tconst scope = this;\n\t\tlet globalState = null,\n\t\t\t\tnumGlobalPlanes = 0,\n\t\t\t\tlocalClippingEnabled = false,\n\t\t\t\trenderingShadows = false;\n\t\tconst plane = new Plane(),\n\t\t\t\t\tviewNormalMatrix = new Matrix3(),\n\t\t\t\t\tuniform = {\n\t\t\tvalue: null,\n\t\t\tneedsUpdate: false\n\t\t};\n\t\tthis.uniform = uniform;\n\t\tthis.numPlanes = 0;\n\t\tthis.numIntersection = 0;\n\n\t\tthis.init = function (planes, enableLocalClipping, camera) {\n\t\t\tconst enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 || localClippingEnabled;\n\t\t\tlocalClippingEnabled = enableLocalClipping;\n\t\t\tglobalState = projectPlanes(planes, camera, 0);\n\t\t\tnumGlobalPlanes = planes.length;\n\t\t\treturn enabled;\n\t\t};\n\n\t\tthis.beginShadows = function () {\n\t\t\trenderingShadows = true;\n\t\t\tprojectPlanes(null);\n\t\t};\n\n\t\tthis.endShadows = function () {\n\t\t\trenderingShadows = false;\n\t\t\tresetGlobalState();\n\t\t};\n\n\t\tthis.setState = function (material, camera, useCache) {\n\t\t\tconst planes = material.clippingPlanes,\n\t\t\t\t\t\tclipIntersection = material.clipIntersection,\n\t\t\t\t\t\tclipShadows = material.clipShadows;\n\t\t\tconst materialProperties = properties.get(material);\n\n\t\t\tif (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {\n\t\t\t\t// there's no local clipping\n\t\t\t\tif (renderingShadows) {\n\t\t\t\t\t// there's no global clipping\n\t\t\t\t\tprojectPlanes(null);\n\t\t\t\t} else {\n\t\t\t\t\tresetGlobalState();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\t\t\t\tlGlobal = nGlobal * 4;\n\t\t\t\tlet dstArray = materialProperties.clippingState || null;\n\t\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\t\tdstArray = projectPlanes(planes, camera, lGlobal, useCache);\n\n\t\t\t\tfor (let i = 0; i !== lGlobal; ++i) {\n\t\t\t\t\tdstArray[i] = globalState[i];\n\t\t\t\t}\n\n\t\t\t\tmaterialProperties.clippingState = dstArray;\n\t\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\t\tthis.numPlanes += nGlobal;\n\t\t\t}\n\t\t};\n\n\t\tfunction resetGlobalState() {\n\t\t\tif (uniform.value !== globalState) {\n\t\t\t\tuniform.value = globalState;\n\t\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\t\t\t}\n\n\t\t\tscope.numPlanes = numGlobalPlanes;\n\t\t\tscope.numIntersection = 0;\n\t\t}\n\n\t\tfunction projectPlanes(planes, camera, dstOffset, skipTransform) {\n\t\t\tconst nPlanes = planes !== null ? planes.length : 0;\n\t\t\tlet dstArray = null;\n\n\t\t\tif (nPlanes !== 0) {\n\t\t\t\tdstArray = uniform.value;\n\n\t\t\t\tif (skipTransform !== true || dstArray === null) {\n\t\t\t\t\tconst flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\t\t\t\t\tviewNormalMatrix.getNormalMatrix(viewMatrix);\n\n\t\t\t\t\tif (dstArray === null || dstArray.length < flatSize) {\n\t\t\t\t\t\tdstArray = new Float32Array(flatSize);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {\n\t\t\t\t\t\tplane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);\n\t\t\t\t\t\tplane.normal.toArray(dstArray, i4);\n\t\t\t\t\t\tdstArray[i4 + 3] = plane.constant;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuniform.value = dstArray;\n\t\t\t\tuniform.needsUpdate = true;\n\t\t\t}\n\n\t\t\tscope.numPlanes = nPlanes;\n\t\t\tscope.numIntersection = 0;\n\t\t\treturn dstArray;\n\t\t}\n\t}\n\n\tfunction WebGLCubeMaps(renderer) {\n\t\tlet cubemaps = new WeakMap();\n\n\t\tfunction mapTextureMapping(texture, mapping) {\n\t\t\tif (mapping === EquirectangularReflectionMapping) {\n\t\t\t\ttexture.mapping = CubeReflectionMapping;\n\t\t\t} else if (mapping === EquirectangularRefractionMapping) {\n\t\t\t\ttexture.mapping = CubeRefractionMapping;\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t}\n\n\t\tfunction get(texture) {\n\t\t\tif (texture && texture.isTexture) {\n\t\t\t\tconst mapping = texture.mapping;\n\n\t\t\t\tif (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {\n\t\t\t\t\tif (cubemaps.has(texture)) {\n\t\t\t\t\t\tconst cubemap = cubemaps.get(texture).texture;\n\t\t\t\t\t\treturn mapTextureMapping(cubemap, texture.mapping);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\t\tif (image && image.height > 0) {\n\t\t\t\t\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\t\t\t\t\t\tconst renderTarget = new WebGLCubeRenderTarget(image.height / 2);\n\t\t\t\t\t\t\trenderTarget.fromEquirectangularTexture(renderer, texture);\n\t\t\t\t\t\t\tcubemaps.set(texture, renderTarget);\n\t\t\t\t\t\t\trenderer.setRenderTarget(currentRenderTarget);\n\t\t\t\t\t\t\ttexture.addEventListener('dispose', onTextureDispose);\n\t\t\t\t\t\t\treturn mapTextureMapping(renderTarget.texture, texture.mapping);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// image not yet ready. try the conversion next frame\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t}\n\n\t\tfunction onTextureDispose(event) {\n\t\t\tconst texture = event.target;\n\t\t\ttexture.removeEventListener('dispose', onTextureDispose);\n\t\t\tconst cubemap = cubemaps.get(texture);\n\n\t\t\tif (cubemap !== undefined) {\n\t\t\t\tcubemaps.delete(texture);\n\t\t\t\tcubemap.dispose();\n\t\t\t}\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\tcubemaps = new WeakMap();\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tdispose: dispose\n\t\t};\n\t}\n\n\tfunction WebGLExtensions(gl) {\n\t\tconst extensions = {};\n\n\t\tfunction getExtension(name) {\n\t\t\tif (extensions[name] !== undefined) {\n\t\t\t\treturn extensions[name];\n\t\t\t}\n\n\t\t\tlet extension;\n\n\t\t\tswitch (name) {\n\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\textension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\textension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\textension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\textension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\textension = gl.getExtension(name);\n\t\t\t}\n\n\t\t\textensions[name] = extension;\n\t\t\treturn extension;\n\t\t}\n\n\t\treturn {\n\t\t\thas: function (name) {\n\t\t\t\treturn getExtension(name) !== null;\n\t\t\t},\n\t\t\tinit: function (capabilities) {\n\t\t\t\tif (capabilities.isWebGL2) {\n\t\t\t\t\tgetExtension('EXT_color_buffer_float');\n\t\t\t\t} else {\n\t\t\t\t\tgetExtension('WEBGL_depth_texture');\n\t\t\t\t\tgetExtension('OES_texture_float');\n\t\t\t\t\tgetExtension('OES_texture_half_float');\n\t\t\t\t\tgetExtension('OES_texture_half_float_linear');\n\t\t\t\t\tgetExtension('OES_standard_derivatives');\n\t\t\t\t\tgetExtension('OES_element_index_uint');\n\t\t\t\t\tgetExtension('OES_vertex_array_object');\n\t\t\t\t\tgetExtension('ANGLE_instanced_arrays');\n\t\t\t\t}\n\n\t\t\t\tgetExtension('OES_texture_float_linear');\n\t\t\t\tgetExtension('EXT_color_buffer_half_float');\n\t\t\t},\n\t\t\tget: function (name) {\n\t\t\t\tconst extension = getExtension(name);\n\n\t\t\t\tif (extension === null) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');\n\t\t\t\t}\n\n\t\t\t\treturn extension;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction WebGLGeometries(gl, attributes, info, bindingStates) {\n\t\tconst geometries = {};\n\t\tconst wireframeAttributes = new WeakMap();\n\n\t\tfunction onGeometryDispose(event) {\n\t\t\tconst geometry = event.target;\n\n\t\t\tif (geometry.index !== null) {\n\t\t\t\tattributes.remove(geometry.index);\n\t\t\t}\n\n\t\t\tfor (const name in geometry.attributes) {\n\t\t\t\tattributes.remove(geometry.attributes[name]);\n\t\t\t}\n\n\t\t\tgeometry.removeEventListener('dispose', onGeometryDispose);\n\t\t\tdelete geometries[geometry.id];\n\t\t\tconst attribute = wireframeAttributes.get(geometry);\n\n\t\t\tif (attribute) {\n\t\t\t\tattributes.remove(attribute);\n\t\t\t\twireframeAttributes.delete(geometry);\n\t\t\t}\n\n\t\t\tbindingStates.releaseStatesOfGeometry(geometry);\n\n\t\t\tif (geometry.isInstancedBufferGeometry === true) {\n\t\t\t\tdelete geometry._maxInstanceCount;\n\t\t\t} //\n\n\n\t\t\tinfo.memory.geometries--;\n\t\t}\n\n\t\tfunction get(object, geometry) {\n\t\t\tif (geometries[geometry.id] === true) return geometry;\n\t\t\tgeometry.addEventListener('dispose', onGeometryDispose);\n\t\t\tgeometries[geometry.id] = true;\n\t\t\tinfo.memory.geometries++;\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction update(geometry) {\n\t\t\tconst geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.\n\n\t\t\tfor (const name in geometryAttributes) {\n\t\t\t\tattributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);\n\t\t\t} // morph targets\n\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\n\t\t\tfor (const name in morphAttributes) {\n\t\t\t\tconst array = morphAttributes[name];\n\n\t\t\t\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\t\t\t\tattributes.update(array[i], gl.ARRAY_BUFFER);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction updateWireframeAttribute(geometry) {\n\t\t\tconst indices = [];\n\t\t\tconst geometryIndex = geometry.index;\n\t\t\tconst geometryPosition = geometry.attributes.position;\n\t\t\tlet version = 0;\n\n\t\t\tif (geometryIndex !== null) {\n\t\t\t\tconst array = geometryIndex.array;\n\t\t\t\tversion = geometryIndex.version;\n\n\t\t\t\tfor (let i = 0, l = array.length; i < l; i += 3) {\n\t\t\t\t\tconst a = array[i + 0];\n\t\t\t\t\tconst b = array[i + 1];\n\t\t\t\t\tconst c = array[i + 2];\n\t\t\t\t\tindices.push(a, b, b, c, c, a);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst array = geometryPosition.array;\n\t\t\t\tversion = geometryPosition.version;\n\n\t\t\t\tfor (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {\n\t\t\t\t\tconst a = i + 0;\n\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\tconst c = i + 2;\n\t\t\t\t\tindices.push(a, b, b, c, c, a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);\n\t\t\tattribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates\n\t\t\t//\n\n\t\t\tconst previousAttribute = wireframeAttributes.get(geometry);\n\t\t\tif (previousAttribute) attributes.remove(previousAttribute); //\n\n\t\t\twireframeAttributes.set(geometry, attribute);\n\t\t}\n\n\t\tfunction getWireframeAttribute(geometry) {\n\t\t\tconst currentAttribute = wireframeAttributes.get(geometry);\n\n\t\t\tif (currentAttribute) {\n\t\t\t\tconst geometryIndex = geometry.index;\n\n\t\t\t\tif (geometryIndex !== null) {\n\t\t\t\t\t// if the attribute is obsolete, create a new one\n\t\t\t\t\tif (currentAttribute.version < geometryIndex.version) {\n\t\t\t\t\t\tupdateWireframeAttribute(geometry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tupdateWireframeAttribute(geometry);\n\t\t\t}\n\n\t\t\treturn wireframeAttributes.get(geometry);\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tupdate: update,\n\t\t\tgetWireframeAttribute: getWireframeAttribute\n\t\t};\n\t}\n\n\tfunction WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\t\tlet mode;\n\n\t\tfunction setMode(value) {\n\t\t\tmode = value;\n\t\t}\n\n\t\tlet type, bytesPerElement;\n\n\t\tfunction setIndex(value) {\n\t\t\ttype = value.type;\n\t\t\tbytesPerElement = value.bytesPerElement;\n\t\t}\n\n\t\tfunction render(start, count) {\n\t\t\tgl.drawElements(mode, count, type, start * bytesPerElement);\n\t\t\tinfo.update(count, mode, 1);\n\t\t}\n\n\t\tfunction renderInstances(start, count, primcount) {\n\t\t\tif (primcount === 0) return;\n\t\t\tlet extension, methodName;\n\n\t\t\tif (isWebGL2) {\n\t\t\t\textension = gl;\n\t\t\t\tmethodName = 'drawElementsInstanced';\n\t\t\t} else {\n\t\t\t\textension = extensions.get('ANGLE_instanced_arrays');\n\t\t\t\tmethodName = 'drawElementsInstancedANGLE';\n\n\t\t\t\tif (extension === null) {\n\t\t\t\t\tconsole.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\textension[methodName](mode, count, type, start * bytesPerElement, primcount);\n\t\t\tinfo.update(count, mode, primcount);\n\t\t} //\n\n\n\t\tthis.setMode = setMode;\n\t\tthis.setIndex = setIndex;\n\t\tthis.render = render;\n\t\tthis.renderInstances = renderInstances;\n\t}\n\n\tfunction WebGLInfo(gl) {\n\t\tconst memory = {\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\t\t};\n\t\tconst render = {\n\t\t\tframe: 0,\n\t\t\tcalls: 0,\n\t\t\ttriangles: 0,\n\t\t\tpoints: 0,\n\t\t\tlines: 0\n\t\t};\n\n\t\tfunction update(count, mode, instanceCount) {\n\t\t\trender.calls++;\n\n\t\t\tswitch (mode) {\n\t\t\t\tcase gl.TRIANGLES:\n\t\t\t\t\trender.triangles += instanceCount * (count / 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.LINES:\n\t\t\t\t\trender.lines += instanceCount * (count / 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.LINE_STRIP:\n\t\t\t\t\trender.lines += instanceCount * (count - 1);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.LINE_LOOP:\n\t\t\t\t\trender.lines += instanceCount * count;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.POINTS:\n\t\t\t\t\trender.points += instanceCount * count;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error('THREE.WebGLInfo: Unknown draw mode:', mode);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfunction reset() {\n\t\t\trender.frame++;\n\t\t\trender.calls = 0;\n\t\t\trender.triangles = 0;\n\t\t\trender.points = 0;\n\t\t\trender.lines = 0;\n\t\t}\n\n\t\treturn {\n\t\t\tmemory: memory,\n\t\t\trender: render,\n\t\t\tprograms: null,\n\t\t\tautoReset: true,\n\t\t\treset: reset,\n\t\t\tupdate: update\n\t\t};\n\t}\n\n\tfunction numericalSort(a, b) {\n\t\treturn a[0] - b[0];\n\t}\n\n\tfunction absNumericalSort(a, b) {\n\t\treturn Math.abs(b[1]) - Math.abs(a[1]);\n\t}\n\n\tfunction WebGLMorphtargets(gl) {\n\t\tconst influencesList = {};\n\t\tconst morphInfluences = new Float32Array(8);\n\t\tconst workInfluences = [];\n\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\tworkInfluences[i] = [i, 0];\n\t\t}\n\n\t\tfunction update(object, geometry, material, program) {\n\t\t\tconst objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array\n\t\t\t// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n\n\t\t\tconst length = objectInfluences === undefined ? 0 : objectInfluences.length;\n\t\t\tlet influences = influencesList[geometry.id];\n\n\t\t\tif (influences === undefined) {\n\t\t\t\t// initialise list\n\t\t\t\tinfluences = [];\n\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tinfluences[i] = [i, 0];\n\t\t\t\t}\n\n\t\t\t\tinfluencesList[geometry.id] = influences;\n\t\t\t} // Collect influences\n\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst influence = influences[i];\n\t\t\t\tinfluence[0] = i;\n\t\t\t\tinfluence[1] = objectInfluences[i];\n\t\t\t}\n\n\t\t\tinfluences.sort(absNumericalSort);\n\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tif (i < length && influences[i][1]) {\n\t\t\t\t\tworkInfluences[i][0] = influences[i][0];\n\t\t\t\t\tworkInfluences[i][1] = influences[i][1];\n\t\t\t\t} else {\n\t\t\t\t\tworkInfluences[i][0] = Number.MAX_SAFE_INTEGER;\n\t\t\t\t\tworkInfluences[i][1] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tworkInfluences.sort(numericalSort);\n\t\t\tconst morphTargets = material.morphTargets && geometry.morphAttributes.position;\n\t\t\tconst morphNormals = material.morphNormals && geometry.morphAttributes.normal;\n\t\t\tlet morphInfluencesSum = 0;\n\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tconst influence = workInfluences[i];\n\t\t\t\tconst index = influence[0];\n\t\t\t\tconst value = influence[1];\n\n\t\t\t\tif (index !== Number.MAX_SAFE_INTEGER && value) {\n\t\t\t\t\tif (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {\n\t\t\t\t\t\tgeometry.setAttribute('morphTarget' + i, morphTargets[index]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {\n\t\t\t\t\t\tgeometry.setAttribute('morphNormal' + i, morphNormals[index]);\n\t\t\t\t\t}\n\n\t\t\t\t\tmorphInfluences[i] = value;\n\t\t\t\t\tmorphInfluencesSum += value;\n\t\t\t\t} else {\n\t\t\t\t\tif (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {\n\t\t\t\t\t\tgeometry.deleteAttribute('morphTarget' + i);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {\n\t\t\t\t\t\tgeometry.deleteAttribute('morphNormal' + i);\n\t\t\t\t\t}\n\n\t\t\t\t\tmorphInfluences[i] = 0;\n\t\t\t\t}\n\t\t\t} // GLSL shader uses formula baseinfluence * base + sum(target * influence)\n\t\t\t// This allows us to switch between absolute morphs and relative morphs without changing shader code\n\t\t\t// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\n\n\t\t\tconst morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\t\t\tprogram.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n\t\t\tprogram.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);\n\t\t}\n\n\t\treturn {\n\t\t\tupdate: update\n\t\t};\n\t}\n\n\tfunction WebGLObjects(gl, geometries, attributes, info) {\n\t\tlet updateMap = new WeakMap();\n\n\t\tfunction update(object) {\n\t\t\tconst frame = info.render.frame;\n\t\t\tconst geometry = object.geometry;\n\t\t\tconst buffergeometry = geometries.get(object, geometry); // Update once per frame\n\n\t\t\tif (updateMap.get(buffergeometry) !== frame) {\n\t\t\t\tgeometries.update(buffergeometry);\n\t\t\t\tupdateMap.set(buffergeometry, frame);\n\t\t\t}\n\n\t\t\tif (object.isInstancedMesh) {\n\t\t\t\tif (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {\n\t\t\t\t\tobject.addEventListener('dispose', onInstancedMeshDispose);\n\t\t\t\t}\n\n\t\t\t\tattributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);\n\n\t\t\t\tif (object.instanceColor !== null) {\n\t\t\t\t\tattributes.update(object.instanceColor, gl.ARRAY_BUFFER);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn buffergeometry;\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\tupdateMap = new WeakMap();\n\t\t}\n\n\t\tfunction onInstancedMeshDispose(event) {\n\t\t\tconst instancedMesh = event.target;\n\t\t\tinstancedMesh.removeEventListener('dispose', onInstancedMeshDispose);\n\t\t\tattributes.remove(instancedMesh.instanceMatrix);\n\t\t\tif (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);\n\t\t}\n\n\t\treturn {\n\t\t\tupdate: update,\n\t\t\tdispose: dispose\n\t\t};\n\t}\n\n\tclass DataTexture2DArray extends Texture {\n\t\tconstructor(data = null, width = 1, height = 1, depth = 1) {\n\t\t\tsuper(null);\n\t\t\tthis.image = {\n\t\t\t\tdata,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tdepth\n\t\t\t};\n\t\t\tthis.magFilter = NearestFilter;\n\t\t\tthis.minFilter = NearestFilter;\n\t\t\tthis.wrapR = ClampToEdgeWrapping;\n\t\t\tthis.generateMipmaps = false;\n\t\t\tthis.flipY = false;\n\t\t\tthis.unpackAlignment = 1;\n\t\t\tthis.needsUpdate = true;\n\t\t}\n\n\t}\n\n\tDataTexture2DArray.prototype.isDataTexture2DArray = true;\n\n\tclass DataTexture3D extends Texture {\n\t\tconstructor(data = null, width = 1, height = 1, depth = 1) {\n\t\t\t// We're going to add .setXXX() methods for setting properties later.\n\t\t\t// Users can still set in DataTexture3D directly.\n\t\t\t//\n\t\t\t//\tconst texture = new THREE.DataTexture3D( data, width, height, depth );\n\t\t\t// \ttexture.anisotropy = 16;\n\t\t\t//\n\t\t\t// See #14839\n\t\t\tsuper(null);\n\t\t\tthis.image = {\n\t\t\t\tdata,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tdepth\n\t\t\t};\n\t\t\tthis.magFilter = NearestFilter;\n\t\t\tthis.minFilter = NearestFilter;\n\t\t\tthis.wrapR = ClampToEdgeWrapping;\n\t\t\tthis.generateMipmaps = false;\n\t\t\tthis.flipY = false;\n\t\t\tthis.unpackAlignment = 1;\n\t\t\tthis.needsUpdate = true;\n\t\t}\n\n\t}\n\n\tDataTexture3D.prototype.isDataTexture3D = true;\n\n\t/**\n\t * Uniforms of a program.\n\t * Those form a tree structure with a special top-level container for the root,\n\t * which you get by calling 'new WebGLUniforms( gl, program )'.\n\t *\n\t *\n\t * Properties of inner nodes including the top-level container:\n\t *\n\t * .seq - array of nested uniforms\n\t * .map - nested uniforms by name\n\t *\n\t *\n\t * Methods of all nodes except the top-level container:\n\t *\n\t * .setValue( gl, value, [textures] )\n\t *\n\t * \t\tuploads a uniform value(s)\n\t *\t\tthe 'textures' parameter is needed for sampler uniforms\n\t *\n\t *\n\t * Static methods of the top-level container (textures factorizations):\n\t *\n\t * .upload( gl, seq, values, textures )\n\t *\n\t * \t\tsets uniforms in 'seq' to 'values[id].value'\n\t *\n\t * .seqWithValue( seq, values ) : filteredSeq\n\t *\n\t * \t\tfilters 'seq' entries with corresponding entry in values\n\t *\n\t *\n\t * Methods of the top-level container (textures factorizations):\n\t *\n\t * .setValue( gl, name, value, textures )\n\t *\n\t * \t\tsets uniform with\tname 'name' to 'value'\n\t *\n\t * .setOptional( gl, obj, prop )\n\t *\n\t * \t\tlike .set for an optional property of the object\n\t *\n\t */\n\tconst emptyTexture = new Texture();\n\tconst emptyTexture2dArray = new DataTexture2DArray();\n\tconst emptyTexture3d = new DataTexture3D();\n\tconst emptyCubeTexture = new CubeTexture(); // --- Utilities ---\n\t// Array Caches (provide typed arrays for temporary by size)\n\n\tconst arrayCacheF32 = [];\n\tconst arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms\n\n\tconst mat4array = new Float32Array(16);\n\tconst mat3array = new Float32Array(9);\n\tconst mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices\n\n\tfunction flatten(array, nBlocks, blockSize) {\n\t\tconst firstElem = array[0];\n\t\tif (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )\n\t\t// see http://jacksondunstan.com/articles/983\n\n\t\tconst n = nBlocks * blockSize;\n\t\tlet r = arrayCacheF32[n];\n\n\t\tif (r === undefined) {\n\t\t\tr = new Float32Array(n);\n\t\t\tarrayCacheF32[n] = r;\n\t\t}\n\n\t\tif (nBlocks !== 0) {\n\t\t\tfirstElem.toArray(r, 0);\n\n\t\t\tfor (let i = 1, offset = 0; i !== nBlocks; ++i) {\n\t\t\t\toffset += blockSize;\n\t\t\t\tarray[i].toArray(r, offset);\n\t\t\t}\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tfunction arraysEqual(a, b) {\n\t\tif (a.length !== b.length) return false;\n\n\t\tfor (let i = 0, l = a.length; i < l; i++) {\n\t\t\tif (a[i] !== b[i]) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction copyArray(a, b) {\n\t\tfor (let i = 0, l = b.length; i < l; i++) {\n\t\t\ta[i] = b[i];\n\t\t}\n\t} // Texture unit allocation\n\n\n\tfunction allocTexUnits(textures, n) {\n\t\tlet r = arrayCacheI32[n];\n\n\t\tif (r === undefined) {\n\t\t\tr = new Int32Array(n);\n\t\t\tarrayCacheI32[n] = r;\n\t\t}\n\n\t\tfor (let i = 0; i !== n; ++i) {\n\t\t\tr[i] = textures.allocateTextureUnit();\n\t\t}\n\n\t\treturn r;\n\t} // --- Setters ---\n\t// Note: Defining these methods externally, because they come in a bunch\n\t// and this way their names minify.\n\t// Single scalar\n\n\n\tfunction setValueV1f(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (cache[0] === v) return;\n\t\tgl.uniform1f(this.addr, v);\n\t\tcache[0] = v;\n\t} // Single float vector (from flat array or THREE.VectorN)\n\n\n\tfunction setValueV2f(gl, v) {\n\t\tconst cache = this.cache;\n\n\t\tif (v.x !== undefined) {\n\t\t\tif (cache[0] !== v.x || cache[1] !== v.y) {\n\t\t\t\tgl.uniform2f(this.addr, v.x, v.y);\n\t\t\t\tcache[0] = v.x;\n\t\t\t\tcache[1] = v.y;\n\t\t\t}\n\t\t} else {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniform2fv(this.addr, v);\n\t\t\tcopyArray(cache, v);\n\t\t}\n\t}\n\n\tfunction setValueV3f(gl, v) {\n\t\tconst cache = this.cache;\n\n\t\tif (v.x !== undefined) {\n\t\t\tif (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {\n\t\t\t\tgl.uniform3f(this.addr, v.x, v.y, v.z);\n\t\t\t\tcache[0] = v.x;\n\t\t\t\tcache[1] = v.y;\n\t\t\t\tcache[2] = v.z;\n\t\t\t}\n\t\t} else if (v.r !== undefined) {\n\t\t\tif (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {\n\t\t\t\tgl.uniform3f(this.addr, v.r, v.g, v.b);\n\t\t\t\tcache[0] = v.r;\n\t\t\t\tcache[1] = v.g;\n\t\t\t\tcache[2] = v.b;\n\t\t\t}\n\t\t} else {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniform3fv(this.addr, v);\n\t\t\tcopyArray(cache, v);\n\t\t}\n\t}\n\n\tfunction setValueV4f(gl, v) {\n\t\tconst cache = this.cache;\n\n\t\tif (v.x !== undefined) {\n\t\t\tif (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {\n\t\t\t\tgl.uniform4f(this.addr, v.x, v.y, v.z, v.w);\n\t\t\t\tcache[0] = v.x;\n\t\t\t\tcache[1] = v.y;\n\t\t\t\tcache[2] = v.z;\n\t\t\t\tcache[3] = v.w;\n\t\t\t}\n\t\t} else {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniform4fv(this.addr, v);\n\t\t\tcopyArray(cache, v);\n\t\t}\n\t} // Single matrix (from flat array or THREE.MatrixN)\n\n\n\tfunction setValueM2(gl, v) {\n\t\tconst cache = this.cache;\n\t\tconst elements = v.elements;\n\n\t\tif (elements === undefined) {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniformMatrix2fv(this.addr, false, v);\n\t\t\tcopyArray(cache, v);\n\t\t} else {\n\t\t\tif (arraysEqual(cache, elements)) return;\n\t\t\tmat2array.set(elements);\n\t\t\tgl.uniformMatrix2fv(this.addr, false, mat2array);\n\t\t\tcopyArray(cache, elements);\n\t\t}\n\t}\n\n\tfunction setValueM3(gl, v) {\n\t\tconst cache = this.cache;\n\t\tconst elements = v.elements;\n\n\t\tif (elements === undefined) {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniformMatrix3fv(this.addr, false, v);\n\t\t\tcopyArray(cache, v);\n\t\t} else {\n\t\t\tif (arraysEqual(cache, elements)) return;\n\t\t\tmat3array.set(elements);\n\t\t\tgl.uniformMatrix3fv(this.addr, false, mat3array);\n\t\t\tcopyArray(cache, elements);\n\t\t}\n\t}\n\n\tfunction setValueM4(gl, v) {\n\t\tconst cache = this.cache;\n\t\tconst elements = v.elements;\n\n\t\tif (elements === undefined) {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniformMatrix4fv(this.addr, false, v);\n\t\t\tcopyArray(cache, v);\n\t\t} else {\n\t\t\tif (arraysEqual(cache, elements)) return;\n\t\t\tmat4array.set(elements);\n\t\t\tgl.uniformMatrix4fv(this.addr, false, mat4array);\n\t\t\tcopyArray(cache, elements);\n\t\t}\n\t} // Single integer / boolean\n\n\n\tfunction setValueV1i(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (cache[0] === v) return;\n\t\tgl.uniform1i(this.addr, v);\n\t\tcache[0] = v;\n\t} // Single integer / boolean vector (from flat array)\n\n\n\tfunction setValueV2i(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform2iv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t}\n\n\tfunction setValueV3i(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform3iv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t}\n\n\tfunction setValueV4i(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform4iv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t} // Single unsigned integer\n\n\n\tfunction setValueV1ui(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (cache[0] === v) return;\n\t\tgl.uniform1ui(this.addr, v);\n\t\tcache[0] = v;\n\t} // Single unsigned integer vector (from flat array)\n\n\n\tfunction setValueV2ui(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform2uiv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t}\n\n\tfunction setValueV3ui(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform3uiv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t}\n\n\tfunction setValueV4ui(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform4uiv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t} // Single texture (2D / Cube)\n\n\n\tfunction setValueT1(gl, v, textures) {\n\t\tconst cache = this.cache;\n\t\tconst unit = textures.allocateTextureUnit();\n\n\t\tif (cache[0] !== unit) {\n\t\t\tgl.uniform1i(this.addr, unit);\n\t\t\tcache[0] = unit;\n\t\t}\n\n\t\ttextures.safeSetTexture2D(v || emptyTexture, unit);\n\t}\n\n\tfunction setValueT3D1(gl, v, textures) {\n\t\tconst cache = this.cache;\n\t\tconst unit = textures.allocateTextureUnit();\n\n\t\tif (cache[0] !== unit) {\n\t\t\tgl.uniform1i(this.addr, unit);\n\t\t\tcache[0] = unit;\n\t\t}\n\n\t\ttextures.setTexture3D(v || emptyTexture3d, unit);\n\t}\n\n\tfunction setValueT6(gl, v, textures) {\n\t\tconst cache = this.cache;\n\t\tconst unit = textures.allocateTextureUnit();\n\n\t\tif (cache[0] !== unit) {\n\t\t\tgl.uniform1i(this.addr, unit);\n\t\t\tcache[0] = unit;\n\t\t}\n\n\t\ttextures.safeSetTextureCube(v || emptyCubeTexture, unit);\n\t}\n\n\tfunction setValueT2DArray1(gl, v, textures) {\n\t\tconst cache = this.cache;\n\t\tconst unit = textures.allocateTextureUnit();\n\n\t\tif (cache[0] !== unit) {\n\t\t\tgl.uniform1i(this.addr, unit);\n\t\t\tcache[0] = unit;\n\t\t}\n\n\t\ttextures.setTexture2DArray(v || emptyTexture2dArray, unit);\n\t} // Helper to pick the right setter for the singular case\n\n\n\tfunction getSingularSetter(type) {\n\t\tswitch (type) {\n\t\t\tcase 0x1406:\n\t\t\t\treturn setValueV1f;\n\t\t\t// FLOAT\n\n\t\t\tcase 0x8b50:\n\t\t\t\treturn setValueV2f;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8b51:\n\t\t\t\treturn setValueV3f;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8b52:\n\t\t\t\treturn setValueV4f;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x8b5a:\n\t\t\t\treturn setValueM2;\n\t\t\t// _MAT2\n\n\t\t\tcase 0x8b5b:\n\t\t\t\treturn setValueM3;\n\t\t\t// _MAT3\n\n\t\t\tcase 0x8b5c:\n\t\t\t\treturn setValueM4;\n\t\t\t// _MAT4\n\n\t\t\tcase 0x1404:\n\t\t\tcase 0x8b56:\n\t\t\t\treturn setValueV1i;\n\t\t\t// INT, BOOL\n\n\t\t\tcase 0x8b53:\n\t\t\tcase 0x8b57:\n\t\t\t\treturn setValueV2i;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8b54:\n\t\t\tcase 0x8b58:\n\t\t\t\treturn setValueV3i;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8b55:\n\t\t\tcase 0x8b59:\n\t\t\t\treturn setValueV4i;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x1405:\n\t\t\t\treturn setValueV1ui;\n\t\t\t// UINT\n\n\t\t\tcase 0x8dc6:\n\t\t\t\treturn setValueV2ui;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8dc7:\n\t\t\t\treturn setValueV3ui;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8dc8:\n\t\t\t\treturn setValueV4ui;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x8b5e: // SAMPLER_2D\n\n\t\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\n\t\t\tcase 0x8dca: // INT_SAMPLER_2D\n\n\t\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\n\t\t\tcase 0x8b62:\n\t\t\t\t// SAMPLER_2D_SHADOW\n\t\t\t\treturn setValueT1;\n\n\t\t\tcase 0x8b5f: // SAMPLER_3D\n\n\t\t\tcase 0x8dcb: // INT_SAMPLER_3D\n\n\t\t\tcase 0x8dd3:\n\t\t\t\t// UNSIGNED_INT_SAMPLER_3D\n\t\t\t\treturn setValueT3D1;\n\n\t\t\tcase 0x8b60: // SAMPLER_CUBE\n\n\t\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\n\t\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\n\t\t\tcase 0x8dc5:\n\t\t\t\t// SAMPLER_CUBE_SHADOW\n\t\t\t\treturn setValueT6;\n\n\t\t\tcase 0x8dc1: // SAMPLER_2D_ARRAY\n\n\t\t\tcase 0x8dcf: // INT_SAMPLER_2D_ARRAY\n\n\t\t\tcase 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n\n\t\t\tcase 0x8dc4:\n\t\t\t\t// SAMPLER_2D_ARRAY_SHADOW\n\t\t\t\treturn setValueT2DArray1;\n\t\t}\n\t} // Array of scalars\n\n\n\tfunction setValueV1fArray(gl, v) {\n\t\tgl.uniform1fv(this.addr, v);\n\t} // Array of vectors (from flat array or array of THREE.VectorN)\n\n\n\tfunction setValueV2fArray(gl, v) {\n\t\tconst data = flatten(v, this.size, 2);\n\t\tgl.uniform2fv(this.addr, data);\n\t}\n\n\tfunction setValueV3fArray(gl, v) {\n\t\tconst data = flatten(v, this.size, 3);\n\t\tgl.uniform3fv(this.addr, data);\n\t}\n\n\tfunction setValueV4fArray(gl, v) {\n\t\tconst data = flatten(v, this.size, 4);\n\t\tgl.uniform4fv(this.addr, data);\n\t} // Array of matrices (from flat array or array of THREE.MatrixN)\n\n\n\tfunction setValueM2Array(gl, v) {\n\t\tconst data = flatten(v, this.size, 4);\n\t\tgl.uniformMatrix2fv(this.addr, false, data);\n\t}\n\n\tfunction setValueM3Array(gl, v) {\n\t\tconst data = flatten(v, this.size, 9);\n\t\tgl.uniformMatrix3fv(this.addr, false, data);\n\t}\n\n\tfunction setValueM4Array(gl, v) {\n\t\tconst data = flatten(v, this.size, 16);\n\t\tgl.uniformMatrix4fv(this.addr, false, data);\n\t} // Array of integer / boolean\n\n\n\tfunction setValueV1iArray(gl, v) {\n\t\tgl.uniform1iv(this.addr, v);\n\t} // Array of integer / boolean vectors (from flat array)\n\n\n\tfunction setValueV2iArray(gl, v) {\n\t\tgl.uniform2iv(this.addr, v);\n\t}\n\n\tfunction setValueV3iArray(gl, v) {\n\t\tgl.uniform3iv(this.addr, v);\n\t}\n\n\tfunction setValueV4iArray(gl, v) {\n\t\tgl.uniform4iv(this.addr, v);\n\t} // Array of unsigned integer\n\n\n\tfunction setValueV1uiArray(gl, v) {\n\t\tgl.uniform1uiv(this.addr, v);\n\t} // Array of unsigned integer vectors (from flat array)\n\n\n\tfunction setValueV2uiArray(gl, v) {\n\t\tgl.uniform2uiv(this.addr, v);\n\t}\n\n\tfunction setValueV3uiArray(gl, v) {\n\t\tgl.uniform3uiv(this.addr, v);\n\t}\n\n\tfunction setValueV4uiArray(gl, v) {\n\t\tgl.uniform4uiv(this.addr, v);\n\t} // Array of textures (2D / Cube)\n\n\n\tfunction setValueT1Array(gl, v, textures) {\n\t\tconst n = v.length;\n\t\tconst units = allocTexUnits(textures, n);\n\t\tgl.uniform1iv(this.addr, units);\n\n\t\tfor (let i = 0; i !== n; ++i) {\n\t\t\ttextures.safeSetTexture2D(v[i] || emptyTexture, units[i]);\n\t\t}\n\t}\n\n\tfunction setValueT6Array(gl, v, textures) {\n\t\tconst n = v.length;\n\t\tconst units = allocTexUnits(textures, n);\n\t\tgl.uniform1iv(this.addr, units);\n\n\t\tfor (let i = 0; i !== n; ++i) {\n\t\t\ttextures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);\n\t\t}\n\t} // Helper to pick the right setter for a pure (bottom-level) array\n\n\n\tfunction getPureArraySetter(type) {\n\t\tswitch (type) {\n\t\t\tcase 0x1406:\n\t\t\t\treturn setValueV1fArray;\n\t\t\t// FLOAT\n\n\t\t\tcase 0x8b50:\n\t\t\t\treturn setValueV2fArray;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8b51:\n\t\t\t\treturn setValueV3fArray;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8b52:\n\t\t\t\treturn setValueV4fArray;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x8b5a:\n\t\t\t\treturn setValueM2Array;\n\t\t\t// _MAT2\n\n\t\t\tcase 0x8b5b:\n\t\t\t\treturn setValueM3Array;\n\t\t\t// _MAT3\n\n\t\t\tcase 0x8b5c:\n\t\t\t\treturn setValueM4Array;\n\t\t\t// _MAT4\n\n\t\t\tcase 0x1404:\n\t\t\tcase 0x8b56:\n\t\t\t\treturn setValueV1iArray;\n\t\t\t// INT, BOOL\n\n\t\t\tcase 0x8b53:\n\t\t\tcase 0x8b57:\n\t\t\t\treturn setValueV2iArray;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8b54:\n\t\t\tcase 0x8b58:\n\t\t\t\treturn setValueV3iArray;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8b55:\n\t\t\tcase 0x8b59:\n\t\t\t\treturn setValueV4iArray;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x1405:\n\t\t\t\treturn setValueV1uiArray;\n\t\t\t// UINT\n\n\t\t\tcase 0x8dc6:\n\t\t\t\treturn setValueV2uiArray;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8dc7:\n\t\t\t\treturn setValueV3uiArray;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8dc8:\n\t\t\t\treturn setValueV4uiArray;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x8b5e: // SAMPLER_2D\n\n\t\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\n\t\t\tcase 0x8dca: // INT_SAMPLER_2D\n\n\t\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\n\t\t\tcase 0x8b62:\n\t\t\t\t// SAMPLER_2D_SHADOW\n\t\t\t\treturn setValueT1Array;\n\n\t\t\tcase 0x8b60: // SAMPLER_CUBE\n\n\t\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\n\t\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\n\t\t\tcase 0x8dc5:\n\t\t\t\t// SAMPLER_CUBE_SHADOW\n\t\t\t\treturn setValueT6Array;\n\t\t}\n\t} // --- Uniform Classes ---\n\n\n\tfunction SingleUniform(id, activeInfo, addr) {\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.cache = [];\n\t\tthis.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG\n\t}\n\n\tfunction PureArrayUniform(id, activeInfo, addr) {\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.cache = [];\n\t\tthis.size = activeInfo.size;\n\t\tthis.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG\n\t}\n\n\tPureArrayUniform.prototype.updateCache = function (data) {\n\t\tconst cache = this.cache;\n\n\t\tif (data instanceof Float32Array && cache.length !== data.length) {\n\t\t\tthis.cache = new Float32Array(data.length);\n\t\t}\n\n\t\tcopyArray(cache, data);\n\t};\n\n\tfunction StructuredUniform(id) {\n\t\tthis.id = id;\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\t}\n\n\tStructuredUniform.prototype.setValue = function (gl, value, textures) {\n\t\tconst seq = this.seq;\n\n\t\tfor (let i = 0, n = seq.length; i !== n; ++i) {\n\t\t\tconst u = seq[i];\n\t\t\tu.setValue(gl, value[u.id], textures);\n\t\t}\n\t}; // --- Top-level ---\n\t// Parser - builds up the property tree from the path strings\n\n\n\tconst RePathPart = /(\\w+)(\\])?(\\[|\\.)?/g; // extracts\n\t// \t- the identifier (member name or array index)\n\t//\t- followed by an optional right bracket (found when array index)\n\t//\t- followed by an optional left bracket or dot (type of subscript)\n\t//\n\t// Note: These portions can be read in a non-overlapping fashion and\n\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t// in the uniform names.\n\n\tfunction addUniform(container, uniformObject) {\n\t\tcontainer.seq.push(uniformObject);\n\t\tcontainer.map[uniformObject.id] = uniformObject;\n\t}\n\n\tfunction parseUniform(activeInfo, addr, container) {\n\t\tconst path = activeInfo.name,\n\t\t\t\t\tpathLength = path.length; // reset RegExp object, because of the early exit of a previous run\n\n\t\tRePathPart.lastIndex = 0;\n\n\t\twhile (true) {\n\t\t\tconst match = RePathPart.exec(path),\n\t\t\t\t\t\tmatchEnd = RePathPart.lastIndex;\n\t\t\tlet id = match[1];\n\t\t\tconst idIsIndex = match[2] === ']',\n\t\t\t\t\t\tsubscript = match[3];\n\t\t\tif (idIsIndex) id = id | 0; // convert to integer\n\n\t\t\tif (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {\n\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\t\t\t\taddUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// step into inner node / create it in case it doesn't exist\n\t\t\t\tconst map = container.map;\n\t\t\t\tlet next = map[id];\n\n\t\t\t\tif (next === undefined) {\n\t\t\t\t\tnext = new StructuredUniform(id);\n\t\t\t\t\taddUniform(container, next);\n\t\t\t\t}\n\n\t\t\t\tcontainer = next;\n\t\t\t}\n\t\t}\n\t} // Root Container\n\n\n\tfunction WebGLUniforms(gl, program) {\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\t\tconst n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n\t\tfor (let i = 0; i < n; ++i) {\n\t\t\tconst info = gl.getActiveUniform(program, i),\n\t\t\t\t\t\taddr = gl.getUniformLocation(program, info.name);\n\t\t\tparseUniform(info, addr, this);\n\t\t}\n\t}\n\n\tWebGLUniforms.prototype.setValue = function (gl, name, value, textures) {\n\t\tconst u = this.map[name];\n\t\tif (u !== undefined) u.setValue(gl, value, textures);\n\t};\n\n\tWebGLUniforms.prototype.setOptional = function (gl, object, name) {\n\t\tconst v = object[name];\n\t\tif (v !== undefined) this.setValue(gl, name, v);\n\t}; // Static interface\n\n\n\tWebGLUniforms.upload = function (gl, seq, values, textures) {\n\t\tfor (let i = 0, n = seq.length; i !== n; ++i) {\n\t\t\tconst u = seq[i],\n\t\t\t\t\t\tv = values[u.id];\n\n\t\t\tif (v.needsUpdate !== false) {\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\t\t\t\tu.setValue(gl, v.value, textures);\n\t\t\t}\n\t\t}\n\t};\n\n\tWebGLUniforms.seqWithValue = function (seq, values) {\n\t\tconst r = [];\n\n\t\tfor (let i = 0, n = seq.length; i !== n; ++i) {\n\t\t\tconst u = seq[i];\n\t\t\tif (u.id in values) r.push(u);\n\t\t}\n\n\t\treturn r;\n\t};\n\n\tfunction WebGLShader(gl, type, string) {\n\t\tconst shader = gl.createShader(type);\n\t\tgl.shaderSource(shader, string);\n\t\tgl.compileShader(shader);\n\t\treturn shader;\n\t}\n\n\tlet programIdCount = 0;\n\n\tfunction addLineNumbers(string) {\n\t\tconst lines = string.split('\\n');\n\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tlines[i] = i + 1 + ': ' + lines[i];\n\t\t}\n\n\t\treturn lines.join('\\n');\n\t}\n\n\tfunction getEncodingComponents(encoding) {\n\t\tswitch (encoding) {\n\t\t\tcase LinearEncoding:\n\t\t\t\treturn ['Linear', '( value )'];\n\n\t\t\tcase sRGBEncoding:\n\t\t\t\treturn ['sRGB', '( value )'];\n\n\t\t\tcase RGBEEncoding:\n\t\t\t\treturn ['RGBE', '( value )'];\n\n\t\t\tcase RGBM7Encoding:\n\t\t\t\treturn ['RGBM', '( value, 7.0 )'];\n\n\t\t\tcase RGBM16Encoding:\n\t\t\t\treturn ['RGBM', '( value, 16.0 )'];\n\n\t\t\tcase RGBDEncoding:\n\t\t\t\treturn ['RGBD', '( value, 256.0 )'];\n\n\t\t\tcase GammaEncoding:\n\t\t\t\treturn ['Gamma', '( value, float( GAMMA_FACTOR ) )'];\n\n\t\t\tcase LogLuvEncoding:\n\t\t\t\treturn ['LogLuv', '( value )'];\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);\n\t\t\t\treturn ['Linear', '( value )'];\n\t\t}\n\t}\n\n\tfunction getShaderErrors(gl, shader, type) {\n\t\tconst status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\t\tconst log = gl.getShaderInfoLog(shader).trim();\n\t\tif (status && log === '') return ''; // --enable-privileged-webgl-extension\n\t\t// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\tconst source = gl.getShaderSource(shader);\n\t\treturn 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\\n' + log + addLineNumbers(source);\n\t}\n\n\tfunction getTexelDecodingFunction(functionName, encoding) {\n\t\tconst components = getEncodingComponents(encoding);\n\t\treturn 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';\n\t}\n\n\tfunction getTexelEncodingFunction(functionName, encoding) {\n\t\tconst components = getEncodingComponents(encoding);\n\t\treturn 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';\n\t}\n\n\tfunction getToneMappingFunction(functionName, toneMapping) {\n\t\tlet toneMappingName;\n\n\t\tswitch (toneMapping) {\n\t\t\tcase LinearToneMapping:\n\t\t\t\ttoneMappingName = 'Linear';\n\t\t\t\tbreak;\n\n\t\t\tcase ReinhardToneMapping:\n\t\t\t\ttoneMappingName = 'Reinhard';\n\t\t\t\tbreak;\n\n\t\t\tcase CineonToneMapping:\n\t\t\t\ttoneMappingName = 'OptimizedCineon';\n\t\t\t\tbreak;\n\n\t\t\tcase ACESFilmicToneMapping:\n\t\t\t\ttoneMappingName = 'ACESFilmic';\n\t\t\t\tbreak;\n\n\t\t\tcase CustomToneMapping:\n\t\t\t\ttoneMappingName = 'Custom';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);\n\t\t\t\ttoneMappingName = 'Linear';\n\t\t}\n\n\t\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\n\t}\n\n\tfunction generateExtensions(parameters) {\n\t\tconst chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission > 0.0) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];\n\t\treturn chunks.filter(filterEmptyLine).join('\\n');\n\t}\n\n\tfunction generateDefines(defines) {\n\t\tconst chunks = [];\n\n\t\tfor (const name in defines) {\n\t\t\tconst value = defines[name];\n\t\t\tif (value === false) continue;\n\t\t\tchunks.push('#define ' + name + ' ' + value);\n\t\t}\n\n\t\treturn chunks.join('\\n');\n\t}\n\n\tfunction fetchAttributeLocations(gl, program) {\n\t\tconst attributes = {};\n\t\tconst n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tconst info = gl.getActiveAttrib(program, i);\n\t\t\tconst name = info.name; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\n\n\t\t\tattributes[name] = gl.getAttribLocation(program, name);\n\t\t}\n\n\t\treturn attributes;\n\t}\n\n\tfunction filterEmptyLine(string) {\n\t\treturn string !== '';\n\t}\n\n\tfunction replaceLightNums(string, parameters) {\n\t\treturn string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);\n\t}\n\n\tfunction replaceClippingPlaneNums(string, parameters) {\n\t\treturn string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);\n\t} // Resolve Includes\n\n\n\tconst includePattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\n\tfunction resolveIncludes(string) {\n\t\treturn string.replace(includePattern, includeReplacer);\n\t}\n\n\tfunction includeReplacer(match, include) {\n\t\tconst string = ShaderChunk[include];\n\n\t\tif (string === undefined) {\n\t\t\tthrow new Error('Can not resolve #include <' + include + '>');\n\t\t}\n\n\t\treturn resolveIncludes(string);\n\t} // Unroll Loops\n\n\n\tconst deprecatedUnrollLoopPattern = /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\tconst unrollLoopPattern = /#pragma unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma unroll_loop_end/g;\n\n\tfunction unrollLoops(string) {\n\t\treturn string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);\n\t}\n\n\tfunction deprecatedLoopReplacer(match, start, end, snippet) {\n\t\tconsole.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');\n\t\treturn loopReplacer(match, start, end, snippet);\n\t}\n\n\tfunction loopReplacer(match, start, end, snippet) {\n\t\tlet string = '';\n\n\t\tfor (let i = parseInt(start); i < parseInt(end); i++) {\n\t\t\tstring += snippet.replace(/\\[\\s*i\\s*\\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);\n\t\t}\n\n\t\treturn string;\n\t} //\n\n\n\tfunction generatePrecision(parameters) {\n\t\tlet precisionstring = 'precision ' + parameters.precision + ' float;\\nprecision ' + parameters.precision + ' int;';\n\n\t\tif (parameters.precision === 'highp') {\n\t\t\tprecisionstring += '\\n#define HIGH_PRECISION';\n\t\t} else if (parameters.precision === 'mediump') {\n\t\t\tprecisionstring += '\\n#define MEDIUM_PRECISION';\n\t\t} else if (parameters.precision === 'lowp') {\n\t\t\tprecisionstring += '\\n#define LOW_PRECISION';\n\t\t}\n\n\t\treturn precisionstring;\n\t}\n\n\tfunction generateShadowMapTypeDefine(parameters) {\n\t\tlet shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\t\tif (parameters.shadowMapType === PCFShadowMap) {\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\t\t} else if (parameters.shadowMapType === PCFSoftShadowMap) {\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\t\t} else if (parameters.shadowMapType === VSMShadowMap) {\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';\n\t\t}\n\n\t\treturn shadowMapTypeDefine;\n\t}\n\n\tfunction generateEnvMapTypeDefine(parameters) {\n\t\tlet envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\n\t\tif (parameters.envMap) {\n\t\t\tswitch (parameters.envMapMode) {\n\t\t\t\tcase CubeReflectionMapping:\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CubeUVReflectionMapping:\n\t\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn envMapTypeDefine;\n\t}\n\n\tfunction generateEnvMapModeDefine(parameters) {\n\t\tlet envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\n\t\tif (parameters.envMap) {\n\t\t\tswitch (parameters.envMapMode) {\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn envMapModeDefine;\n\t}\n\n\tfunction generateEnvMapBlendingDefine(parameters) {\n\t\tlet envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';\n\n\t\tif (parameters.envMap) {\n\t\t\tswitch (parameters.combine) {\n\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MixOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AddOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn envMapBlendingDefine;\n\t}\n\n\tfunction WebGLProgram(renderer, cacheKey, parameters, bindingStates) {\n\t\tconst gl = renderer.getContext();\n\t\tconst defines = parameters.defines;\n\t\tlet vertexShader = parameters.vertexShader;\n\t\tlet fragmentShader = parameters.fragmentShader;\n\t\tconst shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);\n\t\tconst envMapTypeDefine = generateEnvMapTypeDefine(parameters);\n\t\tconst envMapModeDefine = generateEnvMapModeDefine(parameters);\n\t\tconst envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);\n\t\tconst gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;\n\t\tconst customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);\n\t\tconst customDefines = generateDefines(defines);\n\t\tconst program = gl.createProgram();\n\t\tlet prefixVertex, prefixFragment;\n\t\tlet versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\\n' : '';\n\n\t\tif (parameters.isRawShaderMaterial) {\n\t\t\tprefixVertex = [customDefines].filter(filterEmptyLine).join('\\n');\n\n\t\t\tif (prefixVertex.length > 0) {\n\t\t\t\tprefixVertex += '\\n';\n\t\t\t}\n\n\t\t\tprefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\\n');\n\n\t\t\tif (prefixFragment.length > 0) {\n\t\t\t\tprefixFragment += '\\n';\n\t\t\t}\n\t\t} else {\n\t\t\tprefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '\tattribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '\tattribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '\tattribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '\tattribute vec4 color;', '#elif defined( USE_COLOR )', '\tattribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '\tattribute vec3 morphTarget0;', '\tattribute vec3 morphTarget1;', '\tattribute vec3 morphTarget2;', '\tattribute vec3 morphTarget3;', '\t#ifdef USE_MORPHNORMALS', '\t\tattribute vec3 morphNormal0;', '\t\tattribute vec3 morphNormal1;', '\t\tattribute vec3 morphNormal2;', '\t\tattribute vec3 morphNormal3;', '\t#else', '\t\tattribute vec3 morphTarget4;', '\t\tattribute vec3 morphTarget5;', '\t\tattribute vec3 morphTarget6;', '\t\tattribute vec3 morphTarget7;', '\t#endif', '#endif', '#ifdef USE_SKINNING', '\tattribute vec4 skinIndex;', '\tattribute vec4 skinWeight;', '#endif', '\\n'].filter(filterEmptyLine).join('\\n');\n\t\t\tprefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer\n\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below\n\t\t\tparameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\tparameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\\n'].filter(filterEmptyLine).join('\\n');\n\t\t}\n\n\t\tvertexShader = resolveIncludes(vertexShader);\n\t\tvertexShader = replaceLightNums(vertexShader, parameters);\n\t\tvertexShader = replaceClippingPlaneNums(vertexShader, parameters);\n\t\tfragmentShader = resolveIncludes(fragmentShader);\n\t\tfragmentShader = replaceLightNums(fragmentShader, parameters);\n\t\tfragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);\n\t\tvertexShader = unrollLoops(vertexShader);\n\t\tfragmentShader = unrollLoops(fragmentShader);\n\n\t\tif (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {\n\t\t\t// GLSL 3.0 conversion for built-in materials and ShaderMaterial\n\t\t\tversionString = '#version 300 es\\n';\n\t\t\tprefixVertex = ['#define attribute in', '#define varying out', '#define texture2D texture'].join('\\n') + '\\n' + prefixVertex;\n\t\t\tprefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\\n') + '\\n' + prefixFragment;\n\t\t}\n\n\t\tconst vertexGlsl = versionString + prefixVertex + vertexShader;\n\t\tconst fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\t\tconst glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);\n\t\tconst glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);\n\t\tgl.attachShader(program, glVertexShader);\n\t\tgl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.\n\n\t\tif (parameters.index0AttributeName !== undefined) {\n\t\t\tgl.bindAttribLocation(program, 0, parameters.index0AttributeName);\n\t\t} else if (parameters.morphTargets === true) {\n\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\tgl.bindAttribLocation(program, 0, 'position');\n\t\t}\n\n\t\tgl.linkProgram(program); // check for link errors\n\n\t\tif (renderer.debug.checkShaderErrors) {\n\t\t\tconst programLog = gl.getProgramInfoLog(program).trim();\n\t\t\tconst vertexLog = gl.getShaderInfoLog(glVertexShader).trim();\n\t\t\tconst fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();\n\t\t\tlet runnable = true;\n\t\t\tlet haveDiagnostics = true;\n\n\t\t\tif (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n\t\t\t\trunnable = false;\n\t\t\t\tconst vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');\n\t\t\t\tconst fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');\n\t\t\t\tconsole.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);\n\t\t\t} else if (programLog !== '') {\n\t\t\t\tconsole.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);\n\t\t\t} else if (vertexLog === '' || fragmentLog === '') {\n\t\t\t\thaveDiagnostics = false;\n\t\t\t}\n\n\t\t\tif (haveDiagnostics) {\n\t\t\t\tthis.diagnostics = {\n\t\t\t\t\trunnable: runnable,\n\t\t\t\t\tprogramLog: programLog,\n\t\t\t\t\tvertexShader: {\n\t\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\t\tprefix: prefixVertex\n\t\t\t\t\t},\n\t\t\t\t\tfragmentShader: {\n\t\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\t\tprefix: prefixFragment\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t} // Clean up\n\t\t// Crashes in iOS9 and iOS10. #18402\n\t\t// gl.detachShader( program, glVertexShader );\n\t\t// gl.detachShader( program, glFragmentShader );\n\n\n\t\tgl.deleteShader(glVertexShader);\n\t\tgl.deleteShader(glFragmentShader); // set up caching for uniform locations\n\n\t\tlet cachedUniforms;\n\n\t\tthis.getUniforms = function () {\n\t\t\tif (cachedUniforms === undefined) {\n\t\t\t\tcachedUniforms = new WebGLUniforms(gl, program);\n\t\t\t}\n\n\t\t\treturn cachedUniforms;\n\t\t}; // set up caching for attribute locations\n\n\n\t\tlet cachedAttributes;\n\n\t\tthis.getAttributes = function () {\n\t\t\tif (cachedAttributes === undefined) {\n\t\t\t\tcachedAttributes = fetchAttributeLocations(gl, program);\n\t\t\t}\n\n\t\t\treturn cachedAttributes;\n\t\t}; // free resource\n\n\n\t\tthis.destroy = function () {\n\t\t\tbindingStates.releaseStatesOfProgram(this);\n\t\t\tgl.deleteProgram(program);\n\t\t\tthis.program = undefined;\n\t\t}; //\n\n\n\t\tthis.name = parameters.shaderName;\n\t\tthis.id = programIdCount++;\n\t\tthis.cacheKey = cacheKey;\n\t\tthis.usedTimes = 1;\n\t\tthis.program = program;\n\t\tthis.vertexShader = glVertexShader;\n\t\tthis.fragmentShader = glFragmentShader;\n\t\treturn this;\n\t}\n\n\tfunction WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {\n\t\tconst programs = [];\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\t\tconst logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\n\t\tconst floatVertexTextures = capabilities.floatVertexTextures;\n\t\tconst maxVertexUniforms = capabilities.maxVertexUniforms;\n\t\tconst vertexTextures = capabilities.vertexTextures;\n\t\tlet precision = capabilities.precision;\n\t\tconst shaderIDs = {\n\t\t\tMeshDepthMaterial: 'depth',\n\t\t\tMeshDistanceMaterial: 'distanceRGBA',\n\t\t\tMeshNormalMaterial: 'normal',\n\t\t\tMeshBasicMaterial: 'basic',\n\t\t\tMeshLambertMaterial: 'lambert',\n\t\t\tMeshPhongMaterial: 'phong',\n\t\t\tMeshToonMaterial: 'toon',\n\t\t\tMeshStandardMaterial: 'physical',\n\t\t\tMeshPhysicalMaterial: 'physical',\n\t\t\tMeshMatcapMaterial: 'matcap',\n\t\t\tLineBasicMaterial: 'basic',\n\t\t\tLineDashedMaterial: 'dashed',\n\t\t\tPointsMaterial: 'points',\n\t\t\tShadowMaterial: 'shadow',\n\t\t\tSpriteMaterial: 'sprite'\n\t\t};\n\t\tconst parameterNames = ['precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor', 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV', 'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap', 'roughnessMap', 'metalnessMap', 'gradientMap', 'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2', 'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning', 'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha', 'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights', 'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows', 'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights', 'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering', 'sheen', 'transmission', 'transmissionMap', 'thicknessMap'];\n\n\t\tfunction getMaxBones(object) {\n\t\t\tconst skeleton = object.skeleton;\n\t\t\tconst bones = skeleton.bones;\n\n\t\t\tif (floatVertexTextures) {\n\t\t\t\treturn 1024;\n\t\t\t} else {\n\t\t\t\t// default for when object is not specified\n\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t\t//\n\t\t\t\t//\t- leave some extra space for other uniforms\n\t\t\t\t//\t- limit here is ANGLE's 254 max uniform vectors\n\t\t\t\t//\t\t(up to 54 should be safe)\n\t\t\t\tconst nVertexUniforms = maxVertexUniforms;\n\t\t\t\tconst nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);\n\t\t\t\tconst maxBones = Math.min(nVertexMatrices, bones.length);\n\n\t\t\t\tif (maxBones < bones.length) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn maxBones;\n\t\t\t}\n\t\t}\n\n\t\tfunction getTextureEncodingFromMap(map) {\n\t\t\tlet encoding;\n\n\t\t\tif (map && map.isTexture) {\n\t\t\t\tencoding = map.encoding;\n\t\t\t} else if (map && map.isWebGLRenderTarget) {\n\t\t\t\tconsole.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\\'t use render targets as textures. Use their .texture property instead.');\n\t\t\t\tencoding = map.texture.encoding;\n\t\t\t} else {\n\t\t\t\tencoding = LinearEncoding;\n\t\t\t}\n\n\t\t\treturn encoding;\n\t\t}\n\n\t\tfunction getParameters(material, lights, shadows, scene, object) {\n\t\t\tconst fog = scene.fog;\n\t\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tconst envMap = cubemaps.get(material.envMap || environment);\n\t\t\tconst shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene\n\t\t\t// (not to blow over maxLights budget)\n\n\t\t\tconst maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;\n\n\t\t\tif (material.precision !== null) {\n\t\t\t\tprecision = capabilities.getMaxPrecision(material.precision);\n\n\t\t\t\tif (precision !== material.precision) {\n\t\t\t\t\tconsole.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet vertexShader, fragmentShader;\n\n\t\t\tif (shaderID) {\n\t\t\t\tconst shader = ShaderLib[shaderID];\n\t\t\t\tvertexShader = shader.vertexShader;\n\t\t\t\tfragmentShader = shader.fragmentShader;\n\t\t\t} else {\n\t\t\t\tvertexShader = material.vertexShader;\n\t\t\t\tfragmentShader = material.fragmentShader;\n\t\t\t}\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\t\tconst parameters = {\n\t\t\t\tisWebGL2: isWebGL2,\n\t\t\t\tshaderID: shaderID,\n\t\t\t\tshaderName: material.type,\n\t\t\t\tvertexShader: vertexShader,\n\t\t\t\tfragmentShader: fragmentShader,\n\t\t\t\tdefines: material.defines,\n\t\t\t\tisRawShaderMaterial: material.isRawShaderMaterial === true,\n\t\t\t\tglslVersion: material.glslVersion,\n\t\t\t\tprecision: precision,\n\t\t\t\tinstancing: object.isInstancedMesh === true,\n\t\t\t\tinstancingColor: object.isInstancedMesh === true && object.instanceColor !== null,\n\t\t\t\tsupportsVertexTextures: vertexTextures,\n\t\t\t\toutputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,\n\t\t\t\tmap: !!material.map,\n\t\t\t\tmapEncoding: getTextureEncodingFromMap(material.map),\n\t\t\t\tmatcap: !!material.matcap,\n\t\t\t\tmatcapEncoding: getTextureEncodingFromMap(material.matcap),\n\t\t\t\tenvMap: !!envMap,\n\t\t\t\tenvMapMode: envMap && envMap.mapping,\n\t\t\t\tenvMapEncoding: getTextureEncodingFromMap(envMap),\n\t\t\t\tenvMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),\n\t\t\t\tlightMap: !!material.lightMap,\n\t\t\t\tlightMapEncoding: getTextureEncodingFromMap(material.lightMap),\n\t\t\t\taoMap: !!material.aoMap,\n\t\t\t\temissiveMap: !!material.emissiveMap,\n\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),\n\t\t\t\tbumpMap: !!material.bumpMap,\n\t\t\t\tnormalMap: !!material.normalMap,\n\t\t\t\tobjectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,\n\t\t\t\ttangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,\n\t\t\t\tclearcoatMap: !!material.clearcoatMap,\n\t\t\t\tclearcoatRoughnessMap: !!material.clearcoatRoughnessMap,\n\t\t\t\tclearcoatNormalMap: !!material.clearcoatNormalMap,\n\t\t\t\tdisplacementMap: !!material.displacementMap,\n\t\t\t\troughnessMap: !!material.roughnessMap,\n\t\t\t\tmetalnessMap: !!material.metalnessMap,\n\t\t\t\tspecularMap: !!material.specularMap,\n\t\t\t\talphaMap: !!material.alphaMap,\n\t\t\t\tgradientMap: !!material.gradientMap,\n\t\t\t\tsheen: !!material.sheen,\n\t\t\t\ttransmission: !!material.transmission,\n\t\t\t\ttransmissionMap: !!material.transmissionMap,\n\t\t\t\tthicknessMap: !!material.thicknessMap,\n\t\t\t\tcombine: material.combine,\n\t\t\t\tvertexTangents: material.normalMap && material.vertexTangents,\n\t\t\t\tvertexColors: material.vertexColors,\n\t\t\t\tvertexAlphas: material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,\n\t\t\t\tvertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmission || !!material.transmissionMap || !!material.thicknessMap,\n\t\t\t\tuvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmission || !!material.transmissionMap || !!material.thicknessMap) && !!material.displacementMap,\n\t\t\t\tfog: !!fog,\n\t\t\t\tuseFog: material.fog,\n\t\t\t\tfogExp2: fog && fog.isFogExp2,\n\t\t\t\tflatShading: !!material.flatShading,\n\t\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\t\t\t\tskinning: object.isSkinnedMesh === true && maxBones > 0,\n\t\t\t\tmaxBones: maxBones,\n\t\t\t\tuseVertexTexture: floatVertexTextures,\n\t\t\t\tmorphTargets: material.morphTargets,\n\t\t\t\tmorphNormals: material.morphNormals,\n\t\t\t\tnumDirLights: lights.directional.length,\n\t\t\t\tnumPointLights: lights.point.length,\n\t\t\t\tnumSpotLights: lights.spot.length,\n\t\t\t\tnumRectAreaLights: lights.rectArea.length,\n\t\t\t\tnumHemiLights: lights.hemi.length,\n\t\t\t\tnumDirLightShadows: lights.directionalShadowMap.length,\n\t\t\t\tnumPointLightShadows: lights.pointShadowMap.length,\n\t\t\t\tnumSpotLightShadows: lights.spotShadowMap.length,\n\t\t\t\tnumClippingPlanes: clipping.numPlanes,\n\t\t\t\tnumClipIntersection: clipping.numIntersection,\n\t\t\t\tdithering: material.dithering,\n\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,\n\t\t\t\tshadowMapType: renderer.shadowMap.type,\n\t\t\t\ttoneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,\n\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\t\t\t\talphaTest: material.alphaTest,\n\t\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\t\tflipSided: material.side === BackSide,\n\t\t\t\tdepthPacking: material.depthPacking !== undefined ? material.depthPacking : false,\n\t\t\t\tindex0AttributeName: material.index0AttributeName,\n\t\t\t\textensionDerivatives: material.extensions && material.extensions.derivatives,\n\t\t\t\textensionFragDepth: material.extensions && material.extensions.fragDepth,\n\t\t\t\textensionDrawBuffers: material.extensions && material.extensions.drawBuffers,\n\t\t\t\textensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,\n\t\t\t\trendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),\n\t\t\t\trendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),\n\t\t\t\trendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),\n\t\t\t\tcustomProgramCacheKey: material.customProgramCacheKey()\n\t\t\t};\n\t\t\treturn parameters;\n\t\t}\n\n\t\tfunction getProgramCacheKey(parameters) {\n\t\t\tconst array = [];\n\n\t\t\tif (parameters.shaderID) {\n\t\t\t\tarray.push(parameters.shaderID);\n\t\t\t} else {\n\t\t\t\tarray.push(parameters.fragmentShader);\n\t\t\t\tarray.push(parameters.vertexShader);\n\t\t\t}\n\n\t\t\tif (parameters.defines !== undefined) {\n\t\t\t\tfor (const name in parameters.defines) {\n\t\t\t\t\tarray.push(name);\n\t\t\t\t\tarray.push(parameters.defines[name]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (parameters.isRawShaderMaterial === false) {\n\t\t\t\tfor (let i = 0; i < parameterNames.length; i++) {\n\t\t\t\t\tarray.push(parameters[parameterNames[i]]);\n\t\t\t\t}\n\n\t\t\t\tarray.push(renderer.outputEncoding);\n\t\t\t\tarray.push(renderer.gammaFactor);\n\t\t\t}\n\n\t\t\tarray.push(parameters.customProgramCacheKey);\n\t\t\treturn array.join();\n\t\t}\n\n\t\tfunction getUniforms(material) {\n\t\t\tconst shaderID = shaderIDs[material.type];\n\t\t\tlet uniforms;\n\n\t\t\tif (shaderID) {\n\t\t\t\tconst shader = ShaderLib[shaderID];\n\t\t\t\tuniforms = UniformsUtils.clone(shader.uniforms);\n\t\t\t} else {\n\t\t\t\tuniforms = material.uniforms;\n\t\t\t}\n\n\t\t\treturn uniforms;\n\t\t}\n\n\t\tfunction acquireProgram(parameters, cacheKey) {\n\t\t\tlet program; // Check if code has been already compiled\n\n\t\t\tfor (let p = 0, pl = programs.length; p < pl; p++) {\n\t\t\t\tconst preexistingProgram = programs[p];\n\n\t\t\t\tif (preexistingProgram.cacheKey === cacheKey) {\n\t\t\t\t\tprogram = preexistingProgram;\n\t\t\t\t\t++program.usedTimes;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (program === undefined) {\n\t\t\t\tprogram = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);\n\t\t\t\tprograms.push(program);\n\t\t\t}\n\n\t\t\treturn program;\n\t\t}\n\n\t\tfunction releaseProgram(program) {\n\t\t\tif (--program.usedTimes === 0) {\n\t\t\t\t// Remove from unordered set\n\t\t\t\tconst i = programs.indexOf(program);\n\t\t\t\tprograms[i] = programs[programs.length - 1];\n\t\t\t\tprograms.pop(); // Free WebGL resources\n\n\t\t\t\tprogram.destroy();\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tgetParameters: getParameters,\n\t\t\tgetProgramCacheKey: getProgramCacheKey,\n\t\t\tgetUniforms: getUniforms,\n\t\t\tacquireProgram: acquireProgram,\n\t\t\treleaseProgram: releaseProgram,\n\t\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\t\tprograms: programs\n\t\t};\n\t}\n\n\tfunction WebGLProperties() {\n\t\tlet properties = new WeakMap();\n\n\t\tfunction get(object) {\n\t\t\tlet map = properties.get(object);\n\n\t\t\tif (map === undefined) {\n\t\t\t\tmap = {};\n\t\t\t\tproperties.set(object, map);\n\t\t\t}\n\n\t\t\treturn map;\n\t\t}\n\n\t\tfunction remove(object) {\n\t\t\tproperties.delete(object);\n\t\t}\n\n\t\tfunction update(object, key, value) {\n\t\t\tproperties.get(object)[key] = value;\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\tproperties = new WeakMap();\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tremove: remove,\n\t\t\tupdate: update,\n\t\t\tdispose: dispose\n\t\t};\n\t}\n\n\tfunction painterSortStable(a, b) {\n\t\tif (a.groupOrder !== b.groupOrder) {\n\t\t\treturn a.groupOrder - b.groupOrder;\n\t\t} else if (a.renderOrder !== b.renderOrder) {\n\t\t\treturn a.renderOrder - b.renderOrder;\n\t\t} else if (a.program !== b.program) {\n\t\t\treturn a.program.id - b.program.id;\n\t\t} else if (a.material.id !== b.material.id) {\n\t\t\treturn a.material.id - b.material.id;\n\t\t} else if (a.z !== b.z) {\n\t\t\treturn a.z - b.z;\n\t\t} else {\n\t\t\treturn a.id - b.id;\n\t\t}\n\t}\n\n\tfunction reversePainterSortStable(a, b) {\n\t\tif (a.groupOrder !== b.groupOrder) {\n\t\t\treturn a.groupOrder - b.groupOrder;\n\t\t} else if (a.renderOrder !== b.renderOrder) {\n\t\t\treturn a.renderOrder - b.renderOrder;\n\t\t} else if (a.z !== b.z) {\n\t\t\treturn b.z - a.z;\n\t\t} else {\n\t\t\treturn a.id - b.id;\n\t\t}\n\t}\n\n\tfunction WebGLRenderList(properties) {\n\t\tconst renderItems = [];\n\t\tlet renderItemsIndex = 0;\n\t\tconst opaque = [];\n\t\tconst transmissive = [];\n\t\tconst transparent = [];\n\t\tconst defaultProgram = {\n\t\t\tid: -1\n\t\t};\n\n\t\tfunction init() {\n\t\t\trenderItemsIndex = 0;\n\t\t\topaque.length = 0;\n\t\t\ttransmissive.length = 0;\n\t\t\ttransparent.length = 0;\n\t\t}\n\n\t\tfunction getNextRenderItem(object, geometry, material, groupOrder, z, group) {\n\t\t\tlet renderItem = renderItems[renderItemsIndex];\n\t\t\tconst materialProperties = properties.get(material);\n\n\t\t\tif (renderItem === undefined) {\n\t\t\t\trenderItem = {\n\t\t\t\t\tid: object.id,\n\t\t\t\t\tobject: object,\n\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\tmaterial: material,\n\t\t\t\t\tprogram: materialProperties.program || defaultProgram,\n\t\t\t\t\tgroupOrder: groupOrder,\n\t\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\t\tz: z,\n\t\t\t\t\tgroup: group\n\t\t\t\t};\n\t\t\t\trenderItems[renderItemsIndex] = renderItem;\n\t\t\t} else {\n\t\t\t\trenderItem.id = object.id;\n\t\t\t\trenderItem.object = object;\n\t\t\t\trenderItem.geometry = geometry;\n\t\t\t\trenderItem.material = material;\n\t\t\t\trenderItem.program = materialProperties.program || defaultProgram;\n\t\t\t\trenderItem.groupOrder = groupOrder;\n\t\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\t\trenderItem.z = z;\n\t\t\t\trenderItem.group = group;\n\t\t\t}\n\n\t\t\trenderItemsIndex++;\n\t\t\treturn renderItem;\n\t\t}\n\n\t\tfunction push(object, geometry, material, groupOrder, z, group) {\n\t\t\tconst renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);\n\n\t\t\tif (material.transmission > 0.0) {\n\t\t\t\ttransmissive.push(renderItem);\n\t\t\t} else if (material.transparent === true) {\n\t\t\t\ttransparent.push(renderItem);\n\t\t\t} else {\n\t\t\t\topaque.push(renderItem);\n\t\t\t}\n\t\t}\n\n\t\tfunction unshift(object, geometry, material, groupOrder, z, group) {\n\t\t\tconst renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);\n\n\t\t\tif (material.transmission > 0.0) {\n\t\t\t\ttransmissive.unshift(renderItem);\n\t\t\t} else if (material.transparent === true) {\n\t\t\t\ttransparent.unshift(renderItem);\n\t\t\t} else {\n\t\t\t\topaque.unshift(renderItem);\n\t\t\t}\n\t\t}\n\n\t\tfunction sort(customOpaqueSort, customTransparentSort) {\n\t\t\tif (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);\n\t\t\tif (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);\n\t\t\tif (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);\n\t\t}\n\n\t\tfunction finish() {\n\t\t\t// Clear references from inactive renderItems in the list\n\t\t\tfor (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {\n\t\t\t\tconst renderItem = renderItems[i];\n\t\t\t\tif (renderItem.id === null) break;\n\t\t\t\trenderItem.id = null;\n\t\t\t\trenderItem.object = null;\n\t\t\t\trenderItem.geometry = null;\n\t\t\t\trenderItem.material = null;\n\t\t\t\trenderItem.program = null;\n\t\t\t\trenderItem.group = null;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\topaque: opaque,\n\t\t\ttransmissive: transmissive,\n\t\t\ttransparent: transparent,\n\t\t\tinit: init,\n\t\t\tpush: push,\n\t\t\tunshift: unshift,\n\t\t\tfinish: finish,\n\t\t\tsort: sort\n\t\t};\n\t}\n\n\tfunction WebGLRenderLists(properties) {\n\t\tlet lists = new WeakMap();\n\n\t\tfunction get(scene, renderCallDepth) {\n\t\t\tlet list;\n\n\t\t\tif (lists.has(scene) === false) {\n\t\t\t\tlist = new WebGLRenderList(properties);\n\t\t\t\tlists.set(scene, [list]);\n\t\t\t} else {\n\t\t\t\tif (renderCallDepth >= lists.get(scene).length) {\n\t\t\t\t\tlist = new WebGLRenderList(properties);\n\t\t\t\t\tlists.get(scene).push(list);\n\t\t\t\t} else {\n\t\t\t\t\tlist = lists.get(scene)[renderCallDepth];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn list;\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\tlists = new WeakMap();\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tdispose: dispose\n\t\t};\n\t}\n\n\tfunction UniformsCache() {\n\t\tconst lights = {};\n\t\treturn {\n\t\t\tget: function (light) {\n\t\t\t\tif (lights[light.id] !== undefined) {\n\t\t\t\t\treturn lights[light.id];\n\t\t\t\t}\n\n\t\t\t\tlet uniforms;\n\n\t\t\t\tswitch (light.type) {\n\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\thalfWidth: new Vector3(),\n\t\t\t\t\t\t\thalfHeight: new Vector3()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlights[light.id] = uniforms;\n\t\t\t\treturn uniforms;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction ShadowUniformsCache() {\n\t\tconst lights = {};\n\t\treturn {\n\t\t\tget: function (light) {\n\t\t\t\tif (lights[light.id] !== undefined) {\n\t\t\t\t\treturn lights[light.id];\n\t\t\t\t}\n\n\t\t\t\tlet uniforms;\n\n\t\t\t\tswitch (light.type) {\n\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2(),\n\t\t\t\t\t\t\tshadowCameraNear: 1,\n\t\t\t\t\t\t\tshadowCameraFar: 1000\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// TODO (abelnation): set RectAreaLight shadow uniforms\n\t\t\t\t}\n\n\t\t\t\tlights[light.id] = uniforms;\n\t\t\t\treturn uniforms;\n\t\t\t}\n\t\t};\n\t}\n\n\tlet nextVersion = 0;\n\n\tfunction shadowCastingLightsFirst(lightA, lightB) {\n\t\treturn (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);\n\t}\n\n\tfunction WebGLLights(extensions, capabilities) {\n\t\tconst cache = new UniformsCache();\n\t\tconst shadowCache = ShadowUniformsCache();\n\t\tconst state = {\n\t\t\tversion: 0,\n\t\t\thash: {\n\t\t\t\tdirectionalLength: -1,\n\t\t\t\tpointLength: -1,\n\t\t\t\tspotLength: -1,\n\t\t\t\trectAreaLength: -1,\n\t\t\t\themiLength: -1,\n\t\t\t\tnumDirectionalShadows: -1,\n\t\t\t\tnumPointShadows: -1,\n\t\t\t\tnumSpotShadows: -1\n\t\t\t},\n\t\t\tambient: [0, 0, 0],\n\t\t\tprobe: [],\n\t\t\tdirectional: [],\n\t\t\tdirectionalShadow: [],\n\t\t\tdirectionalShadowMap: [],\n\t\t\tdirectionalShadowMatrix: [],\n\t\t\tspot: [],\n\t\t\tspotShadow: [],\n\t\t\tspotShadowMap: [],\n\t\t\tspotShadowMatrix: [],\n\t\t\trectArea: [],\n\t\t\trectAreaLTC1: null,\n\t\t\trectAreaLTC2: null,\n\t\t\tpoint: [],\n\t\t\tpointShadow: [],\n\t\t\tpointShadowMap: [],\n\t\t\tpointShadowMatrix: [],\n\t\t\themi: []\n\t\t};\n\n\t\tfor (let i = 0; i < 9; i++) state.probe.push(new Vector3());\n\n\t\tconst vector3 = new Vector3();\n\t\tconst matrix4 = new Matrix4();\n\t\tconst matrix42 = new Matrix4();\n\n\t\tfunction setup(lights) {\n\t\t\tlet r = 0,\n\t\t\t\t\tg = 0,\n\t\t\t\t\tb = 0;\n\n\t\t\tfor (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);\n\n\t\t\tlet directionalLength = 0;\n\t\t\tlet pointLength = 0;\n\t\t\tlet spotLength = 0;\n\t\t\tlet rectAreaLength = 0;\n\t\t\tlet hemiLength = 0;\n\t\t\tlet numDirectionalShadows = 0;\n\t\t\tlet numPointShadows = 0;\n\t\t\tlet numSpotShadows = 0;\n\t\t\tlights.sort(shadowCastingLightsFirst);\n\n\t\t\tfor (let i = 0, l = lights.length; i < l; i++) {\n\t\t\t\tconst light = lights[i];\n\t\t\t\tconst color = light.color;\n\t\t\t\tconst intensity = light.intensity;\n\t\t\t\tconst distance = light.distance;\n\t\t\t\tconst shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;\n\n\t\t\t\tif (light.isAmbientLight) {\n\t\t\t\t\tr += color.r * intensity;\n\t\t\t\t\tg += color.g * intensity;\n\t\t\t\t\tb += color.b * intensity;\n\t\t\t\t} else if (light.isLightProbe) {\n\t\t\t\t\tfor (let j = 0; j < 9; j++) {\n\t\t\t\t\t\tstate.probe[j].addScaledVector(light.sh.coefficients[j], intensity);\n\t\t\t\t\t}\n\t\t\t\t} else if (light.isDirectionalLight) {\n\t\t\t\t\tconst uniforms = cache.get(light);\n\t\t\t\t\tuniforms.color.copy(light.color).multiplyScalar(light.intensity);\n\n\t\t\t\t\tif (light.castShadow) {\n\t\t\t\t\t\tconst shadow = light.shadow;\n\t\t\t\t\t\tconst shadowUniforms = shadowCache.get(light);\n\t\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\t\tstate.directionalShadow[directionalLength] = shadowUniforms;\n\t\t\t\t\t\tstate.directionalShadowMap[directionalLength] = shadowMap;\n\t\t\t\t\t\tstate.directionalShadowMatrix[directionalLength] = light.shadow.matrix;\n\t\t\t\t\t\tnumDirectionalShadows++;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.directional[directionalLength] = uniforms;\n\t\t\t\t\tdirectionalLength++;\n\t\t\t\t} else if (light.isSpotLight) {\n\t\t\t\t\tconst uniforms = cache.get(light);\n\t\t\t\t\tuniforms.position.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tuniforms.color.copy(color).multiplyScalar(intensity);\n\t\t\t\t\tuniforms.distance = distance;\n\t\t\t\t\tuniforms.coneCos = Math.cos(light.angle);\n\t\t\t\t\tuniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));\n\t\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\t\tif (light.castShadow) {\n\t\t\t\t\t\tconst shadow = light.shadow;\n\t\t\t\t\t\tconst shadowUniforms = shadowCache.get(light);\n\t\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\t\tstate.spotShadow[spotLength] = shadowUniforms;\n\t\t\t\t\t\tstate.spotShadowMap[spotLength] = shadowMap;\n\t\t\t\t\t\tstate.spotShadowMatrix[spotLength] = light.shadow.matrix;\n\t\t\t\t\t\tnumSpotShadows++;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.spot[spotLength] = uniforms;\n\t\t\t\t\tspotLength++;\n\t\t\t\t} else if (light.isRectAreaLight) {\n\t\t\t\t\tconst uniforms = cache.get(light); // (a) intensity is the total visible light emitted\n\t\t\t\t\t//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\n\t\t\t\t\t// (b) intensity is the brightness of the light\n\n\t\t\t\t\tuniforms.color.copy(color).multiplyScalar(intensity);\n\t\t\t\t\tuniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n\t\t\t\t\tuniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);\n\t\t\t\t\tstate.rectArea[rectAreaLength] = uniforms;\n\t\t\t\t\trectAreaLength++;\n\t\t\t\t} else if (light.isPointLight) {\n\t\t\t\t\tconst uniforms = cache.get(light);\n\t\t\t\t\tuniforms.color.copy(light.color).multiplyScalar(light.intensity);\n\t\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\t\tif (light.castShadow) {\n\t\t\t\t\t\tconst shadow = light.shadow;\n\t\t\t\t\t\tconst shadowUniforms = shadowCache.get(light);\n\t\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\t\tshadowUniforms.shadowCameraNear = shadow.camera.near;\n\t\t\t\t\t\tshadowUniforms.shadowCameraFar = shadow.camera.far;\n\t\t\t\t\t\tstate.pointShadow[pointLength] = shadowUniforms;\n\t\t\t\t\t\tstate.pointShadowMap[pointLength] = shadowMap;\n\t\t\t\t\t\tstate.pointShadowMatrix[pointLength] = light.shadow.matrix;\n\t\t\t\t\t\tnumPointShadows++;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.point[pointLength] = uniforms;\n\t\t\t\t\tpointLength++;\n\t\t\t\t} else if (light.isHemisphereLight) {\n\t\t\t\t\tconst uniforms = cache.get(light);\n\t\t\t\t\tuniforms.skyColor.copy(light.color).multiplyScalar(intensity);\n\t\t\t\t\tuniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);\n\t\t\t\t\tstate.hemi[hemiLength] = uniforms;\n\t\t\t\t\themiLength++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rectAreaLength > 0) {\n\t\t\t\tif (capabilities.isWebGL2) {\n\t\t\t\t\t// WebGL 2\n\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\t\t\t\t} else {\n\t\t\t\t\t// WebGL 1\n\t\t\t\t\tif (extensions.has('OES_texture_float_linear') === true) {\n\t\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\t\t\t\t\t} else if (extensions.has('OES_texture_half_float_linear') === true) {\n\t\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n\t\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.ambient[0] = r;\n\t\t\tstate.ambient[1] = g;\n\t\t\tstate.ambient[2] = b;\n\t\t\tconst hash = state.hash;\n\n\t\t\tif (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {\n\t\t\t\tstate.directional.length = directionalLength;\n\t\t\t\tstate.spot.length = spotLength;\n\t\t\t\tstate.rectArea.length = rectAreaLength;\n\t\t\t\tstate.point.length = pointLength;\n\t\t\t\tstate.hemi.length = hemiLength;\n\t\t\t\tstate.directionalShadow.length = numDirectionalShadows;\n\t\t\t\tstate.directionalShadowMap.length = numDirectionalShadows;\n\t\t\t\tstate.pointShadow.length = numPointShadows;\n\t\t\t\tstate.pointShadowMap.length = numPointShadows;\n\t\t\t\tstate.spotShadow.length = numSpotShadows;\n\t\t\t\tstate.spotShadowMap.length = numSpotShadows;\n\t\t\t\tstate.directionalShadowMatrix.length = numDirectionalShadows;\n\t\t\t\tstate.pointShadowMatrix.length = numPointShadows;\n\t\t\t\tstate.spotShadowMatrix.length = numSpotShadows;\n\t\t\t\thash.directionalLength = directionalLength;\n\t\t\t\thash.pointLength = pointLength;\n\t\t\t\thash.spotLength = spotLength;\n\t\t\t\thash.rectAreaLength = rectAreaLength;\n\t\t\t\thash.hemiLength = hemiLength;\n\t\t\t\thash.numDirectionalShadows = numDirectionalShadows;\n\t\t\t\thash.numPointShadows = numPointShadows;\n\t\t\t\thash.numSpotShadows = numSpotShadows;\n\t\t\t\tstate.version = nextVersion++;\n\t\t\t}\n\t\t}\n\n\t\tfunction setupView(lights, camera) {\n\t\t\tlet directionalLength = 0;\n\t\t\tlet pointLength = 0;\n\t\t\tlet spotLength = 0;\n\t\t\tlet rectAreaLength = 0;\n\t\t\tlet hemiLength = 0;\n\t\t\tconst viewMatrix = camera.matrixWorldInverse;\n\n\t\t\tfor (let i = 0, l = lights.length; i < l; i++) {\n\t\t\t\tconst light = lights[i];\n\n\t\t\t\tif (light.isDirectionalLight) {\n\t\t\t\t\tconst uniforms = state.directional[directionalLength];\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tvector3.setFromMatrixPosition(light.target.matrixWorld);\n\t\t\t\t\tuniforms.direction.sub(vector3);\n\t\t\t\t\tuniforms.direction.transformDirection(viewMatrix);\n\t\t\t\t\tdirectionalLength++;\n\t\t\t\t} else if (light.isSpotLight) {\n\t\t\t\t\tconst uniforms = state.spot[spotLength];\n\t\t\t\t\tuniforms.position.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tuniforms.position.applyMatrix4(viewMatrix);\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tvector3.setFromMatrixPosition(light.target.matrixWorld);\n\t\t\t\t\tuniforms.direction.sub(vector3);\n\t\t\t\t\tuniforms.direction.transformDirection(viewMatrix);\n\t\t\t\t\tspotLength++;\n\t\t\t\t} else if (light.isRectAreaLight) {\n\t\t\t\t\tconst uniforms = state.rectArea[rectAreaLength];\n\t\t\t\t\tuniforms.position.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tuniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors\n\n\t\t\t\t\tmatrix42.identity();\n\t\t\t\t\tmatrix4.copy(light.matrixWorld);\n\t\t\t\t\tmatrix4.premultiply(viewMatrix);\n\t\t\t\t\tmatrix42.extractRotation(matrix4);\n\t\t\t\t\tuniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n\t\t\t\t\tuniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);\n\t\t\t\t\tuniforms.halfWidth.applyMatrix4(matrix42);\n\t\t\t\t\tuniforms.halfHeight.applyMatrix4(matrix42);\n\t\t\t\t\trectAreaLength++;\n\t\t\t\t} else if (light.isPointLight) {\n\t\t\t\t\tconst uniforms = state.point[pointLength];\n\t\t\t\t\tuniforms.position.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tuniforms.position.applyMatrix4(viewMatrix);\n\t\t\t\t\tpointLength++;\n\t\t\t\t} else if (light.isHemisphereLight) {\n\t\t\t\t\tconst uniforms = state.hemi[hemiLength];\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tuniforms.direction.transformDirection(viewMatrix);\n\t\t\t\t\tuniforms.direction.normalize();\n\t\t\t\t\themiLength++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsetup: setup,\n\t\t\tsetupView: setupView,\n\t\t\tstate: state\n\t\t};\n\t}\n\n\tfunction WebGLRenderState(extensions, capabilities) {\n\t\tconst lights = new WebGLLights(extensions, capabilities);\n\t\tconst lightsArray = [];\n\t\tconst shadowsArray = [];\n\n\t\tfunction init() {\n\t\t\tlightsArray.length = 0;\n\t\t\tshadowsArray.length = 0;\n\t\t}\n\n\t\tfunction pushLight(light) {\n\t\t\tlightsArray.push(light);\n\t\t}\n\n\t\tfunction pushShadow(shadowLight) {\n\t\t\tshadowsArray.push(shadowLight);\n\t\t}\n\n\t\tfunction setupLights() {\n\t\t\tlights.setup(lightsArray);\n\t\t}\n\n\t\tfunction setupLightsView(camera) {\n\t\t\tlights.setupView(lightsArray, camera);\n\t\t}\n\n\t\tconst state = {\n\t\t\tlightsArray: lightsArray,\n\t\t\tshadowsArray: shadowsArray,\n\t\t\tlights: lights\n\t\t};\n\t\treturn {\n\t\t\tinit: init,\n\t\t\tstate: state,\n\t\t\tsetupLights: setupLights,\n\t\t\tsetupLightsView: setupLightsView,\n\t\t\tpushLight: pushLight,\n\t\t\tpushShadow: pushShadow\n\t\t};\n\t}\n\n\tfunction WebGLRenderStates(extensions, capabilities) {\n\t\tlet renderStates = new WeakMap();\n\n\t\tfunction get(scene, renderCallDepth = 0) {\n\t\t\tlet renderState;\n\n\t\t\tif (renderStates.has(scene) === false) {\n\t\t\t\trenderState = new WebGLRenderState(extensions, capabilities);\n\t\t\t\trenderStates.set(scene, [renderState]);\n\t\t\t} else {\n\t\t\t\tif (renderCallDepth >= renderStates.get(scene).length) {\n\t\t\t\t\trenderState = new WebGLRenderState(extensions, capabilities);\n\t\t\t\t\trenderStates.get(scene).push(renderState);\n\t\t\t\t} else {\n\t\t\t\t\trenderState = renderStates.get(scene)[renderCallDepth];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn renderState;\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\trenderStates = new WeakMap();\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tdispose: dispose\n\t\t};\n\t}\n\n\t/**\n\t * parameters = {\n\t *\n\t *\topacity: <float>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>\n\t * }\n\t */\n\n\tclass MeshDepthMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshDepthMaterial';\n\t\t\tthis.depthPacking = BasicDepthPacking;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.map = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.fog = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.depthPacking = source.depthPacking;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.map = source.map;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\n\t *\treferencePosition: <float>,\n\t *\tnearDistance: <float>,\n\t *\tfarDistance: <float>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>\n\t *\n\t * }\n\t */\n\n\tclass MeshDistanceMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshDistanceMaterial';\n\t\t\tthis.referencePosition = new Vector3();\n\t\t\tthis.nearDistance = 1;\n\t\t\tthis.farDistance = 1000;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.map = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.fog = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.referencePosition.copy(source.referencePosition);\n\t\t\tthis.nearDistance = source.nearDistance;\n\t\t\tthis.farDistance = source.farDistance;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.map = source.map;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\n\n\tvar vsm_frag = \"uniform sampler2D shadow_pass;\\nuniform vec2 resolution;\\nuniform float radius;\\n#include <packing>\\nvoid main() {\\n\\tfloat mean = 0.0;\\n\\tfloat squared_mean = 0.0;\\n\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\\n\\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\\n\\t\\t#ifdef HORIZONTAL_PASS\\n\\t\\t\\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\\n\\t\\t\\tmean += distribution.x;\\n\\t\\t\\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\\n\\t\\t#else\\n\\t\\t\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\\n\\t\\t\\tmean += depth;\\n\\t\\t\\tsquared_mean += depth * depth;\\n\\t\\t#endif\\n\\t}\\n\\tmean = mean * HALF_SAMPLE_RATE;\\n\\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\\n\\tfloat std_dev = sqrt( squared_mean - mean * mean );\\n\\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\\n}\";\n\n\tvar vsm_vert = \"void main() {\\n\\tgl_Position = vec4( position, 1.0 );\\n}\";\n\n\tfunction WebGLShadowMap(_renderer, _objects, _capabilities) {\n\t\tlet _frustum = new Frustum();\n\n\t\tconst _shadowMapSize = new Vector2(),\n\t\t\t\t\t_viewportSize = new Vector2(),\n\t\t\t\t\t_viewport = new Vector4(),\n\t\t\t\t\t_depthMaterials = [],\n\t\t\t\t\t_distanceMaterials = [],\n\t\t\t\t\t_materialCache = {},\n\t\t\t\t\t_maxTextureSize = _capabilities.maxTextureSize;\n\n\t\tconst shadowSide = {\n\t\t\t0: BackSide,\n\t\t\t1: FrontSide,\n\t\t\t2: DoubleSide\n\t\t};\n\t\tconst shadowMaterialVertical = new ShaderMaterial({\n\t\t\tdefines: {\n\t\t\t\tSAMPLE_RATE: 2.0 / 8.0,\n\t\t\t\tHALF_SAMPLE_RATE: 1.0 / 8.0\n\t\t\t},\n\t\t\tuniforms: {\n\t\t\t\tshadow_pass: {\n\t\t\t\t\tvalue: null\n\t\t\t\t},\n\t\t\t\tresolution: {\n\t\t\t\t\tvalue: new Vector2()\n\t\t\t\t},\n\t\t\t\tradius: {\n\t\t\t\t\tvalue: 4.0\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: vsm_vert,\n\t\t\tfragmentShader: vsm_frag\n\t\t});\n\t\tconst shadowMaterialHorizontal = shadowMaterialVertical.clone();\n\t\tshadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n\t\tconst fullScreenTri = new BufferGeometry();\n\t\tfullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));\n\t\tconst fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);\n\t\tconst scope = this;\n\t\tthis.enabled = false;\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\t\tthis.type = PCFShadowMap;\n\n\t\tthis.render = function (lights, scene, camera) {\n\t\t\tif (scope.enabled === false) return;\n\t\t\tif (scope.autoUpdate === false && scope.needsUpdate === false) return;\n\t\t\tif (lights.length === 0) return;\n\n\t\t\tconst currentRenderTarget = _renderer.getRenderTarget();\n\n\t\t\tconst activeCubeFace = _renderer.getActiveCubeFace();\n\n\t\t\tconst activeMipmapLevel = _renderer.getActiveMipmapLevel();\n\n\t\t\tconst _state = _renderer.state; // Set GL state for depth map.\n\n\t\t\t_state.setBlending(NoBlending);\n\n\t\t\t_state.buffers.color.setClear(1, 1, 1, 1);\n\n\t\t\t_state.buffers.depth.setTest(true);\n\n\t\t\t_state.setScissorTest(false); // render depth map\n\n\n\t\t\tfor (let i = 0, il = lights.length; i < il; i++) {\n\t\t\t\tconst light = lights[i];\n\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\tif (shadow === undefined) {\n\t\t\t\t\tconsole.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;\n\n\t\t\t\t_shadowMapSize.copy(shadow.mapSize);\n\n\t\t\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t\t\t_shadowMapSize.multiply(shadowFrameExtents);\n\n\t\t\t\t_viewportSize.copy(shadow.mapSize);\n\n\t\t\t\tif (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {\n\t\t\t\t\tif (_shadowMapSize.x > _maxTextureSize) {\n\t\t\t\t\t\t_viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);\n\t\t\t\t\t\t_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n\t\t\t\t\t\tshadow.mapSize.x = _viewportSize.x;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_shadowMapSize.y > _maxTextureSize) {\n\t\t\t\t\t\t_viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);\n\t\t\t\t\t\t_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n\t\t\t\t\t\tshadow.mapSize.y = _viewportSize.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {\n\t\t\t\t\tconst pars = {\n\t\t\t\t\t\tminFilter: LinearFilter,\n\t\t\t\t\t\tmagFilter: LinearFilter,\n\t\t\t\t\t\tformat: RGBAFormat\n\t\t\t\t\t};\n\t\t\t\t\tshadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n\t\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\n\t\t\t\t\tshadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n\t\t\t\t\tshadow.camera.updateProjectionMatrix();\n\t\t\t\t}\n\n\t\t\t\tif (shadow.map === null) {\n\t\t\t\t\tconst pars = {\n\t\t\t\t\t\tminFilter: NearestFilter,\n\t\t\t\t\t\tmagFilter: NearestFilter,\n\t\t\t\t\t\tformat: RGBAFormat\n\t\t\t\t\t};\n\t\t\t\t\tshadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n\t\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\n\t\t\t\t\tshadow.camera.updateProjectionMatrix();\n\t\t\t\t}\n\n\t\t\t\t_renderer.setRenderTarget(shadow.map);\n\n\t\t\t\t_renderer.clear();\n\n\t\t\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\t\t\tfor (let vp = 0; vp < viewportCount; vp++) {\n\t\t\t\t\tconst viewport = shadow.getViewport(vp);\n\n\t\t\t\t\t_viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);\n\n\t\t\t\t\t_state.viewport(_viewport);\n\n\t\t\t\t\tshadow.updateMatrices(light, vp);\n\t\t\t\t\t_frustum = shadow.getFrustum();\n\t\t\t\t\trenderObject(scene, camera, shadow.camera, light, this.type);\n\t\t\t\t} // do blur pass for VSM\n\n\n\t\t\t\tif (!shadow.isPointLightShadow && this.type === VSMShadowMap) {\n\t\t\t\t\tVSMPass(shadow, camera);\n\t\t\t\t}\n\n\t\t\t\tshadow.needsUpdate = false;\n\t\t\t}\n\n\t\t\tscope.needsUpdate = false;\n\n\t\t\t_renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);\n\t\t};\n\n\t\tfunction VSMPass(shadow, camera) {\n\t\t\tconst geometry = _objects.update(fullScreenMesh); // vertical pass\n\n\n\t\t\tshadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n\t\t\tshadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n\t\t\tshadowMaterialVertical.uniforms.radius.value = shadow.radius;\n\n\t\t\t_renderer.setRenderTarget(shadow.mapPass);\n\n\t\t\t_renderer.clear();\n\n\t\t\t_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizontal pass\n\n\n\t\t\tshadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n\t\t\tshadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n\t\t\tshadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n\n\t\t\t_renderer.setRenderTarget(shadow.map);\n\n\t\t\t_renderer.clear();\n\n\t\t\t_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);\n\t\t}\n\n\t\tfunction getDepthMaterialVariant(useMorphing) {\n\t\t\tconst index = useMorphing << 0;\n\t\t\tlet material = _depthMaterials[index];\n\n\t\t\tif (material === undefined) {\n\t\t\t\tmaterial = new MeshDepthMaterial({\n\t\t\t\t\tdepthPacking: RGBADepthPacking,\n\t\t\t\t\tmorphTargets: useMorphing\n\t\t\t\t});\n\t\t\t\t_depthMaterials[index] = material;\n\t\t\t}\n\n\t\t\treturn material;\n\t\t}\n\n\t\tfunction getDistanceMaterialVariant(useMorphing) {\n\t\t\tconst index = useMorphing << 0;\n\t\t\tlet material = _distanceMaterials[index];\n\n\t\t\tif (material === undefined) {\n\t\t\t\tmaterial = new MeshDistanceMaterial({\n\t\t\t\t\tmorphTargets: useMorphing\n\t\t\t\t});\n\t\t\t\t_distanceMaterials[index] = material;\n\t\t\t}\n\n\t\t\treturn material;\n\t\t}\n\n\t\tfunction getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {\n\t\t\tlet result = null;\n\t\t\tlet getMaterialVariant = getDepthMaterialVariant;\n\t\t\tlet customMaterial = object.customDepthMaterial;\n\n\t\t\tif (light.isPointLight === true) {\n\t\t\t\tgetMaterialVariant = getDistanceMaterialVariant;\n\t\t\t\tcustomMaterial = object.customDistanceMaterial;\n\t\t\t}\n\n\t\t\tif (customMaterial === undefined) {\n\t\t\t\tlet useMorphing = false;\n\n\t\t\t\tif (material.morphTargets === true) {\n\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\t\t\t\t}\n\n\t\t\t\tresult = getMaterialVariant(useMorphing);\n\t\t\t} else {\n\t\t\t\tresult = customMaterial;\n\t\t\t}\n\n\t\t\tif (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {\n\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t// appropriate state\n\t\t\t\tconst keyA = result.uuid,\n\t\t\t\t\t\t\tkeyB = material.uuid;\n\t\t\t\tlet materialsForVariant = _materialCache[keyA];\n\n\t\t\t\tif (materialsForVariant === undefined) {\n\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t_materialCache[keyA] = materialsForVariant;\n\t\t\t\t}\n\n\t\t\t\tlet cachedMaterial = materialsForVariant[keyB];\n\n\t\t\t\tif (cachedMaterial === undefined) {\n\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\tmaterialsForVariant[keyB] = cachedMaterial;\n\t\t\t\t}\n\n\t\t\t\tresult = cachedMaterial;\n\t\t\t}\n\n\t\t\tresult.visible = material.visible;\n\t\t\tresult.wireframe = material.wireframe;\n\n\t\t\tif (type === VSMShadowMap) {\n\t\t\t\tresult.side = material.shadowSide !== null ? material.shadowSide : material.side;\n\t\t\t} else {\n\t\t\t\tresult.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];\n\t\t\t}\n\n\t\t\tresult.clipShadows = material.clipShadows;\n\t\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\t\tresult.clipIntersection = material.clipIntersection;\n\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\t\tresult.linewidth = material.linewidth;\n\n\t\t\tif (light.isPointLight === true && result.isMeshDistanceMaterial === true) {\n\t\t\t\tresult.referencePosition.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\tresult.nearDistance = shadowCameraNear;\n\t\t\t\tresult.farDistance = shadowCameraFar;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction renderObject(object, camera, shadowCamera, light, type) {\n\t\t\tif (object.visible === false) return;\n\t\t\tconst visible = object.layers.test(camera.layers);\n\n\t\t\tif (visible && (object.isMesh || object.isLine || object.isPoints)) {\n\t\t\t\tif ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {\n\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);\n\n\t\t\t\t\tconst geometry = _objects.update(object);\n\n\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\tif (Array.isArray(material)) {\n\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\tfor (let k = 0, kl = groups.length; k < kl; k++) {\n\t\t\t\t\t\t\tconst group = groups[k];\n\t\t\t\t\t\t\tconst groupMaterial = material[group.materialIndex];\n\n\t\t\t\t\t\t\tif (groupMaterial && groupMaterial.visible) {\n\t\t\t\t\t\t\t\tconst depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);\n\n\t\t\t\t\t\t\t\t_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (material.visible) {\n\t\t\t\t\t\tconst depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);\n\n\t\t\t\t\t\t_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst children = object.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\trenderObject(children[i], camera, shadowCamera, light, type);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction WebGLState(gl, extensions, capabilities) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\n\t\tfunction ColorBuffer() {\n\t\t\tlet locked = false;\n\t\t\tconst color = new Vector4();\n\t\t\tlet currentColorMask = null;\n\t\t\tconst currentColorClear = new Vector4(0, 0, 0, 0);\n\t\t\treturn {\n\t\t\t\tsetMask: function (colorMask) {\n\t\t\t\t\tif (currentColorMask !== colorMask && !locked) {\n\t\t\t\t\t\tgl.colorMask(colorMask, colorMask, colorMask, colorMask);\n\t\t\t\t\t\tcurrentColorMask = colorMask;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetLocked: function (lock) {\n\t\t\t\t\tlocked = lock;\n\t\t\t\t},\n\t\t\t\tsetClear: function (r, g, b, a, premultipliedAlpha) {\n\t\t\t\t\tif (premultipliedAlpha === true) {\n\t\t\t\t\t\tr *= a;\n\t\t\t\t\t\tg *= a;\n\t\t\t\t\t\tb *= a;\n\t\t\t\t\t}\n\n\t\t\t\t\tcolor.set(r, g, b, a);\n\n\t\t\t\t\tif (currentColorClear.equals(color) === false) {\n\t\t\t\t\t\tgl.clearColor(r, g, b, a);\n\t\t\t\t\t\tcurrentColorClear.copy(color);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treset: function () {\n\t\t\t\t\tlocked = false;\n\t\t\t\t\tcurrentColorMask = null;\n\t\t\t\t\tcurrentColorClear.set(-1, 0, 0, 0); // set to invalid state\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction DepthBuffer() {\n\t\t\tlet locked = false;\n\t\t\tlet currentDepthMask = null;\n\t\t\tlet currentDepthFunc = null;\n\t\t\tlet currentDepthClear = null;\n\t\t\treturn {\n\t\t\t\tsetTest: function (depthTest) {\n\t\t\t\t\tif (depthTest) {\n\t\t\t\t\t\tenable(gl.DEPTH_TEST);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisable(gl.DEPTH_TEST);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetMask: function (depthMask) {\n\t\t\t\t\tif (currentDepthMask !== depthMask && !locked) {\n\t\t\t\t\t\tgl.depthMask(depthMask);\n\t\t\t\t\t\tcurrentDepthMask = depthMask;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetFunc: function (depthFunc) {\n\t\t\t\t\tif (currentDepthFunc !== depthFunc) {\n\t\t\t\t\t\tif (depthFunc) {\n\t\t\t\t\t\t\tswitch (depthFunc) {\n\t\t\t\t\t\t\t\tcase NeverDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.NEVER);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase AlwaysDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.ALWAYS);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.LESS);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessEqualDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.LEQUAL);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase EqualDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.EQUAL);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.GEQUAL);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.GREATER);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase NotEqualDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.NOTEQUAL);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.LEQUAL);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgl.depthFunc(gl.LEQUAL);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetLocked: function (lock) {\n\t\t\t\t\tlocked = lock;\n\t\t\t\t},\n\t\t\t\tsetClear: function (depth) {\n\t\t\t\t\tif (currentDepthClear !== depth) {\n\t\t\t\t\t\tgl.clearDepth(depth);\n\t\t\t\t\t\tcurrentDepthClear = depth;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treset: function () {\n\t\t\t\t\tlocked = false;\n\t\t\t\t\tcurrentDepthMask = null;\n\t\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\t\tcurrentDepthClear = null;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction StencilBuffer() {\n\t\t\tlet locked = false;\n\t\t\tlet currentStencilMask = null;\n\t\t\tlet currentStencilFunc = null;\n\t\t\tlet currentStencilRef = null;\n\t\t\tlet currentStencilFuncMask = null;\n\t\t\tlet currentStencilFail = null;\n\t\t\tlet currentStencilZFail = null;\n\t\t\tlet currentStencilZPass = null;\n\t\t\tlet currentStencilClear = null;\n\t\t\treturn {\n\t\t\t\tsetTest: function (stencilTest) {\n\t\t\t\t\tif (!locked) {\n\t\t\t\t\t\tif (stencilTest) {\n\t\t\t\t\t\t\tenable(gl.STENCIL_TEST);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdisable(gl.STENCIL_TEST);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetMask: function (stencilMask) {\n\t\t\t\t\tif (currentStencilMask !== stencilMask && !locked) {\n\t\t\t\t\t\tgl.stencilMask(stencilMask);\n\t\t\t\t\t\tcurrentStencilMask = stencilMask;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetFunc: function (stencilFunc, stencilRef, stencilMask) {\n\t\t\t\t\tif (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {\n\t\t\t\t\t\tgl.stencilFunc(stencilFunc, stencilRef, stencilMask);\n\t\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\t\tcurrentStencilRef = stencilRef;\n\t\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetOp: function (stencilFail, stencilZFail, stencilZPass) {\n\t\t\t\t\tif (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {\n\t\t\t\t\t\tgl.stencilOp(stencilFail, stencilZFail, stencilZPass);\n\t\t\t\t\t\tcurrentStencilFail = stencilFail;\n\t\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetLocked: function (lock) {\n\t\t\t\t\tlocked = lock;\n\t\t\t\t},\n\t\t\t\tsetClear: function (stencil) {\n\t\t\t\t\tif (currentStencilClear !== stencil) {\n\t\t\t\t\t\tgl.clearStencil(stencil);\n\t\t\t\t\t\tcurrentStencilClear = stencil;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treset: function () {\n\t\t\t\t\tlocked = false;\n\t\t\t\t\tcurrentStencilMask = null;\n\t\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\t\tcurrentStencilRef = null;\n\t\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\t\tcurrentStencilFail = null;\n\t\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\t\tcurrentStencilClear = null;\n\t\t\t\t}\n\t\t\t};\n\t\t} //\n\n\n\t\tconst colorBuffer = new ColorBuffer();\n\t\tconst depthBuffer = new DepthBuffer();\n\t\tconst stencilBuffer = new StencilBuffer();\n\t\tlet enabledCapabilities = {};\n\t\tlet xrFramebuffer = null;\n\t\tlet currentBoundFramebuffers = {};\n\t\tlet currentProgram = null;\n\t\tlet currentBlendingEnabled = false;\n\t\tlet currentBlending = null;\n\t\tlet currentBlendEquation = null;\n\t\tlet currentBlendSrc = null;\n\t\tlet currentBlendDst = null;\n\t\tlet currentBlendEquationAlpha = null;\n\t\tlet currentBlendSrcAlpha = null;\n\t\tlet currentBlendDstAlpha = null;\n\t\tlet currentPremultipledAlpha = false;\n\t\tlet currentFlipSided = null;\n\t\tlet currentCullFace = null;\n\t\tlet currentLineWidth = null;\n\t\tlet currentPolygonOffsetFactor = null;\n\t\tlet currentPolygonOffsetUnits = null;\n\t\tconst maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n\t\tlet lineWidthAvailable = false;\n\t\tlet version = 0;\n\t\tconst glVersion = gl.getParameter(gl.VERSION);\n\n\t\tif (glVersion.indexOf('WebGL') !== -1) {\n\t\t\tversion = parseFloat(/^WebGL (\\d)/.exec(glVersion)[1]);\n\t\t\tlineWidthAvailable = version >= 1.0;\n\t\t} else if (glVersion.indexOf('OpenGL ES') !== -1) {\n\t\t\tversion = parseFloat(/^OpenGL ES (\\d)/.exec(glVersion)[1]);\n\t\t\tlineWidthAvailable = version >= 2.0;\n\t\t}\n\n\t\tlet currentTextureSlot = null;\n\t\tlet currentBoundTextures = {};\n\t\tconst scissorParam = gl.getParameter(gl.SCISSOR_BOX);\n\t\tconst viewportParam = gl.getParameter(gl.VIEWPORT);\n\t\tconst currentScissor = new Vector4().fromArray(scissorParam);\n\t\tconst currentViewport = new Vector4().fromArray(viewportParam);\n\n\t\tfunction createTexture(type, target, count) {\n\t\t\tconst data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.\n\n\t\t\tconst texture = gl.createTexture();\n\t\t\tgl.bindTexture(type, texture);\n\t\t\tgl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\t\t\tgl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tgl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t}\n\n\t\tconst emptyTextures = {};\n\t\temptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);\n\t\temptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6); // init\n\n\t\tcolorBuffer.setClear(0, 0, 0, 1);\n\t\tdepthBuffer.setClear(1);\n\t\tstencilBuffer.setClear(0);\n\t\tenable(gl.DEPTH_TEST);\n\t\tdepthBuffer.setFunc(LessEqualDepth);\n\t\tsetFlipSided(false);\n\t\tsetCullFace(CullFaceBack);\n\t\tenable(gl.CULL_FACE);\n\t\tsetBlending(NoBlending); //\n\n\t\tfunction enable(id) {\n\t\t\tif (enabledCapabilities[id] !== true) {\n\t\t\t\tgl.enable(id);\n\t\t\t\tenabledCapabilities[id] = true;\n\t\t\t}\n\t\t}\n\n\t\tfunction disable(id) {\n\t\t\tif (enabledCapabilities[id] !== false) {\n\t\t\t\tgl.disable(id);\n\t\t\t\tenabledCapabilities[id] = false;\n\t\t\t}\n\t\t}\n\n\t\tfunction bindXRFramebuffer(framebuffer) {\n\t\t\tif (framebuffer !== xrFramebuffer) {\n\t\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\t\t\t\txrFramebuffer = framebuffer;\n\t\t\t}\n\t\t}\n\n\t\tfunction bindFramebuffer(target, framebuffer) {\n\t\t\tif (framebuffer === null && xrFramebuffer !== null) framebuffer = xrFramebuffer; // use active XR framebuffer if available\n\n\t\t\tif (currentBoundFramebuffers[target] !== framebuffer) {\n\t\t\t\tgl.bindFramebuffer(target, framebuffer);\n\t\t\t\tcurrentBoundFramebuffers[target] = framebuffer;\n\n\t\t\t\tif (isWebGL2) {\n\t\t\t\t\t// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER\n\t\t\t\t\tif (target === gl.DRAW_FRAMEBUFFER) {\n\t\t\t\t\t\tcurrentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (target === gl.FRAMEBUFFER) {\n\t\t\t\t\t\tcurrentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction useProgram(program) {\n\t\t\tif (currentProgram !== program) {\n\t\t\t\tgl.useProgram(program);\n\t\t\t\tcurrentProgram = program;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tconst equationToGL = {\n\t\t\t[AddEquation]: gl.FUNC_ADD,\n\t\t\t[SubtractEquation]: gl.FUNC_SUBTRACT,\n\t\t\t[ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT\n\t\t};\n\n\t\tif (isWebGL2) {\n\t\t\tequationToGL[MinEquation] = gl.MIN;\n\t\t\tequationToGL[MaxEquation] = gl.MAX;\n\t\t} else {\n\t\t\tconst extension = extensions.get('EXT_blend_minmax');\n\n\t\t\tif (extension !== null) {\n\t\t\t\tequationToGL[MinEquation] = extension.MIN_EXT;\n\t\t\t\tequationToGL[MaxEquation] = extension.MAX_EXT;\n\t\t\t}\n\t\t}\n\n\t\tconst factorToGL = {\n\t\t\t[ZeroFactor]: gl.ZERO,\n\t\t\t[OneFactor]: gl.ONE,\n\t\t\t[SrcColorFactor]: gl.SRC_COLOR,\n\t\t\t[SrcAlphaFactor]: gl.SRC_ALPHA,\n\t\t\t[SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,\n\t\t\t[DstColorFactor]: gl.DST_COLOR,\n\t\t\t[DstAlphaFactor]: gl.DST_ALPHA,\n\t\t\t[OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,\n\t\t\t[OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,\n\t\t\t[OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,\n\t\t\t[OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA\n\t\t};\n\n\t\tfunction setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {\n\t\t\tif (blending === NoBlending) {\n\t\t\t\tif (currentBlendingEnabled === true) {\n\t\t\t\t\tdisable(gl.BLEND);\n\t\t\t\t\tcurrentBlendingEnabled = false;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (currentBlendingEnabled === false) {\n\t\t\t\tenable(gl.BLEND);\n\t\t\t\tcurrentBlendingEnabled = true;\n\t\t\t}\n\n\t\t\tif (blending !== CustomBlending) {\n\t\t\t\tif (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {\n\t\t\t\t\tif (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {\n\t\t\t\t\t\tgl.blendEquation(gl.FUNC_ADD);\n\t\t\t\t\t\tcurrentBlendEquation = AddEquation;\n\t\t\t\t\t\tcurrentBlendEquationAlpha = AddEquation;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (premultipliedAlpha) {\n\t\t\t\t\t\tswitch (blending) {\n\t\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\t\tgl.blendFunc(gl.ONE, gl.ONE);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.error('THREE.WebGLState: Invalid blending: ', blending);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch (blending) {\n\t\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\t\tgl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\t\tgl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\t\tgl.blendFunc(gl.ZERO, gl.SRC_COLOR);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.error('THREE.WebGLState: Invalid blending: ', blending);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\t\tcurrentBlendDst = null;\n\t\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\t\tcurrentBlendDstAlpha = null;\n\t\t\t\t\tcurrentBlending = blending;\n\t\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t} // custom blending\n\n\n\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\t\tif (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {\n\t\t\t\tgl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);\n\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\t\t\t}\n\n\t\t\tif (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {\n\t\t\t\tgl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);\n\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\t\t\t}\n\n\t\t\tcurrentBlending = blending;\n\t\t\tcurrentPremultipledAlpha = null;\n\t\t}\n\n\t\tfunction setMaterial(material, frontFaceCW) {\n\t\t\tmaterial.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);\n\t\t\tlet flipSided = material.side === BackSide;\n\t\t\tif (frontFaceCW) flipSided = !flipSided;\n\t\t\tsetFlipSided(flipSided);\n\t\t\tmaterial.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);\n\t\t\tdepthBuffer.setFunc(material.depthFunc);\n\t\t\tdepthBuffer.setTest(material.depthTest);\n\t\t\tdepthBuffer.setMask(material.depthWrite);\n\t\t\tcolorBuffer.setMask(material.colorWrite);\n\t\t\tconst stencilWrite = material.stencilWrite;\n\t\t\tstencilBuffer.setTest(stencilWrite);\n\n\t\t\tif (stencilWrite) {\n\t\t\t\tstencilBuffer.setMask(material.stencilWriteMask);\n\t\t\t\tstencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);\n\t\t\t\tstencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);\n\t\t\t}\n\n\t\t\tsetPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);\n\t\t\tmaterial.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n\t\t} //\n\n\n\t\tfunction setFlipSided(flipSided) {\n\t\t\tif (currentFlipSided !== flipSided) {\n\t\t\t\tif (flipSided) {\n\t\t\t\t\tgl.frontFace(gl.CW);\n\t\t\t\t} else {\n\t\t\t\t\tgl.frontFace(gl.CCW);\n\t\t\t\t}\n\n\t\t\t\tcurrentFlipSided = flipSided;\n\t\t\t}\n\t\t}\n\n\t\tfunction setCullFace(cullFace) {\n\t\t\tif (cullFace !== CullFaceNone) {\n\t\t\t\tenable(gl.CULL_FACE);\n\n\t\t\t\tif (cullFace !== currentCullFace) {\n\t\t\t\t\tif (cullFace === CullFaceBack) {\n\t\t\t\t\t\tgl.cullFace(gl.BACK);\n\t\t\t\t\t} else if (cullFace === CullFaceFront) {\n\t\t\t\t\t\tgl.cullFace(gl.FRONT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgl.cullFace(gl.FRONT_AND_BACK);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdisable(gl.CULL_FACE);\n\t\t\t}\n\n\t\t\tcurrentCullFace = cullFace;\n\t\t}\n\n\t\tfunction setLineWidth(width) {\n\t\t\tif (width !== currentLineWidth) {\n\t\t\t\tif (lineWidthAvailable) gl.lineWidth(width);\n\t\t\t\tcurrentLineWidth = width;\n\t\t\t}\n\t\t}\n\n\t\tfunction setPolygonOffset(polygonOffset, factor, units) {\n\t\t\tif (polygonOffset) {\n\t\t\t\tenable(gl.POLYGON_OFFSET_FILL);\n\n\t\t\t\tif (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {\n\t\t\t\t\tgl.polygonOffset(factor, units);\n\t\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\t\tcurrentPolygonOffsetUnits = units;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdisable(gl.POLYGON_OFFSET_FILL);\n\t\t\t}\n\t\t}\n\n\t\tfunction setScissorTest(scissorTest) {\n\t\t\tif (scissorTest) {\n\t\t\t\tenable(gl.SCISSOR_TEST);\n\t\t\t} else {\n\t\t\t\tdisable(gl.SCISSOR_TEST);\n\t\t\t}\n\t\t} // texture\n\n\n\t\tfunction activeTexture(webglSlot) {\n\t\t\tif (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\tif (currentTextureSlot !== webglSlot) {\n\t\t\t\tgl.activeTexture(webglSlot);\n\t\t\t\tcurrentTextureSlot = webglSlot;\n\t\t\t}\n\t\t}\n\n\t\tfunction bindTexture(webglType, webglTexture) {\n\t\t\tif (currentTextureSlot === null) {\n\t\t\t\tactiveTexture();\n\t\t\t}\n\n\t\t\tlet boundTexture = currentBoundTextures[currentTextureSlot];\n\n\t\t\tif (boundTexture === undefined) {\n\t\t\t\tboundTexture = {\n\t\t\t\t\ttype: undefined,\n\t\t\t\t\ttexture: undefined\n\t\t\t\t};\n\t\t\t\tcurrentBoundTextures[currentTextureSlot] = boundTexture;\n\t\t\t}\n\n\t\t\tif (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {\n\t\t\t\tgl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);\n\t\t\t\tboundTexture.type = webglType;\n\t\t\t\tboundTexture.texture = webglTexture;\n\t\t\t}\n\t\t}\n\n\t\tfunction unbindTexture() {\n\t\t\tconst boundTexture = currentBoundTextures[currentTextureSlot];\n\n\t\t\tif (boundTexture !== undefined && boundTexture.type !== undefined) {\n\t\t\t\tgl.bindTexture(boundTexture.type, null);\n\t\t\t\tboundTexture.type = undefined;\n\t\t\t\tboundTexture.texture = undefined;\n\t\t\t}\n\t\t}\n\n\t\tfunction compressedTexImage2D() {\n\t\t\ttry {\n\t\t\t\tgl.compressedTexImage2D.apply(gl, arguments);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('THREE.WebGLState:', error);\n\t\t\t}\n\t\t}\n\n\t\tfunction texImage2D() {\n\t\t\ttry {\n\t\t\t\tgl.texImage2D.apply(gl, arguments);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('THREE.WebGLState:', error);\n\t\t\t}\n\t\t}\n\n\t\tfunction texImage3D() {\n\t\t\ttry {\n\t\t\t\tgl.texImage3D.apply(gl, arguments);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('THREE.WebGLState:', error);\n\t\t\t}\n\t\t} //\n\n\n\t\tfunction scissor(scissor) {\n\t\t\tif (currentScissor.equals(scissor) === false) {\n\t\t\t\tgl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);\n\t\t\t\tcurrentScissor.copy(scissor);\n\t\t\t}\n\t\t}\n\n\t\tfunction viewport(viewport) {\n\t\t\tif (currentViewport.equals(viewport) === false) {\n\t\t\t\tgl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);\n\t\t\t\tcurrentViewport.copy(viewport);\n\t\t\t}\n\t\t} //\n\n\n\t\tfunction reset() {\n\t\t\t// reset state\n\t\t\tgl.disable(gl.BLEND);\n\t\t\tgl.disable(gl.CULL_FACE);\n\t\t\tgl.disable(gl.DEPTH_TEST);\n\t\t\tgl.disable(gl.POLYGON_OFFSET_FILL);\n\t\t\tgl.disable(gl.SCISSOR_TEST);\n\t\t\tgl.disable(gl.STENCIL_TEST);\n\t\t\tgl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n\t\t\tgl.blendEquation(gl.FUNC_ADD);\n\t\t\tgl.blendFunc(gl.ONE, gl.ZERO);\n\t\t\tgl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);\n\t\t\tgl.colorMask(true, true, true, true);\n\t\t\tgl.clearColor(0, 0, 0, 0);\n\t\t\tgl.depthMask(true);\n\t\t\tgl.depthFunc(gl.LESS);\n\t\t\tgl.clearDepth(1);\n\t\t\tgl.stencilMask(0xffffffff);\n\t\t\tgl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);\n\t\t\tgl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n\t\t\tgl.clearStencil(0);\n\t\t\tgl.cullFace(gl.BACK);\n\t\t\tgl.frontFace(gl.CCW);\n\t\t\tgl.polygonOffset(0, 0);\n\t\t\tgl.activeTexture(gl.TEXTURE0);\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n\t\t\tif (isWebGL2 === true) {\n\t\t\t\tgl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);\n\t\t\t\tgl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n\t\t\t}\n\n\t\t\tgl.useProgram(null);\n\t\t\tgl.lineWidth(1);\n\t\t\tgl.scissor(0, 0, gl.canvas.width, gl.canvas.height);\n\t\t\tgl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // reset internals\n\n\t\t\tenabledCapabilities = {};\n\t\t\tcurrentTextureSlot = null;\n\t\t\tcurrentBoundTextures = {};\n\t\t\txrFramebuffer = null;\n\t\t\tcurrentBoundFramebuffers = {};\n\t\t\tcurrentProgram = null;\n\t\t\tcurrentBlendingEnabled = false;\n\t\t\tcurrentBlending = null;\n\t\t\tcurrentBlendEquation = null;\n\t\t\tcurrentBlendSrc = null;\n\t\t\tcurrentBlendDst = null;\n\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\tcurrentBlendDstAlpha = null;\n\t\t\tcurrentPremultipledAlpha = false;\n\t\t\tcurrentFlipSided = null;\n\t\t\tcurrentCullFace = null;\n\t\t\tcurrentLineWidth = null;\n\t\t\tcurrentPolygonOffsetFactor = null;\n\t\t\tcurrentPolygonOffsetUnits = null;\n\t\t\tcurrentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);\n\t\t\tcurrentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);\n\t\t\tcolorBuffer.reset();\n\t\t\tdepthBuffer.reset();\n\t\t\tstencilBuffer.reset();\n\t\t}\n\n\t\treturn {\n\t\t\tbuffers: {\n\t\t\t\tcolor: colorBuffer,\n\t\t\t\tdepth: depthBuffer,\n\t\t\t\tstencil: stencilBuffer\n\t\t\t},\n\t\t\tenable: enable,\n\t\t\tdisable: disable,\n\t\t\tbindFramebuffer: bindFramebuffer,\n\t\t\tbindXRFramebuffer: bindXRFramebuffer,\n\t\t\tuseProgram: useProgram,\n\t\t\tsetBlending: setBlending,\n\t\t\tsetMaterial: setMaterial,\n\t\t\tsetFlipSided: setFlipSided,\n\t\t\tsetCullFace: setCullFace,\n\t\t\tsetLineWidth: setLineWidth,\n\t\t\tsetPolygonOffset: setPolygonOffset,\n\t\t\tsetScissorTest: setScissorTest,\n\t\t\tactiveTexture: activeTexture,\n\t\t\tbindTexture: bindTexture,\n\t\t\tunbindTexture: unbindTexture,\n\t\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\t\ttexImage2D: texImage2D,\n\t\t\ttexImage3D: texImage3D,\n\t\t\tscissor: scissor,\n\t\t\tviewport: viewport,\n\t\t\treset: reset\n\t\t};\n\t}\n\n\tfunction WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\t\tconst maxTextures = capabilities.maxTextures;\n\t\tconst maxCubemapSize = capabilities.maxCubemapSize;\n\t\tconst maxTextureSize = capabilities.maxTextureSize;\n\t\tconst maxSamples = capabilities.maxSamples;\n\n\t\tconst _videoTextures = new WeakMap();\n\n\t\tlet _canvas; // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,\n\t\t// also OffscreenCanvas.getContext(\"webgl\"), but not OffscreenCanvas.getContext(\"2d\")!\n\t\t// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).\n\n\n\t\tlet useOffscreenCanvas = false;\n\n\t\ttry {\n\t\t\tuseOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;\n\t\t} catch (err) {// Ignore any errors\n\t\t}\n\n\t\tfunction createCanvas(width, height) {\n\t\t\t// Use OffscreenCanvas when available. Specially needed in web workers\n\t\t\treturn useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');\n\t\t}\n\n\t\tfunction resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {\n\t\t\tlet scale = 1; // handle case if texture exceeds max size\n\n\t\t\tif (image.width > maxSize || image.height > maxSize) {\n\t\t\t\tscale = maxSize / Math.max(image.width, image.height);\n\t\t\t} // only perform resize if necessary\n\n\n\t\t\tif (scale < 1 || needsPowerOfTwo === true) {\n\t\t\t\t// only perform resize for certain image types\n\t\t\t\tif (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n\t\t\t\t\tconst floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;\n\t\t\t\t\tconst width = floor(scale * image.width);\n\t\t\t\t\tconst height = floor(scale * image.height);\n\t\t\t\t\tif (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas\n\n\t\t\t\t\tconst canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;\n\t\t\t\t\tcanvas.width = width;\n\t\t\t\t\tcanvas.height = height;\n\t\t\t\t\tconst context = canvas.getContext('2d');\n\t\t\t\t\tcontext.drawImage(image, 0, 0, width, height);\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');\n\t\t\t\t\treturn canvas;\n\t\t\t\t} else {\n\t\t\t\t\tif ('data' in image) {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn image;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn image;\n\t\t}\n\n\t\tfunction isPowerOfTwo$1(image) {\n\t\t\treturn isPowerOfTwo(image.width) && isPowerOfTwo(image.height);\n\t\t}\n\n\t\tfunction textureNeedsPowerOfTwo(texture) {\n\t\t\tif (isWebGL2) return false;\n\t\t\treturn texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\t\t}\n\n\t\tfunction textureNeedsGenerateMipmaps(texture, supportsMips) {\n\t\t\treturn texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\t\t}\n\n\t\tfunction generateMipmap(target, texture, width, height) {\n\t\t\t_gl.generateMipmap(target);\n\n\t\t\tconst textureProperties = properties.get(texture);\n\t\t\ttextureProperties.__maxMipLevel = Math.log2(Math.max(width, height));\n\t\t}\n\n\t\tfunction getInternalFormat(internalFormatName, glFormat, glType) {\n\t\t\tif (isWebGL2 === false) return glFormat;\n\n\t\t\tif (internalFormatName !== null) {\n\t\t\t\tif (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'');\n\t\t\t}\n\n\t\t\tlet internalFormat = glFormat;\n\n\t\t\tif (glFormat === _gl.RED) {\n\t\t\t\tif (glType === _gl.FLOAT) internalFormat = _gl.R32F;\n\t\t\t\tif (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;\n\t\t\t\tif (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;\n\t\t\t}\n\n\t\t\tif (glFormat === _gl.RGB) {\n\t\t\t\tif (glType === _gl.FLOAT) internalFormat = _gl.RGB32F;\n\t\t\t\tif (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGB16F;\n\t\t\t\tif (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8;\n\t\t\t}\n\n\t\t\tif (glFormat === _gl.RGBA) {\n\t\t\t\tif (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;\n\t\t\t\tif (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;\n\t\t\t\tif (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8;\n\t\t\t}\n\n\t\t\tif (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {\n\t\t\t\textensions.get('EXT_color_buffer_float');\n\t\t\t}\n\n\t\t\treturn internalFormat;\n\t\t} // Fallback filters for non-power-of-2 textures\n\n\n\t\tfunction filterFallback(f) {\n\t\t\tif (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {\n\t\t\t\treturn _gl.NEAREST;\n\t\t\t}\n\n\t\t\treturn _gl.LINEAR;\n\t\t} //\n\n\n\t\tfunction onTextureDispose(event) {\n\t\t\tconst texture = event.target;\n\t\t\ttexture.removeEventListener('dispose', onTextureDispose);\n\t\t\tdeallocateTexture(texture);\n\n\t\t\tif (texture.isVideoTexture) {\n\t\t\t\t_videoTextures.delete(texture);\n\t\t\t}\n\n\t\t\tinfo.memory.textures--;\n\t\t}\n\n\t\tfunction onRenderTargetDispose(event) {\n\t\t\tconst renderTarget = event.target;\n\t\t\trenderTarget.removeEventListener('dispose', onRenderTargetDispose);\n\t\t\tdeallocateRenderTarget(renderTarget);\n\t\t} //\n\n\n\t\tfunction deallocateTexture(texture) {\n\t\t\tconst textureProperties = properties.get(texture);\n\t\t\tif (textureProperties.__webglInit === undefined) return;\n\n\t\t\t_gl.deleteTexture(textureProperties.__webglTexture);\n\n\t\t\tproperties.remove(texture);\n\t\t}\n\n\t\tfunction deallocateRenderTarget(renderTarget) {\n\t\t\tconst texture = renderTarget.texture;\n\t\t\tconst renderTargetProperties = properties.get(renderTarget);\n\t\t\tconst textureProperties = properties.get(texture);\n\t\t\tif (!renderTarget) return;\n\n\t\t\tif (textureProperties.__webglTexture !== undefined) {\n\t\t\t\t_gl.deleteTexture(textureProperties.__webglTexture);\n\n\t\t\t\tinfo.memory.textures--;\n\t\t\t}\n\n\t\t\tif (renderTarget.depthTexture) {\n\t\t\t\trenderTarget.depthTexture.dispose();\n\t\t\t}\n\n\t\t\tif (renderTarget.isWebGLCubeRenderTarget) {\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\t_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);\n\n\t\t\t\t\tif (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);\n\n\t\t\t\tif (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);\n\t\t\t\tif (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);\n\t\t\t\tif (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);\n\t\t\t\tif (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);\n\t\t\t}\n\n\t\t\tif (renderTarget.isWebGLMultipleRenderTargets) {\n\t\t\t\tfor (let i = 0, il = texture.length; i < il; i++) {\n\t\t\t\t\tconst attachmentProperties = properties.get(texture[i]);\n\n\t\t\t\t\tif (attachmentProperties.__webglTexture) {\n\t\t\t\t\t\t_gl.deleteTexture(attachmentProperties.__webglTexture);\n\n\t\t\t\t\t\tinfo.memory.textures--;\n\t\t\t\t\t}\n\n\t\t\t\t\tproperties.remove(texture[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproperties.remove(texture);\n\t\t\tproperties.remove(renderTarget);\n\t\t} //\n\n\n\t\tlet textureUnits = 0;\n\n\t\tfunction resetTextureUnits() {\n\t\t\ttextureUnits = 0;\n\t\t}\n\n\t\tfunction allocateTextureUnit() {\n\t\t\tconst textureUnit = textureUnits;\n\n\t\t\tif (textureUnit >= maxTextures) {\n\t\t\t\tconsole.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);\n\t\t\t}\n\n\t\t\ttextureUnits += 1;\n\t\t\treturn textureUnit;\n\t\t} //\n\n\n\t\tfunction setTexture2D(texture, slot) {\n\t\t\tconst textureProperties = properties.get(texture);\n\t\t\tif (texture.isVideoTexture) updateVideoTexture(texture);\n\n\t\t\tif (texture.version > 0 && textureProperties.__version !== texture.version) {\n\t\t\t\tconst image = texture.image;\n\n\t\t\t\tif (image === undefined) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');\n\t\t\t\t} else if (image.complete === false) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');\n\t\t\t\t} else {\n\t\t\t\t\tuploadTexture(textureProperties, texture, slot);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);\n\t\t}\n\n\t\tfunction setTexture2DArray(texture, slot) {\n\t\t\tconst textureProperties = properties.get(texture);\n\n\t\t\tif (texture.version > 0 && textureProperties.__version !== texture.version) {\n\t\t\t\tuploadTexture(textureProperties, texture, slot);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);\n\t\t}\n\n\t\tfunction setTexture3D(texture, slot) {\n\t\t\tconst textureProperties = properties.get(texture);\n\n\t\t\tif (texture.version > 0 && textureProperties.__version !== texture.version) {\n\t\t\t\tuploadTexture(textureProperties, texture, slot);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);\n\t\t}\n\n\t\tfunction setTextureCube(texture, slot) {\n\t\t\tconst textureProperties = properties.get(texture);\n\n\t\t\tif (texture.version > 0 && textureProperties.__version !== texture.version) {\n\t\t\t\tuploadCubeTexture(textureProperties, texture, slot);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);\n\t\t}\n\n\t\tconst wrappingToGL = {\n\t\t\t[RepeatWrapping]: _gl.REPEAT,\n\t\t\t[ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,\n\t\t\t[MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT\n\t\t};\n\t\tconst filterToGL = {\n\t\t\t[NearestFilter]: _gl.NEAREST,\n\t\t\t[NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,\n\t\t\t[NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,\n\t\t\t[LinearFilter]: _gl.LINEAR,\n\t\t\t[LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,\n\t\t\t[LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR\n\t\t};\n\n\t\tfunction setTextureParameters(textureType, texture, supportsMips) {\n\t\t\tif (supportsMips) {\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);\n\n\t\t\t\tif (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {\n\t\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);\n\t\t\t\t}\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);\n\t\t\t} else {\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);\n\n\t\t\t\tif (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {\n\t\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);\n\t\t\t\t}\n\n\t\t\t\tif (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');\n\t\t\t\t}\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));\n\n\t\t\t\tif (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (extensions.has('EXT_texture_filter_anisotropic') === true) {\n\t\t\t\tconst extension = extensions.get('EXT_texture_filter_anisotropic');\n\t\t\t\tif (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2\n\n\t\t\t\tif (isWebGL2 === false && texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false) return; // verify extension for WebGL 1 only\n\n\t\t\t\tif (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {\n\t\t\t\t\t_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));\n\n\t\t\t\t\tproperties.get(texture).__currentAnisotropy = texture.anisotropy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction initTexture(textureProperties, texture) {\n\t\t\tif (textureProperties.__webglInit === undefined) {\n\t\t\t\ttextureProperties.__webglInit = true;\n\t\t\t\ttexture.addEventListener('dispose', onTextureDispose);\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\t\t\tinfo.memory.textures++;\n\t\t\t}\n\t\t}\n\n\t\tfunction uploadTexture(textureProperties, texture, slot) {\n\t\t\tlet textureType = _gl.TEXTURE_2D;\n\t\t\tif (texture.isDataTexture2DArray) textureType = _gl.TEXTURE_2D_ARRAY;\n\t\t\tif (texture.isDataTexture3D) textureType = _gl.TEXTURE_3D;\n\t\t\tinitTexture(textureProperties, texture);\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(textureType, textureProperties.__webglTexture);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);\n\n\t\t\tconst needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;\n\t\t\tconst image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);\n\t\t\tconst supportsMips = isPowerOfTwo$1(image) || isWebGL2,\n\t\t\t\t\t\tglFormat = utils.convert(texture.format);\n\t\t\tlet glType = utils.convert(texture.type),\n\t\t\t\t\tglInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\t\t\tsetTextureParameters(textureType, texture, supportsMips);\n\t\t\tlet mipmap;\n\t\t\tconst mipmaps = texture.mipmaps;\n\n\t\t\tif (texture.isDepthTexture) {\n\t\t\t\t// populate depth texture with dummy data\n\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT;\n\n\t\t\t\tif (isWebGL2) {\n\t\t\t\t\tif (texture.type === FloatType) {\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT32F;\n\t\t\t\t\t} else if (texture.type === UnsignedIntType) {\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT24;\n\t\t\t\t\t} else if (texture.type === UnsignedInt248Type) {\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH24_STENCIL8;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (texture.type === FloatType) {\n\t\t\t\t\t\tconsole.error('WebGLRenderer: Floating point depth texture requires WebGL2.');\n\t\t\t\t\t}\n\t\t\t\t} // validation checks for WebGL 1\n\n\n\t\t\t\tif (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {\n\t\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t\t// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\tif (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');\n\t\t\t\t\t\ttexture.type = UnsignedShortType;\n\t\t\t\t\t\tglType = utils.convert(texture.type);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {\n\t\t\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\tglInternalFormat = _gl.DEPTH_STENCIL; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t\t// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\n\t\t\t\t\tif (texture.type !== UnsignedInt248Type) {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');\n\t\t\t\t\t\ttexture.type = UnsignedInt248Type;\n\t\t\t\t\t\tglType = utils.convert(texture.type);\n\t\t\t\t\t}\n\t\t\t\t} //\n\n\n\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);\n\t\t\t} else if (texture.isDataTexture) {\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\t\t\tif (mipmaps.length > 0 && supportsMips) {\n\t\t\t\t\tfor (let i = 0, il = mipmaps.length; i < il; i++) {\n\t\t\t\t\t\tmipmap = mipmaps[i];\n\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\t\t\t\t} else {\n\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);\n\t\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\t\t\t\t}\n\t\t\t} else if (texture.isCompressedTexture) {\n\t\t\t\tfor (let i = 0, il = mipmaps.length; i < il; i++) {\n\t\t\t\t\tmipmap = mipmaps[i];\n\n\t\t\t\t\tif (texture.format !== RGBAFormat && texture.format !== RGBFormat) {\n\t\t\t\t\t\tif (glFormat !== null) {\n\t\t\t\t\t\t\tstate.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\t\t\t} else if (texture.isDataTexture2DArray) {\n\t\t\t\tstate.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\t\t\t} else if (texture.isDataTexture3D) {\n\t\t\t\tstate.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\t\t\t} else {\n\t\t\t\t// regular Texture (image, video, canvas)\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\t\t\tif (mipmaps.length > 0 && supportsMips) {\n\t\t\t\t\tfor (let i = 0, il = mipmaps.length; i < il; i++) {\n\t\t\t\t\t\tmipmap = mipmaps[i];\n\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\t\t\t\t} else {\n\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);\n\t\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n\t\t\t\tgenerateMipmap(textureType, texture, image.width, image.height);\n\t\t\t}\n\n\t\t\ttextureProperties.__version = texture.version;\n\t\t\tif (texture.onUpdate) texture.onUpdate(texture);\n\t\t}\n\n\t\tfunction uploadCubeTexture(textureProperties, texture, slot) {\n\t\t\tif (texture.image.length !== 6) return;\n\t\t\tinitTexture(textureProperties, texture);\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);\n\n\t\t\tconst isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);\n\t\t\tconst isDataTexture = texture.image[0] && texture.image[0].isDataTexture;\n\t\t\tconst cubeImage = [];\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tif (!isCompressed && !isDataTexture) {\n\t\t\t\t\tcubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);\n\t\t\t\t} else {\n\t\t\t\t\tcubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst image = cubeImage[0],\n\t\t\t\t\t\tsupportsMips = isPowerOfTwo$1(image) || isWebGL2,\n\t\t\t\t\t\tglFormat = utils.convert(texture.format),\n\t\t\t\t\t\tglType = utils.convert(texture.type),\n\t\t\t\t\t\tglInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\t\t\tsetTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);\n\t\t\tlet mipmaps;\n\n\t\t\tif (isCompressed) {\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tmipmaps = cubeImage[i].mipmaps;\n\n\t\t\t\t\tfor (let j = 0; j < mipmaps.length; j++) {\n\t\t\t\t\t\tconst mipmap = mipmaps[j];\n\n\t\t\t\t\t\tif (texture.format !== RGBAFormat && texture.format !== RGBFormat) {\n\t\t\t\t\t\t\tif (glFormat !== null) {\n\t\t\t\t\t\t\t\tstate.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\t\t\t} else {\n\t\t\t\tmipmaps = texture.mipmaps;\n\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tif (isDataTexture) {\n\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);\n\n\t\t\t\t\t\tfor (let j = 0; j < mipmaps.length; j++) {\n\t\t\t\t\t\t\tconst mipmap = mipmaps[j];\n\t\t\t\t\t\t\tconst mipmapImage = mipmap.image[i].image;\n\t\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);\n\n\t\t\t\t\t\tfor (let j = 0; j < mipmaps.length; j++) {\n\t\t\t\t\t\t\tconst mipmap = mipmaps[j];\n\t\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length;\n\t\t\t}\n\n\t\t\tif (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n\t\t\t\t// We assume images for cube map have the same size.\n\t\t\t\tgenerateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);\n\t\t\t}\n\n\t\t\ttextureProperties.__version = texture.version;\n\t\t\tif (texture.onUpdate) texture.onUpdate(texture);\n\t\t} // Render targets\n\t\t// Setup storage for target texture and bind it to correct framebuffer\n\n\n\t\tfunction setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {\n\t\t\tconst glFormat = utils.convert(texture.format);\n\t\t\tconst glType = utils.convert(texture.type);\n\t\t\tconst glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\n\t\t\tif (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {\n\t\t\t\tstate.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);\n\t\t\t} else {\n\t\t\t\tstate.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);\n\t\t\t}\n\n\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n\t\t\t_gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);\n\n\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, null);\n\t\t} // Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\n\n\t\tfunction setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {\n\t\t\t_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);\n\n\t\t\tif (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {\n\t\t\t\tlet glInternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t\tif (isMultisample) {\n\t\t\t\t\tconst depthTexture = renderTarget.depthTexture;\n\n\t\t\t\t\tif (depthTexture && depthTexture.isDepthTexture) {\n\t\t\t\t\t\tif (depthTexture.type === FloatType) {\n\t\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT32F;\n\t\t\t\t\t\t} else if (depthTexture.type === UnsignedIntType) {\n\t\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT24;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst samples = getRenderTargetSamples(renderTarget);\n\n\t\t\t\t\t_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n\t\t\t\t} else {\n\t\t\t\t\t_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);\n\t\t\t\t}\n\n\t\t\t\t_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);\n\t\t\t} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {\n\t\t\t\tif (isMultisample) {\n\t\t\t\t\tconst samples = getRenderTargetSamples(renderTarget);\n\n\t\t\t\t\t_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);\n\t\t\t\t} else {\n\t\t\t\t\t_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);\n\t\t\t\t}\n\n\t\t\t\t_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);\n\t\t\t} else {\n\t\t\t\t// Use the first texture for MRT so far\n\t\t\t\tconst texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;\n\t\t\t\tconst glFormat = utils.convert(texture.format);\n\t\t\t\tconst glType = utils.convert(texture.type);\n\t\t\t\tconst glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\n\t\t\t\tif (isMultisample) {\n\t\t\t\t\tconst samples = getRenderTargetSamples(renderTarget);\n\n\t\t\t\t\t_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n\t\t\t\t} else {\n\t\t\t\t\t_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);\n\t\t} // Setup resources for a Depth Texture for a FBO (needs an extension)\n\n\n\t\tfunction setupDepthTexture(framebuffer, renderTarget) {\n\t\t\tconst isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;\n\t\t\tif (isCube) throw new Error('Depth Texture with cube render targets is not supported');\n\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n\t\t\tif (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {\n\t\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\t\t\t} // upload an empty depth texture with framebuffer size\n\n\n\t\t\tif (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {\n\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t\t}\n\n\t\t\tsetTexture2D(renderTarget.depthTexture, 0);\n\n\t\t\tconst webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;\n\n\t\t\tif (renderTarget.depthTexture.format === DepthFormat) {\n\t\t\t\t_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);\n\t\t\t} else if (renderTarget.depthTexture.format === DepthStencilFormat) {\n\t\t\t\t_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown depthTexture format');\n\t\t\t}\n\t\t} // Setup GL resources for a non-texture depth buffer\n\n\n\t\tfunction setupDepthRenderbuffer(renderTarget) {\n\t\t\tconst renderTargetProperties = properties.get(renderTarget);\n\t\t\tconst isCube = renderTarget.isWebGLCubeRenderTarget === true;\n\n\t\t\tif (renderTarget.depthTexture) {\n\t\t\t\tif (isCube) throw new Error('target.depthTexture not supported in Cube render targets');\n\t\t\t\tsetupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);\n\t\t\t} else {\n\t\t\t\tif (isCube) {\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, null);\n\t\t} // Set up GL resources for the render target\n\n\n\t\tfunction setupRenderTarget(renderTarget) {\n\t\t\tconst texture = renderTarget.texture;\n\t\t\tconst renderTargetProperties = properties.get(renderTarget);\n\t\t\tconst textureProperties = properties.get(texture);\n\t\t\trenderTarget.addEventListener('dispose', onRenderTargetDispose);\n\n\t\t\tif (renderTarget.isWebGLMultipleRenderTargets !== true) {\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\t\t\ttextureProperties.__version = texture.version;\n\t\t\t\tinfo.memory.textures++;\n\t\t\t}\n\n\t\t\tconst isCube = renderTarget.isWebGLCubeRenderTarget === true;\n\t\t\tconst isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;\n\t\t\tconst isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;\n\t\t\tconst isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;\n\t\t\tconst supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2; // Handles WebGL2 RGBFormat fallback - #18858\n\n\t\t\tif (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {\n\t\t\t\ttexture.format = RGBAFormat;\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');\n\t\t\t} // Setup framebuffer\n\n\n\t\t\tif (isCube) {\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\t\tif (isMultipleRenderTargets) {\n\t\t\t\t\tif (capabilities.drawBuffers) {\n\t\t\t\t\t\tconst textures = renderTarget.texture;\n\n\t\t\t\t\t\tfor (let i = 0, il = textures.length; i < il; i++) {\n\t\t\t\t\t\t\tconst attachmentProperties = properties.get(textures[i]);\n\n\t\t\t\t\t\t\tif (attachmentProperties.__webglTexture === undefined) {\n\t\t\t\t\t\t\t\tattachmentProperties.__webglTexture = _gl.createTexture();\n\t\t\t\t\t\t\t\tinfo.memory.textures++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');\n\t\t\t\t\t}\n\t\t\t\t} else if (isMultisample) {\n\t\t\t\t\tif (isWebGL2) {\n\t\t\t\t\t\trenderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\n\t\t\t\t\t\trenderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();\n\n\t\t\t\t\t\t_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);\n\n\t\t\t\t\t\tconst glFormat = utils.convert(texture.format);\n\t\t\t\t\t\tconst glType = utils.convert(texture.type);\n\t\t\t\t\t\tconst glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\t\t\t\t\t\tconst samples = getRenderTargetSamples(renderTarget);\n\n\t\t\t\t\t\t_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n\n\t\t\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n\n\t\t\t\t\t\t_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);\n\n\t\t\t\t\t\t_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);\n\n\t\t\t\t\t\tif (renderTarget.depthBuffer) {\n\t\t\t\t\t\t\trenderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n\t\t\t\t\t\t\tsetupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // Setup color buffer\n\n\n\t\t\tif (isCube) {\n\t\t\t\tstate.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);\n\t\t\t\tsetTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);\n\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tsetupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);\n\t\t\t\t}\n\n\t\t\t\tif (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n\t\t\t\t\tgenerateMipmap(_gl.TEXTURE_CUBE_MAP, texture, renderTarget.width, renderTarget.height);\n\t\t\t\t}\n\n\t\t\t\tstate.bindTexture(_gl.TEXTURE_CUBE_MAP, null);\n\t\t\t} else if (isMultipleRenderTargets) {\n\t\t\t\tconst textures = renderTarget.texture;\n\n\t\t\t\tfor (let i = 0, il = textures.length; i < il; i++) {\n\t\t\t\t\tconst attachment = textures[i];\n\t\t\t\t\tconst attachmentProperties = properties.get(attachment);\n\t\t\t\t\tstate.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);\n\t\t\t\t\tsetTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);\n\t\t\t\t\tsetupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D);\n\n\t\t\t\t\tif (textureNeedsGenerateMipmaps(attachment, supportsMips)) {\n\t\t\t\t\t\tgenerateMipmap(_gl.TEXTURE_2D, attachment, renderTarget.width, renderTarget.height);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstate.bindTexture(_gl.TEXTURE_2D, null);\n\t\t\t} else {\n\t\t\t\tlet glTextureType = _gl.TEXTURE_2D;\n\n\t\t\t\tif (isRenderTarget3D) {\n\t\t\t\t\t// Render targets containing layers, i.e: Texture 3D and 2d arrays\n\t\t\t\t\tif (isWebGL2) {\n\t\t\t\t\t\tconst isTexture3D = texture.isDataTexture3D;\n\t\t\t\t\t\tglTextureType = isTexture3D ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstate.bindTexture(glTextureType, textureProperties.__webglTexture);\n\t\t\t\tsetTextureParameters(glTextureType, texture, supportsMips);\n\t\t\t\tsetupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);\n\n\t\t\t\tif (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n\t\t\t\t\tgenerateMipmap(_gl.TEXTURE_2D, texture, renderTarget.width, renderTarget.height);\n\t\t\t\t}\n\n\t\t\t\tstate.bindTexture(_gl.TEXTURE_2D, null);\n\t\t\t} // Setup depth and stencil buffers\n\n\n\t\t\tif (renderTarget.depthBuffer) {\n\t\t\t\tsetupDepthRenderbuffer(renderTarget);\n\t\t\t}\n\t\t}\n\n\t\tfunction updateRenderTargetMipmap(renderTarget) {\n\t\t\tconst supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;\n\t\t\tconst textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];\n\n\t\t\tfor (let i = 0, il = textures.length; i < il; i++) {\n\t\t\t\tconst texture = textures[i];\n\n\t\t\t\tif (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n\t\t\t\t\tconst target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\n\t\t\t\t\tconst webglTexture = properties.get(texture).__webglTexture;\n\n\t\t\t\t\tstate.bindTexture(target, webglTexture);\n\t\t\t\t\tgenerateMipmap(target, texture, renderTarget.width, renderTarget.height);\n\t\t\t\t\tstate.bindTexture(target, null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction updateMultisampleRenderTarget(renderTarget) {\n\t\t\tif (renderTarget.isWebGLMultisampleRenderTarget) {\n\t\t\t\tif (isWebGL2) {\n\t\t\t\t\tconst width = renderTarget.width;\n\t\t\t\t\tconst height = renderTarget.height;\n\t\t\t\t\tlet mask = _gl.COLOR_BUFFER_BIT;\n\t\t\t\t\tif (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;\n\t\t\t\t\tif (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;\n\t\t\t\t\tconst renderTargetProperties = properties.get(renderTarget);\n\t\t\t\t\tstate.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n\t\t\t\t\tstate.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);\n\n\t\t\t\t\t_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);\n\n\t\t\t\t\tstate.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);\n\t\t\t\t\tstate.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction getRenderTargetSamples(renderTarget) {\n\t\t\treturn isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;\n\t\t}\n\n\t\tfunction updateVideoTexture(texture) {\n\t\t\tconst frame = info.render.frame; // Check the last frame we updated the VideoTexture\n\n\t\t\tif (_videoTextures.get(texture) !== frame) {\n\t\t\t\t_videoTextures.set(texture, frame);\n\n\t\t\t\ttexture.update();\n\t\t\t}\n\t\t} // backwards compatibility\n\n\n\t\tlet warnedTexture2D = false;\n\t\tlet warnedTextureCube = false;\n\n\t\tfunction safeSetTexture2D(texture, slot) {\n\t\t\tif (texture && texture.isWebGLRenderTarget) {\n\t\t\t\tif (warnedTexture2D === false) {\n\t\t\t\t\tconsole.warn('THREE.WebGLTextures.safeSetTexture2D: don\\'t use render targets as textures. Use their .texture property instead.');\n\t\t\t\t\twarnedTexture2D = true;\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\t\t\t}\n\n\t\t\tsetTexture2D(texture, slot);\n\t\t}\n\n\t\tfunction safeSetTextureCube(texture, slot) {\n\t\t\tif (texture && texture.isWebGLCubeRenderTarget) {\n\t\t\t\tif (warnedTextureCube === false) {\n\t\t\t\t\tconsole.warn('THREE.WebGLTextures.safeSetTextureCube: don\\'t use cube render targets as textures. Use their .texture property instead.');\n\t\t\t\t\twarnedTextureCube = true;\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\t\t\t}\n\n\t\t\tsetTextureCube(texture, slot);\n\t\t} //\n\n\n\t\tthis.allocateTextureUnit = allocateTextureUnit;\n\t\tthis.resetTextureUnits = resetTextureUnits;\n\t\tthis.setTexture2D = setTexture2D;\n\t\tthis.setTexture2DArray = setTexture2DArray;\n\t\tthis.setTexture3D = setTexture3D;\n\t\tthis.setTextureCube = setTextureCube;\n\t\tthis.setupRenderTarget = setupRenderTarget;\n\t\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\t\tthis.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n\t\tthis.safeSetTexture2D = safeSetTexture2D;\n\t\tthis.safeSetTextureCube = safeSetTextureCube;\n\t}\n\n\tfunction WebGLUtils(gl, extensions, capabilities) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\n\t\tfunction convert(p) {\n\t\t\tlet extension;\n\t\t\tif (p === UnsignedByteType) return gl.UNSIGNED_BYTE;\n\t\t\tif (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\tif (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\tif (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;\n\t\t\tif (p === ByteType) return gl.BYTE;\n\t\t\tif (p === ShortType) return gl.SHORT;\n\t\t\tif (p === UnsignedShortType) return gl.UNSIGNED_SHORT;\n\t\t\tif (p === IntType) return gl.INT;\n\t\t\tif (p === UnsignedIntType) return gl.UNSIGNED_INT;\n\t\t\tif (p === FloatType) return gl.FLOAT;\n\n\t\t\tif (p === HalfFloatType) {\n\t\t\t\tif (isWebGL2) return gl.HALF_FLOAT;\n\t\t\t\textension = extensions.get('OES_texture_half_float');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\treturn extension.HALF_FLOAT_OES;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === AlphaFormat) return gl.ALPHA;\n\t\t\tif (p === RGBFormat) return gl.RGB;\n\t\t\tif (p === RGBAFormat) return gl.RGBA;\n\t\t\tif (p === LuminanceFormat) return gl.LUMINANCE;\n\t\t\tif (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;\n\t\t\tif (p === DepthFormat) return gl.DEPTH_COMPONENT;\n\t\t\tif (p === DepthStencilFormat) return gl.DEPTH_STENCIL;\n\t\t\tif (p === RedFormat) return gl.RED; // WebGL2 formats.\n\n\t\t\tif (p === RedIntegerFormat) return gl.RED_INTEGER;\n\t\t\tif (p === RGFormat) return gl.RG;\n\t\t\tif (p === RGIntegerFormat) return gl.RG_INTEGER;\n\t\t\tif (p === RGBIntegerFormat) return gl.RGB_INTEGER;\n\t\t\tif (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;\n\n\t\t\tif (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {\n\t\t\t\textension = extensions.get('WEBGL_compressed_texture_s3tc');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\tif (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {\n\t\t\t\textension = extensions.get('WEBGL_compressed_texture_pvrtc');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\tif (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\t\tif (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === RGB_ETC1_Format) {\n\t\t\t\textension = extensions.get('WEBGL_compressed_texture_etc1');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\treturn extension.COMPRESSED_RGB_ETC1_WEBGL;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {\n\t\t\t\textension = extensions.get('WEBGL_compressed_texture_etc');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\tif (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;\n\t\t\t\t\tif (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {\n\t\t\t\textension = extensions.get('WEBGL_compressed_texture_astc');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\t// TODO Complete?\n\t\t\t\t\treturn p;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === RGBA_BPTC_Format) {\n\t\t\t\textension = extensions.get('EXT_texture_compression_bptc');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\t// TODO Complete?\n\t\t\t\t\treturn p;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === UnsignedInt248Type) {\n\t\t\t\tif (isWebGL2) return gl.UNSIGNED_INT_24_8;\n\t\t\t\textension = extensions.get('WEBGL_depth_texture');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\treturn extension.UNSIGNED_INT_24_8_WEBGL;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tconvert: convert\n\t\t};\n\t}\n\n\tclass ArrayCamera extends PerspectiveCamera {\n\t\tconstructor(array = []) {\n\t\t\tsuper();\n\t\t\tthis.cameras = array;\n\t\t}\n\n\t}\n\n\tArrayCamera.prototype.isArrayCamera = true;\n\n\tclass Group extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'Group';\n\t\t}\n\n\t}\n\n\tGroup.prototype.isGroup = true;\n\n\tconst _moveEvent = {\n\t\ttype: 'move'\n\t};\n\n\tclass WebXRController {\n\t\tconstructor() {\n\t\t\tthis._targetRay = null;\n\t\t\tthis._grip = null;\n\t\t\tthis._hand = null;\n\t\t}\n\n\t\tgetHandSpace() {\n\t\t\tif (this._hand === null) {\n\t\t\t\tthis._hand = new Group();\n\t\t\t\tthis._hand.matrixAutoUpdate = false;\n\t\t\t\tthis._hand.visible = false;\n\t\t\t\tthis._hand.joints = {};\n\t\t\t\tthis._hand.inputState = {\n\t\t\t\t\tpinching: false\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn this._hand;\n\t\t}\n\n\t\tgetTargetRaySpace() {\n\t\t\tif (this._targetRay === null) {\n\t\t\t\tthis._targetRay = new Group();\n\t\t\t\tthis._targetRay.matrixAutoUpdate = false;\n\t\t\t\tthis._targetRay.visible = false;\n\t\t\t\tthis._targetRay.hasLinearVelocity = false;\n\t\t\t\tthis._targetRay.linearVelocity = new Vector3();\n\t\t\t\tthis._targetRay.hasAngularVelocity = false;\n\t\t\t\tthis._targetRay.angularVelocity = new Vector3();\n\t\t\t}\n\n\t\t\treturn this._targetRay;\n\t\t}\n\n\t\tgetGripSpace() {\n\t\t\tif (this._grip === null) {\n\t\t\t\tthis._grip = new Group();\n\t\t\t\tthis._grip.matrixAutoUpdate = false;\n\t\t\t\tthis._grip.visible = false;\n\t\t\t\tthis._grip.hasLinearVelocity = false;\n\t\t\t\tthis._grip.linearVelocity = new Vector3();\n\t\t\t\tthis._grip.hasAngularVelocity = false;\n\t\t\t\tthis._grip.angularVelocity = new Vector3();\n\t\t\t}\n\n\t\t\treturn this._grip;\n\t\t}\n\n\t\tdispatchEvent(event) {\n\t\t\tif (this._targetRay !== null) {\n\t\t\t\tthis._targetRay.dispatchEvent(event);\n\t\t\t}\n\n\t\t\tif (this._grip !== null) {\n\t\t\t\tthis._grip.dispatchEvent(event);\n\t\t\t}\n\n\t\t\tif (this._hand !== null) {\n\t\t\t\tthis._hand.dispatchEvent(event);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tdisconnect(inputSource) {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'disconnected',\n\t\t\t\tdata: inputSource\n\t\t\t});\n\n\t\t\tif (this._targetRay !== null) {\n\t\t\t\tthis._targetRay.visible = false;\n\t\t\t}\n\n\t\t\tif (this._grip !== null) {\n\t\t\t\tthis._grip.visible = false;\n\t\t\t}\n\n\t\t\tif (this._hand !== null) {\n\t\t\t\tthis._hand.visible = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tupdate(inputSource, frame, referenceSpace) {\n\t\t\tlet inputPose = null;\n\t\t\tlet gripPose = null;\n\t\t\tlet handPose = null;\n\t\t\tconst targetRay = this._targetRay;\n\t\t\tconst grip = this._grip;\n\t\t\tconst hand = this._hand;\n\n\t\t\tif (inputSource && frame.session.visibilityState !== 'visible-blurred') {\n\t\t\t\tif (targetRay !== null) {\n\t\t\t\t\tinputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);\n\n\t\t\t\t\tif (inputPose !== null) {\n\t\t\t\t\t\ttargetRay.matrix.fromArray(inputPose.transform.matrix);\n\t\t\t\t\t\ttargetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);\n\n\t\t\t\t\t\tif (inputPose.linearVelocity) {\n\t\t\t\t\t\t\ttargetRay.hasLinearVelocity = true;\n\t\t\t\t\t\t\ttargetRay.linearVelocity.copy(inputPose.linearVelocity);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttargetRay.hasLinearVelocity = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (inputPose.angularVelocity) {\n\t\t\t\t\t\t\ttargetRay.hasAngularVelocity = true;\n\t\t\t\t\t\t\ttargetRay.angularVelocity.copy(inputPose.angularVelocity);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttargetRay.hasAngularVelocity = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.dispatchEvent(_moveEvent);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (hand && inputSource.hand) {\n\t\t\t\t\thandPose = true;\n\n\t\t\t\t\tfor (const inputjoint of inputSource.hand.values()) {\n\t\t\t\t\t\t// Update the joints groups with the XRJoint poses\n\t\t\t\t\t\tconst jointPose = frame.getJointPose(inputjoint, referenceSpace);\n\n\t\t\t\t\t\tif (hand.joints[inputjoint.jointName] === undefined) {\n\t\t\t\t\t\t\t// The transform of this joint will be updated with the joint pose on each frame\n\t\t\t\t\t\t\tconst joint = new Group();\n\t\t\t\t\t\t\tjoint.matrixAutoUpdate = false;\n\t\t\t\t\t\t\tjoint.visible = false;\n\t\t\t\t\t\t\thand.joints[inputjoint.jointName] = joint; // ??\n\n\t\t\t\t\t\t\thand.add(joint);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst joint = hand.joints[inputjoint.jointName];\n\n\t\t\t\t\t\tif (jointPose !== null) {\n\t\t\t\t\t\t\tjoint.matrix.fromArray(jointPose.transform.matrix);\n\t\t\t\t\t\t\tjoint.matrix.decompose(joint.position, joint.rotation, joint.scale);\n\t\t\t\t\t\t\tjoint.jointRadius = jointPose.radius;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tjoint.visible = jointPose !== null;\n\t\t\t\t\t} // Custom events\n\t\t\t\t\t// Check pinchz\n\n\n\t\t\t\t\tconst indexTip = hand.joints['index-finger-tip'];\n\t\t\t\t\tconst thumbTip = hand.joints['thumb-tip'];\n\t\t\t\t\tconst distance = indexTip.position.distanceTo(thumbTip.position);\n\t\t\t\t\tconst distanceToPinch = 0.02;\n\t\t\t\t\tconst threshold = 0.005;\n\n\t\t\t\t\tif (hand.inputState.pinching && distance > distanceToPinch + threshold) {\n\t\t\t\t\t\thand.inputState.pinching = false;\n\t\t\t\t\t\tthis.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'pinchend',\n\t\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\t\ttarget: this\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {\n\t\t\t\t\t\thand.inputState.pinching = true;\n\t\t\t\t\t\tthis.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'pinchstart',\n\t\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\t\ttarget: this\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (grip !== null && inputSource.gripSpace) {\n\t\t\t\t\t\tgripPose = frame.getPose(inputSource.gripSpace, referenceSpace);\n\n\t\t\t\t\t\tif (gripPose !== null) {\n\t\t\t\t\t\t\tgrip.matrix.fromArray(gripPose.transform.matrix);\n\t\t\t\t\t\t\tgrip.matrix.decompose(grip.position, grip.rotation, grip.scale);\n\n\t\t\t\t\t\t\tif (gripPose.linearVelocity) {\n\t\t\t\t\t\t\t\tgrip.hasLinearVelocity = true;\n\t\t\t\t\t\t\t\tgrip.linearVelocity.copy(gripPose.linearVelocity);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgrip.hasLinearVelocity = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (gripPose.angularVelocity) {\n\t\t\t\t\t\t\t\tgrip.hasAngularVelocity = true;\n\t\t\t\t\t\t\t\tgrip.angularVelocity.copy(gripPose.angularVelocity);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgrip.hasAngularVelocity = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (targetRay !== null) {\n\t\t\t\ttargetRay.visible = inputPose !== null;\n\t\t\t}\n\n\t\t\tif (grip !== null) {\n\t\t\t\tgrip.visible = gripPose !== null;\n\t\t\t}\n\n\t\t\tif (hand !== null) {\n\t\t\t\thand.visible = handPose !== null;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass WebXRManager extends EventDispatcher {\n\t\tconstructor(renderer, gl) {\n\t\t\tsuper();\n\t\t\tconst scope = this;\n\t\t\tconst state = renderer.state;\n\t\t\tlet session = null;\n\t\t\tlet framebufferScaleFactor = 1.0;\n\t\t\tlet referenceSpace = null;\n\t\t\tlet referenceSpaceType = 'local-floor';\n\t\t\tlet pose = null;\n\t\t\tconst controllers = [];\n\t\t\tconst inputSourcesMap = new Map(); //\n\n\t\t\tconst cameraL = new PerspectiveCamera();\n\t\t\tcameraL.layers.enable(1);\n\t\t\tcameraL.viewport = new Vector4();\n\t\t\tconst cameraR = new PerspectiveCamera();\n\t\t\tcameraR.layers.enable(2);\n\t\t\tcameraR.viewport = new Vector4();\n\t\t\tconst cameras = [cameraL, cameraR];\n\t\t\tconst cameraVR = new ArrayCamera();\n\t\t\tcameraVR.layers.enable(1);\n\t\t\tcameraVR.layers.enable(2);\n\t\t\tlet _currentDepthNear = null;\n\t\t\tlet _currentDepthFar = null; //\n\n\t\t\tthis.cameraAutoUpdate = true;\n\t\t\tthis.enabled = false;\n\t\t\tthis.isPresenting = false;\n\n\t\t\tthis.getController = function (index) {\n\t\t\t\tlet controller = controllers[index];\n\n\t\t\t\tif (controller === undefined) {\n\t\t\t\t\tcontroller = new WebXRController();\n\t\t\t\t\tcontrollers[index] = controller;\n\t\t\t\t}\n\n\t\t\t\treturn controller.getTargetRaySpace();\n\t\t\t};\n\n\t\t\tthis.getControllerGrip = function (index) {\n\t\t\t\tlet controller = controllers[index];\n\n\t\t\t\tif (controller === undefined) {\n\t\t\t\t\tcontroller = new WebXRController();\n\t\t\t\t\tcontrollers[index] = controller;\n\t\t\t\t}\n\n\t\t\t\treturn controller.getGripSpace();\n\t\t\t};\n\n\t\t\tthis.getHand = function (index) {\n\t\t\t\tlet controller = controllers[index];\n\n\t\t\t\tif (controller === undefined) {\n\t\t\t\t\tcontroller = new WebXRController();\n\t\t\t\t\tcontrollers[index] = controller;\n\t\t\t\t}\n\n\t\t\t\treturn controller.getHandSpace();\n\t\t\t}; //\n\n\n\t\t\tfunction onSessionEvent(event) {\n\t\t\t\tconst controller = inputSourcesMap.get(event.inputSource);\n\n\t\t\t\tif (controller) {\n\t\t\t\t\tcontroller.dispatchEvent({\n\t\t\t\t\t\ttype: event.type,\n\t\t\t\t\t\tdata: event.inputSource\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction onSessionEnd() {\n\t\t\t\tinputSourcesMap.forEach(function (controller, inputSource) {\n\t\t\t\t\tcontroller.disconnect(inputSource);\n\t\t\t\t});\n\t\t\t\tinputSourcesMap.clear();\n\t\t\t\t_currentDepthNear = null;\n\t\t\t\t_currentDepthFar = null; // restore framebuffer/rendering state\n\n\t\t\t\tstate.bindXRFramebuffer(null);\n\t\t\t\trenderer.setRenderTarget(renderer.getRenderTarget()); //\n\n\t\t\t\tanimation.stop();\n\t\t\t\tscope.isPresenting = false;\n\t\t\t\tscope.dispatchEvent({\n\t\t\t\t\ttype: 'sessionend'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.setFramebufferScaleFactor = function (value) {\n\t\t\t\tframebufferScaleFactor = value;\n\n\t\t\t\tif (scope.isPresenting === true) {\n\t\t\t\t\tconsole.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.setReferenceSpaceType = function (value) {\n\t\t\t\treferenceSpaceType = value;\n\n\t\t\t\tif (scope.isPresenting === true) {\n\t\t\t\t\tconsole.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.getReferenceSpace = function () {\n\t\t\t\treturn referenceSpace;\n\t\t\t};\n\n\t\t\tthis.getSession = function () {\n\t\t\t\treturn session;\n\t\t\t};\n\n\t\t\tthis.setSession = async function (value) {\n\t\t\t\tsession = value;\n\n\t\t\t\tif (session !== null) {\n\t\t\t\t\tsession.addEventListener('select', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('selectstart', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('selectend', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('squeeze', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('squeezestart', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('squeezeend', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('end', onSessionEnd);\n\t\t\t\t\tsession.addEventListener('inputsourceschange', onInputSourcesChange);\n\t\t\t\t\tconst attributes = gl.getContextAttributes();\n\n\t\t\t\t\tif (attributes.xrCompatible !== true) {\n\t\t\t\t\t\tawait gl.makeXRCompatible();\n\t\t\t\t\t}\n\n\t\t\t\t\tconst layerInit = {\n\t\t\t\t\t\tantialias: attributes.antialias,\n\t\t\t\t\t\talpha: attributes.alpha,\n\t\t\t\t\t\tdepth: attributes.depth,\n\t\t\t\t\t\tstencil: attributes.stencil,\n\t\t\t\t\t\tframebufferScaleFactor: framebufferScaleFactor\n\t\t\t\t\t}; // eslint-disable-next-line no-undef\n\n\t\t\t\t\tconst baseLayer = new XRWebGLLayer(session, gl, layerInit);\n\t\t\t\t\tsession.updateRenderState({\n\t\t\t\t\t\tbaseLayer: baseLayer\n\t\t\t\t\t});\n\t\t\t\t\treferenceSpace = await session.requestReferenceSpace(referenceSpaceType);\n\t\t\t\t\tanimation.setContext(session);\n\t\t\t\t\tanimation.start();\n\t\t\t\t\tscope.isPresenting = true;\n\t\t\t\t\tscope.dispatchEvent({\n\t\t\t\t\t\ttype: 'sessionstart'\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfunction onInputSourcesChange(event) {\n\t\t\t\tconst inputSources = session.inputSources; // Assign inputSources to available controllers\n\n\t\t\t\tfor (let i = 0; i < controllers.length; i++) {\n\t\t\t\t\tinputSourcesMap.set(inputSources[i], controllers[i]);\n\t\t\t\t} // Notify disconnected\n\n\n\t\t\t\tfor (let i = 0; i < event.removed.length; i++) {\n\t\t\t\t\tconst inputSource = event.removed[i];\n\t\t\t\t\tconst controller = inputSourcesMap.get(inputSource);\n\n\t\t\t\t\tif (controller) {\n\t\t\t\t\t\tcontroller.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'disconnected',\n\t\t\t\t\t\t\tdata: inputSource\n\t\t\t\t\t\t});\n\t\t\t\t\t\tinputSourcesMap.delete(inputSource);\n\t\t\t\t\t}\n\t\t\t\t} // Notify connected\n\n\n\t\t\t\tfor (let i = 0; i < event.added.length; i++) {\n\t\t\t\t\tconst inputSource = event.added[i];\n\t\t\t\t\tconst controller = inputSourcesMap.get(inputSource);\n\n\t\t\t\t\tif (controller) {\n\t\t\t\t\t\tcontroller.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'connected',\n\t\t\t\t\t\t\tdata: inputSource\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} //\n\n\n\t\t\tconst cameraLPos = new Vector3();\n\t\t\tconst cameraRPos = new Vector3();\n\t\t\t/**\n\t\t\t * Assumes 2 cameras that are parallel and share an X-axis, and that\n\t\t\t * the cameras' projection and world matrices have already been set.\n\t\t\t * And that near and far planes are identical for both cameras.\n\t\t\t * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n\t\t\t */\n\n\t\t\tfunction setProjectionFromUnion(camera, cameraL, cameraR) {\n\t\t\t\tcameraLPos.setFromMatrixPosition(cameraL.matrixWorld);\n\t\t\t\tcameraRPos.setFromMatrixPosition(cameraR.matrixWorld);\n\t\t\t\tconst ipd = cameraLPos.distanceTo(cameraRPos);\n\t\t\t\tconst projL = cameraL.projectionMatrix.elements;\n\t\t\t\tconst projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and\n\t\t\t\t// most likely identical top and bottom frustum extents.\n\t\t\t\t// Use the left camera for these values.\n\n\t\t\t\tconst near = projL[14] / (projL[10] - 1);\n\t\t\t\tconst far = projL[14] / (projL[10] + 1);\n\t\t\t\tconst topFov = (projL[9] + 1) / projL[5];\n\t\t\t\tconst bottomFov = (projL[9] - 1) / projL[5];\n\t\t\t\tconst leftFov = (projL[8] - 1) / projL[0];\n\t\t\t\tconst rightFov = (projR[8] + 1) / projR[0];\n\t\t\t\tconst left = near * leftFov;\n\t\t\t\tconst right = near * rightFov; // Calculate the new camera's position offset from the\n\t\t\t\t// left camera. xOffset should be roughly half `ipd`.\n\n\t\t\t\tconst zOffset = ipd / (-leftFov + rightFov);\n\t\t\t\tconst xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?\n\n\t\t\t\tcameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);\n\t\t\t\tcamera.translateX(xOffset);\n\t\t\t\tcamera.translateZ(zOffset);\n\t\t\t\tcamera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);\n\t\t\t\tcamera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale\n\t\t\t\t// the values so that the near plane's position does not change in world space,\n\t\t\t\t// although must now be relative to the new union camera.\n\n\t\t\t\tconst near2 = near + zOffset;\n\t\t\t\tconst far2 = far + zOffset;\n\t\t\t\tconst left2 = left - xOffset;\n\t\t\t\tconst right2 = right + (ipd - xOffset);\n\t\t\t\tconst top2 = topFov * far / far2 * near2;\n\t\t\t\tconst bottom2 = bottomFov * far / far2 * near2;\n\t\t\t\tcamera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);\n\t\t\t}\n\n\t\t\tfunction updateCamera(camera, parent) {\n\t\t\t\tif (parent === null) {\n\t\t\t\t\tcamera.matrixWorld.copy(camera.matrix);\n\t\t\t\t} else {\n\t\t\t\t\tcamera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);\n\t\t\t\t}\n\n\t\t\t\tcamera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n\t\t\t}\n\n\t\t\tthis.updateCamera = function (camera) {\n\t\t\t\tif (session === null) return;\n\t\t\t\tcameraVR.near = cameraR.near = cameraL.near = camera.near;\n\t\t\t\tcameraVR.far = cameraR.far = cameraL.far = camera.far;\n\n\t\t\t\tif (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {\n\t\t\t\t\t// Note that the new renderState won't apply until the next frame. See #18320\n\t\t\t\t\tsession.updateRenderState({\n\t\t\t\t\t\tdepthNear: cameraVR.near,\n\t\t\t\t\t\tdepthFar: cameraVR.far\n\t\t\t\t\t});\n\t\t\t\t\t_currentDepthNear = cameraVR.near;\n\t\t\t\t\t_currentDepthFar = cameraVR.far;\n\t\t\t\t}\n\n\t\t\t\tconst parent = camera.parent;\n\t\t\t\tconst cameras = cameraVR.cameras;\n\t\t\t\tupdateCamera(cameraVR, parent);\n\n\t\t\t\tfor (let i = 0; i < cameras.length; i++) {\n\t\t\t\t\tupdateCamera(cameras[i], parent);\n\t\t\t\t} // update camera and its children\n\n\n\t\t\t\tcamera.matrixWorld.copy(cameraVR.matrixWorld);\n\t\t\t\tcamera.matrix.copy(cameraVR.matrix);\n\t\t\t\tcamera.matrix.decompose(camera.position, camera.quaternion, camera.scale);\n\t\t\t\tconst children = camera.children;\n\n\t\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tchildren[i].updateMatrixWorld(true);\n\t\t\t\t} // update projection matrix for proper view frustum culling\n\n\n\t\t\t\tif (cameras.length === 2) {\n\t\t\t\t\tsetProjectionFromUnion(cameraVR, cameraL, cameraR);\n\t\t\t\t} else {\n\t\t\t\t\t// assume single camera setup (AR)\n\t\t\t\t\tcameraVR.projectionMatrix.copy(cameraL.projectionMatrix);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.getCamera = function () {\n\t\t\t\treturn cameraVR;\n\t\t\t}; // Animation Loop\n\n\n\t\t\tlet onAnimationFrameCallback = null;\n\n\t\t\tfunction onAnimationFrame(time, frame) {\n\t\t\t\tpose = frame.getViewerPose(referenceSpace);\n\n\t\t\t\tif (pose !== null) {\n\t\t\t\t\tconst views = pose.views;\n\t\t\t\t\tconst baseLayer = session.renderState.baseLayer;\n\t\t\t\t\tstate.bindXRFramebuffer(baseLayer.framebuffer);\n\t\t\t\t\tlet cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list\n\n\t\t\t\t\tif (views.length !== cameraVR.cameras.length) {\n\t\t\t\t\t\tcameraVR.cameras.length = 0;\n\t\t\t\t\t\tcameraVRNeedsUpdate = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < views.length; i++) {\n\t\t\t\t\t\tconst view = views[i];\n\t\t\t\t\t\tconst viewport = baseLayer.getViewport(view);\n\t\t\t\t\t\tconst camera = cameras[i];\n\t\t\t\t\t\tcamera.matrix.fromArray(view.transform.matrix);\n\t\t\t\t\t\tcamera.projectionMatrix.fromArray(view.projectionMatrix);\n\t\t\t\t\t\tcamera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);\n\n\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\tcameraVR.matrix.copy(camera.matrix);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (cameraVRNeedsUpdate === true) {\n\t\t\t\t\t\t\tcameraVR.cameras.push(camera);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} //\n\n\n\t\t\t\tconst inputSources = session.inputSources;\n\n\t\t\t\tfor (let i = 0; i < controllers.length; i++) {\n\t\t\t\t\tconst controller = controllers[i];\n\t\t\t\t\tconst inputSource = inputSources[i];\n\t\t\t\t\tcontroller.update(inputSource, frame, referenceSpace);\n\t\t\t\t}\n\n\t\t\t\tif (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);\n\t\t\t}\n\n\t\t\tconst animation = new WebGLAnimation();\n\t\t\tanimation.setAnimationLoop(onAnimationFrame);\n\n\t\t\tthis.setAnimationLoop = function (callback) {\n\t\t\t\tonAnimationFrameCallback = callback;\n\t\t\t};\n\n\t\t\tthis.dispose = function () {};\n\t\t}\n\n\t}\n\n\tfunction WebGLMaterials(properties) {\n\t\tfunction refreshFogUniforms(uniforms, fog) {\n\t\t\tuniforms.fogColor.value.copy(fog.color);\n\n\t\t\tif (fog.isFog) {\n\t\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\t\tuniforms.fogFar.value = fog.far;\n\t\t\t} else if (fog.isFogExp2) {\n\t\t\t\tuniforms.fogDensity.value = fog.density;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {\n\t\t\tif (material.isMeshBasicMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t} else if (material.isMeshLambertMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsLambert(uniforms, material);\n\t\t\t} else if (material.isMeshToonMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsToon(uniforms, material);\n\t\t\t} else if (material.isMeshPhongMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsPhong(uniforms, material);\n\t\t\t} else if (material.isMeshStandardMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\n\t\t\t\tif (material.isMeshPhysicalMaterial) {\n\t\t\t\t\trefreshUniformsPhysical(uniforms, material, transmissionRenderTarget);\n\t\t\t\t} else {\n\t\t\t\t\trefreshUniformsStandard(uniforms, material);\n\t\t\t\t}\n\t\t\t} else if (material.isMeshMatcapMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsMatcap(uniforms, material);\n\t\t\t} else if (material.isMeshDepthMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsDepth(uniforms, material);\n\t\t\t} else if (material.isMeshDistanceMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsDistance(uniforms, material);\n\t\t\t} else if (material.isMeshNormalMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsNormal(uniforms, material);\n\t\t\t} else if (material.isLineBasicMaterial) {\n\t\t\t\trefreshUniformsLine(uniforms, material);\n\n\t\t\t\tif (material.isLineDashedMaterial) {\n\t\t\t\t\trefreshUniformsDash(uniforms, material);\n\t\t\t\t}\n\t\t\t} else if (material.isPointsMaterial) {\n\t\t\t\trefreshUniformsPoints(uniforms, material, pixelRatio, height);\n\t\t\t} else if (material.isSpriteMaterial) {\n\t\t\t\trefreshUniformsSprites(uniforms, material);\n\t\t\t} else if (material.isShadowMaterial) {\n\t\t\t\tuniforms.color.value.copy(material.color);\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\t} else if (material.isShaderMaterial) {\n\t\t\t\tmaterial.uniformsNeedUpdate = false; // #15581\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsCommon(uniforms, material) {\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t\tif (material.color) {\n\t\t\t\tuniforms.diffuse.value.copy(material.color);\n\t\t\t}\n\n\t\t\tif (material.emissive) {\n\t\t\t\tuniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n\t\t\t}\n\n\t\t\tif (material.map) {\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t}\n\n\t\t\tif (material.alphaMap) {\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\t\t\t}\n\n\t\t\tif (material.specularMap) {\n\t\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\t}\n\n\t\t\tconst envMap = properties.get(material).envMap;\n\n\t\t\tif (envMap) {\n\t\t\t\tuniforms.envMap.value = envMap;\n\t\t\t\tuniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;\n\t\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t\t\tconst maxMipLevel = properties.get(envMap).__maxMipLevel;\n\n\t\t\t\tif (maxMipLevel !== undefined) {\n\t\t\t\t\tuniforms.maxMipLevel.value = maxMipLevel;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (material.lightMap) {\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\t\t}\n\n\t\t\tif (material.aoMap) {\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\t\t\t} // uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. specular map\n\t\t\t// 3. displacementMap map\n\t\t\t// 4. normal map\n\t\t\t// 5. bump map\n\t\t\t// 6. roughnessMap map\n\t\t\t// 7. metalnessMap map\n\t\t\t// 8. alphaMap map\n\t\t\t// 9. emissiveMap map\n\t\t\t// 10. clearcoat map\n\t\t\t// 11. clearcoat normal map\n\t\t\t// 12. clearcoat roughnessMap map\n\n\n\t\t\tlet uvScaleMap;\n\n\t\t\tif (material.map) {\n\t\t\t\tuvScaleMap = material.map;\n\t\t\t} else if (material.specularMap) {\n\t\t\t\tuvScaleMap = material.specularMap;\n\t\t\t} else if (material.displacementMap) {\n\t\t\t\tuvScaleMap = material.displacementMap;\n\t\t\t} else if (material.normalMap) {\n\t\t\t\tuvScaleMap = material.normalMap;\n\t\t\t} else if (material.bumpMap) {\n\t\t\t\tuvScaleMap = material.bumpMap;\n\t\t\t} else if (material.roughnessMap) {\n\t\t\t\tuvScaleMap = material.roughnessMap;\n\t\t\t} else if (material.metalnessMap) {\n\t\t\t\tuvScaleMap = material.metalnessMap;\n\t\t\t} else if (material.alphaMap) {\n\t\t\t\tuvScaleMap = material.alphaMap;\n\t\t\t} else if (material.emissiveMap) {\n\t\t\t\tuvScaleMap = material.emissiveMap;\n\t\t\t} else if (material.clearcoatMap) {\n\t\t\t\tuvScaleMap = material.clearcoatMap;\n\t\t\t} else if (material.clearcoatNormalMap) {\n\t\t\t\tuvScaleMap = material.clearcoatNormalMap;\n\t\t\t} else if (material.clearcoatRoughnessMap) {\n\t\t\t\tuvScaleMap = material.clearcoatRoughnessMap;\n\t\t\t}\n\n\t\t\tif (uvScaleMap !== undefined) {\n\t\t\t\t// backwards compatibility\n\t\t\t\tif (uvScaleMap.isWebGLRenderTarget) {\n\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\t\t\t\t}\n\n\t\t\t\tif (uvScaleMap.matrixAutoUpdate === true) {\n\t\t\t\t\tuvScaleMap.updateMatrix();\n\t\t\t\t}\n\n\t\t\t\tuniforms.uvTransform.value.copy(uvScaleMap.matrix);\n\t\t\t} // uv repeat and offset setting priorities for uv2\n\t\t\t// 1. ao map\n\t\t\t// 2. light map\n\n\n\t\t\tlet uv2ScaleMap;\n\n\t\t\tif (material.aoMap) {\n\t\t\t\tuv2ScaleMap = material.aoMap;\n\t\t\t} else if (material.lightMap) {\n\t\t\t\tuv2ScaleMap = material.lightMap;\n\t\t\t}\n\n\t\t\tif (uv2ScaleMap !== undefined) {\n\t\t\t\t// backwards compatibility\n\t\t\t\tif (uv2ScaleMap.isWebGLRenderTarget) {\n\t\t\t\t\tuv2ScaleMap = uv2ScaleMap.texture;\n\t\t\t\t}\n\n\t\t\t\tif (uv2ScaleMap.matrixAutoUpdate === true) {\n\t\t\t\t\tuv2ScaleMap.updateMatrix();\n\t\t\t\t}\n\n\t\t\t\tuniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsLine(uniforms, material) {\n\t\t\tuniforms.diffuse.value.copy(material.color);\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t}\n\n\t\tfunction refreshUniformsDash(uniforms, material) {\n\t\t\tuniforms.dashSize.value = material.dashSize;\n\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\t\tuniforms.scale.value = material.scale;\n\t\t}\n\n\t\tfunction refreshUniformsPoints(uniforms, material, pixelRatio, height) {\n\t\t\tuniforms.diffuse.value.copy(material.color);\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\tuniforms.size.value = material.size * pixelRatio;\n\t\t\tuniforms.scale.value = height * 0.5;\n\n\t\t\tif (material.map) {\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t}\n\n\t\t\tif (material.alphaMap) {\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\t\t\t} // uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. alpha map\n\n\n\t\t\tlet uvScaleMap;\n\n\t\t\tif (material.map) {\n\t\t\t\tuvScaleMap = material.map;\n\t\t\t} else if (material.alphaMap) {\n\t\t\t\tuvScaleMap = material.alphaMap;\n\t\t\t}\n\n\t\t\tif (uvScaleMap !== undefined) {\n\t\t\t\tif (uvScaleMap.matrixAutoUpdate === true) {\n\t\t\t\t\tuvScaleMap.updateMatrix();\n\t\t\t\t}\n\n\t\t\t\tuniforms.uvTransform.value.copy(uvScaleMap.matrix);\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsSprites(uniforms, material) {\n\t\t\tuniforms.diffuse.value.copy(material.color);\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\tuniforms.rotation.value = material.rotation;\n\n\t\t\tif (material.map) {\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t}\n\n\t\t\tif (material.alphaMap) {\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\t\t\t} // uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. alpha map\n\n\n\t\t\tlet uvScaleMap;\n\n\t\t\tif (material.map) {\n\t\t\t\tuvScaleMap = material.map;\n\t\t\t} else if (material.alphaMap) {\n\t\t\t\tuvScaleMap = material.alphaMap;\n\t\t\t}\n\n\t\t\tif (uvScaleMap !== undefined) {\n\t\t\t\tif (uvScaleMap.matrixAutoUpdate === true) {\n\t\t\t\t\tuvScaleMap.updateMatrix();\n\t\t\t\t}\n\n\t\t\t\tuniforms.uvTransform.value.copy(uvScaleMap.matrix);\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsLambert(uniforms, material) {\n\t\t\tif (material.emissiveMap) {\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsPhong(uniforms, material) {\n\t\t\tuniforms.specular.value.copy(material.specular);\n\t\t\tuniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )\n\n\t\t\tif (material.emissiveMap) {\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t}\n\n\t\t\tif (material.bumpMap) {\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\t\tif (material.side === BackSide) uniforms.bumpScale.value *= -1;\n\t\t\t}\n\n\t\t\tif (material.normalMap) {\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy(material.normalScale);\n\t\t\t\tif (material.side === BackSide) uniforms.normalScale.value.negate();\n\t\t\t}\n\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsToon(uniforms, material) {\n\t\t\tif (material.gradientMap) {\n\t\t\t\tuniforms.gradientMap.value = material.gradientMap;\n\t\t\t}\n\n\t\t\tif (material.emissiveMap) {\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t}\n\n\t\t\tif (material.bumpMap) {\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\t\tif (material.side === BackSide) uniforms.bumpScale.value *= -1;\n\t\t\t}\n\n\t\t\tif (material.normalMap) {\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy(material.normalScale);\n\t\t\t\tif (material.side === BackSide) uniforms.normalScale.value.negate();\n\t\t\t}\n\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsStandard(uniforms, material) {\n\t\t\tuniforms.roughness.value = material.roughness;\n\t\t\tuniforms.metalness.value = material.metalness;\n\n\t\t\tif (material.roughnessMap) {\n\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\t\t\t}\n\n\t\t\tif (material.metalnessMap) {\n\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\t\t\t}\n\n\t\t\tif (material.emissiveMap) {\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t}\n\n\t\t\tif (material.bumpMap) {\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\t\tif (material.side === BackSide) uniforms.bumpScale.value *= -1;\n\t\t\t}\n\n\t\t\tif (material.normalMap) {\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy(material.normalScale);\n\t\t\t\tif (material.side === BackSide) uniforms.normalScale.value.negate();\n\t\t\t}\n\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\n\t\t\tconst envMap = properties.get(material).envMap;\n\n\t\t\tif (envMap) {\n\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {\n\t\t\trefreshUniformsStandard(uniforms, material);\n\t\t\tuniforms.reflectivity.value = material.reflectivity; // also part of uniforms common\n\n\t\t\tuniforms.clearcoat.value = material.clearcoat;\n\t\t\tuniforms.clearcoatRoughness.value = material.clearcoatRoughness;\n\t\t\tif (material.sheen) uniforms.sheen.value.copy(material.sheen);\n\n\t\t\tif (material.clearcoatMap) {\n\t\t\t\tuniforms.clearcoatMap.value = material.clearcoatMap;\n\t\t\t}\n\n\t\t\tif (material.clearcoatRoughnessMap) {\n\t\t\t\tuniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;\n\t\t\t}\n\n\t\t\tif (material.clearcoatNormalMap) {\n\t\t\t\tuniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);\n\t\t\t\tuniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;\n\n\t\t\t\tif (material.side === BackSide) {\n\t\t\t\t\tuniforms.clearcoatNormalScale.value.negate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tuniforms.transmission.value = material.transmission;\n\n\t\t\tif (material.transmissionMap) {\n\t\t\t\tuniforms.transmissionMap.value = material.transmissionMap;\n\t\t\t}\n\n\t\t\tif (material.transmission > 0.0) {\n\t\t\t\tuniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;\n\t\t\t\tuniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);\n\t\t\t}\n\n\t\t\tuniforms.thickness.value = material.thickness;\n\n\t\t\tif (material.thicknessMap) {\n\t\t\t\tuniforms.thicknessMap.value = material.thicknessMap;\n\t\t\t}\n\n\t\t\tuniforms.attenuationDistance.value = material.attenuationDistance;\n\t\t\tuniforms.attenuationColor.value.copy(material.attenuationColor);\n\t\t}\n\n\t\tfunction refreshUniformsMatcap(uniforms, material) {\n\t\t\tif (material.matcap) {\n\t\t\t\tuniforms.matcap.value = material.matcap;\n\t\t\t}\n\n\t\t\tif (material.bumpMap) {\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\t\tif (material.side === BackSide) uniforms.bumpScale.value *= -1;\n\t\t\t}\n\n\t\t\tif (material.normalMap) {\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy(material.normalScale);\n\t\t\t\tif (material.side === BackSide) uniforms.normalScale.value.negate();\n\t\t\t}\n\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsDepth(uniforms, material) {\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsDistance(uniforms, material) {\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\n\t\t\tuniforms.referencePosition.value.copy(material.referencePosition);\n\t\t\tuniforms.nearDistance.value = material.nearDistance;\n\t\t\tuniforms.farDistance.value = material.farDistance;\n\t\t}\n\n\t\tfunction refreshUniformsNormal(uniforms, material) {\n\t\t\tif (material.bumpMap) {\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\t\tif (material.side === BackSide) uniforms.bumpScale.value *= -1;\n\t\t\t}\n\n\t\t\tif (material.normalMap) {\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy(material.normalScale);\n\t\t\t\tif (material.side === BackSide) uniforms.normalScale.value.negate();\n\t\t\t}\n\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\trefreshFogUniforms: refreshFogUniforms,\n\t\t\trefreshMaterialUniforms: refreshMaterialUniforms\n\t\t};\n\t}\n\n\tfunction createCanvasElement() {\n\t\tconst canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');\n\t\tcanvas.style.display = 'block';\n\t\treturn canvas;\n\t}\n\n\tfunction WebGLRenderer(parameters) {\n\t\tparameters = parameters || {};\n\n\t\tconst _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),\n\t\t\t\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\t\t\t\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t\t\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t\t\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t\t\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t\t\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t\t\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n\t\t\t\t\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',\n\t\t\t\t\t_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;\n\n\t\tlet currentRenderList = null;\n\t\tlet currentRenderState = null; // render() can be called from within a callback triggered by another render.\n\t\t// We track this so that the nested render call gets its list and state isolated from the parent render call.\n\n\t\tconst renderListStack = [];\n\t\tconst renderStateStack = []; // public properties\n\n\t\tthis.domElement = _canvas; // Debug configuration container\n\n\t\tthis.debug = {\n\t\t\t/**\n\t\t\t * Enables error checking and reporting when shader programs are being compiled\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tcheckShaderErrors: true\n\t\t}; // clearing\n\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true; // scene graph\n\n\t\tthis.sortObjects = true; // user-defined clipping\n\n\t\tthis.clippingPlanes = [];\n\t\tthis.localClippingEnabled = false; // physically based shading\n\n\t\tthis.gammaFactor = 2.0; // for backwards compatibility\n\n\t\tthis.outputEncoding = LinearEncoding; // physical lights\n\n\t\tthis.physicallyCorrectLights = false; // tone mapping\n\n\t\tthis.toneMapping = NoToneMapping;\n\t\tthis.toneMappingExposure = 1.0; // internal properties\n\n\t\tconst _this = this;\n\n\t\tlet _isContextLost = false; // internal state cache\n\n\t\tlet _currentActiveCubeFace = 0;\n\t\tlet _currentActiveMipmapLevel = 0;\n\t\tlet _currentRenderTarget = null;\n\n\t\tlet _currentMaterialId = -1;\n\n\t\tlet _currentCamera = null;\n\n\t\tconst _currentViewport = new Vector4();\n\n\t\tconst _currentScissor = new Vector4();\n\n\t\tlet _currentScissorTest = null; //\n\n\t\tlet _width = _canvas.width;\n\t\tlet _height = _canvas.height;\n\t\tlet _pixelRatio = 1;\n\t\tlet _opaqueSort = null;\n\t\tlet _transparentSort = null;\n\n\t\tconst _viewport = new Vector4(0, 0, _width, _height);\n\n\t\tconst _scissor = new Vector4(0, 0, _width, _height);\n\n\t\tlet _scissorTest = false; //\n\n\t\tconst _currentDrawBuffers = []; // frustum\n\n\t\tconst _frustum = new Frustum(); // clipping\n\n\n\t\tlet _clippingEnabled = false;\n\t\tlet _localClippingEnabled = false; // transmission\n\n\t\tlet _transmissionRenderTarget = null; // camera matrices cache\n\n\t\tconst _projScreenMatrix = new Matrix4();\n\n\t\tconst _vector3 = new Vector3();\n\n\t\tconst _emptyScene = {\n\t\t\tbackground: null,\n\t\t\tfog: null,\n\t\t\tenvironment: null,\n\t\t\toverrideMaterial: null,\n\t\t\tisScene: true\n\t\t};\n\n\t\tfunction getTargetPixelRatio() {\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\t\t} // initialize\n\n\n\t\tlet _gl = _context;\n\n\t\tfunction getContext(contextNames, contextAttributes) {\n\t\t\tfor (let i = 0; i < contextNames.length; i++) {\n\t\t\t\tconst contextName = contextNames[i];\n\n\t\t\t\tconst context = _canvas.getContext(contextName, contextAttributes);\n\n\t\t\t\tif (context !== null) return context;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tconst contextAttributes = {\n\t\t\t\talpha: _alpha,\n\t\t\t\tdepth: _depth,\n\t\t\t\tstencil: _stencil,\n\t\t\t\tantialias: _antialias,\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer,\n\t\t\t\tpowerPreference: _powerPreference,\n\t\t\t\tfailIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat\n\t\t\t}; // event listeners must be registered before WebGL context is created, see #12753\n\n\t\t\t_canvas.addEventListener('webglcontextlost', onContextLost, false);\n\n\t\t\t_canvas.addEventListener('webglcontextrestored', onContextRestore, false);\n\n\t\t\tif (_gl === null) {\n\t\t\t\tconst contextNames = ['webgl2', 'webgl', 'experimental-webgl'];\n\n\t\t\t\tif (_this.isWebGL1Renderer === true) {\n\t\t\t\t\tcontextNames.shift();\n\t\t\t\t}\n\n\t\t\t\t_gl = getContext(contextNames, contextAttributes);\n\n\t\t\t\tif (_gl === null) {\n\t\t\t\t\tif (getContext(contextNames)) {\n\t\t\t\t\t\tthrow new Error('Error creating WebGL context with your selected attributes.');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Error creating WebGL context.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\n\t\t\tif (_gl.getShaderPrecisionFormat === undefined) {\n\t\t\t\t_gl.getShaderPrecisionFormat = function () {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t'rangeMin': 1,\n\t\t\t\t\t\t'rangeMax': 1,\n\t\t\t\t\t\t'precision': 1\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error('THREE.WebGLRenderer: ' + error.message);\n\t\t\tthrow error;\n\t\t}\n\n\t\tlet extensions, capabilities, state, info;\n\t\tlet properties, textures, cubemaps, attributes, geometries, objects;\n\t\tlet programCache, materials, renderLists, renderStates, clipping, shadowMap;\n\t\tlet background, morphtargets, bufferRenderer, indexedBufferRenderer;\n\t\tlet utils, bindingStates;\n\n\t\tfunction initGLContext() {\n\t\t\textensions = new WebGLExtensions(_gl);\n\t\t\tcapabilities = new WebGLCapabilities(_gl, extensions, parameters);\n\t\t\textensions.init(capabilities);\n\t\t\tutils = new WebGLUtils(_gl, extensions, capabilities);\n\t\t\tstate = new WebGLState(_gl, extensions, capabilities);\n\t\t\t_currentDrawBuffers[0] = _gl.BACK;\n\t\t\tinfo = new WebGLInfo(_gl);\n\t\t\tproperties = new WebGLProperties();\n\t\t\ttextures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);\n\t\t\tcubemaps = new WebGLCubeMaps(_this);\n\t\t\tattributes = new WebGLAttributes(_gl, capabilities);\n\t\t\tbindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);\n\t\t\tgeometries = new WebGLGeometries(_gl, attributes, info, bindingStates);\n\t\t\tobjects = new WebGLObjects(_gl, geometries, attributes, info);\n\t\t\tmorphtargets = new WebGLMorphtargets(_gl);\n\t\t\tclipping = new WebGLClipping(properties);\n\t\t\tprogramCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);\n\t\t\tmaterials = new WebGLMaterials(properties);\n\t\t\trenderLists = new WebGLRenderLists(properties);\n\t\t\trenderStates = new WebGLRenderStates(extensions, capabilities);\n\t\t\tbackground = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);\n\t\t\tshadowMap = new WebGLShadowMap(_this, objects, capabilities);\n\t\t\tbufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);\n\t\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);\n\t\t\tinfo.programs = programCache.programs;\n\t\t\t_this.capabilities = capabilities;\n\t\t\t_this.extensions = extensions;\n\t\t\t_this.properties = properties;\n\t\t\t_this.renderLists = renderLists;\n\t\t\t_this.shadowMap = shadowMap;\n\t\t\t_this.state = state;\n\t\t\t_this.info = info;\n\t\t}\n\n\t\tinitGLContext(); // xr\n\n\t\tconst xr = new WebXRManager(_this, _gl);\n\t\tthis.xr = xr; // API\n\n\t\tthis.getContext = function () {\n\t\t\treturn _gl;\n\t\t};\n\n\t\tthis.getContextAttributes = function () {\n\t\t\treturn _gl.getContextAttributes();\n\t\t};\n\n\t\tthis.forceContextLoss = function () {\n\t\t\tconst extension = extensions.get('WEBGL_lose_context');\n\t\t\tif (extension) extension.loseContext();\n\t\t};\n\n\t\tthis.forceContextRestore = function () {\n\t\t\tconst extension = extensions.get('WEBGL_lose_context');\n\t\t\tif (extension) extension.restoreContext();\n\t\t};\n\n\t\tthis.getPixelRatio = function () {\n\t\t\treturn _pixelRatio;\n\t\t};\n\n\t\tthis.setPixelRatio = function (value) {\n\t\t\tif (value === undefined) return;\n\t\t\t_pixelRatio = value;\n\t\t\tthis.setSize(_width, _height, false);\n\t\t};\n\n\t\tthis.getSize = function (target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn target.set(_width, _height);\n\t\t};\n\n\t\tthis.setSize = function (width, height, updateStyle) {\n\t\t\tif (xr.isPresenting) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\t\t\t_canvas.width = Math.floor(width * _pixelRatio);\n\t\t\t_canvas.height = Math.floor(height * _pixelRatio);\n\n\t\t\tif (updateStyle !== false) {\n\t\t\t\t_canvas.style.width = width + 'px';\n\t\t\t\t_canvas.style.height = height + 'px';\n\t\t\t}\n\n\t\t\tthis.setViewport(0, 0, width, height);\n\t\t};\n\n\t\tthis.getDrawingBufferSize = function (target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn target.set(_width * _pixelRatio, _height * _pixelRatio).floor();\n\t\t};\n\n\t\tthis.setDrawingBufferSize = function (width, height, pixelRatio) {\n\t\t\t_width = width;\n\t\t\t_height = height;\n\t\t\t_pixelRatio = pixelRatio;\n\t\t\t_canvas.width = Math.floor(width * pixelRatio);\n\t\t\t_canvas.height = Math.floor(height * pixelRatio);\n\t\t\tthis.setViewport(0, 0, width, height);\n\t\t};\n\n\t\tthis.getCurrentViewport = function (target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');\n\t\t\t\ttarget = new Vector4();\n\t\t\t}\n\n\t\t\treturn target.copy(_currentViewport);\n\t\t};\n\n\t\tthis.getViewport = function (target) {\n\t\t\treturn target.copy(_viewport);\n\t\t};\n\n\t\tthis.setViewport = function (x, y, width, height) {\n\t\t\tif (x.isVector4) {\n\t\t\t\t_viewport.set(x.x, x.y, x.z, x.w);\n\t\t\t} else {\n\t\t\t\t_viewport.set(x, y, width, height);\n\t\t\t}\n\n\t\t\tstate.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());\n\t\t};\n\n\t\tthis.getScissor = function (target) {\n\t\t\treturn target.copy(_scissor);\n\t\t};\n\n\t\tthis.setScissor = function (x, y, width, height) {\n\t\t\tif (x.isVector4) {\n\t\t\t\t_scissor.set(x.x, x.y, x.z, x.w);\n\t\t\t} else {\n\t\t\t\t_scissor.set(x, y, width, height);\n\t\t\t}\n\n\t\t\tstate.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());\n\t\t};\n\n\t\tthis.getScissorTest = function () {\n\t\t\treturn _scissorTest;\n\t\t};\n\n\t\tthis.setScissorTest = function (boolean) {\n\t\t\tstate.setScissorTest(_scissorTest = boolean);\n\t\t};\n\n\t\tthis.setOpaqueSort = function (method) {\n\t\t\t_opaqueSort = method;\n\t\t};\n\n\t\tthis.setTransparentSort = function (method) {\n\t\t\t_transparentSort = method;\n\t\t}; // Clearing\n\n\n\t\tthis.getClearColor = function (target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('WebGLRenderer: .getClearColor() now requires a Color as an argument');\n\t\t\t\ttarget = new Color();\n\t\t\t}\n\n\t\t\treturn target.copy(background.getClearColor());\n\t\t};\n\n\t\tthis.setClearColor = function () {\n\t\t\tbackground.setClearColor.apply(background, arguments);\n\t\t};\n\n\t\tthis.getClearAlpha = function () {\n\t\t\treturn background.getClearAlpha();\n\t\t};\n\n\t\tthis.setClearAlpha = function () {\n\t\t\tbackground.setClearAlpha.apply(background, arguments);\n\t\t};\n\n\t\tthis.clear = function (color, depth, stencil) {\n\t\t\tlet bits = 0;\n\t\t\tif (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;\n\t\t\tif (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\tif (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t\t_gl.clear(bits);\n\t\t};\n\n\t\tthis.clearColor = function () {\n\t\t\tthis.clear(true, false, false);\n\t\t};\n\n\t\tthis.clearDepth = function () {\n\t\t\tthis.clear(false, true, false);\n\t\t};\n\n\t\tthis.clearStencil = function () {\n\t\t\tthis.clear(false, false, true);\n\t\t}; //\n\n\n\t\tthis.dispose = function () {\n\t\t\t_canvas.removeEventListener('webglcontextlost', onContextLost, false);\n\n\t\t\t_canvas.removeEventListener('webglcontextrestored', onContextRestore, false);\n\n\t\t\trenderLists.dispose();\n\t\t\trenderStates.dispose();\n\t\t\tproperties.dispose();\n\t\t\tcubemaps.dispose();\n\t\t\tobjects.dispose();\n\t\t\tbindingStates.dispose();\n\t\t\txr.dispose();\n\t\t\txr.removeEventListener('sessionstart', onXRSessionStart);\n\t\t\txr.removeEventListener('sessionend', onXRSessionEnd);\n\n\t\t\tif (_transmissionRenderTarget) {\n\t\t\t\t_transmissionRenderTarget.dispose();\n\n\t\t\t\t_transmissionRenderTarget = null;\n\t\t\t}\n\n\t\t\tanimation.stop();\n\t\t}; // Events\n\n\n\t\tfunction onContextLost(event) {\n\t\t\tevent.preventDefault();\n\t\t\tconsole.log('THREE.WebGLRenderer: Context Lost.');\n\t\t\t_isContextLost = true;\n\t\t}\n\n\t\tfunction onContextRestore()\n\t\t/* event */\n\t\t{\n\t\t\tconsole.log('THREE.WebGLRenderer: Context Restored.');\n\t\t\t_isContextLost = false;\n\t\t\tconst infoAutoReset = info.autoReset;\n\t\t\tconst shadowMapEnabled = shadowMap.enabled;\n\t\t\tconst shadowMapAutoUpdate = shadowMap.autoUpdate;\n\t\t\tconst shadowMapNeedsUpdate = shadowMap.needsUpdate;\n\t\t\tconst shadowMapType = shadowMap.type;\n\t\t\tinitGLContext();\n\t\t\tinfo.autoReset = infoAutoReset;\n\t\t\tshadowMap.enabled = shadowMapEnabled;\n\t\t\tshadowMap.autoUpdate = shadowMapAutoUpdate;\n\t\t\tshadowMap.needsUpdate = shadowMapNeedsUpdate;\n\t\t\tshadowMap.type = shadowMapType;\n\t\t}\n\n\t\tfunction onMaterialDispose(event) {\n\t\t\tconst material = event.target;\n\t\t\tmaterial.removeEventListener('dispose', onMaterialDispose);\n\t\t\tdeallocateMaterial(material);\n\t\t} // Buffer deallocation\n\n\n\t\tfunction deallocateMaterial(material) {\n\t\t\treleaseMaterialProgramReferences(material);\n\t\t\tproperties.remove(material);\n\t\t}\n\n\t\tfunction releaseMaterialProgramReferences(material) {\n\t\t\tconst programs = properties.get(material).programs;\n\n\t\t\tif (programs !== undefined) {\n\t\t\t\tprograms.forEach(function (program) {\n\t\t\t\t\tprogramCache.releaseProgram(program);\n\t\t\t\t});\n\t\t\t}\n\t\t} // Buffer rendering\n\n\n\t\tfunction renderObjectImmediate(object, program) {\n\t\t\tobject.render(function (object) {\n\t\t\t\t_this.renderBufferImmediate(object, program);\n\t\t\t});\n\t\t}\n\n\t\tthis.renderBufferImmediate = function (object, program) {\n\t\t\tbindingStates.initAttributes();\n\t\t\tconst buffers = properties.get(object);\n\t\t\tif (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();\n\t\t\tif (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();\n\t\t\tif (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();\n\t\t\tif (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();\n\t\t\tconst programAttributes = program.getAttributes();\n\n\t\t\tif (object.hasPositions) {\n\t\t\t\t_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);\n\n\t\t\t\t_gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);\n\n\t\t\t\tbindingStates.enableAttribute(programAttributes.position);\n\n\t\t\t\t_gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);\n\t\t\t}\n\n\t\t\tif (object.hasNormals) {\n\t\t\t\t_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);\n\n\t\t\t\t_gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);\n\n\t\t\t\tbindingStates.enableAttribute(programAttributes.normal);\n\n\t\t\t\t_gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);\n\t\t\t}\n\n\t\t\tif (object.hasUvs) {\n\t\t\t\t_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);\n\n\t\t\t\t_gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);\n\n\t\t\t\tbindingStates.enableAttribute(programAttributes.uv);\n\n\t\t\t\t_gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);\n\t\t\t}\n\n\t\t\tif (object.hasColors) {\n\t\t\t\t_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);\n\n\t\t\t\t_gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);\n\n\t\t\t\tbindingStates.enableAttribute(programAttributes.color);\n\n\t\t\t\t_gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);\n\t\t\t}\n\n\t\t\tbindingStates.disableUnusedAttributes();\n\n\t\t\t_gl.drawArrays(_gl.TRIANGLES, 0, object.count);\n\n\t\t\tobject.count = 0;\n\t\t};\n\n\t\tthis.renderBufferDirect = function (camera, scene, geometry, material, object, group) {\n\t\t\tif (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\n\n\t\t\tconst frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;\n\t\t\tconst program = setProgram(camera, scene, material, object);\n\t\t\tstate.setMaterial(material, frontFaceCW); //\n\n\t\t\tlet index = geometry.index;\n\t\t\tconst position = geometry.attributes.position; //\n\n\t\t\tif (index === null) {\n\t\t\t\tif (position === undefined || position.count === 0) return;\n\t\t\t} else if (index.count === 0) {\n\t\t\t\treturn;\n\t\t\t} //\n\n\n\t\t\tlet rangeFactor = 1;\n\n\t\t\tif (material.wireframe === true) {\n\t\t\t\tindex = geometries.getWireframeAttribute(geometry);\n\t\t\t\trangeFactor = 2;\n\t\t\t}\n\n\t\t\tif (material.morphTargets || material.morphNormals) {\n\t\t\t\tmorphtargets.update(object, geometry, material, program);\n\t\t\t}\n\n\t\t\tbindingStates.setup(object, material, program, geometry, index);\n\t\t\tlet attribute;\n\t\t\tlet renderer = bufferRenderer;\n\n\t\t\tif (index !== null) {\n\t\t\t\tattribute = attributes.get(index);\n\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\trenderer.setIndex(attribute);\n\t\t\t} //\n\n\n\t\t\tconst dataCount = index !== null ? index.count : position.count;\n\t\t\tconst rangeStart = geometry.drawRange.start * rangeFactor;\n\t\t\tconst rangeCount = geometry.drawRange.count * rangeFactor;\n\t\t\tconst groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\t\tconst groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\t\t\tconst drawStart = Math.max(rangeStart, groupStart);\n\t\t\tconst drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;\n\t\t\tconst drawCount = Math.max(0, drawEnd - drawStart + 1);\n\t\t\tif (drawCount === 0) return; //\n\n\t\t\tif (object.isMesh) {\n\t\t\t\tif (material.wireframe === true) {\n\t\t\t\t\tstate.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());\n\t\t\t\t\trenderer.setMode(_gl.LINES);\n\t\t\t\t} else {\n\t\t\t\t\trenderer.setMode(_gl.TRIANGLES);\n\t\t\t\t}\n\t\t\t} else if (object.isLine) {\n\t\t\t\tlet lineWidth = material.linewidth;\n\t\t\t\tif (lineWidth === undefined) lineWidth = 1; // Not using Line*Material\n\n\t\t\t\tstate.setLineWidth(lineWidth * getTargetPixelRatio());\n\n\t\t\t\tif (object.isLineSegments) {\n\t\t\t\t\trenderer.setMode(_gl.LINES);\n\t\t\t\t} else if (object.isLineLoop) {\n\t\t\t\t\trenderer.setMode(_gl.LINE_LOOP);\n\t\t\t\t} else {\n\t\t\t\t\trenderer.setMode(_gl.LINE_STRIP);\n\t\t\t\t}\n\t\t\t} else if (object.isPoints) {\n\t\t\t\trenderer.setMode(_gl.POINTS);\n\t\t\t} else if (object.isSprite) {\n\t\t\t\trenderer.setMode(_gl.TRIANGLES);\n\t\t\t}\n\n\t\t\tif (object.isInstancedMesh) {\n\t\t\t\trenderer.renderInstances(drawStart, drawCount, object.count);\n\t\t\t} else if (geometry.isInstancedBufferGeometry) {\n\t\t\t\tconst instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);\n\t\t\t\trenderer.renderInstances(drawStart, drawCount, instanceCount);\n\t\t\t} else {\n\t\t\t\trenderer.render(drawStart, drawCount);\n\t\t\t}\n\t\t}; // Compile\n\n\n\t\tthis.compile = function (scene, camera) {\n\t\t\tcurrentRenderState = renderStates.get(scene);\n\t\t\tcurrentRenderState.init();\n\t\t\tscene.traverseVisible(function (object) {\n\t\t\t\tif (object.isLight && object.layers.test(camera.layers)) {\n\t\t\t\t\tcurrentRenderState.pushLight(object);\n\n\t\t\t\t\tif (object.castShadow) {\n\t\t\t\t\t\tcurrentRenderState.pushShadow(object);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tcurrentRenderState.setupLights();\n\t\t\tscene.traverse(function (object) {\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif (material) {\n\t\t\t\t\tif (Array.isArray(material)) {\n\t\t\t\t\t\tfor (let i = 0; i < material.length; i++) {\n\t\t\t\t\t\t\tconst material2 = material[i];\n\t\t\t\t\t\t\tgetProgram(material2, scene, object);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgetProgram(material, scene, object);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}; // Animation Loop\n\n\n\t\tlet onAnimationFrameCallback = null;\n\n\t\tfunction onAnimationFrame(time) {\n\t\t\tif (onAnimationFrameCallback) onAnimationFrameCallback(time);\n\t\t}\n\n\t\tfunction onXRSessionStart() {\n\t\t\tanimation.stop();\n\t\t}\n\n\t\tfunction onXRSessionEnd() {\n\t\t\tanimation.start();\n\t\t}\n\n\t\tconst animation = new WebGLAnimation();\n\t\tanimation.setAnimationLoop(onAnimationFrame);\n\t\tif (typeof window !== 'undefined') animation.setContext(window);\n\n\t\tthis.setAnimationLoop = function (callback) {\n\t\t\tonAnimationFrameCallback = callback;\n\t\t\txr.setAnimationLoop(callback);\n\t\t\tcallback === null ? animation.stop() : animation.start();\n\t\t};\n\n\t\txr.addEventListener('sessionstart', onXRSessionStart);\n\t\txr.addEventListener('sessionend', onXRSessionEnd); // Rendering\n\n\t\tthis.render = function (scene, camera) {\n\t\t\tif (camera !== undefined && camera.isCamera !== true) {\n\t\t\t\tconsole.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_isContextLost === true) return; // update scene graph\n\n\t\t\tif (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum\n\n\t\t\tif (camera.parent === null) camera.updateMatrixWorld();\n\n\t\t\tif (xr.enabled === true && xr.isPresenting === true) {\n\t\t\t\tif (xr.cameraAutoUpdate === true) xr.updateCamera(camera);\n\t\t\t\tcamera = xr.getCamera(); // use XR camera for rendering\n\t\t\t} //\n\n\n\t\t\tif (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);\n\t\t\tcurrentRenderState = renderStates.get(scene, renderStateStack.length);\n\t\t\tcurrentRenderState.init();\n\t\t\trenderStateStack.push(currentRenderState);\n\n\t\t\t_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n\n\t\t\t_frustum.setFromProjectionMatrix(_projScreenMatrix);\n\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t_clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);\n\t\t\tcurrentRenderList = renderLists.get(scene, renderListStack.length);\n\t\t\tcurrentRenderList.init();\n\t\t\trenderListStack.push(currentRenderList);\n\t\t\tprojectObject(scene, camera, 0, _this.sortObjects);\n\t\t\tcurrentRenderList.finish();\n\n\t\t\tif (_this.sortObjects === true) {\n\t\t\t\tcurrentRenderList.sort(_opaqueSort, _transparentSort);\n\t\t\t} //\n\n\n\t\t\tif (_clippingEnabled === true) clipping.beginShadows();\n\t\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\t\t\tshadowMap.render(shadowsArray, scene, camera);\n\t\t\tcurrentRenderState.setupLights();\n\t\t\tcurrentRenderState.setupLightsView(camera);\n\t\t\tif (_clippingEnabled === true) clipping.endShadows(); //\n\n\t\t\tif (this.info.autoReset === true) this.info.reset(); //\n\n\t\t\tbackground.render(currentRenderList, scene); // render scene\n\n\t\t\tconst opaqueObjects = currentRenderList.opaque;\n\t\t\tconst transmissiveObjects = currentRenderList.transmissive;\n\t\t\tconst transparentObjects = currentRenderList.transparent;\n\t\t\tif (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);\n\t\t\tif (transmissiveObjects.length > 0) renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera);\n\t\t\tif (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera); //\n\n\t\t\tif (_currentRenderTarget !== null) {\n\t\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\t\t\t\ttextures.updateRenderTargetMipmap(_currentRenderTarget); // resolve multisample renderbuffers to a single-sample texture if necessary\n\n\t\t\t\ttextures.updateMultisampleRenderTarget(_currentRenderTarget);\n\t\t\t} //\n\n\n\t\t\tif (scene.isScene === true) scene.onAfterRender(_this, scene, camera); // Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\t\tstate.buffers.depth.setTest(true);\n\t\t\tstate.buffers.depth.setMask(true);\n\t\t\tstate.buffers.color.setMask(true);\n\t\t\tstate.setPolygonOffset(false); // _gl.finish();\n\n\t\t\tbindingStates.resetDefaultState();\n\t\t\t_currentMaterialId = -1;\n\t\t\t_currentCamera = null;\n\t\t\trenderStateStack.pop();\n\n\t\t\tif (renderStateStack.length > 0) {\n\t\t\t\tcurrentRenderState = renderStateStack[renderStateStack.length - 1];\n\t\t\t} else {\n\t\t\t\tcurrentRenderState = null;\n\t\t\t}\n\n\t\t\trenderListStack.pop();\n\n\t\t\tif (renderListStack.length > 0) {\n\t\t\t\tcurrentRenderList = renderListStack[renderListStack.length - 1];\n\t\t\t} else {\n\t\t\t\tcurrentRenderList = null;\n\t\t\t}\n\t\t};\n\n\t\tfunction projectObject(object, camera, groupOrder, sortObjects) {\n\t\t\tif (object.visible === false) return;\n\t\t\tconst visible = object.layers.test(camera.layers);\n\n\t\t\tif (visible) {\n\t\t\t\tif (object.isGroup) {\n\t\t\t\t\tgroupOrder = object.renderOrder;\n\t\t\t\t} else if (object.isLOD) {\n\t\t\t\t\tif (object.autoUpdate === true) object.update(camera);\n\t\t\t\t} else if (object.isLight) {\n\t\t\t\t\tcurrentRenderState.pushLight(object);\n\n\t\t\t\t\tif (object.castShadow) {\n\t\t\t\t\t\tcurrentRenderState.pushShadow(object);\n\t\t\t\t\t}\n\t\t\t\t} else if (object.isSprite) {\n\t\t\t\t\tif (!object.frustumCulled || _frustum.intersectsSprite(object)) {\n\t\t\t\t\t\tif (sortObjects) {\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst geometry = objects.update(object);\n\t\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\t\tif (material.visible) {\n\t\t\t\t\t\t\tcurrentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (object.isImmediateRenderObject) {\n\t\t\t\t\tif (sortObjects) {\n\t\t\t\t\t\t_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);\n\t\t\t\t} else if (object.isMesh || object.isLine || object.isPoints) {\n\t\t\t\t\tif (object.isSkinnedMesh) {\n\t\t\t\t\t\t// update skeleton only once in a frame\n\t\t\t\t\t\tif (object.skeleton.frame !== info.render.frame) {\n\t\t\t\t\t\t\tobject.skeleton.update();\n\t\t\t\t\t\t\tobject.skeleton.frame = info.render.frame;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!object.frustumCulled || _frustum.intersectsObject(object)) {\n\t\t\t\t\t\tif (sortObjects) {\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst geometry = objects.update(object);\n\t\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\t\tif (Array.isArray(material)) {\n\t\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\t\tfor (let i = 0, l = groups.length; i < l; i++) {\n\t\t\t\t\t\t\t\tconst group = groups[i];\n\t\t\t\t\t\t\t\tconst groupMaterial = material[group.materialIndex];\n\n\t\t\t\t\t\t\t\tif (groupMaterial && groupMaterial.visible) {\n\t\t\t\t\t\t\t\t\tcurrentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (material.visible) {\n\t\t\t\t\t\t\tcurrentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst children = object.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tprojectObject(children[i], camera, groupOrder, sortObjects);\n\t\t\t}\n\t\t}\n\n\t\tfunction renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera) {\n\t\t\tif (_transmissionRenderTarget === null) {\n\t\t\t\t_transmissionRenderTarget = new WebGLRenderTarget(1024, 1024, {\n\t\t\t\t\tgenerateMipmaps: true,\n\t\t\t\t\tminFilter: LinearMipmapLinearFilter,\n\t\t\t\t\tmagFilter: NearestFilter,\n\t\t\t\t\twrapS: ClampToEdgeWrapping,\n\t\t\t\t\twrapT: ClampToEdgeWrapping\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst currentRenderTarget = _this.getRenderTarget();\n\n\t\t\t_this.setRenderTarget(_transmissionRenderTarget);\n\n\t\t\t_this.clear();\n\n\t\t\trenderObjects(opaqueObjects, scene, camera);\n\t\t\ttextures.updateRenderTargetMipmap(_transmissionRenderTarget);\n\n\t\t\t_this.setRenderTarget(currentRenderTarget);\n\n\t\t\trenderObjects(transmissiveObjects, scene, camera);\n\t\t}\n\n\t\tfunction renderObjects(renderList, scene, camera) {\n\t\t\tconst overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n\t\t\tfor (let i = 0, l = renderList.length; i < l; i++) {\n\t\t\t\tconst renderItem = renderList[i];\n\t\t\t\tconst object = renderItem.object;\n\t\t\t\tconst geometry = renderItem.geometry;\n\t\t\t\tconst material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n\t\t\t\tconst group = renderItem.group;\n\n\t\t\t\tif (camera.isArrayCamera) {\n\t\t\t\t\tconst cameras = camera.cameras;\n\n\t\t\t\t\tfor (let j = 0, jl = cameras.length; j < jl; j++) {\n\t\t\t\t\t\tconst camera2 = cameras[j];\n\n\t\t\t\t\t\tif (object.layers.test(camera2.layers)) {\n\t\t\t\t\t\t\tstate.viewport(_currentViewport.copy(camera2.viewport));\n\t\t\t\t\t\t\tcurrentRenderState.setupLightsView(camera2);\n\t\t\t\t\t\t\trenderObject(object, scene, camera2, geometry, material, group);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trenderObject(object, scene, camera, geometry, material, group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction renderObject(object, scene, camera, geometry, material, group) {\n\t\t\tobject.onBeforeRender(_this, scene, camera, geometry, material, group);\n\t\t\tobject.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n\t\t\tobject.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n\n\t\t\tif (object.isImmediateRenderObject) {\n\t\t\t\tconst program = setProgram(camera, scene, material, object);\n\t\t\t\tstate.setMaterial(material);\n\t\t\t\tbindingStates.reset();\n\t\t\t\trenderObjectImmediate(object, program);\n\t\t\t} else {\n\t\t\t\t_this.renderBufferDirect(camera, scene, geometry, material, object, group);\n\t\t\t}\n\n\t\t\tobject.onAfterRender(_this, scene, camera, geometry, material, group);\n\t\t}\n\n\t\tfunction getProgram(material, scene, object) {\n\t\t\tif (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\t\tconst materialProperties = properties.get(material);\n\t\t\tconst lights = currentRenderState.state.lights;\n\t\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\t\t\tconst lightsStateVersion = lights.state.version;\n\t\t\tconst parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);\n\t\t\tconst programCacheKey = programCache.getProgramCacheKey(parameters);\n\t\t\tlet programs = materialProperties.programs; // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change\n\n\t\t\tmaterialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tmaterialProperties.fog = scene.fog;\n\t\t\tmaterialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);\n\n\t\t\tif (programs === undefined) {\n\t\t\t\t// new material\n\t\t\t\tmaterial.addEventListener('dispose', onMaterialDispose);\n\t\t\t\tprograms = new Map();\n\t\t\t\tmaterialProperties.programs = programs;\n\t\t\t}\n\n\t\t\tlet program = programs.get(programCacheKey);\n\n\t\t\tif (program !== undefined) {\n\t\t\t\t// early out if program and light state is identical\n\t\t\t\tif (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {\n\t\t\t\t\tupdateCommonMaterialProperties(material, parameters);\n\t\t\t\t\treturn program;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tparameters.uniforms = programCache.getUniforms(material);\n\t\t\t\tmaterial.onBuild(parameters, _this);\n\t\t\t\tmaterial.onBeforeCompile(parameters, _this);\n\t\t\t\tprogram = programCache.acquireProgram(parameters, programCacheKey);\n\t\t\t\tprograms.set(programCacheKey, program);\n\t\t\t\tmaterialProperties.uniforms = parameters.uniforms;\n\t\t\t}\n\n\t\t\tconst uniforms = materialProperties.uniforms;\n\n\t\t\tif (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {\n\t\t\t\tuniforms.clippingPlanes = clipping.uniform;\n\t\t\t}\n\n\t\t\tupdateCommonMaterialProperties(material, parameters); // store the light setup it was created for\n\n\t\t\tmaterialProperties.needsLights = materialNeedsLights(material);\n\t\t\tmaterialProperties.lightsStateVersion = lightsStateVersion;\n\n\t\t\tif (materialProperties.needsLights) {\n\t\t\t\t// wire up the material to this renderer's lighting state\n\t\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\n\t\t\t\tuniforms.lightProbe.value = lights.state.probe;\n\t\t\t\tuniforms.directionalLights.value = lights.state.directional;\n\t\t\t\tuniforms.directionalLightShadows.value = lights.state.directionalShadow;\n\t\t\t\tuniforms.spotLights.value = lights.state.spot;\n\t\t\t\tuniforms.spotLightShadows.value = lights.state.spotShadow;\n\t\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\n\t\t\t\tuniforms.ltc_1.value = lights.state.rectAreaLTC1;\n\t\t\t\tuniforms.ltc_2.value = lights.state.rectAreaLTC2;\n\t\t\t\tuniforms.pointLights.value = lights.state.point;\n\t\t\t\tuniforms.pointLightShadows.value = lights.state.pointShadow;\n\t\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\n\t\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n\t\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n\t\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\n\t\t\t\tuniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\n\t\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\n\t\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms\n\t\t\t}\n\n\t\t\tconst progUniforms = program.getUniforms();\n\t\t\tconst uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);\n\t\t\tmaterialProperties.currentProgram = program;\n\t\t\tmaterialProperties.uniformsList = uniformsList;\n\t\t\treturn program;\n\t\t}\n\n\t\tfunction updateCommonMaterialProperties(material, parameters) {\n\t\t\tconst materialProperties = properties.get(material);\n\t\t\tmaterialProperties.outputEncoding = parameters.outputEncoding;\n\t\t\tmaterialProperties.instancing = parameters.instancing;\n\t\t\tmaterialProperties.skinning = parameters.skinning;\n\t\t\tmaterialProperties.numClippingPlanes = parameters.numClippingPlanes;\n\t\t\tmaterialProperties.numIntersection = parameters.numClipIntersection;\n\t\t\tmaterialProperties.vertexAlphas = parameters.vertexAlphas;\n\t\t}\n\n\t\tfunction setProgram(camera, scene, material, object) {\n\t\t\tif (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\t\ttextures.resetTextureUnits();\n\t\t\tconst fog = scene.fog;\n\t\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tconst encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;\n\t\t\tconst envMap = cubemaps.get(material.envMap || environment);\n\t\t\tconst vertexAlphas = material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;\n\t\t\tconst materialProperties = properties.get(material);\n\t\t\tconst lights = currentRenderState.state.lights;\n\n\t\t\tif (_clippingEnabled === true) {\n\t\t\t\tif (_localClippingEnabled === true || camera !== _currentCamera) {\n\t\t\t\t\tconst useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup\n\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t// (#8465, #8379)\n\n\t\t\t\t\tclipping.setState(material, camera, useCache);\n\t\t\t\t}\n\t\t\t} //\n\n\n\t\t\tlet needsProgramChange = false;\n\n\t\t\tif (material.version === materialProperties.__version) {\n\t\t\t\tif (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (materialProperties.outputEncoding !== encoding) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (object.isInstancedMesh && materialProperties.instancing === false) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (!object.isInstancedMesh && materialProperties.instancing === true) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (object.isSkinnedMesh && materialProperties.skinning === false) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (!object.isSkinnedMesh && materialProperties.skinning === true) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (materialProperties.envMap !== envMap) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (material.fog && materialProperties.fog !== fog) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (materialProperties.vertexAlphas !== vertexAlphas) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tneedsProgramChange = true;\n\t\t\t\tmaterialProperties.__version = material.version;\n\t\t\t} //\n\n\n\t\t\tlet program = materialProperties.currentProgram;\n\n\t\t\tif (needsProgramChange === true) {\n\t\t\t\tprogram = getProgram(material, scene, object);\n\t\t\t}\n\n\t\t\tlet refreshProgram = false;\n\t\t\tlet refreshMaterial = false;\n\t\t\tlet refreshLights = false;\n\t\t\tconst p_uniforms = program.getUniforms(),\n\t\t\t\t\t\tm_uniforms = materialProperties.uniforms;\n\n\t\t\tif (state.useProgram(program.program)) {\n\t\t\t\trefreshProgram = true;\n\t\t\t\trefreshMaterial = true;\n\t\t\t\trefreshLights = true;\n\t\t\t}\n\n\t\t\tif (material.id !== _currentMaterialId) {\n\t\t\t\t_currentMaterialId = material.id;\n\t\t\t\trefreshMaterial = true;\n\t\t\t}\n\n\t\t\tif (refreshProgram || _currentCamera !== camera) {\n\t\t\t\tp_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);\n\n\t\t\t\tif (capabilities.logarithmicDepthBuffer) {\n\t\t\t\t\tp_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));\n\t\t\t\t}\n\n\t\t\t\tif (_currentCamera !== camera) {\n\t\t\t\t\t_currentCamera = camera; // lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\t\trefreshMaterial = true; // set to true on material change\n\n\t\t\t\t\trefreshLights = true; // remains set until update done\n\t\t\t\t} // load material specific uniforms\n\t\t\t\t// (shader material also gets them for the sake of genericity)\n\n\n\t\t\t\tif (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {\n\t\t\t\t\tconst uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\t\tif (uCamPos !== undefined) {\n\t\t\t\t\t\tuCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {\n\t\t\t\t\tp_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);\n\t\t\t\t}\n\n\t\t\t\tif (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {\n\t\t\t\t\tp_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);\n\t\t\t\t}\n\t\t\t} // skinning uniforms must be set even if material didn't change\n\t\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t\t// otherwise textures used for skinning can take over texture units reserved for other material textures\n\n\n\t\t\tif (object.isSkinnedMesh) {\n\t\t\t\tp_uniforms.setOptional(_gl, object, 'bindMatrix');\n\t\t\t\tp_uniforms.setOptional(_gl, object, 'bindMatrixInverse');\n\t\t\t\tconst skeleton = object.skeleton;\n\n\t\t\t\tif (skeleton) {\n\t\t\t\t\tif (capabilities.floatVertexTextures) {\n\t\t\t\t\t\tif (skeleton.boneTexture === null) skeleton.computeBoneTexture();\n\t\t\t\t\t\tp_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);\n\t\t\t\t\t\tp_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp_uniforms.setOptional(_gl, skeleton, 'boneMatrices');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {\n\t\t\t\tmaterialProperties.receiveShadow = object.receiveShadow;\n\t\t\t\tp_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);\n\t\t\t}\n\n\t\t\tif (refreshMaterial) {\n\t\t\t\tp_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);\n\n\t\t\t\tif (materialProperties.needsLights) {\n\t\t\t\t\t// the current material requires lighting info\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t// values\n\t\t\t\t\t//\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t// the GL state when required\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate(m_uniforms, refreshLights);\n\t\t\t\t} // refresh uniforms common to several materials\n\n\n\t\t\t\tif (fog && material.fog) {\n\t\t\t\t\tmaterials.refreshFogUniforms(m_uniforms, fog);\n\t\t\t\t}\n\n\t\t\t\tmaterials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);\n\t\t\t\tWebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\n\t\t\t}\n\n\t\t\tif (material.isShaderMaterial && material.uniformsNeedUpdate === true) {\n\t\t\t\tWebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\n\t\t\t\tmaterial.uniformsNeedUpdate = false;\n\t\t\t}\n\n\t\t\tif (material.isSpriteMaterial) {\n\t\t\t\tp_uniforms.setValue(_gl, 'center', object.center);\n\t\t\t} // common matrices\n\n\n\t\t\tp_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);\n\t\t\tp_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);\n\t\t\tp_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);\n\t\t\treturn program;\n\t\t} // If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\n\t\tfunction markUniformsLightsNeedsUpdate(uniforms, value) {\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\t\tuniforms.lightProbe.needsUpdate = value;\n\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\tuniforms.directionalLightShadows.needsUpdate = value;\n\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\tuniforms.pointLightShadows.needsUpdate = value;\n\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\tuniforms.spotLightShadows.needsUpdate = value;\n\t\t\tuniforms.rectAreaLights.needsUpdate = value;\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\t\t}\n\n\t\tfunction materialNeedsLights(material) {\n\t\t\treturn material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;\n\t\t}\n\n\t\tthis.getActiveCubeFace = function () {\n\t\t\treturn _currentActiveCubeFace;\n\t\t};\n\n\t\tthis.getActiveMipmapLevel = function () {\n\t\t\treturn _currentActiveMipmapLevel;\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\t\t\treturn _currentRenderTarget;\n\t\t};\n\n\t\tthis.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {\n\t\t\t_currentRenderTarget = renderTarget;\n\t\t\t_currentActiveCubeFace = activeCubeFace;\n\t\t\t_currentActiveMipmapLevel = activeMipmapLevel;\n\n\t\t\tif (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {\n\t\t\t\ttextures.setupRenderTarget(renderTarget);\n\t\t\t}\n\n\t\t\tlet framebuffer = null;\n\t\t\tlet isCube = false;\n\t\t\tlet isRenderTarget3D = false;\n\n\t\t\tif (renderTarget) {\n\t\t\t\tconst texture = renderTarget.texture;\n\n\t\t\t\tif (texture.isDataTexture3D || texture.isDataTexture2DArray) {\n\t\t\t\t\tisRenderTarget3D = true;\n\t\t\t\t}\n\n\t\t\t\tconst __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;\n\n\t\t\t\tif (renderTarget.isWebGLCubeRenderTarget) {\n\t\t\t\t\tframebuffer = __webglFramebuffer[activeCubeFace];\n\t\t\t\t\tisCube = true;\n\t\t\t\t} else if (renderTarget.isWebGLMultisampleRenderTarget) {\n\t\t\t\t\tframebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;\n\t\t\t\t} else {\n\t\t\t\t\tframebuffer = __webglFramebuffer;\n\t\t\t\t}\n\n\t\t\t\t_currentViewport.copy(renderTarget.viewport);\n\n\t\t\t\t_currentScissor.copy(renderTarget.scissor);\n\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\t\t\t} else {\n\t\t\t\t_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();\n\n\t\t\t\t_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();\n\n\t\t\t\t_currentScissorTest = _scissorTest;\n\t\t\t}\n\n\t\t\tconst framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n\t\t\tif (framebufferBound && capabilities.drawBuffers) {\n\t\t\t\tlet needsUpdate = false;\n\n\t\t\t\tif (renderTarget) {\n\t\t\t\t\tif (renderTarget.isWebGLMultipleRenderTargets) {\n\t\t\t\t\t\tconst textures = renderTarget.texture;\n\n\t\t\t\t\t\tif (_currentDrawBuffers.length !== textures.length || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {\n\t\t\t\t\t\t\tfor (let i = 0, il = textures.length; i < il; i++) {\n\t\t\t\t\t\t\t\t_currentDrawBuffers[i] = _gl.COLOR_ATTACHMENT0 + i;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_currentDrawBuffers.length = textures.length;\n\t\t\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {\n\t\t\t\t\t\t\t_currentDrawBuffers[0] = _gl.COLOR_ATTACHMENT0;\n\t\t\t\t\t\t\t_currentDrawBuffers.length = 1;\n\t\t\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.BACK) {\n\t\t\t\t\t\t_currentDrawBuffers[0] = _gl.BACK;\n\t\t\t\t\t\t_currentDrawBuffers.length = 1;\n\t\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (needsUpdate) {\n\t\t\t\t\tif (capabilities.isWebGL2) {\n\t\t\t\t\t\t_gl.drawBuffers(_currentDrawBuffers);\n\t\t\t\t\t} else {\n\t\t\t\t\t\textensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(_currentDrawBuffers);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.viewport(_currentViewport);\n\t\t\tstate.scissor(_currentScissor);\n\t\t\tstate.setScissorTest(_currentScissorTest);\n\n\t\t\tif (isCube) {\n\t\t\t\tconst textureProperties = properties.get(renderTarget.texture);\n\n\t\t\t\t_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);\n\t\t\t} else if (isRenderTarget3D) {\n\t\t\t\tconst textureProperties = properties.get(renderTarget.texture);\n\t\t\t\tconst layer = activeCubeFace || 0;\n\n\t\t\t\t_gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);\n\t\t\t}\n\t\t};\n\n\t\tthis.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {\n\t\t\tif (!(renderTarget && renderTarget.isWebGLRenderTarget)) {\n\t\t\t\tconsole.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet framebuffer = properties.get(renderTarget).__webglFramebuffer;\n\n\t\t\tif (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {\n\t\t\t\tframebuffer = framebuffer[activeCubeFaceIndex];\n\t\t\t}\n\n\t\t\tif (framebuffer) {\n\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n\t\t\t\ttry {\n\t\t\t\t\tconst texture = renderTarget.texture;\n\t\t\t\t\tconst textureFormat = texture.format;\n\t\t\t\t\tconst textureType = texture.type;\n\n\t\t\t\t\tif (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {\n\t\t\t\t\t\tconsole.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));\n\n\t\t\t\t\tif (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t!(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t!halfFloatSupportedByExt) {\n\t\t\t\t\t\tconsole.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {\n\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\t\t\t\t\t\tif (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {\n\t\t\t\t\t\t\t_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\t// restore framebuffer of current render target if necessary\n\t\t\t\t\tconst framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;\n\t\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.copyFramebufferToTexture = function (position, texture, level = 0) {\n\t\t\tconst levelScale = Math.pow(2, -level);\n\t\t\tconst width = Math.floor(texture.image.width * levelScale);\n\t\t\tconst height = Math.floor(texture.image.height * levelScale);\n\t\t\tlet glFormat = utils.convert(texture.format);\n\n\t\t\tif (capabilities.isWebGL2) {\n\t\t\t\t// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100\n\t\t\t\tif (glFormat === _gl.RGB) glFormat = _gl.RGB8;\n\t\t\t\tif (glFormat === _gl.RGBA) glFormat = _gl.RGBA8;\n\t\t\t}\n\n\t\t\ttextures.setTexture2D(texture, 0);\n\n\t\t\t_gl.copyTexImage2D(_gl.TEXTURE_2D, level, glFormat, position.x, position.y, width, height, 0);\n\n\t\t\tstate.unbindTexture();\n\t\t};\n\n\t\tthis.copyTextureToTexture = function (position, srcTexture, dstTexture, level = 0) {\n\t\t\tconst width = srcTexture.image.width;\n\t\t\tconst height = srcTexture.image.height;\n\t\t\tconst glFormat = utils.convert(dstTexture.format);\n\t\t\tconst glType = utils.convert(dstTexture.type);\n\t\t\ttextures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei\n\t\t\t// parameters, make sure they are correct for the dstTexture\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n\n\t\t\tif (srcTexture.isDataTexture) {\n\t\t\t\t_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);\n\t\t\t} else {\n\t\t\t\tif (srcTexture.isCompressedTexture) {\n\t\t\t\t\t_gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);\n\t\t\t\t} else {\n\t\t\t\t\t_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);\n\t\t\t\t}\n\t\t\t} // Generate mipmaps only when copying level 0\n\n\n\t\t\tif (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);\n\t\t\tstate.unbindTexture();\n\t\t};\n\n\t\tthis.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture, level = 0) {\n\t\t\tif (_this.isWebGL1Renderer) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst {\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tdata\n\t\t\t} = srcTexture.image;\n\t\t\tconst glFormat = utils.convert(dstTexture.format);\n\t\t\tconst glType = utils.convert(dstTexture.type);\n\t\t\tlet glTarget;\n\n\t\t\tif (dstTexture.isDataTexture3D) {\n\t\t\t\ttextures.setTexture3D(dstTexture, 0);\n\t\t\t\tglTarget = _gl.TEXTURE_3D;\n\t\t\t} else if (dstTexture.isDataTexture2DArray) {\n\t\t\t\ttextures.setTexture2DArray(dstTexture, 0);\n\t\t\t\tglTarget = _gl.TEXTURE_2D_ARRAY;\n\t\t\t} else {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n\n\t\t\tconst unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);\n\n\t\t\tconst unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);\n\n\t\t\tconst unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);\n\n\t\t\tconst unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);\n\n\t\t\tconst unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, width);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, height);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);\n\n\t\t\t_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, sourceBox.max.x - sourceBox.min.x + 1, sourceBox.max.y - sourceBox.min.y + 1, sourceBox.max.z - sourceBox.min.z + 1, glFormat, glType, data);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages); // Generate mipmaps only when copying level 0\n\n\n\t\t\tif (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);\n\t\t\tstate.unbindTexture();\n\t\t};\n\n\t\tthis.initTexture = function (texture) {\n\t\t\ttextures.setTexture2D(texture, 0);\n\t\t\tstate.unbindTexture();\n\t\t};\n\n\t\tthis.resetState = function () {\n\t\t\t_currentActiveCubeFace = 0;\n\t\t\t_currentActiveMipmapLevel = 0;\n\t\t\t_currentRenderTarget = null;\n\t\t\tstate.reset();\n\t\t\tbindingStates.reset();\n\t\t};\n\n\t\tif (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {\n\t\t\t\tdetail: this\n\t\t\t})); // eslint-disable-line no-undef\n\n\t\t}\n\t}\n\n\tclass WebGL1Renderer extends WebGLRenderer {}\n\n\tWebGL1Renderer.prototype.isWebGL1Renderer = true;\n\n\tclass FogExp2 {\n\t\tconstructor(color, density = 0.00025) {\n\t\t\tthis.name = '';\n\t\t\tthis.color = new Color(color);\n\t\t\tthis.density = density;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new FogExp2(this.color, this.density);\n\t\t}\n\n\t\ttoJSON()\n\t\t/* meta */\n\t\t{\n\t\t\treturn {\n\t\t\t\ttype: 'FogExp2',\n\t\t\t\tcolor: this.color.getHex(),\n\t\t\t\tdensity: this.density\n\t\t\t};\n\t\t}\n\n\t}\n\n\tFogExp2.prototype.isFogExp2 = true;\n\n\tclass Fog {\n\t\tconstructor(color, near = 1, far = 1000) {\n\t\t\tthis.name = '';\n\t\t\tthis.color = new Color(color);\n\t\t\tthis.near = near;\n\t\t\tthis.far = far;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new Fog(this.color, this.near, this.far);\n\t\t}\n\n\t\ttoJSON()\n\t\t/* meta */\n\t\t{\n\t\t\treturn {\n\t\t\t\ttype: 'Fog',\n\t\t\t\tcolor: this.color.getHex(),\n\t\t\t\tnear: this.near,\n\t\t\t\tfar: this.far\n\t\t\t};\n\t\t}\n\n\t}\n\n\tFog.prototype.isFog = true;\n\n\tclass Scene extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'Scene';\n\t\t\tthis.background = null;\n\t\t\tthis.environment = null;\n\t\t\tthis.fog = null;\n\t\t\tthis.overrideMaterial = null;\n\t\t\tthis.autoUpdate = true; // checked by the renderer\n\n\t\t\tif (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n\t\t\t\t__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {\n\t\t\t\t\tdetail: this\n\t\t\t\t})); // eslint-disable-line no-undef\n\n\t\t\t}\n\t\t}\n\n\t\tcopy(source, recursive) {\n\t\t\tsuper.copy(source, recursive);\n\t\t\tif (source.background !== null) this.background = source.background.clone();\n\t\t\tif (source.environment !== null) this.environment = source.environment.clone();\n\t\t\tif (source.fog !== null) this.fog = source.fog.clone();\n\t\t\tif (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();\n\t\t\tthis.autoUpdate = source.autoUpdate;\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tif (this.background !== null) data.object.background = this.background.toJSON(meta);\n\t\t\tif (this.environment !== null) data.object.environment = this.environment.toJSON(meta);\n\t\t\tif (this.fog !== null) data.object.fog = this.fog.toJSON();\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tScene.prototype.isScene = true;\n\n\tclass InterleavedBuffer {\n\t\tconstructor(array, stride) {\n\t\t\tthis.array = array;\n\t\t\tthis.stride = stride;\n\t\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\t\t\tthis.usage = StaticDrawUsage;\n\t\t\tthis.updateRange = {\n\t\t\t\toffset: 0,\n\t\t\t\tcount: -1\n\t\t\t};\n\t\t\tthis.version = 0;\n\t\t\tthis.uuid = generateUUID();\n\t\t}\n\n\t\tonUploadCallback() {}\n\n\t\tset needsUpdate(value) {\n\t\t\tif (value === true) this.version++;\n\t\t}\n\n\t\tsetUsage(value) {\n\t\t\tthis.usage = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.array = new source.array.constructor(source.array);\n\t\t\tthis.count = source.count;\n\t\t\tthis.stride = source.stride;\n\t\t\tthis.usage = source.usage;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyAt(index1, attribute, index2) {\n\t\t\tindex1 *= this.stride;\n\t\t\tindex2 *= attribute.stride;\n\n\t\t\tfor (let i = 0, l = this.stride; i < l; i++) {\n\t\t\t\tthis.array[index1 + i] = attribute.array[index2 + i];\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tset(value, offset = 0) {\n\t\t\tthis.array.set(value, offset);\n\t\t\treturn this;\n\t\t}\n\n\t\tclone(data) {\n\t\t\tif (data.arrayBuffers === undefined) {\n\t\t\t\tdata.arrayBuffers = {};\n\t\t\t}\n\n\t\t\tif (this.array.buffer._uuid === undefined) {\n\t\t\t\tthis.array.buffer._uuid = generateUUID();\n\t\t\t}\n\n\t\t\tif (data.arrayBuffers[this.array.buffer._uuid] === undefined) {\n\t\t\t\tdata.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;\n\t\t\t}\n\n\t\t\tconst array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);\n\t\t\tconst ib = new this.constructor(array, this.stride);\n\t\t\tib.setUsage(this.usage);\n\t\t\treturn ib;\n\t\t}\n\n\t\tonUpload(callback) {\n\t\t\tthis.onUploadCallback = callback;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(data) {\n\t\t\tif (data.arrayBuffers === undefined) {\n\t\t\t\tdata.arrayBuffers = {};\n\t\t\t} // generate UUID for array buffer if necessary\n\n\n\t\t\tif (this.array.buffer._uuid === undefined) {\n\t\t\t\tthis.array.buffer._uuid = generateUUID();\n\t\t\t}\n\n\t\t\tif (data.arrayBuffers[this.array.buffer._uuid] === undefined) {\n\t\t\t\tdata.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));\n\t\t\t} //\n\n\n\t\t\treturn {\n\t\t\t\tuuid: this.uuid,\n\t\t\t\tbuffer: this.array.buffer._uuid,\n\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\tstride: this.stride\n\t\t\t};\n\t\t}\n\n\t}\n\n\tInterleavedBuffer.prototype.isInterleavedBuffer = true;\n\n\tconst _vector$6 = /*@__PURE__*/new Vector3();\n\n\tclass InterleavedBufferAttribute {\n\t\tconstructor(interleavedBuffer, itemSize, offset, normalized) {\n\t\t\tthis.name = '';\n\t\t\tthis.data = interleavedBuffer;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.offset = offset;\n\t\t\tthis.normalized = normalized === true;\n\t\t}\n\n\t\tget count() {\n\t\t\treturn this.data.count;\n\t\t}\n\n\t\tget array() {\n\t\t\treturn this.data.array;\n\t\t}\n\n\t\tset needsUpdate(value) {\n\t\t\tthis.data.needsUpdate = value;\n\t\t}\n\n\t\tapplyMatrix4(m) {\n\t\t\tfor (let i = 0, l = this.data.count; i < l; i++) {\n\t\t\t\t_vector$6.x = this.getX(i);\n\t\t\t\t_vector$6.y = this.getY(i);\n\t\t\t\t_vector$6.z = this.getZ(i);\n\n\t\t\t\t_vector$6.applyMatrix4(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyNormalMatrix(m) {\n\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t_vector$6.x = this.getX(i);\n\t\t\t\t_vector$6.y = this.getY(i);\n\t\t\t\t_vector$6.z = this.getZ(i);\n\n\t\t\t\t_vector$6.applyNormalMatrix(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttransformDirection(m) {\n\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t_vector$6.x = this.getX(i);\n\t\t\t\t_vector$6.y = this.getY(i);\n\t\t\t\t_vector$6.z = this.getZ(i);\n\n\t\t\t\t_vector$6.transformDirection(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetX(index, x) {\n\t\t\tthis.data.array[index * this.data.stride + this.offset] = x;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetY(index, y) {\n\t\t\tthis.data.array[index * this.data.stride + this.offset + 1] = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetZ(index, z) {\n\t\t\tthis.data.array[index * this.data.stride + this.offset + 2] = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetW(index, w) {\n\t\t\tthis.data.array[index * this.data.stride + this.offset + 3] = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetX(index) {\n\t\t\treturn this.data.array[index * this.data.stride + this.offset];\n\t\t}\n\n\t\tgetY(index) {\n\t\t\treturn this.data.array[index * this.data.stride + this.offset + 1];\n\t\t}\n\n\t\tgetZ(index) {\n\t\t\treturn this.data.array[index * this.data.stride + this.offset + 2];\n\t\t}\n\n\t\tgetW(index) {\n\t\t\treturn this.data.array[index * this.data.stride + this.offset + 3];\n\t\t}\n\n\t\tsetXY(index, x, y) {\n\t\t\tindex = index * this.data.stride + this.offset;\n\t\t\tthis.data.array[index + 0] = x;\n\t\t\tthis.data.array[index + 1] = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetXYZ(index, x, y, z) {\n\t\t\tindex = index * this.data.stride + this.offset;\n\t\t\tthis.data.array[index + 0] = x;\n\t\t\tthis.data.array[index + 1] = y;\n\t\t\tthis.data.array[index + 2] = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetXYZW(index, x, y, z, w) {\n\t\t\tindex = index * this.data.stride + this.offset;\n\t\t\tthis.data.array[index + 0] = x;\n\t\t\tthis.data.array[index + 1] = y;\n\t\t\tthis.data.array[index + 2] = z;\n\t\t\tthis.data.array[index + 3] = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tclone(data) {\n\t\t\tif (data === undefined) {\n\t\t\t\tconsole.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor (let i = 0; i < this.count; i++) {\n\t\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\t\tfor (let j = 0; j < this.itemSize; j++) {\n\t\t\t\t\t\tarray.push(this.data.array[index + j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);\n\t\t\t} else {\n\t\t\t\tif (data.interleavedBuffers === undefined) {\n\t\t\t\t\tdata.interleavedBuffers = {};\n\t\t\t\t}\n\n\t\t\t\tif (data.interleavedBuffers[this.data.uuid] === undefined) {\n\t\t\t\t\tdata.interleavedBuffers[this.data.uuid] = this.data.clone(data);\n\t\t\t\t}\n\n\t\t\t\treturn new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);\n\t\t\t}\n\t\t}\n\n\t\ttoJSON(data) {\n\t\t\tif (data === undefined) {\n\t\t\t\tconsole.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor (let i = 0; i < this.count; i++) {\n\t\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\t\tfor (let j = 0; j < this.itemSize; j++) {\n\t\t\t\t\t\tarray.push(this.data.array[index + j]);\n\t\t\t\t\t}\n\t\t\t\t} // deinterleave data and save it as an ordinary buffer attribute for now\n\n\n\t\t\t\treturn {\n\t\t\t\t\titemSize: this.itemSize,\n\t\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\t\tarray: array,\n\t\t\t\t\tnormalized: this.normalized\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// save as true interlaved attribtue\n\t\t\t\tif (data.interleavedBuffers === undefined) {\n\t\t\t\t\tdata.interleavedBuffers = {};\n\t\t\t\t}\n\n\t\t\t\tif (data.interleavedBuffers[this.data.uuid] === undefined) {\n\t\t\t\t\tdata.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tisInterleavedBufferAttribute: true,\n\t\t\t\t\titemSize: this.itemSize,\n\t\t\t\t\tdata: this.data.uuid,\n\t\t\t\t\toffset: this.offset,\n\t\t\t\t\tnormalized: this.normalized\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t}\n\n\tInterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\trotation: <float>,\n\t *\tsizeAttenuation: <bool>\n\t * }\n\t */\n\n\tclass SpriteMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'SpriteMaterial';\n\t\t\tthis.color = new Color(0xffffff);\n\t\t\tthis.map = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.rotation = 0;\n\t\t\tthis.sizeAttenuation = true;\n\t\t\tthis.transparent = true;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.map = source.map;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.rotation = source.rotation;\n\t\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tSpriteMaterial.prototype.isSpriteMaterial = true;\n\n\tlet _geometry;\n\n\tconst _intersectPoint = /*@__PURE__*/new Vector3();\n\n\tconst _worldScale = /*@__PURE__*/new Vector3();\n\n\tconst _mvPosition = /*@__PURE__*/new Vector3();\n\n\tconst _alignedPosition = /*@__PURE__*/new Vector2();\n\n\tconst _rotatedPosition = /*@__PURE__*/new Vector2();\n\n\tconst _viewWorldMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _vA = /*@__PURE__*/new Vector3();\n\n\tconst _vB = /*@__PURE__*/new Vector3();\n\n\tconst _vC = /*@__PURE__*/new Vector3();\n\n\tconst _uvA = /*@__PURE__*/new Vector2();\n\n\tconst _uvB = /*@__PURE__*/new Vector2();\n\n\tconst _uvC = /*@__PURE__*/new Vector2();\n\n\tclass Sprite extends Object3D {\n\t\tconstructor(material) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Sprite';\n\n\t\t\tif (_geometry === undefined) {\n\t\t\t\t_geometry = new BufferGeometry();\n\t\t\t\tconst float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);\n\t\t\t\tconst interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n\n\t\t\t\t_geometry.setIndex([0, 1, 2, 0, 2, 3]);\n\n\t\t\t\t_geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n\n\t\t\t\t_geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n\t\t\t}\n\n\t\t\tthis.geometry = _geometry;\n\t\t\tthis.material = material !== undefined ? material : new SpriteMaterial();\n\t\t\tthis.center = new Vector2(0.5, 0.5);\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tif (raycaster.camera === null) {\n\t\t\t\tconsole.error('THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.');\n\t\t\t}\n\n\t\t\t_worldScale.setFromMatrixScale(this.matrixWorld);\n\n\t\t\t_viewWorldMatrix.copy(raycaster.camera.matrixWorld);\n\n\t\t\tthis.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);\n\n\t\t\t_mvPosition.setFromMatrixPosition(this.modelViewMatrix);\n\n\t\t\tif (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {\n\t\t\t\t_worldScale.multiplyScalar(-_mvPosition.z);\n\t\t\t}\n\n\t\t\tconst rotation = this.material.rotation;\n\t\t\tlet sin, cos;\n\n\t\t\tif (rotation !== 0) {\n\t\t\t\tcos = Math.cos(rotation);\n\t\t\t\tsin = Math.sin(rotation);\n\t\t\t}\n\n\t\t\tconst center = this.center;\n\t\t\ttransformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\t\t\ttransformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\t\t\ttransformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\n\t\t\t_uvA.set(0, 0);\n\n\t\t\t_uvB.set(1, 0);\n\n\t\t\t_uvC.set(1, 1); // check first triangle\n\n\n\t\t\tlet intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);\n\n\t\t\tif (intersect === null) {\n\t\t\t\t// check second triangle\n\t\t\t\ttransformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\n\t\t\t\t_uvB.set(0, 1);\n\n\t\t\t\tintersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);\n\n\t\t\t\tif (intersect === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst distance = raycaster.ray.origin.distanceTo(_intersectPoint);\n\t\t\tif (distance < raycaster.near || distance > raycaster.far) return;\n\t\t\tintersects.push({\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: _intersectPoint.clone(),\n\t\t\t\tuv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),\n\t\t\t\tface: null,\n\t\t\t\tobject: this\n\t\t\t});\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tif (source.center !== undefined) this.center.copy(source.center);\n\t\t\tthis.material = source.material;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tSprite.prototype.isSprite = true;\n\n\tfunction transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {\n\t\t// compute position in camera space\n\t\t_alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero\n\n\n\t\tif (sin !== undefined) {\n\t\t\t_rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;\n\t\t\t_rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;\n\t\t} else {\n\t\t\t_rotatedPosition.copy(_alignedPosition);\n\t\t}\n\n\t\tvertexPosition.copy(mvPosition);\n\t\tvertexPosition.x += _rotatedPosition.x;\n\t\tvertexPosition.y += _rotatedPosition.y; // transform to world space\n\n\t\tvertexPosition.applyMatrix4(_viewWorldMatrix);\n\t}\n\n\tconst _v1$2 = /*@__PURE__*/new Vector3();\n\n\tconst _v2$1 = /*@__PURE__*/new Vector3();\n\n\tclass LOD extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis._currentLevel = 0;\n\t\t\tthis.type = 'LOD';\n\t\t\tObject.defineProperties(this, {\n\t\t\t\tlevels: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: []\n\t\t\t\t},\n\t\t\t\tisLOD: {\n\t\t\t\t\tvalue: true\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.autoUpdate = true;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source, false);\n\t\t\tconst levels = source.levels;\n\n\t\t\tfor (let i = 0, l = levels.length; i < l; i++) {\n\t\t\t\tconst level = levels[i];\n\t\t\t\tthis.addLevel(level.object.clone(), level.distance);\n\t\t\t}\n\n\t\t\tthis.autoUpdate = source.autoUpdate;\n\t\t\treturn this;\n\t\t}\n\n\t\taddLevel(object, distance = 0) {\n\t\t\tdistance = Math.abs(distance);\n\t\t\tconst levels = this.levels;\n\t\t\tlet l;\n\n\t\t\tfor (l = 0; l < levels.length; l++) {\n\t\t\t\tif (distance < levels[l].distance) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlevels.splice(l, 0, {\n\t\t\t\tdistance: distance,\n\t\t\t\tobject: object\n\t\t\t});\n\t\t\tthis.add(object);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetCurrentLevel() {\n\t\t\treturn this._currentLevel;\n\t\t}\n\n\t\tgetObjectForDistance(distance) {\n\t\t\tconst levels = this.levels;\n\n\t\t\tif (levels.length > 0) {\n\t\t\t\tlet i, l;\n\n\t\t\t\tfor (i = 1, l = levels.length; i < l; i++) {\n\t\t\t\t\tif (distance < levels[i].distance) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn levels[i - 1].object;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tconst levels = this.levels;\n\n\t\t\tif (levels.length > 0) {\n\t\t\t\t_v1$2.setFromMatrixPosition(this.matrixWorld);\n\n\t\t\t\tconst distance = raycaster.ray.origin.distanceTo(_v1$2);\n\t\t\t\tthis.getObjectForDistance(distance).raycast(raycaster, intersects);\n\t\t\t}\n\t\t}\n\n\t\tupdate(camera) {\n\t\t\tconst levels = this.levels;\n\n\t\t\tif (levels.length > 1) {\n\t\t\t\t_v1$2.setFromMatrixPosition(camera.matrixWorld);\n\n\t\t\t\t_v2$1.setFromMatrixPosition(this.matrixWorld);\n\n\t\t\t\tconst distance = _v1$2.distanceTo(_v2$1) / camera.zoom;\n\t\t\t\tlevels[0].object.visible = true;\n\t\t\t\tlet i, l;\n\n\t\t\t\tfor (i = 1, l = levels.length; i < l; i++) {\n\t\t\t\t\tif (distance >= levels[i].distance) {\n\t\t\t\t\t\tlevels[i - 1].object.visible = false;\n\t\t\t\t\t\tlevels[i].object.visible = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._currentLevel = i - 1;\n\n\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\tlevels[i].object.visible = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tif (this.autoUpdate === false) data.object.autoUpdate = false;\n\t\t\tdata.object.levels = [];\n\t\t\tconst levels = this.levels;\n\n\t\t\tfor (let i = 0, l = levels.length; i < l; i++) {\n\t\t\t\tconst level = levels[i];\n\t\t\t\tdata.object.levels.push({\n\t\t\t\t\tobject: level.object.uuid,\n\t\t\t\t\tdistance: level.distance\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tconst _basePosition = /*@__PURE__*/new Vector3();\n\n\tconst _skinIndex = /*@__PURE__*/new Vector4();\n\n\tconst _skinWeight = /*@__PURE__*/new Vector4();\n\n\tconst _vector$5 = /*@__PURE__*/new Vector3();\n\n\tconst _matrix = /*@__PURE__*/new Matrix4();\n\n\tclass SkinnedMesh extends Mesh {\n\t\tconstructor(geometry, material) {\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'SkinnedMesh';\n\t\t\tthis.bindMode = 'attached';\n\t\t\tthis.bindMatrix = new Matrix4();\n\t\t\tthis.bindMatrixInverse = new Matrix4();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.bindMode = source.bindMode;\n\t\t\tthis.bindMatrix.copy(source.bindMatrix);\n\t\t\tthis.bindMatrixInverse.copy(source.bindMatrixInverse);\n\t\t\tthis.skeleton = source.skeleton;\n\t\t\treturn this;\n\t\t}\n\n\t\tbind(skeleton, bindMatrix) {\n\t\t\tthis.skeleton = skeleton;\n\n\t\t\tif (bindMatrix === undefined) {\n\t\t\t\tthis.updateMatrixWorld(true);\n\t\t\t\tthis.skeleton.calculateInverses();\n\t\t\t\tbindMatrix = this.matrixWorld;\n\t\t\t}\n\n\t\t\tthis.bindMatrix.copy(bindMatrix);\n\t\t\tthis.bindMatrixInverse.copy(bindMatrix).invert();\n\t\t}\n\n\t\tpose() {\n\t\t\tthis.skeleton.pose();\n\t\t}\n\n\t\tnormalizeSkinWeights() {\n\t\t\tconst vector = new Vector4();\n\t\t\tconst skinWeight = this.geometry.attributes.skinWeight;\n\n\t\t\tfor (let i = 0, l = skinWeight.count; i < l; i++) {\n\t\t\t\tvector.x = skinWeight.getX(i);\n\t\t\t\tvector.y = skinWeight.getY(i);\n\t\t\t\tvector.z = skinWeight.getZ(i);\n\t\t\t\tvector.w = skinWeight.getW(i);\n\t\t\t\tconst scale = 1.0 / vector.manhattanLength();\n\n\t\t\t\tif (scale !== Infinity) {\n\t\t\t\t\tvector.multiplyScalar(scale);\n\t\t\t\t} else {\n\t\t\t\t\tvector.set(1, 0, 0, 0); // do something reasonable\n\t\t\t\t}\n\n\t\t\t\tskinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);\n\t\t\t}\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tsuper.updateMatrixWorld(force);\n\n\t\t\tif (this.bindMode === 'attached') {\n\t\t\t\tthis.bindMatrixInverse.copy(this.matrixWorld).invert();\n\t\t\t} else if (this.bindMode === 'detached') {\n\t\t\t\tthis.bindMatrixInverse.copy(this.bindMatrix).invert();\n\t\t\t} else {\n\t\t\t\tconsole.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);\n\t\t\t}\n\t\t}\n\n\t\tboneTransform(index, target) {\n\t\t\tconst skeleton = this.skeleton;\n\t\t\tconst geometry = this.geometry;\n\n\t\t\t_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n\n\t\t\t_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n\n\t\t\t_basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);\n\n\t\t\ttarget.set(0, 0, 0);\n\n\t\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\tconst weight = _skinWeight.getComponent(i);\n\n\t\t\t\tif (weight !== 0) {\n\t\t\t\t\tconst boneIndex = _skinIndex.getComponent(i);\n\n\t\t\t\t\t_matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);\n\n\t\t\t\t\ttarget.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn target.applyMatrix4(this.bindMatrixInverse);\n\t\t}\n\n\t}\n\n\tSkinnedMesh.prototype.isSkinnedMesh = true;\n\n\tclass Bone extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'Bone';\n\t\t}\n\n\t}\n\n\tBone.prototype.isBone = true;\n\n\tclass DataTexture extends Texture {\n\t\tconstructor(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {\n\t\t\tsuper(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\n\t\t\tthis.image = {\n\t\t\t\tdata: data || null,\n\t\t\t\twidth: width || 1,\n\t\t\t\theight: height || 1\n\t\t\t};\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\t\t\tthis.generateMipmaps = false;\n\t\t\tthis.flipY = false;\n\t\t\tthis.unpackAlignment = 1;\n\t\t\tthis.needsUpdate = true;\n\t\t}\n\n\t}\n\n\tDataTexture.prototype.isDataTexture = true;\n\n\tconst _offsetMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _identityMatrix = /*@__PURE__*/new Matrix4();\n\n\tclass Skeleton {\n\t\tconstructor(bones = [], boneInverses = []) {\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.bones = bones.slice(0);\n\t\t\tthis.boneInverses = boneInverses;\n\t\t\tthis.boneMatrices = null;\n\t\t\tthis.boneTexture = null;\n\t\t\tthis.boneTextureSize = 0;\n\t\t\tthis.frame = -1;\n\t\t\tthis.init();\n\t\t}\n\n\t\tinit() {\n\t\t\tconst bones = this.bones;\n\t\t\tconst boneInverses = this.boneInverses;\n\t\t\tthis.boneMatrices = new Float32Array(bones.length * 16); // calculate inverse bone matrices if necessary\n\n\t\t\tif (boneInverses.length === 0) {\n\t\t\t\tthis.calculateInverses();\n\t\t\t} else {\n\t\t\t\t// handle special case\n\t\t\t\tif (bones.length !== boneInverses.length) {\n\t\t\t\t\tconsole.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');\n\t\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\t\tfor (let i = 0, il = this.bones.length; i < il; i++) {\n\t\t\t\t\t\tthis.boneInverses.push(new Matrix4());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcalculateInverses() {\n\t\t\tthis.boneInverses.length = 0;\n\n\t\t\tfor (let i = 0, il = this.bones.length; i < il; i++) {\n\t\t\t\tconst inverse = new Matrix4();\n\n\t\t\t\tif (this.bones[i]) {\n\t\t\t\t\tinverse.copy(this.bones[i].matrixWorld).invert();\n\t\t\t\t}\n\n\t\t\t\tthis.boneInverses.push(inverse);\n\t\t\t}\n\t\t}\n\n\t\tpose() {\n\t\t\t// recover the bind-time world matrices\n\t\t\tfor (let i = 0, il = this.bones.length; i < il; i++) {\n\t\t\t\tconst bone = this.bones[i];\n\n\t\t\t\tif (bone) {\n\t\t\t\t\tbone.matrixWorld.copy(this.boneInverses[i]).invert();\n\t\t\t\t}\n\t\t\t} // compute the local matrices, positions, rotations and scales\n\n\n\t\t\tfor (let i = 0, il = this.bones.length; i < il; i++) {\n\t\t\t\tconst bone = this.bones[i];\n\n\t\t\t\tif (bone) {\n\t\t\t\t\tif (bone.parent && bone.parent.isBone) {\n\t\t\t\t\t\tbone.matrix.copy(bone.parent.matrixWorld).invert();\n\t\t\t\t\t\tbone.matrix.multiply(bone.matrixWorld);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbone.matrix.copy(bone.matrixWorld);\n\t\t\t\t\t}\n\n\t\t\t\t\tbone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tupdate() {\n\t\t\tconst bones = this.bones;\n\t\t\tconst boneInverses = this.boneInverses;\n\t\t\tconst boneMatrices = this.boneMatrices;\n\t\t\tconst boneTexture = this.boneTexture; // flatten bone matrices to array\n\n\t\t\tfor (let i = 0, il = bones.length; i < il; i++) {\n\t\t\t\t// compute the offset between the current and the original transform\n\t\t\t\tconst matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;\n\n\t\t\t\t_offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);\n\n\t\t\t\t_offsetMatrix.toArray(boneMatrices, i * 16);\n\t\t\t}\n\n\t\t\tif (boneTexture !== null) {\n\t\t\t\tboneTexture.needsUpdate = true;\n\t\t\t}\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new Skeleton(this.bones, this.boneInverses);\n\t\t}\n\n\t\tcomputeBoneTexture() {\n\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t//\t\t\tRGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t//\twith\t8x8\tpixel texture max\t 16 bones * 4 pixels =\t(8 * 8)\n\t\t\t//\t\t\t 16x16 pixel texture max\t 64 bones * 4 pixels = (16 * 16)\n\t\t\t//\t\t\t 32x32 pixel texture max\t256 bones * 4 pixels = (32 * 32)\n\t\t\t//\t\t\t 64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\t\t\tlet size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix\n\n\t\t\tsize = ceilPowerOfTwo(size);\n\t\t\tsize = Math.max(size, 4);\n\t\t\tconst boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel\n\n\t\t\tboneMatrices.set(this.boneMatrices); // copy current values\n\n\t\t\tconst boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);\n\t\t\tthis.boneMatrices = boneMatrices;\n\t\t\tthis.boneTexture = boneTexture;\n\t\t\tthis.boneTextureSize = size;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetBoneByName(name) {\n\t\t\tfor (let i = 0, il = this.bones.length; i < il; i++) {\n\t\t\t\tconst bone = this.bones[i];\n\n\t\t\t\tif (bone.name === name) {\n\t\t\t\t\treturn bone;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\tdispose() {\n\t\t\tif (this.boneTexture !== null) {\n\t\t\t\tthis.boneTexture.dispose();\n\t\t\t\tthis.boneTexture = null;\n\t\t\t}\n\t\t}\n\n\t\tfromJSON(json, bones) {\n\t\t\tthis.uuid = json.uuid;\n\n\t\t\tfor (let i = 0, l = json.bones.length; i < l; i++) {\n\t\t\t\tconst uuid = json.bones[i];\n\t\t\t\tlet bone = bones[uuid];\n\n\t\t\t\tif (bone === undefined) {\n\t\t\t\t\tconsole.warn('THREE.Skeleton: No bone found with UUID:', uuid);\n\t\t\t\t\tbone = new Bone();\n\t\t\t\t}\n\n\t\t\t\tthis.bones.push(bone);\n\t\t\t\tthis.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));\n\t\t\t}\n\n\t\t\tthis.init();\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Skeleton',\n\t\t\t\t\tgenerator: 'Skeleton.toJSON'\n\t\t\t\t},\n\t\t\t\tbones: [],\n\t\t\t\tboneInverses: []\n\t\t\t};\n\t\t\tdata.uuid = this.uuid;\n\t\t\tconst bones = this.bones;\n\t\t\tconst boneInverses = this.boneInverses;\n\n\t\t\tfor (let i = 0, l = bones.length; i < l; i++) {\n\t\t\t\tconst bone = bones[i];\n\t\t\t\tdata.bones.push(bone.uuid);\n\t\t\t\tconst boneInverse = boneInverses[i];\n\t\t\t\tdata.boneInverses.push(boneInverse.toArray());\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tconst _instanceLocalMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _instanceWorldMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _instanceIntersects = [];\n\n\tconst _mesh = /*@__PURE__*/new Mesh();\n\n\tclass InstancedMesh extends Mesh {\n\t\tconstructor(geometry, material, count) {\n\t\t\tsuper(geometry, material);\n\t\t\tthis.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);\n\t\t\tthis.instanceColor = null;\n\t\t\tthis.count = count;\n\t\t\tthis.frustumCulled = false;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.instanceMatrix.copy(source.instanceMatrix);\n\t\t\tif (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();\n\t\t\tthis.count = source.count;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetColorAt(index, color) {\n\t\t\tcolor.fromArray(this.instanceColor.array, index * 3);\n\t\t}\n\n\t\tgetMatrixAt(index, matrix) {\n\t\t\tmatrix.fromArray(this.instanceMatrix.array, index * 16);\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tconst matrixWorld = this.matrixWorld;\n\t\t\tconst raycastTimes = this.count;\n\t\t\t_mesh.geometry = this.geometry;\n\t\t\t_mesh.material = this.material;\n\t\t\tif (_mesh.material === undefined) return;\n\n\t\t\tfor (let instanceId = 0; instanceId < raycastTimes; instanceId++) {\n\t\t\t\t// calculate the world matrix for each instance\n\t\t\t\tthis.getMatrixAt(instanceId, _instanceLocalMatrix);\n\n\t\t\t\t_instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance\n\n\n\t\t\t\t_mesh.matrixWorld = _instanceWorldMatrix;\n\n\t\t\t\t_mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast\n\n\n\t\t\t\tfor (let i = 0, l = _instanceIntersects.length; i < l; i++) {\n\t\t\t\t\tconst intersect = _instanceIntersects[i];\n\t\t\t\t\tintersect.instanceId = instanceId;\n\t\t\t\t\tintersect.object = this;\n\t\t\t\t\tintersects.push(intersect);\n\t\t\t\t}\n\n\t\t\t\t_instanceIntersects.length = 0;\n\t\t\t}\n\t\t}\n\n\t\tsetColorAt(index, color) {\n\t\t\tif (this.instanceColor === null) {\n\t\t\t\tthis.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);\n\t\t\t}\n\n\t\t\tcolor.toArray(this.instanceColor.array, index * 3);\n\t\t}\n\n\t\tsetMatrixAt(index, matrix) {\n\t\t\tmatrix.toArray(this.instanceMatrix.array, index * 16);\n\t\t}\n\n\t\tupdateMorphTargets() {}\n\n\t\tdispose() {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'dispose'\n\t\t\t});\n\t\t}\n\n\t}\n\n\tInstancedMesh.prototype.isInstancedMesh = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\n\t *\tlinewidth: <float>,\n\t *\tlinecap: \"round\",\n\t *\tlinejoin: \"round\"\n\t * }\n\t */\n\n\tclass LineBasicMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'LineBasicMaterial';\n\t\t\tthis.color = new Color(0xffffff);\n\t\t\tthis.linewidth = 1;\n\t\t\tthis.linecap = 'round';\n\t\t\tthis.linejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.linewidth = source.linewidth;\n\t\t\tthis.linecap = source.linecap;\n\t\t\tthis.linejoin = source.linejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\n\tconst _start$1 = /*@__PURE__*/new Vector3();\n\n\tconst _end$1 = /*@__PURE__*/new Vector3();\n\n\tconst _inverseMatrix$1 = /*@__PURE__*/new Matrix4();\n\n\tconst _ray$1 = /*@__PURE__*/new Ray();\n\n\tconst _sphere$1 = /*@__PURE__*/new Sphere();\n\n\tclass Line extends Object3D {\n\t\tconstructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Line';\n\t\t\tthis.geometry = geometry;\n\t\t\tthis.material = material;\n\t\t\tthis.updateMorphTargets();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.material = source.material;\n\t\t\tthis.geometry = source.geometry;\n\t\t\treturn this;\n\t\t}\n\n\t\tcomputeLineDistances() {\n\t\t\tconst geometry = this.geometry;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\t// we assume non-indexed geometry\n\t\t\t\tif (geometry.index === null) {\n\t\t\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\t\t\tconst lineDistances = [0];\n\n\t\t\t\t\tfor (let i = 1, l = positionAttribute.count; i < l; i++) {\n\t\t\t\t\t\t_start$1.fromBufferAttribute(positionAttribute, i - 1);\n\n\t\t\t\t\t\t_end$1.fromBufferAttribute(positionAttribute, i);\n\n\t\t\t\t\t\tlineDistances[i] = lineDistances[i - 1];\n\t\t\t\t\t\tlineDistances[i] += _start$1.distanceTo(_end$1);\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\n\t\t\t\t}\n\t\t\t} else if (geometry.isGeometry) {\n\t\t\t\tconsole.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst matrixWorld = this.matrixWorld;\n\t\t\tconst threshold = raycaster.params.Line.threshold;\n\t\t\tconst drawRange = geometry.drawRange; // Checking boundingSphere distance to ray\n\n\t\t\tif (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n\t\t\t_sphere$1.copy(geometry.boundingSphere);\n\n\t\t\t_sphere$1.applyMatrix4(matrixWorld);\n\n\t\t\t_sphere$1.radius += threshold;\n\t\t\tif (raycaster.ray.intersectsSphere(_sphere$1) === false) return; //\n\n\t\t\t_inverseMatrix$1.copy(matrixWorld).invert();\n\n\t\t\t_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);\n\n\t\t\tconst localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n\t\t\tconst localThresholdSq = localThreshold * localThreshold;\n\t\t\tconst vStart = new Vector3();\n\t\t\tconst vEnd = new Vector3();\n\t\t\tconst interSegment = new Vector3();\n\t\t\tconst interRay = new Vector3();\n\t\t\tconst step = this.isLineSegments ? 2 : 1;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tconst attributes = geometry.attributes;\n\t\t\t\tconst positionAttribute = attributes.position;\n\n\t\t\t\tif (index !== null) {\n\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\tconst end = Math.min(index.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\tfor (let i = start, l = end - 1; i < l; i += step) {\n\t\t\t\t\t\tconst a = index.getX(i);\n\t\t\t\t\t\tconst b = index.getX(i + 1);\n\t\t\t\t\t\tvStart.fromBufferAttribute(positionAttribute, a);\n\t\t\t\t\t\tvEnd.fromBufferAttribute(positionAttribute, b);\n\n\t\t\t\t\t\tconst distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n\n\t\t\t\t\t\tif (distSq > localThresholdSq) continue;\n\t\t\t\t\t\tinterRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tconst distance = raycaster.ray.origin.distanceTo(interRay);\n\t\t\t\t\t\tif (distance < raycaster.near || distance > raycaster.far) continue;\n\t\t\t\t\t\tintersects.push({\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4(this.matrixWorld),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\tconst end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\tfor (let i = start, l = end - 1; i < l; i += step) {\n\t\t\t\t\t\tvStart.fromBufferAttribute(positionAttribute, i);\n\t\t\t\t\t\tvEnd.fromBufferAttribute(positionAttribute, i + 1);\n\n\t\t\t\t\t\tconst distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n\n\t\t\t\t\t\tif (distSq > localThresholdSq) continue;\n\t\t\t\t\t\tinterRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tconst distance = raycaster.ray.origin.distanceTo(interRay);\n\t\t\t\t\t\tif (distance < raycaster.near || distance > raycaster.far) continue;\n\t\t\t\t\t\tintersects.push({\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4(this.matrixWorld),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (geometry.isGeometry) {\n\t\t\t\tconsole.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t}\n\t\t}\n\n\t\tupdateMorphTargets() {\n\t\t\tconst geometry = this.geometry;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\t\tconst keys = Object.keys(morphAttributes);\n\n\t\t\t\tif (keys.length > 0) {\n\t\t\t\t\tconst morphAttribute = morphAttributes[keys[0]];\n\n\t\t\t\t\tif (morphAttribute !== undefined) {\n\t\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\t\tfor (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n\t\t\t\t\t\t\tconst name = morphAttribute[m].name || String(m);\n\t\t\t\t\t\t\tthis.morphTargetInfluences.push(0);\n\t\t\t\t\t\t\tthis.morphTargetDictionary[name] = m;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\t\tif (morphTargets !== undefined && morphTargets.length > 0) {\n\t\t\t\t\tconsole.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tLine.prototype.isLine = true;\n\n\tconst _start = /*@__PURE__*/new Vector3();\n\n\tconst _end = /*@__PURE__*/new Vector3();\n\n\tclass LineSegments extends Line {\n\t\tconstructor(geometry, material) {\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'LineSegments';\n\t\t}\n\n\t\tcomputeLineDistances() {\n\t\t\tconst geometry = this.geometry;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\t// we assume non-indexed geometry\n\t\t\t\tif (geometry.index === null) {\n\t\t\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\t\t\tconst lineDistances = [];\n\n\t\t\t\t\tfor (let i = 0, l = positionAttribute.count; i < l; i += 2) {\n\t\t\t\t\t\t_start.fromBufferAttribute(positionAttribute, i);\n\n\t\t\t\t\t\t_end.fromBufferAttribute(positionAttribute, i + 1);\n\n\t\t\t\t\t\tlineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];\n\t\t\t\t\t\tlineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\n\t\t\t\t}\n\t\t\t} else if (geometry.isGeometry) {\n\t\t\t\tconsole.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tLineSegments.prototype.isLineSegments = true;\n\n\tclass LineLoop extends Line {\n\t\tconstructor(geometry, material) {\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'LineLoop';\n\t\t}\n\n\t}\n\n\tLineLoop.prototype.isLineLoop = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tsize: <float>,\n\t *\tsizeAttenuation: <bool>\n\t *\n\t *\tmorphTargets: <bool>\n\t * }\n\t */\n\n\tclass PointsMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'PointsMaterial';\n\t\t\tthis.color = new Color(0xffffff);\n\t\t\tthis.map = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.size = 1;\n\t\t\tthis.sizeAttenuation = true;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.map = source.map;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.size = source.size;\n\t\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tPointsMaterial.prototype.isPointsMaterial = true;\n\n\tconst _inverseMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _ray = /*@__PURE__*/new Ray();\n\n\tconst _sphere = /*@__PURE__*/new Sphere();\n\n\tconst _position$2 = /*@__PURE__*/new Vector3();\n\n\tclass Points extends Object3D {\n\t\tconstructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Points';\n\t\t\tthis.geometry = geometry;\n\t\t\tthis.material = material;\n\t\t\tthis.updateMorphTargets();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.material = source.material;\n\t\t\tthis.geometry = source.geometry;\n\t\t\treturn this;\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst matrixWorld = this.matrixWorld;\n\t\t\tconst threshold = raycaster.params.Points.threshold;\n\t\t\tconst drawRange = geometry.drawRange; // Checking boundingSphere distance to ray\n\n\t\t\tif (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n\t\t\t_sphere.copy(geometry.boundingSphere);\n\n\t\t\t_sphere.applyMatrix4(matrixWorld);\n\n\t\t\t_sphere.radius += threshold;\n\t\t\tif (raycaster.ray.intersectsSphere(_sphere) === false) return; //\n\n\t\t\t_inverseMatrix.copy(matrixWorld).invert();\n\n\t\t\t_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n\n\t\t\tconst localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n\t\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tconst attributes = geometry.attributes;\n\t\t\t\tconst positionAttribute = attributes.position;\n\n\t\t\t\tif (index !== null) {\n\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\tconst end = Math.min(index.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\tfor (let i = start, il = end; i < il; i++) {\n\t\t\t\t\t\tconst a = index.getX(i);\n\n\t\t\t\t\t\t_position$2.fromBufferAttribute(positionAttribute, a);\n\n\t\t\t\t\t\ttestPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\tconst end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\tfor (let i = start, l = end; i < l; i++) {\n\t\t\t\t\t\t_position$2.fromBufferAttribute(positionAttribute, i);\n\n\t\t\t\t\t\ttestPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t}\n\t\t}\n\n\t\tupdateMorphTargets() {\n\t\t\tconst geometry = this.geometry;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\t\tconst keys = Object.keys(morphAttributes);\n\n\t\t\t\tif (keys.length > 0) {\n\t\t\t\t\tconst morphAttribute = morphAttributes[keys[0]];\n\n\t\t\t\t\tif (morphAttribute !== undefined) {\n\t\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\t\tfor (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n\t\t\t\t\t\t\tconst name = morphAttribute[m].name || String(m);\n\t\t\t\t\t\t\tthis.morphTargetInfluences.push(0);\n\t\t\t\t\t\t\tthis.morphTargetDictionary[name] = m;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\t\tif (morphTargets !== undefined && morphTargets.length > 0) {\n\t\t\t\t\tconsole.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tPoints.prototype.isPoints = true;\n\n\tfunction testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {\n\t\tconst rayPointDistanceSq = _ray.distanceSqToPoint(point);\n\n\t\tif (rayPointDistanceSq < localThresholdSq) {\n\t\t\tconst intersectPoint = new Vector3();\n\n\t\t\t_ray.closestPointToPoint(point, intersectPoint);\n\n\t\t\tintersectPoint.applyMatrix4(matrixWorld);\n\t\t\tconst distance = raycaster.ray.origin.distanceTo(intersectPoint);\n\t\t\tif (distance < raycaster.near || distance > raycaster.far) return;\n\t\t\tintersects.push({\n\t\t\t\tdistance: distance,\n\t\t\t\tdistanceToRay: Math.sqrt(rayPointDistanceSq),\n\t\t\t\tpoint: intersectPoint,\n\t\t\t\tindex: index,\n\t\t\t\tface: null,\n\t\t\t\tobject: object\n\t\t\t});\n\t\t}\n\t}\n\n\tclass VideoTexture extends Texture {\n\t\tconstructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n\t\t\tsuper(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n\t\t\tthis.format = format !== undefined ? format : RGBFormat;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\t\t\tthis.generateMipmaps = false;\n\t\t\tconst scope = this;\n\n\t\t\tfunction updateVideo() {\n\t\t\t\tscope.needsUpdate = true;\n\t\t\t\tvideo.requestVideoFrameCallback(updateVideo);\n\t\t\t}\n\n\t\t\tif ('requestVideoFrameCallback' in video) {\n\t\t\t\tvideo.requestVideoFrameCallback(updateVideo);\n\t\t\t}\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.image).copy(this);\n\t\t}\n\n\t\tupdate() {\n\t\t\tconst video = this.image;\n\t\t\tconst hasVideoFrameCallback = ('requestVideoFrameCallback' in video);\n\n\t\t\tif (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tVideoTexture.prototype.isVideoTexture = true;\n\n\tclass CompressedTexture extends Texture {\n\t\tconstructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {\n\t\t\tsuper(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\n\t\t\tthis.image = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\t\t\tthis.mipmaps = mipmaps; // no flipping for cube textures\n\t\t\t// (also flipping doesn't work for compressed textures )\n\n\t\t\tthis.flipY = false; // can't generate mipmaps for compressed textures\n\t\t\t// mips must be embedded in DDS files\n\n\t\t\tthis.generateMipmaps = false;\n\t\t}\n\n\t}\n\n\tCompressedTexture.prototype.isCompressedTexture = true;\n\n\tclass CanvasTexture extends Texture {\n\t\tconstructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n\t\t\tsuper(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n\t\t\tthis.needsUpdate = true;\n\t\t}\n\n\t}\n\n\tCanvasTexture.prototype.isCanvasTexture = true;\n\n\tclass DepthTexture extends Texture {\n\t\tconstructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {\n\t\t\tformat = format !== undefined ? format : DepthFormat;\n\n\t\t\tif (format !== DepthFormat && format !== DepthStencilFormat) {\n\t\t\t\tthrow new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');\n\t\t\t}\n\n\t\t\tif (type === undefined && format === DepthFormat) type = UnsignedShortType;\n\t\t\tif (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;\n\t\t\tsuper(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n\t\t\tthis.image = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\t\t\tthis.flipY = false;\n\t\t\tthis.generateMipmaps = false;\n\t\t}\n\n\t}\n\n\tDepthTexture.prototype.isDepthTexture = true;\n\n\tclass CircleGeometry extends BufferGeometry {\n\t\tconstructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CircleGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tsegments: segments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\t\tsegments = Math.max(3, segments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst uv = new Vector2(); // center point\n\n\t\t\tvertices.push(0, 0, 0);\n\t\t\tnormals.push(0, 0, 1);\n\t\t\tuvs.push(0.5, 0.5);\n\n\t\t\tfor (let s = 0, i = 3; s <= segments; s++, i += 3) {\n\t\t\t\tconst segment = thetaStart + s / segments * thetaLength; // vertex\n\n\t\t\t\tvertex.x = radius * Math.cos(segment);\n\t\t\t\tvertex.y = radius * Math.sin(segment);\n\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\tnormals.push(0, 0, 1); // uvs\n\n\t\t\t\tuv.x = (vertices[i] / radius + 1) / 2;\n\t\t\t\tuv.y = (vertices[i + 1] / radius + 1) / 2;\n\t\t\t\tuvs.push(uv.x, uv.y);\n\t\t\t} // indices\n\n\n\t\t\tfor (let i = 1; i <= segments; i++) {\n\t\t\t\tindices.push(i, i + 1, 0);\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tclass CylinderGeometry extends BufferGeometry {\n\t\tconstructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CylinderGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradiusTop: radiusTop,\n\t\t\t\tradiusBottom: radiusBottom,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\t\tconst scope = this;\n\t\t\tradialSegments = Math.floor(radialSegments);\n\t\t\theightSegments = Math.floor(heightSegments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tlet index = 0;\n\t\t\tconst indexArray = [];\n\t\t\tconst halfHeight = height / 2;\n\t\t\tlet groupStart = 0; // generate geometry\n\n\t\t\tgenerateTorso();\n\n\t\t\tif (openEnded === false) {\n\t\t\t\tif (radiusTop > 0) generateCap(true);\n\t\t\t\tif (radiusBottom > 0) generateCap(false);\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n\t\t\tfunction generateTorso() {\n\t\t\t\tconst normal = new Vector3();\n\t\t\t\tconst vertex = new Vector3();\n\t\t\t\tlet groupCount = 0; // this will be used to calculate the normal\n\n\t\t\t\tconst slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs\n\n\t\t\t\tfor (let y = 0; y <= heightSegments; y++) {\n\t\t\t\t\tconst indexRow = [];\n\t\t\t\t\tconst v = y / heightSegments; // calculate the radius of the current row\n\n\t\t\t\t\tconst radius = v * (radiusBottom - radiusTop) + radiusTop;\n\n\t\t\t\t\tfor (let x = 0; x <= radialSegments; x++) {\n\t\t\t\t\t\tconst u = x / radialSegments;\n\t\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\t\t\t\t\t\tconst sinTheta = Math.sin(theta);\n\t\t\t\t\t\tconst cosTheta = Math.cos(theta); // vertex\n\n\t\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\t\tvertex.y = -v * height + halfHeight;\n\t\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\t\t\tnormal.set(sinTheta, slope, cosTheta).normalize();\n\t\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // uv\n\n\t\t\t\t\t\tuvs.push(u, 1 - v); // save index of vertex in respective row\n\n\t\t\t\t\t\tindexRow.push(index++);\n\t\t\t\t\t} // now save vertices of the row in our index array\n\n\n\t\t\t\t\tindexArray.push(indexRow);\n\t\t\t\t} // generate indices\n\n\n\t\t\t\tfor (let x = 0; x < radialSegments; x++) {\n\t\t\t\t\tfor (let y = 0; y < heightSegments; y++) {\n\t\t\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\t\t\tconst a = indexArray[y][x];\n\t\t\t\t\t\tconst b = indexArray[y + 1][x];\n\t\t\t\t\t\tconst c = indexArray[y + 1][x + 1];\n\t\t\t\t\t\tconst d = indexArray[y][x + 1]; // faces\n\n\t\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\t\tindices.push(b, c, d); // update group counter\n\n\t\t\t\t\t\tgroupCount += 6;\n\t\t\t\t\t}\n\t\t\t\t} // add a group to the geometry. this will ensure multi material support\n\n\n\t\t\t\tscope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t}\n\n\t\t\tfunction generateCap(top) {\n\t\t\t\t// save the index of the first center vertex\n\t\t\t\tconst centerIndexStart = index;\n\t\t\t\tconst uv = new Vector2();\n\t\t\t\tconst vertex = new Vector3();\n\t\t\t\tlet groupCount = 0;\n\t\t\t\tconst radius = top === true ? radiusTop : radiusBottom;\n\t\t\t\tconst sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.\n\t\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\t\tfor (let x = 1; x <= radialSegments; x++) {\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertices.push(0, halfHeight * sign, 0); // normal\n\n\t\t\t\t\tnormals.push(0, sign, 0); // uv\n\n\t\t\t\t\tuvs.push(0.5, 0.5); // increase index\n\n\t\t\t\t\tindex++;\n\t\t\t\t} // save the index of the last center vertex\n\n\n\t\t\t\tconst centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs\n\n\t\t\t\tfor (let x = 0; x <= radialSegments; x++) {\n\t\t\t\t\tconst u = x / radialSegments;\n\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\t\t\t\t\tconst cosTheta = Math.cos(theta);\n\t\t\t\t\tconst sinTheta = Math.sin(theta); // vertex\n\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\t\tnormals.push(0, sign, 0); // uv\n\n\t\t\t\t\tuv.x = cosTheta * 0.5 + 0.5;\n\t\t\t\t\tuv.y = sinTheta * 0.5 * sign + 0.5;\n\t\t\t\t\tuvs.push(uv.x, uv.y); // increase index\n\n\t\t\t\t\tindex++;\n\t\t\t\t} // generate indices\n\n\n\t\t\t\tfor (let x = 0; x < radialSegments; x++) {\n\t\t\t\t\tconst c = centerIndexStart + x;\n\t\t\t\t\tconst i = centerIndexEnd + x;\n\n\t\t\t\t\tif (top === true) {\n\t\t\t\t\t\t// face top\n\t\t\t\t\t\tindices.push(i, i + 1, c);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// face bottom\n\t\t\t\t\t\tindices.push(i + 1, i, c);\n\t\t\t\t\t}\n\n\t\t\t\t\tgroupCount += 3;\n\t\t\t\t} // add a group to the geometry. this will ensure multi material support\n\n\n\t\t\t\tscope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass ConeGeometry extends CylinderGeometry {\n\t\tconstructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {\n\t\t\tsuper(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);\n\t\t\tthis.type = 'ConeGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\t}\n\n\t}\n\n\tclass PolyhedronGeometry extends BufferGeometry {\n\t\tconstructor(vertices, indices, radius = 1, detail = 0) {\n\t\t\tsuper();\n\t\t\tthis.type = 'PolyhedronGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tvertices: vertices,\n\t\t\t\tindices: indices,\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t}; // default buffer data\n\n\t\t\tconst vertexBuffer = [];\n\t\t\tconst uvBuffer = []; // the subdivision creates the vertex buffer data\n\n\t\t\tsubdivide(detail); // all vertices should lie on a conceptual sphere with a given radius\n\n\t\t\tapplyRadius(radius); // finally, create the uv data\n\n\t\t\tgenerateUVs(); // build non-indexed geometry\n\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));\n\n\t\t\tif (detail === 0) {\n\t\t\t\tthis.computeVertexNormals(); // flat normals\n\t\t\t} else {\n\t\t\t\tthis.normalizeNormals(); // smooth normals\n\t\t\t} // helper functions\n\n\n\t\t\tfunction subdivide(detail) {\n\t\t\t\tconst a = new Vector3();\n\t\t\t\tconst b = new Vector3();\n\t\t\t\tconst c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value\n\n\t\t\t\tfor (let i = 0; i < indices.length; i += 3) {\n\t\t\t\t\t// get the vertices of the face\n\t\t\t\t\tgetVertexByIndex(indices[i + 0], a);\n\t\t\t\t\tgetVertexByIndex(indices[i + 1], b);\n\t\t\t\t\tgetVertexByIndex(indices[i + 2], c); // perform subdivision\n\n\t\t\t\t\tsubdivideFace(a, b, c, detail);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction subdivideFace(a, b, c, detail) {\n\t\t\t\tconst cols = detail + 1; // we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\t\tconst v = []; // construct all of the vertices for this subdivision\n\n\t\t\t\tfor (let i = 0; i <= cols; i++) {\n\t\t\t\t\tv[i] = [];\n\t\t\t\t\tconst aj = a.clone().lerp(c, i / cols);\n\t\t\t\t\tconst bj = b.clone().lerp(c, i / cols);\n\t\t\t\t\tconst rows = cols - i;\n\n\t\t\t\t\tfor (let j = 0; j <= rows; j++) {\n\t\t\t\t\t\tif (j === 0 && i === cols) {\n\t\t\t\t\t\t\tv[i][j] = aj;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tv[i][j] = aj.clone().lerp(bj, j / rows);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // construct all of the faces\n\n\n\t\t\t\tfor (let i = 0; i < cols; i++) {\n\t\t\t\t\tfor (let j = 0; j < 2 * (cols - i) - 1; j++) {\n\t\t\t\t\t\tconst k = Math.floor(j / 2);\n\n\t\t\t\t\t\tif (j % 2 === 0) {\n\t\t\t\t\t\t\tpushVertex(v[i][k + 1]);\n\t\t\t\t\t\t\tpushVertex(v[i + 1][k]);\n\t\t\t\t\t\t\tpushVertex(v[i][k]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpushVertex(v[i][k + 1]);\n\t\t\t\t\t\t\tpushVertex(v[i + 1][k + 1]);\n\t\t\t\t\t\t\tpushVertex(v[i + 1][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction applyRadius(radius) {\n\t\t\t\tconst vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\t\tfor (let i = 0; i < vertexBuffer.length; i += 3) {\n\t\t\t\t\tvertex.x = vertexBuffer[i + 0];\n\t\t\t\t\tvertex.y = vertexBuffer[i + 1];\n\t\t\t\t\tvertex.z = vertexBuffer[i + 2];\n\t\t\t\t\tvertex.normalize().multiplyScalar(radius);\n\t\t\t\t\tvertexBuffer[i + 0] = vertex.x;\n\t\t\t\t\tvertexBuffer[i + 1] = vertex.y;\n\t\t\t\t\tvertexBuffer[i + 2] = vertex.z;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction generateUVs() {\n\t\t\t\tconst vertex = new Vector3();\n\n\t\t\t\tfor (let i = 0; i < vertexBuffer.length; i += 3) {\n\t\t\t\t\tvertex.x = vertexBuffer[i + 0];\n\t\t\t\t\tvertex.y = vertexBuffer[i + 1];\n\t\t\t\t\tvertex.z = vertexBuffer[i + 2];\n\t\t\t\t\tconst u = azimuth(vertex) / 2 / Math.PI + 0.5;\n\t\t\t\t\tconst v = inclination(vertex) / Math.PI + 0.5;\n\t\t\t\t\tuvBuffer.push(u, 1 - v);\n\t\t\t\t}\n\n\t\t\t\tcorrectUVs();\n\t\t\t\tcorrectSeam();\n\t\t\t}\n\n\t\t\tfunction correctSeam() {\n\t\t\t\t// handle case when face straddles the seam, see #3269\n\t\t\t\tfor (let i = 0; i < uvBuffer.length; i += 6) {\n\t\t\t\t\t// uv data of a single face\n\t\t\t\t\tconst x0 = uvBuffer[i + 0];\n\t\t\t\t\tconst x1 = uvBuffer[i + 2];\n\t\t\t\t\tconst x2 = uvBuffer[i + 4];\n\t\t\t\t\tconst max = Math.max(x0, x1, x2);\n\t\t\t\t\tconst min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary\n\n\t\t\t\t\tif (max > 0.9 && min < 0.1) {\n\t\t\t\t\t\tif (x0 < 0.2) uvBuffer[i + 0] += 1;\n\t\t\t\t\t\tif (x1 < 0.2) uvBuffer[i + 2] += 1;\n\t\t\t\t\t\tif (x2 < 0.2) uvBuffer[i + 4] += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction pushVertex(vertex) {\n\t\t\t\tvertexBuffer.push(vertex.x, vertex.y, vertex.z);\n\t\t\t}\n\n\t\t\tfunction getVertexByIndex(index, vertex) {\n\t\t\t\tconst stride = index * 3;\n\t\t\t\tvertex.x = vertices[stride + 0];\n\t\t\t\tvertex.y = vertices[stride + 1];\n\t\t\t\tvertex.z = vertices[stride + 2];\n\t\t\t}\n\n\t\t\tfunction correctUVs() {\n\t\t\t\tconst a = new Vector3();\n\t\t\t\tconst b = new Vector3();\n\t\t\t\tconst c = new Vector3();\n\t\t\t\tconst centroid = new Vector3();\n\t\t\t\tconst uvA = new Vector2();\n\t\t\t\tconst uvB = new Vector2();\n\t\t\t\tconst uvC = new Vector2();\n\n\t\t\t\tfor (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {\n\t\t\t\t\ta.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);\n\t\t\t\t\tb.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);\n\t\t\t\t\tc.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);\n\t\t\t\t\tuvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);\n\t\t\t\t\tuvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);\n\t\t\t\t\tuvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);\n\t\t\t\t\tcentroid.copy(a).add(b).add(c).divideScalar(3);\n\t\t\t\t\tconst azi = azimuth(centroid);\n\t\t\t\t\tcorrectUV(uvA, j + 0, a, azi);\n\t\t\t\t\tcorrectUV(uvB, j + 2, b, azi);\n\t\t\t\t\tcorrectUV(uvC, j + 4, c, azi);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction correctUV(uv, stride, vector, azimuth) {\n\t\t\t\tif (azimuth < 0 && uv.x === 1) {\n\t\t\t\t\tuvBuffer[stride] = uv.x - 1;\n\t\t\t\t}\n\n\t\t\t\tif (vector.x === 0 && vector.z === 0) {\n\t\t\t\t\tuvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;\n\t\t\t\t}\n\t\t\t} // Angle around the Y axis, counter-clockwise when looking from above.\n\n\n\t\t\tfunction azimuth(vector) {\n\t\t\t\treturn Math.atan2(vector.z, -vector.x);\n\t\t\t} // Angle above the XZ plane.\n\n\n\t\t\tfunction inclination(vector) {\n\t\t\t\treturn Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass DodecahedronGeometry extends PolyhedronGeometry {\n\t\tconstructor(radius = 1, detail = 0) {\n\t\t\tconst t = (1 + Math.sqrt(5)) / 2;\n\t\t\tconst r = 1 / t;\n\t\t\tconst vertices = [// (1, 1, 1)\n\t\t\t-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, 1/, )\n\t\t\t0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (1/, , 0)\n\t\t\t-r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (, 0, 1/)\n\t\t\t-t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];\n\t\t\tconst indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];\n\t\t\tsuper(vertices, indices, radius, detail);\n\t\t\tthis.type = 'DodecahedronGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\t}\n\n\t}\n\n\tconst _v0 = new Vector3();\n\n\tconst _v1$1 = new Vector3();\n\n\tconst _normal = new Vector3();\n\n\tconst _triangle = new Triangle();\n\n\tclass EdgesGeometry extends BufferGeometry {\n\t\tconstructor(geometry, thresholdAngle) {\n\t\t\tsuper();\n\t\t\tthis.type = 'EdgesGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tthresholdAngle: thresholdAngle\n\t\t\t};\n\t\t\tthresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;\n\n\t\t\tif (geometry.isGeometry === true) {\n\t\t\t\tconsole.error('THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst precisionPoints = 4;\n\t\t\tconst precision = Math.pow(10, precisionPoints);\n\t\t\tconst thresholdDot = Math.cos(DEG2RAD * thresholdAngle);\n\t\t\tconst indexAttr = geometry.getIndex();\n\t\t\tconst positionAttr = geometry.getAttribute('position');\n\t\t\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\t\t\tconst indexArr = [0, 0, 0];\n\t\t\tconst vertKeys = ['a', 'b', 'c'];\n\t\t\tconst hashes = new Array(3);\n\t\t\tconst edgeData = {};\n\t\t\tconst vertices = [];\n\n\t\t\tfor (let i = 0; i < indexCount; i += 3) {\n\t\t\t\tif (indexAttr) {\n\t\t\t\t\tindexArr[0] = indexAttr.getX(i);\n\t\t\t\t\tindexArr[1] = indexAttr.getX(i + 1);\n\t\t\t\t\tindexArr[2] = indexAttr.getX(i + 2);\n\t\t\t\t} else {\n\t\t\t\t\tindexArr[0] = i;\n\t\t\t\t\tindexArr[1] = i + 1;\n\t\t\t\t\tindexArr[2] = i + 2;\n\t\t\t\t}\n\n\t\t\t\tconst {\n\t\t\t\t\ta,\n\t\t\t\t\tb,\n\t\t\t\t\tc\n\t\t\t\t} = _triangle;\n\t\t\t\ta.fromBufferAttribute(positionAttr, indexArr[0]);\n\t\t\t\tb.fromBufferAttribute(positionAttr, indexArr[1]);\n\t\t\t\tc.fromBufferAttribute(positionAttr, indexArr[2]);\n\n\t\t\t\t_triangle.getNormal(_normal); // create hashes for the edge from the vertices\n\n\n\t\t\t\thashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;\n\t\t\t\thashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;\n\t\t\t\thashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`; // skip degenerate triangles\n\n\t\t\t\tif (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} // iterate over every edge\n\n\n\t\t\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t\t\t// get the first and next vertex making up the edge\n\t\t\t\t\tconst jNext = (j + 1) % 3;\n\t\t\t\t\tconst vecHash0 = hashes[j];\n\t\t\t\t\tconst vecHash1 = hashes[jNext];\n\t\t\t\t\tconst v0 = _triangle[vertKeys[j]];\n\t\t\t\t\tconst v1 = _triangle[vertKeys[jNext]];\n\t\t\t\t\tconst hash = `${vecHash0}_${vecHash1}`;\n\t\t\t\t\tconst reverseHash = `${vecHash1}_${vecHash0}`;\n\n\t\t\t\t\tif (reverseHash in edgeData && edgeData[reverseHash]) {\n\t\t\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\t\t\tif (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {\n\t\t\t\t\t\t\tvertices.push(v0.x, v0.y, v0.z);\n\t\t\t\t\t\t\tvertices.push(v1.x, v1.y, v1.z);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedgeData[reverseHash] = null;\n\t\t\t\t\t} else if (!(hash in edgeData)) {\n\t\t\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\t\t\tedgeData[hash] = {\n\t\t\t\t\t\t\tindex0: indexArr[j],\n\t\t\t\t\t\t\tindex1: indexArr[jNext],\n\t\t\t\t\t\t\tnormal: _normal.clone()\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // iterate over all remaining, unmatched edges and add them to the vertex array\n\n\n\t\t\tfor (const key in edgeData) {\n\t\t\t\tif (edgeData[key]) {\n\t\t\t\t\tconst {\n\t\t\t\t\t\tindex0,\n\t\t\t\t\t\tindex1\n\t\t\t\t\t} = edgeData[key];\n\n\t\t\t\t\t_v0.fromBufferAttribute(positionAttr, index0);\n\n\t\t\t\t\t_v1$1.fromBufferAttribute(positionAttr, index1);\n\n\t\t\t\t\tvertices.push(_v0.x, _v0.y, _v0.z);\n\t\t\t\t\tvertices.push(_v1$1.x, _v1$1.y, _v1$1.z);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t}\n\n\t}\n\n\t/**\n\t * Port from https://github.com/mapbox/earcut (v2.2.2)\n\t */\n\tconst Earcut = {\n\t\ttriangulate: function (data, holeIndices, dim) {\n\t\t\tdim = dim || 2;\n\t\t\tconst hasHoles = holeIndices && holeIndices.length;\n\t\t\tconst outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\t\t\tlet outerNode = linkedList(data, 0, outerLen, dim, true);\n\t\t\tconst triangles = [];\n\t\t\tif (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\t\t\tlet minX, minY, maxX, maxY, x, y, invSize;\n\t\t\tif (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\n\t\t\tif (data.length > 80 * dim) {\n\t\t\t\tminX = maxX = data[0];\n\t\t\t\tminY = maxY = data[1];\n\n\t\t\t\tfor (let i = dim; i < outerLen; i += dim) {\n\t\t\t\t\tx = data[i];\n\t\t\t\t\ty = data[i + 1];\n\t\t\t\t\tif (x < minX) minX = x;\n\t\t\t\t\tif (y < minY) minY = y;\n\t\t\t\t\tif (x > maxX) maxX = x;\n\t\t\t\t\tif (y > maxY) maxY = y;\n\t\t\t\t} // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\n\n\t\t\t\tinvSize = Math.max(maxX - minX, maxY - minY);\n\t\t\t\tinvSize = invSize !== 0 ? 1 / invSize : 0;\n\t\t\t}\n\n\t\t\tearcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\t\t\treturn triangles;\n\t\t}\n\t}; // create a circular doubly linked list from polygon points in the specified winding order\n\n\tfunction linkedList(data, start, end, dim, clockwise) {\n\t\tlet i, last;\n\n\t\tif (clockwise === signedArea(data, start, end, dim) > 0) {\n\t\t\tfor (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n\t\t} else {\n\t\t\tfor (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n\t\t}\n\n\t\tif (last && equals(last, last.next)) {\n\t\t\tremoveNode(last);\n\t\t\tlast = last.next;\n\t\t}\n\n\t\treturn last;\n\t} // eliminate colinear or duplicate points\n\n\n\tfunction filterPoints(start, end) {\n\t\tif (!start) return start;\n\t\tif (!end) end = start;\n\t\tlet p = start,\n\t\t\t\tagain;\n\n\t\tdo {\n\t\t\tagain = false;\n\n\t\t\tif (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n\t\t\t\tremoveNode(p);\n\t\t\t\tp = end = p.prev;\n\t\t\t\tif (p === p.next) break;\n\t\t\t\tagain = true;\n\t\t\t} else {\n\t\t\t\tp = p.next;\n\t\t\t}\n\t\t} while (again || p !== end);\n\n\t\treturn end;\n\t} // main ear slicing loop which triangulates a polygon (given as a linked list)\n\n\n\tfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n\t\tif (!ear) return; // interlink polygon nodes in z-order\n\n\t\tif (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\t\tlet stop = ear,\n\t\t\t\tprev,\n\t\t\t\tnext; // iterate through ears, slicing them one by one\n\n\t\twhile (ear.prev !== ear.next) {\n\t\t\tprev = ear.prev;\n\t\t\tnext = ear.next;\n\n\t\t\tif (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n\t\t\t\t// cut off the triangle\n\t\t\t\ttriangles.push(prev.i / dim);\n\t\t\t\ttriangles.push(ear.i / dim);\n\t\t\t\ttriangles.push(next.i / dim);\n\t\t\t\tremoveNode(ear); // skipping the next vertex leads to less sliver triangles\n\n\t\t\t\tear = next.next;\n\t\t\t\tstop = next.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tear = next; // if we looped through the whole remaining polygon and can't find any more ears\n\n\t\t\tif (ear === stop) {\n\t\t\t\t// try filtering points and slicing again\n\t\t\t\tif (!pass) {\n\t\t\t\t\tearcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally\n\t\t\t\t} else if (pass === 1) {\n\t\t\t\t\tear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n\t\t\t\t\tearcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two\n\t\t\t\t} else if (pass === 2) {\n\t\t\t\t\tsplitEarcut(ear, triangles, dim, minX, minY, invSize);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // check whether a polygon node forms a valid ear with adjacent nodes\n\n\n\tfunction isEar(ear) {\n\t\tconst a = ear.prev,\n\t\t\t\t\tb = ear,\n\t\t\t\t\tc = ear.next;\n\t\tif (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\t\t// now make sure we don't have other points inside the potential ear\n\n\t\tlet p = ear.next.next;\n\n\t\twhile (p !== ear.prev) {\n\t\t\tif (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n\t\t\tp = p.next;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction isEarHashed(ear, minX, minY, invSize) {\n\t\tconst a = ear.prev,\n\t\t\t\t\tb = ear,\n\t\t\t\t\tc = ear.next;\n\t\tif (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\t\t// triangle bbox; min & max are calculated like this for speed\n\n\t\tconst minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,\n\t\t\t\t\tminTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,\n\t\t\t\t\tmaxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,\n\t\t\t\t\tmaxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;\n\n\t\tconst minZ = zOrder(minTX, minTY, minX, minY, invSize),\n\t\t\t\t\tmaxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\t\tlet p = ear.prevZ,\n\t\t\t\tn = ear.nextZ; // look for points inside the triangle in both directions\n\n\t\twhile (p && p.z >= minZ && n && n.z <= maxZ) {\n\t\t\tif (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n\t\t\tp = p.prevZ;\n\t\t\tif (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n\t\t\tn = n.nextZ;\n\t\t} // look for remaining points in decreasing z-order\n\n\n\t\twhile (p && p.z >= minZ) {\n\t\t\tif (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n\t\t\tp = p.prevZ;\n\t\t} // look for remaining points in increasing z-order\n\n\n\t\twhile (n && n.z <= maxZ) {\n\t\t\tif (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n\t\t\tn = n.nextZ;\n\t\t}\n\n\t\treturn true;\n\t} // go through all polygon nodes and cure small local self-intersections\n\n\n\tfunction cureLocalIntersections(start, triangles, dim) {\n\t\tlet p = start;\n\n\t\tdo {\n\t\t\tconst a = p.prev,\n\t\t\t\t\t\tb = p.next.next;\n\n\t\t\tif (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\t\t\t\ttriangles.push(a.i / dim);\n\t\t\t\ttriangles.push(p.i / dim);\n\t\t\t\ttriangles.push(b.i / dim); // remove two nodes involved\n\n\t\t\t\tremoveNode(p);\n\t\t\t\tremoveNode(p.next);\n\t\t\t\tp = start = b;\n\t\t\t}\n\n\t\t\tp = p.next;\n\t\t} while (p !== start);\n\n\t\treturn filterPoints(p);\n\t} // try splitting polygon into two and triangulate them independently\n\n\n\tfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n\t\t// look for a valid diagonal that divides the polygon into two\n\t\tlet a = start;\n\n\t\tdo {\n\t\t\tlet b = a.next.next;\n\n\t\t\twhile (b !== a.prev) {\n\t\t\t\tif (a.i !== b.i && isValidDiagonal(a, b)) {\n\t\t\t\t\t// split the polygon in two by the diagonal\n\t\t\t\t\tlet c = splitPolygon(a, b); // filter colinear points around the cuts\n\n\t\t\t\t\ta = filterPoints(a, a.next);\n\t\t\t\t\tc = filterPoints(c, c.next); // run earcut on each half\n\n\t\t\t\t\tearcutLinked(a, triangles, dim, minX, minY, invSize);\n\t\t\t\t\tearcutLinked(c, triangles, dim, minX, minY, invSize);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tb = b.next;\n\t\t\t}\n\n\t\t\ta = a.next;\n\t\t} while (a !== start);\n\t} // link every hole into the outer loop, producing a single-ring polygon without holes\n\n\n\tfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n\t\tconst queue = [];\n\t\tlet i, len, start, end, list;\n\n\t\tfor (i = 0, len = holeIndices.length; i < len; i++) {\n\t\t\tstart = holeIndices[i] * dim;\n\t\t\tend = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n\t\t\tlist = linkedList(data, start, end, dim, false);\n\t\t\tif (list === list.next) list.steiner = true;\n\t\t\tqueue.push(getLeftmost(list));\n\t\t}\n\n\t\tqueue.sort(compareX); // process holes from left to right\n\n\t\tfor (i = 0; i < queue.length; i++) {\n\t\t\teliminateHole(queue[i], outerNode);\n\t\t\touterNode = filterPoints(outerNode, outerNode.next);\n\t\t}\n\n\t\treturn outerNode;\n\t}\n\n\tfunction compareX(a, b) {\n\t\treturn a.x - b.x;\n\t} // find a bridge between vertices that connects hole with an outer ring and and link it\n\n\n\tfunction eliminateHole(hole, outerNode) {\n\t\touterNode = findHoleBridge(hole, outerNode);\n\n\t\tif (outerNode) {\n\t\t\tconst b = splitPolygon(outerNode, hole); // filter collinear points around the cuts\n\n\t\t\tfilterPoints(outerNode, outerNode.next);\n\t\t\tfilterPoints(b, b.next);\n\t\t}\n\t} // David Eberly's algorithm for finding a bridge between hole and outer polygon\n\n\n\tfunction findHoleBridge(hole, outerNode) {\n\t\tlet p = outerNode;\n\t\tconst hx = hole.x;\n\t\tconst hy = hole.y;\n\t\tlet qx = -Infinity,\n\t\t\t\tm; // find a segment intersected by a ray from the hole's leftmost point to the left;\n\t\t// segment's endpoint with lesser x will be potential connection point\n\n\t\tdo {\n\t\t\tif (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n\t\t\t\tconst x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n\n\t\t\t\tif (x <= hx && x > qx) {\n\t\t\t\t\tqx = x;\n\n\t\t\t\t\tif (x === hx) {\n\t\t\t\t\t\tif (hy === p.y) return p;\n\t\t\t\t\t\tif (hy === p.next.y) return p.next;\n\t\t\t\t\t}\n\n\t\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = p.next;\n\t\t} while (p !== outerNode);\n\n\t\tif (!m) return null;\n\t\tif (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\t\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t\t// if there are no points found, we have a valid connection;\n\t\t// otherwise choose the point of the minimum angle with the ray as connection point\n\n\t\tconst stop = m,\n\t\t\t\t\tmx = m.x,\n\t\t\t\t\tmy = m.y;\n\t\tlet tanMin = Infinity,\n\t\t\t\ttan;\n\t\tp = m;\n\n\t\tdo {\n\t\t\tif (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\t\t\t\ttan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n\t\t\t\tif (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n\t\t\t\t\tm = p;\n\t\t\t\t\ttanMin = tan;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = p.next;\n\t\t} while (p !== stop);\n\n\t\treturn m;\n\t} // whether sector in vertex m contains sector in vertex p in the same coordinates\n\n\n\tfunction sectorContainsSector(m, p) {\n\t\treturn area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n\t} // interlink polygon nodes in z-order\n\n\n\tfunction indexCurve(start, minX, minY, invSize) {\n\t\tlet p = start;\n\n\t\tdo {\n\t\t\tif (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n\t\t\tp.prevZ = p.prev;\n\t\t\tp.nextZ = p.next;\n\t\t\tp = p.next;\n\t\t} while (p !== start);\n\n\t\tp.prevZ.nextZ = null;\n\t\tp.prevZ = null;\n\t\tsortLinked(p);\n\t} // Simon Tatham's linked list merge sort algorithm\n\t// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n\n\n\tfunction sortLinked(list) {\n\t\tlet i,\n\t\t\t\tp,\n\t\t\t\tq,\n\t\t\t\te,\n\t\t\t\ttail,\n\t\t\t\tnumMerges,\n\t\t\t\tpSize,\n\t\t\t\tqSize,\n\t\t\t\tinSize = 1;\n\n\t\tdo {\n\t\t\tp = list;\n\t\t\tlist = null;\n\t\t\ttail = null;\n\t\t\tnumMerges = 0;\n\n\t\t\twhile (p) {\n\t\t\t\tnumMerges++;\n\t\t\t\tq = p;\n\t\t\t\tpSize = 0;\n\n\t\t\t\tfor (i = 0; i < inSize; i++) {\n\t\t\t\t\tpSize++;\n\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\tif (!q) break;\n\t\t\t\t}\n\n\t\t\t\tqSize = inSize;\n\n\t\t\t\twhile (pSize > 0 || qSize > 0 && q) {\n\t\t\t\t\tif (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n\t\t\t\t\t\te = p;\n\t\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\t\tpSize--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = q;\n\t\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\t\tqSize--;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tail) tail.nextZ = e;else list = e;\n\t\t\t\t\te.prevZ = tail;\n\t\t\t\t\ttail = e;\n\t\t\t\t}\n\n\t\t\t\tp = q;\n\t\t\t}\n\n\t\t\ttail.nextZ = null;\n\t\t\tinSize *= 2;\n\t\t} while (numMerges > 1);\n\n\t\treturn list;\n\t} // z-order of a point given coords and inverse of the longer side of data bbox\n\n\n\tfunction zOrder(x, y, minX, minY, invSize) {\n\t\t// coords are transformed into non-negative 15-bit integer range\n\t\tx = 32767 * (x - minX) * invSize;\n\t\ty = 32767 * (y - minY) * invSize;\n\t\tx = (x | x << 8) & 0x00FF00FF;\n\t\tx = (x | x << 4) & 0x0F0F0F0F;\n\t\tx = (x | x << 2) & 0x33333333;\n\t\tx = (x | x << 1) & 0x55555555;\n\t\ty = (y | y << 8) & 0x00FF00FF;\n\t\ty = (y | y << 4) & 0x0F0F0F0F;\n\t\ty = (y | y << 2) & 0x33333333;\n\t\ty = (y | y << 1) & 0x55555555;\n\t\treturn x | y << 1;\n\t} // find the leftmost node of a polygon ring\n\n\n\tfunction getLeftmost(start) {\n\t\tlet p = start,\n\t\t\t\tleftmost = start;\n\n\t\tdo {\n\t\t\tif (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n\t\t\tp = p.next;\n\t\t} while (p !== start);\n\n\t\treturn leftmost;\n\t} // check if a point lies within a convex triangle\n\n\n\tfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n\t\treturn (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n\t} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n\n\n\tfunction isValidDiagonal(a, b) {\n\t\treturn a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges\n\t\tlocallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible\n\t\tarea(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n\t\tequals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n\t} // signed area of a triangle\n\n\n\tfunction area(p, q, r) {\n\t\treturn (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n\t} // check if two points are equal\n\n\n\tfunction equals(p1, p2) {\n\t\treturn p1.x === p2.x && p1.y === p2.y;\n\t} // check if two segments intersect\n\n\n\tfunction intersects(p1, q1, p2, q2) {\n\t\tconst o1 = sign(area(p1, q1, p2));\n\t\tconst o2 = sign(area(p1, q1, q2));\n\t\tconst o3 = sign(area(p2, q2, p1));\n\t\tconst o4 = sign(area(p2, q2, q1));\n\t\tif (o1 !== o2 && o3 !== o4) return true; // general case\n\n\t\tif (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n\n\t\tif (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n\n\t\tif (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n\n\t\tif (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n\t\treturn false;\n\t} // for collinear points p, q, r, check if point q lies on segment pr\n\n\n\tfunction onSegment(p, q, r) {\n\t\treturn q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n\t}\n\n\tfunction sign(num) {\n\t\treturn num > 0 ? 1 : num < 0 ? -1 : 0;\n\t} // check if a polygon diagonal intersects any polygon segments\n\n\n\tfunction intersectsPolygon(a, b) {\n\t\tlet p = a;\n\n\t\tdo {\n\t\t\tif (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n\t\t\tp = p.next;\n\t\t} while (p !== a);\n\n\t\treturn false;\n\t} // check if a polygon diagonal is locally inside the polygon\n\n\n\tfunction locallyInside(a, b) {\n\t\treturn area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n\t} // check if the middle point of a polygon diagonal is inside the polygon\n\n\n\tfunction middleInside(a, b) {\n\t\tlet p = a,\n\t\t\t\tinside = false;\n\t\tconst px = (a.x + b.x) / 2,\n\t\t\t\t\tpy = (a.y + b.y) / 2;\n\n\t\tdo {\n\t\t\tif (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n\t\t\tp = p.next;\n\t\t} while (p !== a);\n\n\t\treturn inside;\n\t} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n\t// if one belongs to the outer ring and another to a hole, it merges it into a single ring\n\n\n\tfunction splitPolygon(a, b) {\n\t\tconst a2 = new Node(a.i, a.x, a.y),\n\t\t\t\t\tb2 = new Node(b.i, b.x, b.y),\n\t\t\t\t\tan = a.next,\n\t\t\t\t\tbp = b.prev;\n\t\ta.next = b;\n\t\tb.prev = a;\n\t\ta2.next = an;\n\t\tan.prev = a2;\n\t\tb2.next = a2;\n\t\ta2.prev = b2;\n\t\tbp.next = b2;\n\t\tb2.prev = bp;\n\t\treturn b2;\n\t} // create a node and optionally link it with previous one (in a circular doubly linked list)\n\n\n\tfunction insertNode(i, x, y, last) {\n\t\tconst p = new Node(i, x, y);\n\n\t\tif (!last) {\n\t\t\tp.prev = p;\n\t\t\tp.next = p;\n\t\t} else {\n\t\t\tp.next = last.next;\n\t\t\tp.prev = last;\n\t\t\tlast.next.prev = p;\n\t\t\tlast.next = p;\n\t\t}\n\n\t\treturn p;\n\t}\n\n\tfunction removeNode(p) {\n\t\tp.next.prev = p.prev;\n\t\tp.prev.next = p.next;\n\t\tif (p.prevZ) p.prevZ.nextZ = p.nextZ;\n\t\tif (p.nextZ) p.nextZ.prevZ = p.prevZ;\n\t}\n\n\tfunction Node(i, x, y) {\n\t\t// vertex index in coordinates array\n\t\tthis.i = i; // vertex coordinates\n\n\t\tthis.x = x;\n\t\tthis.y = y; // previous and next vertex nodes in a polygon ring\n\n\t\tthis.prev = null;\n\t\tthis.next = null; // z-order curve value\n\n\t\tthis.z = null; // previous and next nodes in z-order\n\n\t\tthis.prevZ = null;\n\t\tthis.nextZ = null; // indicates whether this is a steiner point\n\n\t\tthis.steiner = false;\n\t}\n\n\tfunction signedArea(data, start, end, dim) {\n\t\tlet sum = 0;\n\n\t\tfor (let i = start, j = end - dim; i < end; i += dim) {\n\t\t\tsum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n\t\t\tj = i;\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\tclass ShapeUtils {\n\t\t// calculate area of the contour polygon\n\t\tstatic area(contour) {\n\t\t\tconst n = contour.length;\n\t\t\tlet a = 0.0;\n\n\t\t\tfor (let p = n - 1, q = 0; q < n; p = q++) {\n\t\t\t\ta += contour[p].x * contour[q].y - contour[q].x * contour[p].y;\n\t\t\t}\n\n\t\t\treturn a * 0.5;\n\t\t}\n\n\t\tstatic isClockWise(pts) {\n\t\t\treturn ShapeUtils.area(pts) < 0;\n\t\t}\n\n\t\tstatic triangulateShape(contour, holes) {\n\t\t\tconst vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\n\t\t\tconst holeIndices = []; // array of hole indices\n\n\t\t\tconst faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n\t\t\tremoveDupEndPts(contour);\n\t\t\taddContour(vertices, contour); //\n\n\t\t\tlet holeIndex = contour.length;\n\t\t\tholes.forEach(removeDupEndPts);\n\n\t\t\tfor (let i = 0; i < holes.length; i++) {\n\t\t\t\tholeIndices.push(holeIndex);\n\t\t\t\tholeIndex += holes[i].length;\n\t\t\t\taddContour(vertices, holes[i]);\n\t\t\t} //\n\n\n\t\t\tconst triangles = Earcut.triangulate(vertices, holeIndices); //\n\n\t\t\tfor (let i = 0; i < triangles.length; i += 3) {\n\t\t\t\tfaces.push(triangles.slice(i, i + 3));\n\t\t\t}\n\n\t\t\treturn faces;\n\t\t}\n\n\t}\n\n\tfunction removeDupEndPts(points) {\n\t\tconst l = points.length;\n\n\t\tif (l > 2 && points[l - 1].equals(points[0])) {\n\t\t\tpoints.pop();\n\t\t}\n\t}\n\n\tfunction addContour(vertices, contour) {\n\t\tfor (let i = 0; i < contour.length; i++) {\n\t\t\tvertices.push(contour[i].x);\n\t\t\tvertices.push(contour[i].y);\n\t\t}\n\t}\n\n\t/**\n\t * Creates extruded geometry from a path shape.\n\t *\n\t * parameters = {\n\t *\n\t *\tcurveSegments: <int>, // number of points on the curves\n\t *\tsteps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n\t *\tdepth: <float>, // Depth to extrude the shape\n\t *\n\t *\tbevelEnabled: <bool>, // turn on bevel\n\t *\tbevelThickness: <float>, // how deep into the original shape bevel goes\n\t *\tbevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n\t *\tbevelOffset: <float>, // how far from shape outline does bevel start\n\t *\tbevelSegments: <int>, // number of bevel layers\n\t *\n\t *\textrudePath: <THREE.Curve> // curve to extrude shape along\n\t *\n\t *\tUVGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t */\n\n\tclass ExtrudeGeometry extends BufferGeometry {\n\t\tconstructor(shapes, options) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ExtrudeGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tshapes: shapes,\n\t\t\t\toptions: options\n\t\t\t};\n\t\t\tshapes = Array.isArray(shapes) ? shapes : [shapes];\n\t\t\tconst scope = this;\n\t\t\tconst verticesArray = [];\n\t\t\tconst uvArray = [];\n\n\t\t\tfor (let i = 0, l = shapes.length; i < l; i++) {\n\t\t\t\tconst shape = shapes[i];\n\t\t\t\taddShape(shape);\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));\n\t\t\tthis.computeVertexNormals(); // functions\n\n\t\t\tfunction addShape(shape) {\n\t\t\t\tconst placeholder = []; // options\n\n\t\t\t\tconst curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\t\t\tconst steps = options.steps !== undefined ? options.steps : 1;\n\t\t\t\tlet depth = options.depth !== undefined ? options.depth : 100;\n\t\t\t\tlet bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\t\t\tlet bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\n\t\t\t\tlet bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\n\t\t\t\tlet bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n\t\t\t\tlet bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\t\t\t\tconst extrudePath = options.extrudePath;\n\t\t\t\tconst uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options\n\n\t\t\t\tif (options.amount !== undefined) {\n\t\t\t\t\tconsole.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');\n\t\t\t\t\tdepth = options.amount;\n\t\t\t\t} //\n\n\n\t\t\t\tlet extrudePts,\n\t\t\t\t\t\textrudeByPath = false;\n\t\t\t\tlet splineTube, binormal, normal, position2;\n\n\t\t\t\tif (extrudePath) {\n\t\t\t\t\textrudePts = extrudePath.getSpacedPoints(steps);\n\t\t\t\t\textrudeByPath = true;\n\t\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\t\t\t\t\t// SETUP TNB variables\n\t\t\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\t\t\tsplineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\t\t\tbinormal = new Vector3();\n\t\t\t\t\tnormal = new Vector3();\n\t\t\t\t\tposition2 = new Vector3();\n\t\t\t\t} // Safeguards if bevels are not enabled\n\n\n\t\t\t\tif (!bevelEnabled) {\n\t\t\t\t\tbevelSegments = 0;\n\t\t\t\t\tbevelThickness = 0;\n\t\t\t\t\tbevelSize = 0;\n\t\t\t\t\tbevelOffset = 0;\n\t\t\t\t} // Variables initialization\n\n\n\t\t\t\tconst shapePoints = shape.extractPoints(curveSegments);\n\t\t\t\tlet vertices = shapePoints.shape;\n\t\t\t\tconst holes = shapePoints.holes;\n\t\t\t\tconst reverse = !ShapeUtils.isClockWise(vertices);\n\n\t\t\t\tif (reverse) {\n\t\t\t\t\tvertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\t\tconst ahole = holes[h];\n\n\t\t\t\t\t\tif (ShapeUtils.isClockWise(ahole)) {\n\t\t\t\t\t\t\tholes[h] = ahole.reverse();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst faces = ShapeUtils.triangulateShape(vertices, holes);\n\t\t\t\t/* Vertices */\n\n\t\t\t\tconst contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\tconst ahole = holes[h];\n\t\t\t\t\tvertices = vertices.concat(ahole);\n\t\t\t\t}\n\n\t\t\t\tfunction scalePt2(pt, vec, size) {\n\t\t\t\t\tif (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');\n\t\t\t\t\treturn vec.clone().multiplyScalar(size).add(pt);\n\t\t\t\t}\n\n\t\t\t\tconst vlen = vertices.length,\n\t\t\t\t\t\t\tflen = faces.length; // Find directions for point movement\n\n\t\t\t\tfunction getBevelVec(inPt, inPrev, inNext) {\n\t\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t\t//\t shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t\t//\n\t\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t\t//\tadjacent edges of inPt at a distance of 1 unit on the left side.\n\t\t\t\t\tlet v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\t\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\t\t\tconst v_prev_x = inPt.x - inPrev.x,\n\t\t\t\t\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\t\t\tconst v_next_x = inNext.x - inPt.x,\n\t\t\t\t\t\t\t\tv_next_y = inNext.y - inPt.y;\n\t\t\t\t\tconst v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges\n\n\t\t\t\t\tconst collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;\n\n\t\t\t\t\tif (Math.abs(collinear0) > Number.EPSILON) {\n\t\t\t\t\t\t// not collinear\n\t\t\t\t\t\t// length of vectors for normalizing\n\t\t\t\t\t\tconst v_prev_len = Math.sqrt(v_prev_lensq);\n\t\t\t\t\t\tconst v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left\n\n\t\t\t\t\t\tconst ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;\n\t\t\t\t\t\tconst ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;\n\t\t\t\t\t\tconst ptNextShift_x = inNext.x - v_next_y / v_next_len;\n\t\t\t\t\t\tconst ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point\n\n\t\t\t\t\t\tconst sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point\n\n\t\t\t\t\t\tv_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;\n\t\t\t\t\t\tv_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t\t//\tbut prevent crazy spikes\n\n\t\t\t\t\t\tconst v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;\n\n\t\t\t\t\t\tif (v_trans_lensq <= 2) {\n\t\t\t\t\t\t\treturn new Vector2(v_trans_x, v_trans_y);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tshrink_by = Math.sqrt(v_trans_lensq / 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// handle special case of collinear edges\n\t\t\t\t\t\tlet direction_eq = false; // assumes: opposite\n\n\t\t\t\t\t\tif (v_prev_x > Number.EPSILON) {\n\t\t\t\t\t\t\tif (v_next_x > Number.EPSILON) {\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (v_prev_x < -Number.EPSILON) {\n\t\t\t\t\t\t\t\tif (v_next_x < -Number.EPSILON) {\n\t\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (Math.sign(v_prev_y) === Math.sign(v_next_y)) {\n\t\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (direction_eq) {\n\t\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\t\tv_trans_x = -v_prev_y;\n\t\t\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\t\t\tshrink_by = Math.sqrt(v_prev_lensq);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\t\tshrink_by = Math.sqrt(v_prev_lensq / 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);\n\t\t\t\t}\n\n\t\t\t\tconst contourMovements = [];\n\n\t\t\t\tfor (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n\t\t\t\t\tif (j === il) j = 0;\n\t\t\t\t\tif (k === il) k = 0; //\t(j)---(i)---(k)\n\t\t\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\t\t\tcontourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);\n\t\t\t\t}\n\n\t\t\t\tconst holesMovements = [];\n\t\t\t\tlet oneHoleMovements,\n\t\t\t\t\t\tverticesMovements = contourMovements.concat();\n\n\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\tconst ahole = holes[h];\n\t\t\t\t\toneHoleMovements = [];\n\n\t\t\t\t\tfor (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n\t\t\t\t\t\tif (j === il) j = 0;\n\t\t\t\t\t\tif (k === il) k = 0; //\t(j)---(i)---(k)\n\n\t\t\t\t\t\toneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);\n\t\t\t\t\t}\n\n\t\t\t\t\tholesMovements.push(oneHoleMovements);\n\t\t\t\t\tverticesMovements = verticesMovements.concat(oneHoleMovements);\n\t\t\t\t} // Loop bevelSegments, 1 for the front, 1 for the back\n\n\n\t\t\t\tfor (let b = 0; b < bevelSegments; b++) {\n\t\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\t\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\t\tconst z = bevelThickness * Math.cos(t * Math.PI / 2);\n\t\t\t\t\tconst bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape\n\n\t\t\t\t\tfor (let i = 0, il = contour.length; i < il; i++) {\n\t\t\t\t\t\tconst vert = scalePt2(contour[i], contourMovements[i], bs);\n\t\t\t\t\t\tv(vert.x, vert.y, -z);\n\t\t\t\t\t} // expand holes\n\n\n\t\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\t\tconst ahole = holes[h];\n\t\t\t\t\t\toneHoleMovements = holesMovements[h];\n\n\t\t\t\t\t\tfor (let i = 0, il = ahole.length; i < il; i++) {\n\t\t\t\t\t\t\tconst vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n\t\t\t\t\t\t\tv(vert.x, vert.y, -z);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst bs = bevelSize + bevelOffset; // Back facing vertices\n\n\t\t\t\tfor (let i = 0; i < vlen; i++) {\n\t\t\t\t\tconst vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n\n\t\t\t\t\tif (!extrudeByPath) {\n\t\t\t\t\t\tv(vert.x, vert.y, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\t\t\t\t\t\tnormal.copy(splineTube.normals[0]).multiplyScalar(vert.x);\n\t\t\t\t\t\tbinormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);\n\t\t\t\t\t\tposition2.copy(extrudePts[0]).add(normal).add(binormal);\n\t\t\t\t\t\tv(position2.x, position2.y, position2.z);\n\t\t\t\t\t}\n\t\t\t\t} // Add stepped vertices...\n\t\t\t\t// Including front facing vertices\n\n\n\t\t\t\tfor (let s = 1; s <= steps; s++) {\n\t\t\t\t\tfor (let i = 0; i < vlen; i++) {\n\t\t\t\t\t\tconst vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n\n\t\t\t\t\t\tif (!extrudeByPath) {\n\t\t\t\t\t\t\tv(vert.x, vert.y, depth / steps * s);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\t\t\t\t\t\t\tnormal.copy(splineTube.normals[s]).multiplyScalar(vert.x);\n\t\t\t\t\t\t\tbinormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);\n\t\t\t\t\t\t\tposition2.copy(extrudePts[s]).add(normal).add(binormal);\n\t\t\t\t\t\t\tv(position2.x, position2.y, position2.z);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // Add bevel segments planes\n\t\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\n\n\t\t\t\tfor (let b = bevelSegments - 1; b >= 0; b--) {\n\t\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\t\tconst z = bevelThickness * Math.cos(t * Math.PI / 2);\n\t\t\t\t\tconst bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape\n\n\t\t\t\t\tfor (let i = 0, il = contour.length; i < il; i++) {\n\t\t\t\t\t\tconst vert = scalePt2(contour[i], contourMovements[i], bs);\n\t\t\t\t\t\tv(vert.x, vert.y, depth + z);\n\t\t\t\t\t} // expand holes\n\n\n\t\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\t\tconst ahole = holes[h];\n\t\t\t\t\t\toneHoleMovements = holesMovements[h];\n\n\t\t\t\t\t\tfor (let i = 0, il = ahole.length; i < il; i++) {\n\t\t\t\t\t\t\tconst vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n\n\t\t\t\t\t\t\tif (!extrudeByPath) {\n\t\t\t\t\t\t\t\tv(vert.x, vert.y, depth + z);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tv(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Faces */\n\t\t\t\t// Top and bottom faces\n\n\n\t\t\t\tbuildLidFaces(); // Sides faces\n\n\t\t\t\tbuildSideFaces(); /////\tInternal functions\n\n\t\t\t\tfunction buildLidFaces() {\n\t\t\t\t\tconst start = verticesArray.length / 3;\n\n\t\t\t\t\tif (bevelEnabled) {\n\t\t\t\t\t\tlet layer = 0; // steps + 1\n\n\t\t\t\t\t\tlet offset = vlen * layer; // Bottom faces\n\n\t\t\t\t\t\tfor (let i = 0; i < flen; i++) {\n\t\t\t\t\t\t\tconst face = faces[i];\n\t\t\t\t\t\t\tf3(face[2] + offset, face[1] + offset, face[0] + offset);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\t\toffset = vlen * layer; // Top faces\n\n\t\t\t\t\t\tfor (let i = 0; i < flen; i++) {\n\t\t\t\t\t\t\tconst face = faces[i];\n\t\t\t\t\t\t\tf3(face[0] + offset, face[1] + offset, face[2] + offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Bottom faces\n\t\t\t\t\t\tfor (let i = 0; i < flen; i++) {\n\t\t\t\t\t\t\tconst face = faces[i];\n\t\t\t\t\t\t\tf3(face[2], face[1], face[0]);\n\t\t\t\t\t\t} // Top faces\n\n\n\t\t\t\t\t\tfor (let i = 0; i < flen; i++) {\n\t\t\t\t\t\t\tconst face = faces[i];\n\t\t\t\t\t\t\tf3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addGroup(start, verticesArray.length / 3 - start, 0);\n\t\t\t\t} // Create faces for the z-sides of the shape\n\n\n\t\t\t\tfunction buildSideFaces() {\n\t\t\t\t\tconst start = verticesArray.length / 3;\n\t\t\t\t\tlet layeroffset = 0;\n\t\t\t\t\tsidewalls(contour, layeroffset);\n\t\t\t\t\tlayeroffset += contour.length;\n\n\t\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\t\tconst ahole = holes[h];\n\t\t\t\t\t\tsidewalls(ahole, layeroffset); //, true\n\n\t\t\t\t\t\tlayeroffset += ahole.length;\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addGroup(start, verticesArray.length / 3 - start, 1);\n\t\t\t\t}\n\n\t\t\t\tfunction sidewalls(contour, layeroffset) {\n\t\t\t\t\tlet i = contour.length;\n\n\t\t\t\t\twhile (--i >= 0) {\n\t\t\t\t\t\tconst j = i;\n\t\t\t\t\t\tlet k = i - 1;\n\t\t\t\t\t\tif (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\t\t\tfor (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {\n\t\t\t\t\t\t\tconst slen1 = vlen * s;\n\t\t\t\t\t\t\tconst slen2 = vlen * (s + 1);\n\t\t\t\t\t\t\tconst a = layeroffset + j + slen1,\n\t\t\t\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\t\t\t\t\t\t\tf4(a, b, c, d);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction v(x, y, z) {\n\t\t\t\t\tplaceholder.push(x);\n\t\t\t\t\tplaceholder.push(y);\n\t\t\t\t\tplaceholder.push(z);\n\t\t\t\t}\n\n\t\t\t\tfunction f3(a, b, c) {\n\t\t\t\t\taddVertex(a);\n\t\t\t\t\taddVertex(b);\n\t\t\t\t\taddVertex(c);\n\t\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\t\tconst uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n\t\t\t\t\taddUV(uvs[0]);\n\t\t\t\t\taddUV(uvs[1]);\n\t\t\t\t\taddUV(uvs[2]);\n\t\t\t\t}\n\n\t\t\t\tfunction f4(a, b, c, d) {\n\t\t\t\t\taddVertex(a);\n\t\t\t\t\taddVertex(b);\n\t\t\t\t\taddVertex(d);\n\t\t\t\t\taddVertex(b);\n\t\t\t\t\taddVertex(c);\n\t\t\t\t\taddVertex(d);\n\t\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\t\tconst uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n\t\t\t\t\taddUV(uvs[0]);\n\t\t\t\t\taddUV(uvs[1]);\n\t\t\t\t\taddUV(uvs[3]);\n\t\t\t\t\taddUV(uvs[1]);\n\t\t\t\t\taddUV(uvs[2]);\n\t\t\t\t\taddUV(uvs[3]);\n\t\t\t\t}\n\n\t\t\t\tfunction addVertex(index) {\n\t\t\t\t\tverticesArray.push(placeholder[index * 3 + 0]);\n\t\t\t\t\tverticesArray.push(placeholder[index * 3 + 1]);\n\t\t\t\t\tverticesArray.push(placeholder[index * 3 + 2]);\n\t\t\t\t}\n\n\t\t\t\tfunction addUV(vector2) {\n\t\t\t\t\tuvArray.push(vector2.x);\n\t\t\t\t\tuvArray.push(vector2.y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tconst shapes = this.parameters.shapes;\n\t\t\tconst options = this.parameters.options;\n\t\t\treturn toJSON$1(shapes, options, data);\n\t\t}\n\n\t}\n\n\tconst WorldUVGenerator = {\n\t\tgenerateTopUV: function (geometry, vertices, indexA, indexB, indexC) {\n\t\t\tconst a_x = vertices[indexA * 3];\n\t\t\tconst a_y = vertices[indexA * 3 + 1];\n\t\t\tconst b_x = vertices[indexB * 3];\n\t\t\tconst b_y = vertices[indexB * 3 + 1];\n\t\t\tconst c_x = vertices[indexC * 3];\n\t\t\tconst c_y = vertices[indexC * 3 + 1];\n\t\t\treturn [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];\n\t\t},\n\t\tgenerateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {\n\t\t\tconst a_x = vertices[indexA * 3];\n\t\t\tconst a_y = vertices[indexA * 3 + 1];\n\t\t\tconst a_z = vertices[indexA * 3 + 2];\n\t\t\tconst b_x = vertices[indexB * 3];\n\t\t\tconst b_y = vertices[indexB * 3 + 1];\n\t\t\tconst b_z = vertices[indexB * 3 + 2];\n\t\t\tconst c_x = vertices[indexC * 3];\n\t\t\tconst c_y = vertices[indexC * 3 + 1];\n\t\t\tconst c_z = vertices[indexC * 3 + 2];\n\t\t\tconst d_x = vertices[indexD * 3];\n\t\t\tconst d_y = vertices[indexD * 3 + 1];\n\t\t\tconst d_z = vertices[indexD * 3 + 2];\n\n\t\t\tif (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {\n\t\t\t\treturn [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];\n\t\t\t} else {\n\t\t\t\treturn [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction toJSON$1(shapes, options, data) {\n\t\tdata.shapes = [];\n\n\t\tif (Array.isArray(shapes)) {\n\t\t\tfor (let i = 0, l = shapes.length; i < l; i++) {\n\t\t\t\tconst shape = shapes[i];\n\t\t\t\tdata.shapes.push(shape.uuid);\n\t\t\t}\n\t\t} else {\n\t\t\tdata.shapes.push(shapes.uuid);\n\t\t}\n\n\t\tif (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();\n\t\treturn data;\n\t}\n\n\tclass IcosahedronGeometry extends PolyhedronGeometry {\n\t\tconstructor(radius = 1, detail = 0) {\n\t\t\tconst t = (1 + Math.sqrt(5)) / 2;\n\t\t\tconst vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];\n\t\t\tconst indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];\n\t\t\tsuper(vertices, indices, radius, detail);\n\t\t\tthis.type = 'IcosahedronGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\t}\n\n\t}\n\n\tclass LatheGeometry extends BufferGeometry {\n\t\tconstructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'LatheGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tpoints: points,\n\t\t\t\tsegments: segments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength\n\t\t\t};\n\t\t\tsegments = Math.floor(segments); // clamp phiLength so it's in range of [ 0, 2PI ]\n\n\t\t\tphiLength = clamp(phiLength, 0, Math.PI * 2); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tconst inverseSegments = 1.0 / segments;\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst uv = new Vector2(); // generate vertices and uvs\n\n\t\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\t\tconst phi = phiStart + i * inverseSegments * phiLength;\n\t\t\t\tconst sin = Math.sin(phi);\n\t\t\t\tconst cos = Math.cos(phi);\n\n\t\t\t\tfor (let j = 0; j <= points.length - 1; j++) {\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = points[j].x * sin;\n\t\t\t\t\tvertex.y = points[j].y;\n\t\t\t\t\tvertex.z = points[j].x * cos;\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // uv\n\n\t\t\t\t\tuv.x = i / segments;\n\t\t\t\t\tuv.y = j / (points.length - 1);\n\t\t\t\t\tuvs.push(uv.x, uv.y);\n\t\t\t\t}\n\t\t\t} // indices\n\n\n\t\t\tfor (let i = 0; i < segments; i++) {\n\t\t\t\tfor (let j = 0; j < points.length - 1; j++) {\n\t\t\t\t\tconst base = j + i * points.length;\n\t\t\t\t\tconst a = base;\n\t\t\t\t\tconst b = base + points.length;\n\t\t\t\t\tconst c = base + points.length + 1;\n\t\t\t\t\tconst d = base + 1; // faces\n\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals\n\n\t\t\tthis.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.\n\t\t\t// because the corresponding vertices are identical (but still have different UVs).\n\n\t\t\tif (phiLength === Math.PI * 2) {\n\t\t\t\tconst normals = this.attributes.normal.array;\n\t\t\t\tconst n1 = new Vector3();\n\t\t\t\tconst n2 = new Vector3();\n\t\t\t\tconst n = new Vector3(); // this is the buffer offset for the last line of vertices\n\n\t\t\t\tconst base = segments * points.length * 3;\n\n\t\t\t\tfor (let i = 0, j = 0; i < points.length; i++, j += 3) {\n\t\t\t\t\t// select the normal of the vertex in the first line\n\t\t\t\t\tn1.x = normals[j + 0];\n\t\t\t\t\tn1.y = normals[j + 1];\n\t\t\t\t\tn1.z = normals[j + 2]; // select the normal of the vertex in the last line\n\n\t\t\t\t\tn2.x = normals[base + j + 0];\n\t\t\t\t\tn2.y = normals[base + j + 1];\n\t\t\t\t\tn2.z = normals[base + j + 2]; // average normals\n\n\t\t\t\t\tn.addVectors(n1, n2).normalize(); // assign the new values to both normals\n\n\t\t\t\t\tnormals[j + 0] = normals[base + j + 0] = n.x;\n\t\t\t\t\tnormals[j + 1] = normals[base + j + 1] = n.y;\n\t\t\t\t\tnormals[j + 2] = normals[base + j + 2] = n.z;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass OctahedronGeometry extends PolyhedronGeometry {\n\t\tconstructor(radius = 1, detail = 0) {\n\t\t\tconst vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];\n\t\t\tconst indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];\n\t\t\tsuper(vertices, indices, radius, detail);\n\t\t\tthis.type = 'OctahedronGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\t}\n\n\t}\n\n\t/**\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html\n\t */\n\n\tclass ParametricGeometry extends BufferGeometry {\n\t\tconstructor(func, slices, stacks) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ParametricGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tfunc: func,\n\t\t\t\tslices: slices,\n\t\t\t\tstacks: stacks\n\t\t\t}; // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = [];\n\t\t\tconst EPS = 0.00001;\n\t\t\tconst normal = new Vector3();\n\t\t\tconst p0 = new Vector3(),\n\t\t\t\t\t\tp1 = new Vector3();\n\t\t\tconst pu = new Vector3(),\n\t\t\t\t\t\tpv = new Vector3();\n\n\t\t\tif (func.length < 3) {\n\t\t\t\tconsole.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');\n\t\t\t} // generate vertices, normals and uvs\n\n\n\t\t\tconst sliceCount = slices + 1;\n\n\t\t\tfor (let i = 0; i <= stacks; i++) {\n\t\t\t\tconst v = i / stacks;\n\n\t\t\t\tfor (let j = 0; j <= slices; j++) {\n\t\t\t\t\tconst u = j / slices; // vertex\n\n\t\t\t\t\tfunc(u, v, p0);\n\t\t\t\t\tvertices.push(p0.x, p0.y, p0.z); // normal\n\t\t\t\t\t// approximate tangent vectors via finite differences\n\n\t\t\t\t\tif (u - EPS >= 0) {\n\t\t\t\t\t\tfunc(u - EPS, v, p1);\n\t\t\t\t\t\tpu.subVectors(p0, p1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfunc(u + EPS, v, p1);\n\t\t\t\t\t\tpu.subVectors(p1, p0);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (v - EPS >= 0) {\n\t\t\t\t\t\tfunc(u, v - EPS, p1);\n\t\t\t\t\t\tpv.subVectors(p0, p1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfunc(u, v + EPS, p1);\n\t\t\t\t\t\tpv.subVectors(p1, p0);\n\t\t\t\t\t} // cross product of tangent vectors returns surface normal\n\n\n\t\t\t\t\tnormal.crossVectors(pu, pv).normalize();\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // uv\n\n\t\t\t\t\tuvs.push(u, v);\n\t\t\t\t}\n\t\t\t} // generate indices\n\n\n\t\t\tfor (let i = 0; i < stacks; i++) {\n\t\t\t\tfor (let j = 0; j < slices; j++) {\n\t\t\t\t\tconst a = i * sliceCount + j;\n\t\t\t\t\tconst b = i * sliceCount + j + 1;\n\t\t\t\t\tconst c = (i + 1) * sliceCount + j + 1;\n\t\t\t\t\tconst d = (i + 1) * sliceCount + j; // faces one and two\n\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tclass RingGeometry extends BufferGeometry {\n\t\tconstructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'RingGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\touterRadius: outerRadius,\n\t\t\t\tthetaSegments: thetaSegments,\n\t\t\t\tphiSegments: phiSegments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\t\tthetaSegments = Math.max(3, thetaSegments);\n\t\t\tphiSegments = Math.max(1, phiSegments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // some helper variables\n\n\t\t\tlet radius = innerRadius;\n\t\t\tconst radiusStep = (outerRadius - innerRadius) / phiSegments;\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst uv = new Vector2(); // generate vertices, normals and uvs\n\n\t\t\tfor (let j = 0; j <= phiSegments; j++) {\n\t\t\t\tfor (let i = 0; i <= thetaSegments; i++) {\n\t\t\t\t\t// values are generate from the inside of the ring to the outside\n\t\t\t\t\tconst segment = thetaStart + i / thetaSegments * thetaLength; // vertex\n\n\t\t\t\t\tvertex.x = radius * Math.cos(segment);\n\t\t\t\t\tvertex.y = radius * Math.sin(segment);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\t\tnormals.push(0, 0, 1); // uv\n\n\t\t\t\t\tuv.x = (vertex.x / outerRadius + 1) / 2;\n\t\t\t\t\tuv.y = (vertex.y / outerRadius + 1) / 2;\n\t\t\t\t\tuvs.push(uv.x, uv.y);\n\t\t\t\t} // increase the radius for next row of vertices\n\n\n\t\t\t\tradius += radiusStep;\n\t\t\t} // indices\n\n\n\t\t\tfor (let j = 0; j < phiSegments; j++) {\n\t\t\t\tconst thetaSegmentLevel = j * (thetaSegments + 1);\n\n\t\t\t\tfor (let i = 0; i < thetaSegments; i++) {\n\t\t\t\t\tconst segment = i + thetaSegmentLevel;\n\t\t\t\t\tconst a = segment;\n\t\t\t\t\tconst b = segment + thetaSegments + 1;\n\t\t\t\t\tconst c = segment + thetaSegments + 2;\n\t\t\t\t\tconst d = segment + 1; // faces\n\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tclass ShapeGeometry extends BufferGeometry {\n\t\tconstructor(shapes, curveSegments = 12) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ShapeGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tshapes: shapes,\n\t\t\t\tcurveSegments: curveSegments\n\t\t\t}; // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tlet groupStart = 0;\n\t\t\tlet groupCount = 0; // allow single and array values for \"shapes\" parameter\n\n\t\t\tif (Array.isArray(shapes) === false) {\n\t\t\t\taddShape(shapes);\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\t\t\taddShape(shapes[i]);\n\t\t\t\t\tthis.addGroup(groupStart, groupCount, i); // enables MultiMaterial support\n\n\t\t\t\t\tgroupStart += groupCount;\n\t\t\t\t\tgroupCount = 0;\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions\n\n\t\t\tfunction addShape(shape) {\n\t\t\t\tconst indexOffset = vertices.length / 3;\n\t\t\t\tconst points = shape.extractPoints(curveSegments);\n\t\t\t\tlet shapeVertices = points.shape;\n\t\t\t\tconst shapeHoles = points.holes; // check direction of vertices\n\n\t\t\t\tif (ShapeUtils.isClockWise(shapeVertices) === false) {\n\t\t\t\t\tshapeVertices = shapeVertices.reverse();\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0, l = shapeHoles.length; i < l; i++) {\n\t\t\t\t\tconst shapeHole = shapeHoles[i];\n\n\t\t\t\t\tif (ShapeUtils.isClockWise(shapeHole) === true) {\n\t\t\t\t\t\tshapeHoles[i] = shapeHole.reverse();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array\n\n\t\t\t\tfor (let i = 0, l = shapeHoles.length; i < l; i++) {\n\t\t\t\t\tconst shapeHole = shapeHoles[i];\n\t\t\t\t\tshapeVertices = shapeVertices.concat(shapeHole);\n\t\t\t\t} // vertices, normals, uvs\n\n\n\t\t\t\tfor (let i = 0, l = shapeVertices.length; i < l; i++) {\n\t\t\t\t\tconst vertex = shapeVertices[i];\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, 0);\n\t\t\t\t\tnormals.push(0, 0, 1);\n\t\t\t\t\tuvs.push(vertex.x, vertex.y); // world uvs\n\t\t\t\t} // incides\n\n\n\t\t\t\tfor (let i = 0, l = faces.length; i < l; i++) {\n\t\t\t\t\tconst face = faces[i];\n\t\t\t\t\tconst a = face[0] + indexOffset;\n\t\t\t\t\tconst b = face[1] + indexOffset;\n\t\t\t\t\tconst c = face[2] + indexOffset;\n\t\t\t\t\tindices.push(a, b, c);\n\t\t\t\t\tgroupCount += 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tconst shapes = this.parameters.shapes;\n\t\t\treturn toJSON(shapes, data);\n\t\t}\n\n\t}\n\n\tfunction toJSON(shapes, data) {\n\t\tdata.shapes = [];\n\n\t\tif (Array.isArray(shapes)) {\n\t\t\tfor (let i = 0, l = shapes.length; i < l; i++) {\n\t\t\t\tconst shape = shapes[i];\n\t\t\t\tdata.shapes.push(shape.uuid);\n\t\t\t}\n\t\t} else {\n\t\t\tdata.shapes.push(shapes.uuid);\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tclass SphereGeometry extends BufferGeometry {\n\t\tconstructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {\n\t\t\tsuper();\n\t\t\tthis.type = 'SphereGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\t\twidthSegments = Math.max(3, Math.floor(widthSegments));\n\t\t\theightSegments = Math.max(2, Math.floor(heightSegments));\n\t\t\tconst thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n\t\t\tlet index = 0;\n\t\t\tconst grid = [];\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst normal = new Vector3(); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // generate vertices, normals and uvs\n\n\t\t\tfor (let iy = 0; iy <= heightSegments; iy++) {\n\t\t\t\tconst verticesRow = [];\n\t\t\t\tconst v = iy / heightSegments; // special case for the poles\n\n\t\t\t\tlet uOffset = 0;\n\n\t\t\t\tif (iy == 0 && thetaStart == 0) {\n\t\t\t\t\tuOffset = 0.5 / widthSegments;\n\t\t\t\t} else if (iy == heightSegments && thetaEnd == Math.PI) {\n\t\t\t\t\tuOffset = -0.5 / widthSegments;\n\t\t\t\t}\n\n\t\t\t\tfor (let ix = 0; ix <= widthSegments; ix++) {\n\t\t\t\t\tconst u = ix / widthSegments; // vertex\n\n\t\t\t\t\tvertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n\t\t\t\t\tvertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n\t\t\t\t\tvertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\t\tnormal.copy(vertex).normalize();\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // uv\n\n\t\t\t\t\tuvs.push(u + uOffset, 1 - v);\n\t\t\t\t\tverticesRow.push(index++);\n\t\t\t\t}\n\n\t\t\t\tgrid.push(verticesRow);\n\t\t\t} // indices\n\n\n\t\t\tfor (let iy = 0; iy < heightSegments; iy++) {\n\t\t\t\tfor (let ix = 0; ix < widthSegments; ix++) {\n\t\t\t\t\tconst a = grid[iy][ix + 1];\n\t\t\t\t\tconst b = grid[iy][ix];\n\t\t\t\t\tconst c = grid[iy + 1][ix];\n\t\t\t\t\tconst d = grid[iy + 1][ix + 1];\n\t\t\t\t\tif (iy !== 0 || thetaStart > 0) indices.push(a, b, d);\n\t\t\t\t\tif (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tclass TetrahedronGeometry extends PolyhedronGeometry {\n\t\tconstructor(radius = 1, detail = 0) {\n\t\t\tconst vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];\n\t\t\tconst indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];\n\t\t\tsuper(vertices, indices, radius, detail);\n\t\t\tthis.type = 'TetrahedronGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\t}\n\n\t}\n\n\t/**\n\t * Text = 3D Text\n\t *\n\t * parameters = {\n\t *\tfont: <THREE.Font>, // font\n\t *\n\t *\tsize: <float>, // size of the text\n\t *\theight: <float>, // thickness to extrude text\n\t *\tcurveSegments: <int>, // number of points on the curves\n\t *\n\t *\tbevelEnabled: <bool>, // turn on bevel\n\t *\tbevelThickness: <float>, // how deep into text bevel goes\n\t *\tbevelSize: <float>, // how far from text outline (including bevelOffset) is bevel\n\t *\tbevelOffset: <float> // how far from text outline does bevel start\n\t * }\n\t */\n\n\tclass TextGeometry extends ExtrudeGeometry {\n\t\tconstructor(text, parameters = {}) {\n\t\t\tconst font = parameters.font;\n\n\t\t\tif (!(font && font.isFont)) {\n\t\t\t\tconsole.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');\n\t\t\t\treturn new BufferGeometry();\n\t\t\t}\n\n\t\t\tconst shapes = font.generateShapes(text, parameters.size); // translate parameters to ExtrudeGeometry API\n\n\t\t\tparameters.depth = parameters.height !== undefined ? parameters.height : 50; // defaults\n\n\t\t\tif (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;\n\t\t\tif (parameters.bevelSize === undefined) parameters.bevelSize = 8;\n\t\t\tif (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;\n\t\t\tsuper(shapes, parameters);\n\t\t\tthis.type = 'TextGeometry';\n\t\t}\n\n\t}\n\n\tclass TorusGeometry extends BufferGeometry {\n\t\tconstructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'TorusGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tarc: arc\n\t\t\t};\n\t\t\tradialSegments = Math.floor(radialSegments);\n\t\t\ttubularSegments = Math.floor(tubularSegments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tconst center = new Vector3();\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst normal = new Vector3(); // generate vertices, normals and uvs\n\n\t\t\tfor (let j = 0; j <= radialSegments; j++) {\n\t\t\t\tfor (let i = 0; i <= tubularSegments; i++) {\n\t\t\t\t\tconst u = i / tubularSegments * arc;\n\t\t\t\t\tconst v = j / radialSegments * Math.PI * 2; // vertex\n\n\t\t\t\t\tvertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);\n\t\t\t\t\tvertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);\n\t\t\t\t\tvertex.z = tube * Math.sin(v);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\t\tcenter.x = radius * Math.cos(u);\n\t\t\t\t\tcenter.y = radius * Math.sin(u);\n\t\t\t\t\tnormal.subVectors(vertex, center).normalize();\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // uv\n\n\t\t\t\t\tuvs.push(i / tubularSegments);\n\t\t\t\t\tuvs.push(j / radialSegments);\n\t\t\t\t}\n\t\t\t} // generate indices\n\n\n\t\t\tfor (let j = 1; j <= radialSegments; j++) {\n\t\t\t\tfor (let i = 1; i <= tubularSegments; i++) {\n\t\t\t\t\t// indices\n\t\t\t\t\tconst a = (tubularSegments + 1) * j + i - 1;\n\t\t\t\t\tconst b = (tubularSegments + 1) * (j - 1) + i - 1;\n\t\t\t\t\tconst c = (tubularSegments + 1) * (j - 1) + i;\n\t\t\t\t\tconst d = (tubularSegments + 1) * j + i; // faces\n\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tclass TorusKnotGeometry extends BufferGeometry {\n\t\tconstructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {\n\t\t\tsuper();\n\t\t\tthis.type = 'TorusKnotGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tp: p,\n\t\t\t\tq: q\n\t\t\t};\n\t\t\ttubularSegments = Math.floor(tubularSegments);\n\t\t\tradialSegments = Math.floor(radialSegments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst normal = new Vector3();\n\t\t\tconst P1 = new Vector3();\n\t\t\tconst P2 = new Vector3();\n\t\t\tconst B = new Vector3();\n\t\t\tconst T = new Vector3();\n\t\t\tconst N = new Vector3(); // generate vertices, normals and uvs\n\n\t\t\tfor (let i = 0; i <= tubularSegments; ++i) {\n\t\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\t\t\t\tconst u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\t\tcalculatePositionOnCurve(u, p, q, radius, P1);\n\t\t\t\tcalculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis\n\n\t\t\t\tT.subVectors(P2, P1);\n\t\t\t\tN.addVectors(P2, P1);\n\t\t\t\tB.crossVectors(T, N);\n\t\t\t\tN.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it\n\n\t\t\t\tB.normalize();\n\t\t\t\tN.normalize();\n\n\t\t\t\tfor (let j = 0; j <= radialSegments; ++j) {\n\t\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\t\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\t\tconst cx = -tube * Math.cos(v);\n\t\t\t\t\tconst cy = tube * Math.sin(v); // now calculate the final vertex position.\n\t\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\t\t\tvertex.x = P1.x + (cx * N.x + cy * B.x);\n\t\t\t\t\tvertex.y = P1.y + (cx * N.y + cy * B.y);\n\t\t\t\t\tvertex.z = P1.z + (cx * N.z + cy * B.z);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\t\t\tnormal.subVectors(vertex, P1).normalize();\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // uv\n\n\t\t\t\t\tuvs.push(i / tubularSegments);\n\t\t\t\t\tuvs.push(j / radialSegments);\n\t\t\t\t}\n\t\t\t} // generate indices\n\n\n\t\t\tfor (let j = 1; j <= tubularSegments; j++) {\n\t\t\t\tfor (let i = 1; i <= radialSegments; i++) {\n\t\t\t\t\t// indices\n\t\t\t\t\tconst a = (radialSegments + 1) * (j - 1) + (i - 1);\n\t\t\t\t\tconst b = (radialSegments + 1) * j + (i - 1);\n\t\t\t\t\tconst c = (radialSegments + 1) * j + i;\n\t\t\t\t\tconst d = (radialSegments + 1) * (j - 1) + i; // faces\n\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve\n\n\t\t\tfunction calculatePositionOnCurve(u, p, q, radius, position) {\n\t\t\t\tconst cu = Math.cos(u);\n\t\t\t\tconst su = Math.sin(u);\n\t\t\t\tconst quOverP = q / p * u;\n\t\t\t\tconst cs = Math.cos(quOverP);\n\t\t\t\tposition.x = radius * (2 + cs) * 0.5 * cu;\n\t\t\t\tposition.y = radius * (2 + cs) * su * 0.5;\n\t\t\t\tposition.z = radius * Math.sin(quOverP) * 0.5;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass TubeGeometry extends BufferGeometry {\n\t\tconstructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {\n\t\t\tsuper();\n\t\t\tthis.type = 'TubeGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tpath: path,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradius: radius,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tclosed: closed\n\t\t\t};\n\t\t\tconst frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals\n\n\t\t\tthis.tangents = frames.tangents;\n\t\t\tthis.normals = frames.normals;\n\t\t\tthis.binormals = frames.binormals; // helper variables\n\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst normal = new Vector3();\n\t\t\tconst uv = new Vector2();\n\t\t\tlet P = new Vector3(); // buffer\n\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = [];\n\t\t\tconst indices = []; // create buffer data\n\n\t\t\tgenerateBufferData(); // build geometry\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions\n\n\t\t\tfunction generateBufferData() {\n\t\t\t\tfor (let i = 0; i < tubularSegments; i++) {\n\t\t\t\t\tgenerateSegment(i);\n\t\t\t\t} // if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t\t// at the regular position on the given path\n\t\t\t\t//\n\t\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\n\t\t\t\tgenerateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.\n\t\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\t\tgenerateUVs(); // finally create faces\n\n\t\t\t\tgenerateIndices();\n\t\t\t}\n\n\t\t\tfunction generateSegment(i) {\n\t\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\t\t\t\tP = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal\n\n\t\t\t\tconst N = frames.normals[i];\n\t\t\t\tconst B = frames.binormals[i]; // generate normals and vertices for the current segment\n\n\t\t\t\tfor (let j = 0; j <= radialSegments; j++) {\n\t\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\t\tconst sin = Math.sin(v);\n\t\t\t\t\tconst cos = -Math.cos(v); // normal\n\n\t\t\t\t\tnormal.x = cos * N.x + sin * B.x;\n\t\t\t\t\tnormal.y = cos * N.y + sin * B.y;\n\t\t\t\t\tnormal.z = cos * N.z + sin * B.z;\n\t\t\t\t\tnormal.normalize();\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // vertex\n\n\t\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\t\tvertex.z = P.z + radius * normal.z;\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction generateIndices() {\n\t\t\t\tfor (let j = 1; j <= tubularSegments; j++) {\n\t\t\t\t\tfor (let i = 1; i <= radialSegments; i++) {\n\t\t\t\t\t\tconst a = (radialSegments + 1) * (j - 1) + (i - 1);\n\t\t\t\t\t\tconst b = (radialSegments + 1) * j + (i - 1);\n\t\t\t\t\t\tconst c = (radialSegments + 1) * j + i;\n\t\t\t\t\t\tconst d = (radialSegments + 1) * (j - 1) + i; // faces\n\n\t\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction generateUVs() {\n\t\t\t\tfor (let i = 0; i <= tubularSegments; i++) {\n\t\t\t\t\tfor (let j = 0; j <= radialSegments; j++) {\n\t\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\t\tuv.y = j / radialSegments;\n\t\t\t\t\t\tuvs.push(uv.x, uv.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.path = this.parameters.path.toJSON();\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tclass WireframeGeometry extends BufferGeometry {\n\t\tconstructor(geometry) {\n\t\t\tsuper();\n\t\t\tthis.type = 'WireframeGeometry';\n\n\t\t\tif (geometry.isGeometry === true) {\n\t\t\t\tconsole.error('THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t\treturn;\n\t\t\t} // buffer\n\n\n\t\t\tconst vertices = []; // helper variables\n\n\t\t\tconst edge = [0, 0],\n\t\t\t\t\t\tedges = {};\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tif (geometry.index !== null) {\n\t\t\t\t// indexed BufferGeometry\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tconst indices = geometry.index;\n\t\t\t\tlet groups = geometry.groups;\n\n\t\t\t\tif (groups.length === 0) {\n\t\t\t\t\tgroups = [{\n\t\t\t\t\t\tstart: 0,\n\t\t\t\t\t\tcount: indices.count,\n\t\t\t\t\t\tmaterialIndex: 0\n\t\t\t\t\t}];\n\t\t\t\t} // create a data structure that contains all eges without duplicates\n\n\n\t\t\t\tfor (let o = 0, ol = groups.length; o < ol; ++o) {\n\t\t\t\t\tconst group = groups[o];\n\t\t\t\t\tconst start = group.start;\n\t\t\t\t\tconst count = group.count;\n\n\t\t\t\t\tfor (let i = start, l = start + count; i < l; i += 3) {\n\t\t\t\t\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t\t\t\t\tconst edge1 = indices.getX(i + j);\n\t\t\t\t\t\t\tconst edge2 = indices.getX(i + (j + 1) % 3);\n\t\t\t\t\t\t\tedge[0] = Math.min(edge1, edge2); // sorting prevents duplicates\n\n\t\t\t\t\t\t\tedge[1] = Math.max(edge1, edge2);\n\t\t\t\t\t\t\tconst key = edge[0] + ',' + edge[1];\n\n\t\t\t\t\t\t\tif (edges[key] === undefined) {\n\t\t\t\t\t\t\t\tedges[key] = {\n\t\t\t\t\t\t\t\t\tindex1: edge[0],\n\t\t\t\t\t\t\t\t\tindex2: edge[1]\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // generate vertices\n\n\n\t\t\t\tfor (const key in edges) {\n\t\t\t\t\tconst e = edges[key];\n\t\t\t\t\tvertex.fromBufferAttribute(position, e.index1);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\t\t\t\t\tvertex.fromBufferAttribute(position, e.index2);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// non-indexed BufferGeometry\n\t\t\t\tconst position = geometry.attributes.position;\n\n\t\t\t\tfor (let i = 0, l = position.count / 3; i < l; i++) {\n\t\t\t\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\t\t\t\t\t\tconst index1 = 3 * i + j;\n\t\t\t\t\t\tvertex.fromBufferAttribute(position, index1);\n\t\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\t\t\t\t\t\tconst index2 = 3 * i + (j + 1) % 3;\n\t\t\t\t\t\tvertex.fromBufferAttribute(position, index2);\n\t\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t}\n\n\t}\n\n\tvar Geometries = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tBoxGeometry: BoxGeometry,\n\t\tBoxBufferGeometry: BoxGeometry,\n\t\tCircleGeometry: CircleGeometry,\n\t\tCircleBufferGeometry: CircleGeometry,\n\t\tConeGeometry: ConeGeometry,\n\t\tConeBufferGeometry: ConeGeometry,\n\t\tCylinderGeometry: CylinderGeometry,\n\t\tCylinderBufferGeometry: CylinderGeometry,\n\t\tDodecahedronGeometry: DodecahedronGeometry,\n\t\tDodecahedronBufferGeometry: DodecahedronGeometry,\n\t\tEdgesGeometry: EdgesGeometry,\n\t\tExtrudeGeometry: ExtrudeGeometry,\n\t\tExtrudeBufferGeometry: ExtrudeGeometry,\n\t\tIcosahedronGeometry: IcosahedronGeometry,\n\t\tIcosahedronBufferGeometry: IcosahedronGeometry,\n\t\tLatheGeometry: LatheGeometry,\n\t\tLatheBufferGeometry: LatheGeometry,\n\t\tOctahedronGeometry: OctahedronGeometry,\n\t\tOctahedronBufferGeometry: OctahedronGeometry,\n\t\tParametricGeometry: ParametricGeometry,\n\t\tParametricBufferGeometry: ParametricGeometry,\n\t\tPlaneGeometry: PlaneGeometry,\n\t\tPlaneBufferGeometry: PlaneGeometry,\n\t\tPolyhedronGeometry: PolyhedronGeometry,\n\t\tPolyhedronBufferGeometry: PolyhedronGeometry,\n\t\tRingGeometry: RingGeometry,\n\t\tRingBufferGeometry: RingGeometry,\n\t\tShapeGeometry: ShapeGeometry,\n\t\tShapeBufferGeometry: ShapeGeometry,\n\t\tSphereGeometry: SphereGeometry,\n\t\tSphereBufferGeometry: SphereGeometry,\n\t\tTetrahedronGeometry: TetrahedronGeometry,\n\t\tTetrahedronBufferGeometry: TetrahedronGeometry,\n\t\tTextGeometry: TextGeometry,\n\t\tTextBufferGeometry: TextGeometry,\n\t\tTorusGeometry: TorusGeometry,\n\t\tTorusBufferGeometry: TorusGeometry,\n\t\tTorusKnotGeometry: TorusKnotGeometry,\n\t\tTorusKnotBufferGeometry: TorusKnotGeometry,\n\t\tTubeGeometry: TubeGeometry,\n\t\tTubeBufferGeometry: TubeGeometry,\n\t\tWireframeGeometry: WireframeGeometry\n\t});\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <THREE.Color>\n\t * }\n\t */\n\n\tclass ShadowMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ShadowMaterial';\n\t\t\tthis.color = new Color(0x000000);\n\t\t\tthis.transparent = true;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tShadowMaterial.prototype.isShadowMaterial = true;\n\n\tclass RawShaderMaterial extends ShaderMaterial {\n\t\tconstructor(parameters) {\n\t\t\tsuper(parameters);\n\t\t\tthis.type = 'RawShaderMaterial';\n\t\t}\n\n\t}\n\n\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\troughness: <float>,\n\t *\tmetalness: <float>,\n\t *\topacity: <float>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\tlightMap: new THREE.Texture( <Image> ),\n\t *\tlightMapIntensity: <float>\n\t *\n\t *\taoMap: new THREE.Texture( <Image> ),\n\t *\taoMapIntensity: <float>\n\t *\n\t *\temissive: <hex>,\n\t *\temissiveIntensity: <float>\n\t *\temissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tbumpMap: new THREE.Texture( <Image> ),\n\t *\tbumpScale: <float>,\n\t *\n\t *\tnormalMap: new THREE.Texture( <Image> ),\n\t *\tnormalMapType: THREE.TangentSpaceNormalMap,\n\t *\tnormalScale: <Vector2>,\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\troughnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tmetalnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tenvMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *\tenvMapIntensity: <float>\n\t *\n\t *\trefractionRatio: <float>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>,\n\t *\n\t *\tflatShading: <bool>\n\t * }\n\t */\n\n\tclass MeshStandardMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.defines = {\n\t\t\t\t'STANDARD': ''\n\t\t\t};\n\t\t\tthis.type = 'MeshStandardMaterial';\n\t\t\tthis.color = new Color(0xffffff); // diffuse\n\n\t\t\tthis.roughness = 1.0;\n\t\t\tthis.metalness = 0.0;\n\t\t\tthis.map = null;\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\t\tthis.emissive = new Color(0x000000);\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\t\tthis.normalScale = new Vector2(1, 1);\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.roughnessMap = null;\n\t\t\tthis.metalnessMap = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.envMap = null;\n\t\t\tthis.envMapIntensity = 1.0;\n\t\t\tthis.refractionRatio = 0.98;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.flatShading = false;\n\t\t\tthis.vertexTangents = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.defines = {\n\t\t\t\t'STANDARD': ''\n\t\t\t};\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.roughness = source.roughness;\n\t\t\tthis.metalness = source.metalness;\n\t\t\tthis.map = source.map;\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\t\tthis.emissive.copy(source.emissive);\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalMapType = source.normalMapType;\n\t\t\tthis.normalScale.copy(source.normalScale);\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.roughnessMap = source.roughnessMap;\n\t\t\tthis.metalnessMap = source.metalnessMap;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.envMapIntensity = source.envMapIntensity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\tthis.flatShading = source.flatShading;\n\t\t\tthis.vertexTangents = source.vertexTangents;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tclearcoat: <float>,\n\t *\tclearcoatMap: new THREE.Texture( <Image> ),\n\t *\tclearcoatRoughness: <float>,\n\t *\tclearcoatRoughnessMap: new THREE.Texture( <Image> ),\n\t *\tclearcoatNormalScale: <Vector2>,\n\t *\tclearcoatNormalMap: new THREE.Texture( <Image> ),\n\t *\n\t *\treflectivity: <float>,\n\t *\tior: <float>,\n\t *\n\t *\tsheen: <Color>,\n\t *\n\t *\ttransmission: <float>,\n\t *\ttransmissionMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tthickness: <float>,\n\t *\tthicknessMap: new THREE.Texture( <Image> ),\n\t *\tattenuationDistance: <float>,\n\t *\tattenuationColor: <Color>\n\t * }\n\t */\n\n\tclass MeshPhysicalMaterial extends MeshStandardMaterial {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.defines = {\n\t\t\t\t'STANDARD': '',\n\t\t\t\t'PHYSICAL': ''\n\t\t\t};\n\t\t\tthis.type = 'MeshPhysicalMaterial';\n\t\t\tthis.clearcoat = 0.0;\n\t\t\tthis.clearcoatMap = null;\n\t\t\tthis.clearcoatRoughness = 0.0;\n\t\t\tthis.clearcoatRoughnessMap = null;\n\t\t\tthis.clearcoatNormalScale = new Vector2(1, 1);\n\t\t\tthis.clearcoatNormalMap = null;\n\t\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\t\t\tObject.defineProperty(this, 'ior', {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);\n\t\t\t\t},\n\t\t\t\tset: function (ior) {\n\t\t\t\t\tthis.reflectivity = clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.sheen = null; // null will disable sheen bsdf\n\n\t\t\tthis.transmission = 0.0;\n\t\t\tthis.transmissionMap = null;\n\t\t\tthis.thickness = 0.01;\n\t\t\tthis.thicknessMap = null;\n\t\t\tthis.attenuationDistance = 0.0;\n\t\t\tthis.attenuationColor = new Color(1, 1, 1);\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.defines = {\n\t\t\t\t'STANDARD': '',\n\t\t\t\t'PHYSICAL': ''\n\t\t\t};\n\t\t\tthis.clearcoat = source.clearcoat;\n\t\t\tthis.clearcoatMap = source.clearcoatMap;\n\t\t\tthis.clearcoatRoughness = source.clearcoatRoughness;\n\t\t\tthis.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n\t\t\tthis.clearcoatNormalMap = source.clearcoatNormalMap;\n\t\t\tthis.clearcoatNormalScale.copy(source.clearcoatNormalScale);\n\t\t\tthis.reflectivity = source.reflectivity;\n\n\t\t\tif (source.sheen) {\n\t\t\t\tthis.sheen = (this.sheen || new Color()).copy(source.sheen);\n\t\t\t} else {\n\t\t\t\tthis.sheen = null;\n\t\t\t}\n\n\t\t\tthis.transmission = source.transmission;\n\t\t\tthis.transmissionMap = source.transmissionMap;\n\t\t\tthis.thickness = source.thickness;\n\t\t\tthis.thicknessMap = source.thicknessMap;\n\t\t\tthis.attenuationDistance = source.attenuationDistance;\n\t\t\tthis.attenuationColor.copy(source.attenuationColor);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\tspecular: <hex>,\n\t *\tshininess: <float>,\n\t *\topacity: <float>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\tlightMap: new THREE.Texture( <Image> ),\n\t *\tlightMapIntensity: <float>\n\t *\n\t *\taoMap: new THREE.Texture( <Image> ),\n\t *\taoMapIntensity: <float>\n\t *\n\t *\temissive: <hex>,\n\t *\temissiveIntensity: <float>\n\t *\temissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tbumpMap: new THREE.Texture( <Image> ),\n\t *\tbumpScale: <float>,\n\t *\n\t *\tnormalMap: new THREE.Texture( <Image> ),\n\t *\tnormalMapType: THREE.TangentSpaceNormalMap,\n\t *\tnormalScale: <Vector2>,\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\tspecularMap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tenvMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *\tcombine: THREE.MultiplyOperation,\n\t *\treflectivity: <float>,\n\t *\trefractionRatio: <float>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>,\n\t *\n\t *\tflatShading: <bool>\n\t * }\n\t */\n\n\tclass MeshPhongMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshPhongMaterial';\n\t\t\tthis.color = new Color(0xffffff); // diffuse\n\n\t\t\tthis.specular = new Color(0x111111);\n\t\t\tthis.shininess = 30;\n\t\t\tthis.map = null;\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\t\tthis.emissive = new Color(0x000000);\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\t\tthis.normalScale = new Vector2(1, 1);\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.specularMap = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.flatShading = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.specular.copy(source.specular);\n\t\t\tthis.shininess = source.shininess;\n\t\t\tthis.map = source.map;\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\t\tthis.emissive.copy(source.emissive);\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalMapType = source.normalMapType;\n\t\t\tthis.normalScale.copy(source.normalScale);\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.specularMap = source.specularMap;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\tthis.flatShading = source.flatShading;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\tgradientMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tlightMap: new THREE.Texture( <Image> ),\n\t *\tlightMapIntensity: <float>\n\t *\n\t *\taoMap: new THREE.Texture( <Image> ),\n\t *\taoMapIntensity: <float>\n\t *\n\t *\temissive: <hex>,\n\t *\temissiveIntensity: <float>\n\t *\temissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tbumpMap: new THREE.Texture( <Image> ),\n\t *\tbumpScale: <float>,\n\t *\n\t *\tnormalMap: new THREE.Texture( <Image> ),\n\t *\tnormalMapType: THREE.TangentSpaceNormalMap,\n\t *\tnormalScale: <Vector2>,\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>\n\t * }\n\t */\n\n\tclass MeshToonMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.defines = {\n\t\t\t\t'TOON': ''\n\t\t\t};\n\t\t\tthis.type = 'MeshToonMaterial';\n\t\t\tthis.color = new Color(0xffffff);\n\t\t\tthis.map = null;\n\t\t\tthis.gradientMap = null;\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\t\tthis.emissive = new Color(0x000000);\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\t\tthis.normalScale = new Vector2(1, 1);\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.map = source.map;\n\t\t\tthis.gradientMap = source.gradientMap;\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\t\tthis.emissive.copy(source.emissive);\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalMapType = source.normalMapType;\n\t\t\tthis.normalScale.copy(source.normalScale);\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshToonMaterial.prototype.isMeshToonMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\topacity: <float>,\n\t *\n\t *\tbumpMap: new THREE.Texture( <Image> ),\n\t *\tbumpScale: <float>,\n\t *\n\t *\tnormalMap: new THREE.Texture( <Image> ),\n\t *\tnormalMapType: THREE.TangentSpaceNormalMap,\n\t *\tnormalScale: <Vector2>,\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>,\n\t *\n\t *\tflatShading: <bool>\n\t * }\n\t */\n\n\tclass MeshNormalMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshNormalMaterial';\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\t\tthis.normalScale = new Vector2(1, 1);\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.fog = false;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.flatShading = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalMapType = source.normalMapType;\n\t\t\tthis.normalScale.copy(source.normalScale);\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\tthis.flatShading = source.flatShading;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\tlightMap: new THREE.Texture( <Image> ),\n\t *\tlightMapIntensity: <float>\n\t *\n\t *\taoMap: new THREE.Texture( <Image> ),\n\t *\taoMapIntensity: <float>\n\t *\n\t *\temissive: <hex>,\n\t *\temissiveIntensity: <float>\n\t *\temissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tspecularMap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tenvMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *\tcombine: THREE.Multiply,\n\t *\treflectivity: <float>,\n\t *\trefractionRatio: <float>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>\n\t * }\n\t */\n\n\tclass MeshLambertMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshLambertMaterial';\n\t\t\tthis.color = new Color(0xffffff); // diffuse\n\n\t\t\tthis.map = null;\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\t\tthis.emissive = new Color(0x000000);\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\t\tthis.specularMap = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.map = source.map;\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\t\tthis.emissive.copy(source.emissive);\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\t\tthis.specularMap = source.specularMap;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\n\t *\tmatcap: new THREE.Texture( <Image> ),\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\tbumpMap: new THREE.Texture( <Image> ),\n\t *\tbumpScale: <float>,\n\t *\n\t *\tnormalMap: new THREE.Texture( <Image> ),\n\t *\tnormalMapType: THREE.TangentSpaceNormalMap,\n\t *\tnormalScale: <Vector2>,\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>\n\t *\n\t *\tflatShading: <bool>\n\t * }\n\t */\n\n\tclass MeshMatcapMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.defines = {\n\t\t\t\t'MATCAP': ''\n\t\t\t};\n\t\t\tthis.type = 'MeshMatcapMaterial';\n\t\t\tthis.color = new Color(0xffffff); // diffuse\n\n\t\t\tthis.matcap = null;\n\t\t\tthis.map = null;\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\t\tthis.normalScale = new Vector2(1, 1);\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.flatShading = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.defines = {\n\t\t\t\t'MATCAP': ''\n\t\t\t};\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.matcap = source.matcap;\n\t\t\tthis.map = source.map;\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalMapType = source.normalMapType;\n\t\t\tthis.normalScale.copy(source.normalScale);\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\tthis.flatShading = source.flatShading;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\n\t *\tlinewidth: <float>,\n\t *\n\t *\tscale: <float>,\n\t *\tdashSize: <float>,\n\t *\tgapSize: <float>\n\t * }\n\t */\n\n\tclass LineDashedMaterial extends LineBasicMaterial {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'LineDashedMaterial';\n\t\t\tthis.scale = 1;\n\t\t\tthis.dashSize = 3;\n\t\t\tthis.gapSize = 1;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.scale = source.scale;\n\t\t\tthis.dashSize = source.dashSize;\n\t\t\tthis.gapSize = source.gapSize;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\n\tvar Materials = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tShadowMaterial: ShadowMaterial,\n\t\tSpriteMaterial: SpriteMaterial,\n\t\tRawShaderMaterial: RawShaderMaterial,\n\t\tShaderMaterial: ShaderMaterial,\n\t\tPointsMaterial: PointsMaterial,\n\t\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\t\tMeshStandardMaterial: MeshStandardMaterial,\n\t\tMeshPhongMaterial: MeshPhongMaterial,\n\t\tMeshToonMaterial: MeshToonMaterial,\n\t\tMeshNormalMaterial: MeshNormalMaterial,\n\t\tMeshLambertMaterial: MeshLambertMaterial,\n\t\tMeshDepthMaterial: MeshDepthMaterial,\n\t\tMeshDistanceMaterial: MeshDistanceMaterial,\n\t\tMeshBasicMaterial: MeshBasicMaterial,\n\t\tMeshMatcapMaterial: MeshMatcapMaterial,\n\t\tLineDashedMaterial: LineDashedMaterial,\n\t\tLineBasicMaterial: LineBasicMaterial,\n\t\tMaterial: Material\n\t});\n\n\tconst AnimationUtils = {\n\t\t// same as Array.prototype.slice, but also works on typed arrays\n\t\tarraySlice: function (array, from, to) {\n\t\t\tif (AnimationUtils.isTypedArray(array)) {\n\t\t\t\t// in ios9 array.subarray(from, undefined) will return empty array\n\t\t\t\t// but array.subarray(from) or array.subarray(from, len) is correct\n\t\t\t\treturn new array.constructor(array.subarray(from, to !== undefined ? to : array.length));\n\t\t\t}\n\n\t\t\treturn array.slice(from, to);\n\t\t},\n\t\t// converts an array to a specific type\n\t\tconvertArray: function (array, type, forceClone) {\n\t\t\tif (!array || // let 'undefined' and 'null' pass\n\t\t\t!forceClone && array.constructor === type) return array;\n\n\t\t\tif (typeof type.BYTES_PER_ELEMENT === 'number') {\n\t\t\t\treturn new type(array); // create typed array\n\t\t\t}\n\n\t\t\treturn Array.prototype.slice.call(array); // create Array\n\t\t},\n\t\tisTypedArray: function (object) {\n\t\t\treturn ArrayBuffer.isView(object) && !(object instanceof DataView);\n\t\t},\n\t\t// returns an array by which times and values can be sorted\n\t\tgetKeyframeOrder: function (times) {\n\t\t\tfunction compareTime(i, j) {\n\t\t\t\treturn times[i] - times[j];\n\t\t\t}\n\n\t\t\tconst n = times.length;\n\t\t\tconst result = new Array(n);\n\n\t\t\tfor (let i = 0; i !== n; ++i) result[i] = i;\n\n\t\t\tresult.sort(compareTime);\n\t\t\treturn result;\n\t\t},\n\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\t\tsortedArray: function (values, stride, order) {\n\t\t\tconst nValues = values.length;\n\t\t\tconst result = new values.constructor(nValues);\n\n\t\t\tfor (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {\n\t\t\t\tconst srcOffset = order[i] * stride;\n\n\t\t\t\tfor (let j = 0; j !== stride; ++j) {\n\t\t\t\t\tresult[dstOffset++] = values[srcOffset + j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\t\t// function for parsing AOS keyframe formats\n\t\tflattenJSON: function (jsonKeys, times, values, valuePropertyName) {\n\t\t\tlet i = 1,\n\t\t\t\t\tkey = jsonKeys[0];\n\n\t\t\twhile (key !== undefined && key[valuePropertyName] === undefined) {\n\t\t\t\tkey = jsonKeys[i++];\n\t\t\t}\n\n\t\t\tif (key === undefined) return; // no data\n\n\t\t\tlet value = key[valuePropertyName];\n\t\t\tif (value === undefined) return; // no data\n\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tdo {\n\t\t\t\t\tvalue = key[valuePropertyName];\n\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\ttimes.push(key.time);\n\t\t\t\t\t\tvalues.push.apply(values, value); // push all elements\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[i++];\n\t\t\t\t} while (key !== undefined);\n\t\t\t} else if (value.toArray !== undefined) {\n\t\t\t\t// ...assume THREE.Math-ish\n\t\t\t\tdo {\n\t\t\t\t\tvalue = key[valuePropertyName];\n\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\ttimes.push(key.time);\n\t\t\t\t\t\tvalue.toArray(values, values.length);\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[i++];\n\t\t\t\t} while (key !== undefined);\n\t\t\t} else {\n\t\t\t\t// otherwise push as-is\n\t\t\t\tdo {\n\t\t\t\t\tvalue = key[valuePropertyName];\n\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\ttimes.push(key.time);\n\t\t\t\t\t\tvalues.push(value);\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[i++];\n\t\t\t\t} while (key !== undefined);\n\t\t\t}\n\t\t},\n\t\tsubclip: function (sourceClip, name, startFrame, endFrame, fps = 30) {\n\t\t\tconst clip = sourceClip.clone();\n\t\t\tclip.name = name;\n\t\t\tconst tracks = [];\n\n\t\t\tfor (let i = 0; i < clip.tracks.length; ++i) {\n\t\t\t\tconst track = clip.tracks[i];\n\t\t\t\tconst valueSize = track.getValueSize();\n\t\t\t\tconst times = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tfor (let j = 0; j < track.times.length; ++j) {\n\t\t\t\t\tconst frame = track.times[j] * fps;\n\t\t\t\t\tif (frame < startFrame || frame >= endFrame) continue;\n\t\t\t\t\ttimes.push(track.times[j]);\n\n\t\t\t\t\tfor (let k = 0; k < valueSize; ++k) {\n\t\t\t\t\t\tvalues.push(track.values[j * valueSize + k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (times.length === 0) continue;\n\t\t\t\ttrack.times = AnimationUtils.convertArray(times, track.times.constructor);\n\t\t\t\ttrack.values = AnimationUtils.convertArray(values, track.values.constructor);\n\t\t\t\ttracks.push(track);\n\t\t\t}\n\n\t\t\tclip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip\n\n\t\t\tlet minStartTime = Infinity;\n\n\t\t\tfor (let i = 0; i < clip.tracks.length; ++i) {\n\t\t\t\tif (minStartTime > clip.tracks[i].times[0]) {\n\t\t\t\t\tminStartTime = clip.tracks[i].times[0];\n\t\t\t\t}\n\t\t\t} // shift all tracks such that clip begins at t=0\n\n\n\t\t\tfor (let i = 0; i < clip.tracks.length; ++i) {\n\t\t\t\tclip.tracks[i].shift(-1 * minStartTime);\n\t\t\t}\n\n\t\t\tclip.resetDuration();\n\t\t\treturn clip;\n\t\t},\n\t\tmakeClipAdditive: function (targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {\n\t\t\tif (fps <= 0) fps = 30;\n\t\t\tconst numTracks = referenceClip.tracks.length;\n\t\t\tconst referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame\n\n\t\t\tfor (let i = 0; i < numTracks; ++i) {\n\t\t\t\tconst referenceTrack = referenceClip.tracks[i];\n\t\t\t\tconst referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric\n\n\t\t\t\tif (referenceTrackType === 'bool' || referenceTrackType === 'string') continue; // Find the track in the target clip whose name and type matches the reference track\n\n\t\t\t\tconst targetTrack = targetClip.tracks.find(function (track) {\n\t\t\t\t\treturn track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;\n\t\t\t\t});\n\t\t\t\tif (targetTrack === undefined) continue;\n\t\t\t\tlet referenceOffset = 0;\n\t\t\t\tconst referenceValueSize = referenceTrack.getValueSize();\n\n\t\t\t\tif (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n\t\t\t\t\treferenceOffset = referenceValueSize / 3;\n\t\t\t\t}\n\n\t\t\t\tlet targetOffset = 0;\n\t\t\t\tconst targetValueSize = targetTrack.getValueSize();\n\n\t\t\t\tif (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n\t\t\t\t\ttargetOffset = targetValueSize / 3;\n\t\t\t\t}\n\n\t\t\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\t\t\tlet referenceValue; // Find the value to subtract out of the track\n\n\t\t\t\tif (referenceTime <= referenceTrack.times[0]) {\n\t\t\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\t\t\tconst startIndex = referenceOffset;\n\t\t\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\t\t\treferenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);\n\t\t\t\t} else if (referenceTime >= referenceTrack.times[lastIndex]) {\n\t\t\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\n\t\t\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\n\t\t\t\t\treferenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);\n\t\t\t\t} else {\n\t\t\t\t\t// Interpolate to the reference value\n\t\t\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\t\t\tconst startIndex = referenceOffset;\n\t\t\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\t\t\tinterpolant.evaluate(referenceTime);\n\t\t\t\t\treferenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);\n\t\t\t\t} // Conjugate the quaternion\n\n\n\t\t\t\tif (referenceTrackType === 'quaternion') {\n\t\t\t\t\tconst referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();\n\t\t\t\t\treferenceQuat.toArray(referenceValue);\n\t\t\t\t} // Subtract the reference value from all of the track values\n\n\n\t\t\t\tconst numTimes = targetTrack.times.length;\n\n\t\t\t\tfor (let j = 0; j < numTimes; ++j) {\n\t\t\t\t\tconst valueStart = j * targetValueSize + targetOffset;\n\n\t\t\t\t\tif (referenceTrackType === 'quaternion') {\n\t\t\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\t\t\tQuaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types\n\n\t\t\t\t\t\tfor (let k = 0; k < valueEnd; ++k) {\n\t\t\t\t\t\t\ttargetTrack.values[valueStart + k] -= referenceValue[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\t\t\treturn targetClip;\n\t\t}\n\t};\n\n\t/**\n\t * Abstract base class of interpolants over parametric samples.\n\t *\n\t * The parameter domain is one dimensional, typically the time or a path\n\t * along a curve defined by the data.\n\t *\n\t * The sample values can have any dimensionality and derived classes may\n\t * apply special interpretations to the data.\n\t *\n\t * This class provides the interval seek in a Template Method, deferring\n\t * the actual interpolation to derived classes.\n\t *\n\t * Time complexity is O(1) for linear access crossing at most two points\n\t * and O(log N) for random access, where N is the number of positions.\n\t *\n\t * References:\n\t *\n\t * \t\thttp://www.oodesign.com/template-method-pattern.html\n\t *\n\t */\n\tclass Interpolant {\n\t\tconstructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\t\t\tthis.parameterPositions = parameterPositions;\n\t\t\tthis._cachedIndex = 0;\n\t\t\tthis.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);\n\t\t\tthis.sampleValues = sampleValues;\n\t\t\tthis.valueSize = sampleSize;\n\t\t\tthis.settings = null;\n\t\t\tthis.DefaultSettings_ = {};\n\t\t}\n\n\t\tevaluate(t) {\n\t\t\tconst pp = this.parameterPositions;\n\t\t\tlet i1 = this._cachedIndex,\n\t\t\t\t\tt1 = pp[i1],\n\t\t\t\t\tt0 = pp[i1 - 1];\n\n\t\t\tvalidate_interval: {\n\t\t\t\tseek: {\n\t\t\t\t\tlet right;\n\n\t\t\t\t\tlinear_scan: {\n\t\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t\t//- slower code:\n\t\t\t\t\t\t//-\n\t\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\t\tforward_scan: if (!(t < t1)) {\n\t\t\t\t\t\t\tfor (let giveUpAt = i1 + 2;;) {\n\t\t\t\t\t\t\t\tif (t1 === undefined) {\n\t\t\t\t\t\t\t\t\tif (t < t0) break forward_scan; // after end\n\n\t\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\t\treturn this.afterEnd_(i1 - 1, t, t0);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (i1 === giveUpAt) break; // this loop\n\n\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\tt1 = pp[++i1];\n\n\t\t\t\t\t\t\t\tif (t < t1) {\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} // prepare binary search on the right side of the index\n\n\n\t\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\t\tbreak linear_scan;\n\t\t\t\t\t\t} //- slower code:\n\t\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\n\n\t\t\t\t\t\tif (!(t >= t0)) {\n\t\t\t\t\t\t\t// looping?\n\t\t\t\t\t\t\tconst t1global = pp[1];\n\n\t\t\t\t\t\t\tif (t < t1global) {\n\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\n\t\t\t\t\t\t\t\tt0 = t1global;\n\t\t\t\t\t\t\t} // linear reverse scan\n\n\n\t\t\t\t\t\t\tfor (let giveUpAt = i1 - 2;;) {\n\t\t\t\t\t\t\t\tif (t0 === undefined) {\n\t\t\t\t\t\t\t\t\t// before start\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\t\treturn this.beforeStart_(0, t, t1);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (i1 === giveUpAt) break; // this loop\n\n\t\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\t\tt0 = pp[--i1 - 1];\n\n\t\t\t\t\t\t\t\tif (t >= t0) {\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} // prepare binary search on the left side of the index\n\n\n\t\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\t\tbreak linear_scan;\n\t\t\t\t\t\t} // the interval is valid\n\n\n\t\t\t\t\t\tbreak validate_interval;\n\t\t\t\t\t} // linear scan\n\t\t\t\t\t// binary search\n\n\n\t\t\t\t\twhile (i1 < right) {\n\t\t\t\t\t\tconst mid = i1 + right >>> 1;\n\n\t\t\t\t\t\tif (t < pp[mid]) {\n\t\t\t\t\t\t\tright = mid;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ti1 = mid + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tt1 = pp[i1];\n\t\t\t\t\tt0 = pp[i1 - 1]; // check boundary cases, again\n\n\t\t\t\t\tif (t0 === undefined) {\n\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\treturn this.beforeStart_(0, t, t1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (t1 === undefined) {\n\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\treturn this.afterEnd_(i1 - 1, t0, t);\n\t\t\t\t\t}\n\t\t\t\t} // seek\n\n\n\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\tthis.intervalChanged_(i1, t0, t1);\n\t\t\t} // validate_interval\n\n\n\t\t\treturn this.interpolate_(i1, t0, t, t1);\n\t\t}\n\n\t\tgetSettings_() {\n\t\t\treturn this.settings || this.DefaultSettings_;\n\t\t}\n\n\t\tcopySampleValue_(index) {\n\t\t\t// copies a sample value to the result buffer\n\t\t\tconst result = this.resultBuffer,\n\t\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\toffset = index * stride;\n\n\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\tresult[i] = values[offset + i];\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} // Template methods for derived classes:\n\n\n\t\tinterpolate_()\n\t\t/* i1, t0, t, t1 */\n\t\t{\n\t\t\tthrow new Error('call to abstract method'); // implementations shall return this.resultBuffer\n\t\t}\n\n\t\tintervalChanged_()\n\t\t/* i1, t0, t1 */\n\t\t{// empty\n\t\t}\n\n\t} // ALIAS DEFINITIONS\n\n\n\tInterpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;\n\tInterpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;\n\n\t/**\n\t * Fast and simple cubic spline interpolant.\n\t *\n\t * It was derived from a Hermitian construction setting the first derivative\n\t * at each sample position to the linear slope between neighboring positions\n\t * over their parameter interval.\n\t */\n\n\tclass CubicInterpolant extends Interpolant {\n\t\tconstructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\t\t\tsuper(parameterPositions, sampleValues, sampleSize, resultBuffer);\n\t\t\tthis._weightPrev = -0;\n\t\t\tthis._offsetPrev = -0;\n\t\t\tthis._weightNext = -0;\n\t\t\tthis._offsetNext = -0;\n\t\t\tthis.DefaultSettings_ = {\n\t\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t\t};\n\t\t}\n\n\t\tintervalChanged_(i1, t0, t1) {\n\t\t\tconst pp = this.parameterPositions;\n\t\t\tlet iPrev = i1 - 2,\n\t\t\t\t\tiNext = i1 + 1,\n\t\t\t\t\ttPrev = pp[iPrev],\n\t\t\t\t\ttNext = pp[iNext];\n\n\t\t\tif (tPrev === undefined) {\n\t\t\t\tswitch (this.getSettings_().endingStart) {\n\t\t\t\t\tcase ZeroSlopeEnding:\n\t\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = 2 * t0 - t1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\t\ttPrev = t0 + pp[iPrev] - pp[iPrev + 1];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// ZeroCurvatureEnding\n\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = t1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tNext === undefined) {\n\t\t\t\tswitch (this.getSettings_().endingEnd) {\n\t\t\t\t\tcase ZeroSlopeEnding:\n\t\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\t\tiNext = i1;\n\t\t\t\t\t\ttNext = 2 * t1 - t0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiNext = 1;\n\t\t\t\t\t\ttNext = t1 + pp[1] - pp[0];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// ZeroCurvatureEnding\n\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\t\ttNext = t0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst halfDt = (t1 - t0) * 0.5,\n\t\t\t\t\t\tstride = this.valueSize;\n\t\t\tthis._weightPrev = halfDt / (t0 - tPrev);\n\t\t\tthis._weightNext = halfDt / (tNext - t1);\n\t\t\tthis._offsetPrev = iPrev * stride;\n\t\t\tthis._offsetNext = iNext * stride;\n\t\t}\n\n\t\tinterpolate_(i1, t0, t, t1) {\n\t\t\tconst result = this.resultBuffer,\n\t\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\to1 = i1 * stride,\n\t\t\t\t\t\to0 = o1 - stride,\n\t\t\t\t\t\toP = this._offsetPrev,\n\t\t\t\t\t\toN = this._offsetNext,\n\t\t\t\t\t\twP = this._weightPrev,\n\t\t\t\t\t\twN = this._weightNext,\n\t\t\t\t\t\tp = (t - t0) / (t1 - t0),\n\t\t\t\t\t\tpp = p * p,\n\t\t\t\t\t\tppp = pp * p; // evaluate polynomials\n\n\t\t\tconst sP = -wP * ppp + 2 * wP * pp - wP * p;\n\t\t\tconst s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\n\t\t\tconst s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\n\t\t\tconst sN = wN * ppp - wN * pp; // combine data linearly\n\n\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\tresult[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t}\n\n\tclass LinearInterpolant extends Interpolant {\n\t\tconstructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\t\t\tsuper(parameterPositions, sampleValues, sampleSize, resultBuffer);\n\t\t}\n\n\t\tinterpolate_(i1, t0, t, t1) {\n\t\t\tconst result = this.resultBuffer,\n\t\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\toffset1 = i1 * stride,\n\t\t\t\t\t\toffset0 = offset1 - stride,\n\t\t\t\t\t\tweight1 = (t - t0) / (t1 - t0),\n\t\t\t\t\t\tweight0 = 1 - weight1;\n\n\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\tresult[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t}\n\n\t/**\n\t *\n\t * Interpolant that evaluates to the sample value at the position preceeding\n\t * the parameter.\n\t */\n\n\tclass DiscreteInterpolant extends Interpolant {\n\t\tconstructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\t\t\tsuper(parameterPositions, sampleValues, sampleSize, resultBuffer);\n\t\t}\n\n\t\tinterpolate_(i1\n\t\t/*, t0, t, t1 */\n\t\t) {\n\t\t\treturn this.copySampleValue_(i1 - 1);\n\t\t}\n\n\t}\n\n\tclass KeyframeTrack {\n\t\tconstructor(name, times, values, interpolation) {\n\t\t\tif (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');\n\t\t\tif (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);\n\t\t\tthis.name = name;\n\t\t\tthis.times = AnimationUtils.convertArray(times, this.TimeBufferType);\n\t\t\tthis.values = AnimationUtils.convertArray(values, this.ValueBufferType);\n\t\t\tthis.setInterpolation(interpolation || this.DefaultInterpolation);\n\t\t} // Serialization (in static context, because of constructor invocation\n\t\t// and automatic invocation of .toJSON):\n\n\n\t\tstatic toJSON(track) {\n\t\t\tconst trackType = track.constructor;\n\t\t\tlet json; // derived classes can define a static toJSON method\n\n\t\t\tif (trackType.toJSON !== this.toJSON) {\n\t\t\t\tjson = trackType.toJSON(track);\n\t\t\t} else {\n\t\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\t\tjson = {\n\t\t\t\t\t'name': track.name,\n\t\t\t\t\t'times': AnimationUtils.convertArray(track.times, Array),\n\t\t\t\t\t'values': AnimationUtils.convertArray(track.values, Array)\n\t\t\t\t};\n\t\t\t\tconst interpolation = track.getInterpolation();\n\n\t\t\t\tif (interpolation !== track.DefaultInterpolation) {\n\t\t\t\t\tjson.interpolation = interpolation;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\t\treturn json;\n\t\t}\n\n\t\tInterpolantFactoryMethodDiscrete(result) {\n\t\t\treturn new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);\n\t\t}\n\n\t\tInterpolantFactoryMethodLinear(result) {\n\t\t\treturn new LinearInterpolant(this.times, this.values, this.getValueSize(), result);\n\t\t}\n\n\t\tInterpolantFactoryMethodSmooth(result) {\n\t\t\treturn new CubicInterpolant(this.times, this.values, this.getValueSize(), result);\n\t\t}\n\n\t\tsetInterpolation(interpolation) {\n\t\t\tlet factoryMethod;\n\n\t\t\tswitch (interpolation) {\n\t\t\t\tcase InterpolateDiscrete:\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateLinear:\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateSmooth:\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (factoryMethod === undefined) {\n\t\t\t\tconst message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;\n\n\t\t\t\tif (this.createInterpolant === undefined) {\n\t\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\t\tif (interpolation !== this.DefaultInterpolation) {\n\t\t\t\t\t\tthis.setInterpolation(this.DefaultInterpolation);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(message); // fatal, in this case\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconsole.warn('THREE.KeyframeTrack:', message);\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tthis.createInterpolant = factoryMethod;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetInterpolation() {\n\t\t\tswitch (this.createInterpolant) {\n\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\t\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\t\tcase this.InterpolantFactoryMethodLinear:\n\t\t\t\t\treturn InterpolateLinear;\n\n\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\t\t\t\t\treturn InterpolateSmooth;\n\t\t\t}\n\t\t}\n\n\t\tgetValueSize() {\n\t\t\treturn this.values.length / this.times.length;\n\t\t} // move all keyframes either forwards or backwards in time\n\n\n\t\tshift(timeOffset) {\n\t\t\tif (timeOffset !== 0.0) {\n\t\t\t\tconst times = this.times;\n\n\t\t\t\tfor (let i = 0, n = times.length; i !== n; ++i) {\n\t\t\t\t\ttimes[i] += timeOffset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\n\n\t\tscale(timeScale) {\n\t\t\tif (timeScale !== 1.0) {\n\t\t\t\tconst times = this.times;\n\n\t\t\t\tfor (let i = 0, n = times.length; i !== n; ++i) {\n\t\t\t\t\ttimes[i] *= timeScale;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\n\n\t\ttrim(startTime, endTime) {\n\t\t\tconst times = this.times,\n\t\t\t\t\t\tnKeys = times.length;\n\t\t\tlet from = 0,\n\t\t\t\t\tto = nKeys - 1;\n\n\t\t\twhile (from !== nKeys && times[from] < startTime) {\n\t\t\t\t++from;\n\t\t\t}\n\n\t\t\twhile (to !== -1 && times[to] > endTime) {\n\t\t\t\t--to;\n\t\t\t}\n\n\t\t\t++to; // inclusive -> exclusive bound\n\n\t\t\tif (from !== 0 || to !== nKeys) {\n\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\t\tif (from >= to) {\n\t\t\t\t\tto = Math.max(to, 1);\n\t\t\t\t\tfrom = to - 1;\n\t\t\t\t}\n\n\t\t\t\tconst stride = this.getValueSize();\n\t\t\t\tthis.times = AnimationUtils.arraySlice(times, from, to);\n\t\t\t\tthis.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\n\n\t\tvalidate() {\n\t\t\tlet valid = true;\n\t\t\tconst valueSize = this.getValueSize();\n\n\t\t\tif (valueSize - Math.floor(valueSize) !== 0) {\n\t\t\t\tconsole.error('THREE.KeyframeTrack: Invalid value size in track.', this);\n\t\t\t\tvalid = false;\n\t\t\t}\n\n\t\t\tconst times = this.times,\n\t\t\t\t\t\tvalues = this.values,\n\t\t\t\t\t\tnKeys = times.length;\n\n\t\t\tif (nKeys === 0) {\n\t\t\t\tconsole.error('THREE.KeyframeTrack: Track is empty.', this);\n\t\t\t\tvalid = false;\n\t\t\t}\n\n\t\t\tlet prevTime = null;\n\n\t\t\tfor (let i = 0; i !== nKeys; i++) {\n\t\t\t\tconst currTime = times[i];\n\n\t\t\t\tif (typeof currTime === 'number' && isNaN(currTime)) {\n\t\t\t\t\tconsole.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (prevTime !== null && prevTime > currTime) {\n\t\t\t\t\tconsole.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tprevTime = currTime;\n\t\t\t}\n\n\t\t\tif (values !== undefined) {\n\t\t\t\tif (AnimationUtils.isTypedArray(values)) {\n\t\t\t\t\tfor (let i = 0, n = values.length; i !== n; ++i) {\n\t\t\t\t\t\tconst value = values[i];\n\n\t\t\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\t\t\tconsole.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);\n\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn valid;\n\t\t} // removes equivalent sequential keys as common in morph target sequences\n\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\n\n\t\toptimize() {\n\t\t\t// times or values may be shared with other tracks, so overwriting is unsafe\n\t\t\tconst times = AnimationUtils.arraySlice(this.times),\n\t\t\t\t\t\tvalues = AnimationUtils.arraySlice(this.values),\n\t\t\t\t\t\tstride = this.getValueSize(),\n\t\t\t\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\t\t\t\t\t\tlastIndex = times.length - 1;\n\t\t\tlet writeIndex = 1;\n\n\t\t\tfor (let i = 1; i < lastIndex; ++i) {\n\t\t\t\tlet keep = false;\n\t\t\t\tconst time = times[i];\n\t\t\t\tconst timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time\n\n\t\t\t\tif (time !== timeNext && (i !== 1 || time !== times[0])) {\n\t\t\t\t\tif (!smoothInterpolation) {\n\t\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\t\t\t\t\t\tconst offset = i * stride,\n\t\t\t\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\t\tfor (let j = 0; j !== stride; ++j) {\n\t\t\t\t\t\t\tconst value = values[offset + j];\n\n\t\t\t\t\t\t\tif (value !== values[offsetP + j] || value !== values[offsetN + j]) {\n\t\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t}\n\t\t\t\t} // in-place compaction\n\n\n\t\t\t\tif (keep) {\n\t\t\t\t\tif (i !== writeIndex) {\n\t\t\t\t\t\ttimes[writeIndex] = times[i];\n\t\t\t\t\t\tconst readOffset = i * stride,\n\t\t\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\t\tfor (let j = 0; j !== stride; ++j) {\n\t\t\t\t\t\t\tvalues[writeOffset + j] = values[readOffset + j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t++writeIndex;\n\t\t\t\t}\n\t\t\t} // flush last keyframe (compaction looks ahead)\n\n\n\t\t\tif (lastIndex > 0) {\n\t\t\t\ttimes[writeIndex] = times[lastIndex];\n\n\t\t\t\tfor (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {\n\t\t\t\t\tvalues[writeOffset + j] = values[readOffset + j];\n\t\t\t\t}\n\n\t\t\t\t++writeIndex;\n\t\t\t}\n\n\t\t\tif (writeIndex !== times.length) {\n\t\t\t\tthis.times = AnimationUtils.arraySlice(times, 0, writeIndex);\n\t\t\t\tthis.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);\n\t\t\t} else {\n\t\t\t\tthis.times = times;\n\t\t\t\tthis.values = values;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\tconst times = AnimationUtils.arraySlice(this.times, 0);\n\t\t\tconst values = AnimationUtils.arraySlice(this.values, 0);\n\t\t\tconst TypedKeyframeTrack = this.constructor;\n\t\t\tconst track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.\n\n\t\t\ttrack.createInterpolant = this.createInterpolant;\n\t\t\treturn track;\n\t\t}\n\n\t}\n\n\tKeyframeTrack.prototype.TimeBufferType = Float32Array;\n\tKeyframeTrack.prototype.ValueBufferType = Float32Array;\n\tKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\n\t/**\n\t * A Track of Boolean keyframe values.\n\t */\n\n\tclass BooleanKeyframeTrack extends KeyframeTrack {}\n\n\tBooleanKeyframeTrack.prototype.ValueTypeName = 'bool';\n\tBooleanKeyframeTrack.prototype.ValueBufferType = Array;\n\tBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\n\tBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\n\tBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined; // Note: Actually this track could have a optimized / compressed\n\n\t/**\n\t * A Track of keyframe values that represent color.\n\t */\n\n\tclass ColorKeyframeTrack extends KeyframeTrack {}\n\n\tColorKeyframeTrack.prototype.ValueTypeName = 'color'; // ValueBufferType is inherited\n\n\t/**\n\t * A Track of numeric keyframe values.\n\t */\n\n\tclass NumberKeyframeTrack extends KeyframeTrack {}\n\n\tNumberKeyframeTrack.prototype.ValueTypeName = 'number'; // ValueBufferType is inherited\n\n\t/**\n\t * Spherical linear unit quaternion interpolant.\n\t */\n\n\tclass QuaternionLinearInterpolant extends Interpolant {\n\t\tconstructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\t\t\tsuper(parameterPositions, sampleValues, sampleSize, resultBuffer);\n\t\t}\n\n\t\tinterpolate_(i1, t0, t, t1) {\n\t\t\tconst result = this.resultBuffer,\n\t\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\talpha = (t - t0) / (t1 - t0);\n\t\t\tlet offset = i1 * stride;\n\n\t\t\tfor (let end = offset + stride; offset !== end; offset += 4) {\n\t\t\t\tQuaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t}\n\n\t/**\n\t * A Track of quaternion keyframe values.\n\t */\n\n\tclass QuaternionKeyframeTrack extends KeyframeTrack {\n\t\tInterpolantFactoryMethodLinear(result) {\n\t\t\treturn new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);\n\t\t}\n\n\t}\n\n\tQuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion'; // ValueBufferType is inherited\n\n\tQuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\tQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n\t/**\n\t * A Track that interpolates Strings\n\t */\n\n\tclass StringKeyframeTrack extends KeyframeTrack {}\n\n\tStringKeyframeTrack.prototype.ValueTypeName = 'string';\n\tStringKeyframeTrack.prototype.ValueBufferType = Array;\n\tStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\n\tStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\n\tStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n\t/**\n\t * A Track of vectored keyframe values.\n\t */\n\n\tclass VectorKeyframeTrack extends KeyframeTrack {}\n\n\tVectorKeyframeTrack.prototype.ValueTypeName = 'vector'; // ValueBufferType is inherited\n\n\tclass AnimationClip {\n\t\tconstructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {\n\t\t\tthis.name = name;\n\t\t\tthis.tracks = tracks;\n\t\t\tthis.duration = duration;\n\t\t\tthis.blendMode = blendMode;\n\t\t\tthis.uuid = generateUUID(); // this means it should figure out its duration by scanning the tracks\n\n\t\t\tif (this.duration < 0) {\n\t\t\t\tthis.resetDuration();\n\t\t\t}\n\t\t}\n\n\t\tstatic parse(json) {\n\t\t\tconst tracks = [],\n\t\t\t\t\t\tjsonTracks = json.tracks,\n\t\t\t\t\t\tframeTime = 1.0 / (json.fps || 1.0);\n\n\t\t\tfor (let i = 0, n = jsonTracks.length; i !== n; ++i) {\n\t\t\t\ttracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));\n\t\t\t}\n\n\t\t\tconst clip = new this(json.name, json.duration, tracks, json.blendMode);\n\t\t\tclip.uuid = json.uuid;\n\t\t\treturn clip;\n\t\t}\n\n\t\tstatic toJSON(clip) {\n\t\t\tconst tracks = [],\n\t\t\t\t\t\tclipTracks = clip.tracks;\n\t\t\tconst json = {\n\t\t\t\t'name': clip.name,\n\t\t\t\t'duration': clip.duration,\n\t\t\t\t'tracks': tracks,\n\t\t\t\t'uuid': clip.uuid,\n\t\t\t\t'blendMode': clip.blendMode\n\t\t\t};\n\n\t\t\tfor (let i = 0, n = clipTracks.length; i !== n; ++i) {\n\t\t\t\ttracks.push(KeyframeTrack.toJSON(clipTracks[i]));\n\t\t\t}\n\n\t\t\treturn json;\n\t\t}\n\n\t\tstatic CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {\n\t\t\tconst numMorphTargets = morphTargetSequence.length;\n\t\t\tconst tracks = [];\n\n\t\t\tfor (let i = 0; i < numMorphTargets; i++) {\n\t\t\t\tlet times = [];\n\t\t\t\tlet values = [];\n\t\t\t\ttimes.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);\n\t\t\t\tvalues.push(0, 1, 0);\n\t\t\t\tconst order = AnimationUtils.getKeyframeOrder(times);\n\t\t\t\ttimes = AnimationUtils.sortedArray(times, 1, order);\n\t\t\t\tvalues = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the\n\t\t\t\t// last frame as well for perfect loop.\n\n\t\t\t\tif (!noLoop && times[0] === 0) {\n\t\t\t\t\ttimes.push(numMorphTargets);\n\t\t\t\t\tvalues.push(values[0]);\n\t\t\t\t}\n\n\t\t\t\ttracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));\n\t\t\t}\n\n\t\t\treturn new this(name, -1, tracks);\n\t\t}\n\n\t\tstatic findByName(objectOrClipArray, name) {\n\t\t\tlet clipArray = objectOrClipArray;\n\n\t\t\tif (!Array.isArray(objectOrClipArray)) {\n\t\t\t\tconst o = objectOrClipArray;\n\t\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < clipArray.length; i++) {\n\t\t\t\tif (clipArray[i].name === name) {\n\t\t\t\t\treturn clipArray[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tstatic CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {\n\t\t\tconst animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences\n\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\n\t\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/; // sort morph target names into animation groups based\n\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\n\t\t\tfor (let i = 0, il = morphTargets.length; i < il; i++) {\n\t\t\t\tconst morphTarget = morphTargets[i];\n\t\t\t\tconst parts = morphTarget.name.match(pattern);\n\n\t\t\t\tif (parts && parts.length > 1) {\n\t\t\t\t\tconst name = parts[1];\n\t\t\t\t\tlet animationMorphTargets = animationToMorphTargets[name];\n\n\t\t\t\t\tif (!animationMorphTargets) {\n\t\t\t\t\t\tanimationToMorphTargets[name] = animationMorphTargets = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationMorphTargets.push(morphTarget);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst clips = [];\n\n\t\t\tfor (const name in animationToMorphTargets) {\n\t\t\t\tclips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));\n\t\t\t}\n\n\t\t\treturn clips;\n\t\t} // parse the animation.hierarchy format\n\n\n\t\tstatic parseAnimation(animation, bones) {\n\t\t\tif (!animation) {\n\t\t\t\tconsole.error('THREE.AnimationClip: No animation in JSONLoader data.');\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {\n\t\t\t\t// only return track if there are actually keys.\n\t\t\t\tif (animationKeys.length !== 0) {\n\t\t\t\t\tconst times = [];\n\t\t\t\t\tconst values = [];\n\t\t\t\t\tAnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again\n\n\t\t\t\t\tif (times.length !== 0) {\n\t\t\t\t\t\tdestTracks.push(new trackType(trackName, times, values));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst tracks = [];\n\t\t\tconst clipName = animation.name || 'default';\n\t\t\tconst fps = animation.fps || 30;\n\t\t\tconst blendMode = animation.blendMode; // automatic length determination in AnimationClip.\n\n\t\t\tlet duration = animation.length || -1;\n\t\t\tconst hierarchyTracks = animation.hierarchy || [];\n\n\t\t\tfor (let h = 0; h < hierarchyTracks.length; h++) {\n\t\t\t\tconst animationKeys = hierarchyTracks[h].keys; // skip empty tracks\n\n\t\t\t\tif (!animationKeys || animationKeys.length === 0) continue; // process morph targets\n\n\t\t\t\tif (animationKeys[0].morphTargets) {\n\t\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\t\tconst morphTargetNames = {};\n\t\t\t\t\tlet k;\n\n\t\t\t\t\tfor (k = 0; k < animationKeys.length; k++) {\n\t\t\t\t\t\tif (animationKeys[k].morphTargets) {\n\t\t\t\t\t\t\tfor (let m = 0; m < animationKeys[k].morphTargets.length; m++) {\n\t\t\t\t\t\t\t\tmorphTargetNames[animationKeys[k].morphTargets[m]] = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} // create a track for each morph target with all zero\n\t\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t\t// the morphTarget is named.\n\n\n\t\t\t\t\tfor (const morphTargetName in morphTargetNames) {\n\t\t\t\t\t\tconst times = [];\n\t\t\t\t\t\tconst values = [];\n\n\t\t\t\t\t\tfor (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {\n\t\t\t\t\t\t\tconst animationKey = animationKeys[k];\n\t\t\t\t\t\t\ttimes.push(animationKey.time);\n\t\t\t\t\t\t\tvalues.push(animationKey.morphTarget === morphTargetName ? 1 : 0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));\n\t\t\t\t\t}\n\n\t\t\t\t\tduration = morphTargetNames.length * (fps || 1.0);\n\t\t\t\t} else {\n\t\t\t\t\t// ...assume skeletal animation\n\t\t\t\t\tconst boneName = '.bones[' + bones[h].name + ']';\n\t\t\t\t\taddNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);\n\t\t\t\t\taddNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);\n\t\t\t\t\taddNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tracks.length === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst clip = new this(clipName, duration, tracks, blendMode);\n\t\t\treturn clip;\n\t\t}\n\n\t\tresetDuration() {\n\t\t\tconst tracks = this.tracks;\n\t\t\tlet duration = 0;\n\n\t\t\tfor (let i = 0, n = tracks.length; i !== n; ++i) {\n\t\t\t\tconst track = this.tracks[i];\n\t\t\t\tduration = Math.max(duration, track.times[track.times.length - 1]);\n\t\t\t}\n\n\t\t\tthis.duration = duration;\n\t\t\treturn this;\n\t\t}\n\n\t\ttrim() {\n\t\t\tfor (let i = 0; i < this.tracks.length; i++) {\n\t\t\t\tthis.tracks[i].trim(0, this.duration);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvalidate() {\n\t\t\tlet valid = true;\n\n\t\t\tfor (let i = 0; i < this.tracks.length; i++) {\n\t\t\t\tvalid = valid && this.tracks[i].validate();\n\t\t\t}\n\n\t\t\treturn valid;\n\t\t}\n\n\t\toptimize() {\n\t\t\tfor (let i = 0; i < this.tracks.length; i++) {\n\t\t\t\tthis.tracks[i].optimize();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\tconst tracks = [];\n\n\t\t\tfor (let i = 0; i < this.tracks.length; i++) {\n\t\t\t\ttracks.push(this.tracks[i].clone());\n\t\t\t}\n\n\t\t\treturn new this.constructor(this.name, this.duration, tracks, this.blendMode);\n\t\t}\n\n\t\ttoJSON() {\n\t\t\treturn this.constructor.toJSON(this);\n\t\t}\n\n\t}\n\n\tfunction getTrackTypeForValueTypeName(typeName) {\n\t\tswitch (typeName.toLowerCase()) {\n\t\t\tcase 'scalar':\n\t\t\tcase 'double':\n\t\t\tcase 'float':\n\t\t\tcase 'number':\n\t\t\tcase 'integer':\n\t\t\t\treturn NumberKeyframeTrack;\n\n\t\t\tcase 'vector':\n\t\t\tcase 'vector2':\n\t\t\tcase 'vector3':\n\t\t\tcase 'vector4':\n\t\t\t\treturn VectorKeyframeTrack;\n\n\t\t\tcase 'color':\n\t\t\t\treturn ColorKeyframeTrack;\n\n\t\t\tcase 'quaternion':\n\t\t\t\treturn QuaternionKeyframeTrack;\n\n\t\t\tcase 'bool':\n\t\t\tcase 'boolean':\n\t\t\t\treturn BooleanKeyframeTrack;\n\n\t\t\tcase 'string':\n\t\t\t\treturn StringKeyframeTrack;\n\t\t}\n\n\t\tthrow new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);\n\t}\n\n\tfunction parseKeyframeTrack(json) {\n\t\tif (json.type === undefined) {\n\t\t\tthrow new Error('THREE.KeyframeTrack: track type undefined, can not parse');\n\t\t}\n\n\t\tconst trackType = getTrackTypeForValueTypeName(json.type);\n\n\t\tif (json.times === undefined) {\n\t\t\tconst times = [],\n\t\t\t\t\t\tvalues = [];\n\t\t\tAnimationUtils.flattenJSON(json.keys, times, values, 'value');\n\t\t\tjson.times = times;\n\t\t\tjson.values = values;\n\t\t} // derived classes can define a static parse method\n\n\n\t\tif (trackType.parse !== undefined) {\n\t\t\treturn trackType.parse(json);\n\t\t} else {\n\t\t\t// by default, we assume a constructor compatible with the base\n\t\t\treturn new trackType(json.name, json.times, json.values, json.interpolation);\n\t\t}\n\t}\n\n\tconst Cache = {\n\t\tenabled: false,\n\t\tfiles: {},\n\t\tadd: function (key, file) {\n\t\t\tif (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\t\tthis.files[key] = file;\n\t\t},\n\t\tget: function (key) {\n\t\t\tif (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\t\treturn this.files[key];\n\t\t},\n\t\tremove: function (key) {\n\t\t\tdelete this.files[key];\n\t\t},\n\t\tclear: function () {\n\t\t\tthis.files = {};\n\t\t}\n\t};\n\n\tclass LoadingManager {\n\t\tconstructor(onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tlet isLoading = false;\n\t\t\tlet itemsLoaded = 0;\n\t\t\tlet itemsTotal = 0;\n\t\t\tlet urlModifier = undefined;\n\t\t\tconst handlers = []; // Refer to #5689 for the reason why we don't set .onStart\n\t\t\t// in the constructor\n\n\t\t\tthis.onStart = undefined;\n\t\t\tthis.onLoad = onLoad;\n\t\t\tthis.onProgress = onProgress;\n\t\t\tthis.onError = onError;\n\n\t\t\tthis.itemStart = function (url) {\n\t\t\t\titemsTotal++;\n\n\t\t\t\tif (isLoading === false) {\n\t\t\t\t\tif (scope.onStart !== undefined) {\n\t\t\t\t\t\tscope.onStart(url, itemsLoaded, itemsTotal);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tisLoading = true;\n\t\t\t};\n\n\t\t\tthis.itemEnd = function (url) {\n\t\t\t\titemsLoaded++;\n\n\t\t\t\tif (scope.onProgress !== undefined) {\n\t\t\t\t\tscope.onProgress(url, itemsLoaded, itemsTotal);\n\t\t\t\t}\n\n\t\t\t\tif (itemsLoaded === itemsTotal) {\n\t\t\t\t\tisLoading = false;\n\n\t\t\t\t\tif (scope.onLoad !== undefined) {\n\t\t\t\t\t\tscope.onLoad();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.itemError = function (url) {\n\t\t\t\tif (scope.onError !== undefined) {\n\t\t\t\t\tscope.onError(url);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.resolveURL = function (url) {\n\t\t\t\tif (urlModifier) {\n\t\t\t\t\treturn urlModifier(url);\n\t\t\t\t}\n\n\t\t\t\treturn url;\n\t\t\t};\n\n\t\t\tthis.setURLModifier = function (transform) {\n\t\t\t\turlModifier = transform;\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tthis.addHandler = function (regex, loader) {\n\t\t\t\thandlers.push(regex, loader);\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tthis.removeHandler = function (regex) {\n\t\t\t\tconst index = handlers.indexOf(regex);\n\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\thandlers.splice(index, 2);\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tthis.getHandler = function (file) {\n\t\t\t\tfor (let i = 0, l = handlers.length; i < l; i += 2) {\n\t\t\t\t\tconst regex = handlers[i];\n\t\t\t\t\tconst loader = handlers[i + 1];\n\t\t\t\t\tif (regex.global) regex.lastIndex = 0; // see #17920\n\n\t\t\t\t\tif (regex.test(file)) {\n\t\t\t\t\t\treturn loader;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t};\n\t\t}\n\n\t}\n\n\tconst DefaultLoadingManager = new LoadingManager();\n\n\tclass Loader {\n\t\tconstructor(manager) {\n\t\t\tthis.manager = manager !== undefined ? manager : DefaultLoadingManager;\n\t\t\tthis.crossOrigin = 'anonymous';\n\t\t\tthis.withCredentials = false;\n\t\t\tthis.path = '';\n\t\t\tthis.resourcePath = '';\n\t\t\tthis.requestHeader = {};\n\t\t}\n\n\t\tload()\n\t\t/* url, onLoad, onProgress, onError */\n\t\t{}\n\n\t\tloadAsync(url, onProgress) {\n\t\t\tconst scope = this;\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tscope.load(url, resolve, onProgress, reject);\n\t\t\t});\n\t\t}\n\n\t\tparse()\n\t\t/* data */\n\t\t{}\n\n\t\tsetCrossOrigin(crossOrigin) {\n\t\t\tthis.crossOrigin = crossOrigin;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetWithCredentials(value) {\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetPath(path) {\n\t\t\tthis.path = path;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetResourcePath(resourcePath) {\n\t\t\tthis.resourcePath = resourcePath;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetRequestHeader(requestHeader) {\n\t\t\tthis.requestHeader = requestHeader;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tconst loading = {};\n\n\tclass FileLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tif (url === undefined) url = '';\n\t\t\tif (this.path !== undefined) url = this.path + url;\n\t\t\turl = this.manager.resolveURL(url);\n\t\t\tconst scope = this;\n\t\t\tconst cached = Cache.get(url);\n\n\t\t\tif (cached !== undefined) {\n\t\t\t\tscope.manager.itemStart(url);\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tif (onLoad) onLoad(cached);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, 0);\n\t\t\t\treturn cached;\n\t\t\t} // Check if request is duplicate\n\n\n\t\t\tif (loading[url] !== undefined) {\n\t\t\t\tloading[url].push({\n\t\t\t\t\tonLoad: onLoad,\n\t\t\t\t\tonProgress: onProgress,\n\t\t\t\t\tonError: onError\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t} // Check for data: URI\n\n\n\t\t\tconst dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\t\tconst dataUriRegexResult = url.match(dataUriRegex);\n\t\t\tlet request; // Safari can not handle Data URIs through XMLHttpRequest so process manually\n\n\t\t\tif (dataUriRegexResult) {\n\t\t\t\tconst mimeType = dataUriRegexResult[1];\n\t\t\t\tconst isBase64 = !!dataUriRegexResult[2];\n\t\t\t\tlet data = dataUriRegexResult[3];\n\t\t\t\tdata = decodeURIComponent(data);\n\t\t\t\tif (isBase64) data = atob(data);\n\n\t\t\t\ttry {\n\t\t\t\t\tlet response;\n\t\t\t\t\tconst responseType = (this.responseType || '').toLowerCase();\n\n\t\t\t\t\tswitch (responseType) {\n\t\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\t\tcase 'blob':\n\t\t\t\t\t\t\tconst view = new Uint8Array(data.length);\n\n\t\t\t\t\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\t\t\t\t\tview[i] = data.charCodeAt(i);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (responseType === 'blob') {\n\t\t\t\t\t\t\t\tresponse = new Blob([view.buffer], {\n\t\t\t\t\t\t\t\t\ttype: mimeType\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresponse = view.buffer;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'document':\n\t\t\t\t\t\t\tconst parser = new DOMParser();\n\t\t\t\t\t\t\tresponse = parser.parseFromString(data, mimeType);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'json':\n\t\t\t\t\t\t\tresponse = JSON.parse(data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// 'text' or other\n\t\t\t\t\t\t\tresponse = data;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\n\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tif (onLoad) onLoad(response);\n\t\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t\t}, 0);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tif (onError) onError(error);\n\t\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Initialise array for duplicate requests\n\t\t\t\tloading[url] = [];\n\t\t\t\tloading[url].push({\n\t\t\t\t\tonLoad: onLoad,\n\t\t\t\t\tonProgress: onProgress,\n\t\t\t\t\tonError: onError\n\t\t\t\t});\n\t\t\t\trequest = new XMLHttpRequest();\n\t\t\t\trequest.open('GET', url, true);\n\t\t\t\trequest.addEventListener('load', function (event) {\n\t\t\t\t\tconst response = this.response;\n\t\t\t\t\tconst callbacks = loading[url];\n\t\t\t\t\tdelete loading[url];\n\n\t\t\t\t\tif (this.status === 200 || this.status === 0) {\n\t\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\t\t\t\t\t\tif (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.'); // Add to cache only on HTTP success, so that we do not cache\n\t\t\t\t\t\t// error response bodies as proper responses to requests.\n\n\t\t\t\t\t\tCache.add(url, response);\n\n\t\t\t\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n\t\t\t\t\t\t\tconst callback = callbacks[i];\n\t\t\t\t\t\t\tif (callback.onLoad) callback.onLoad(response);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n\t\t\t\t\t\t\tconst callback = callbacks[i];\n\t\t\t\t\t\t\tif (callback.onError) callback.onError(event);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t\t}\n\t\t\t\t}, false);\n\t\t\t\trequest.addEventListener('progress', function (event) {\n\t\t\t\t\tconst callbacks = loading[url];\n\n\t\t\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n\t\t\t\t\t\tconst callback = callbacks[i];\n\t\t\t\t\t\tif (callback.onProgress) callback.onProgress(event);\n\t\t\t\t\t}\n\t\t\t\t}, false);\n\t\t\t\trequest.addEventListener('error', function (event) {\n\t\t\t\t\tconst callbacks = loading[url];\n\t\t\t\t\tdelete loading[url];\n\n\t\t\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n\t\t\t\t\t\tconst callback = callbacks[i];\n\t\t\t\t\t\tif (callback.onError) callback.onError(event);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, false);\n\t\t\t\trequest.addEventListener('abort', function (event) {\n\t\t\t\t\tconst callbacks = loading[url];\n\t\t\t\t\tdelete loading[url];\n\n\t\t\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n\t\t\t\t\t\tconst callback = callbacks[i];\n\t\t\t\t\t\tif (callback.onError) callback.onError(event);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, false);\n\t\t\t\tif (this.responseType !== undefined) request.responseType = this.responseType;\n\t\t\t\tif (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;\n\t\t\t\tif (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');\n\n\t\t\t\tfor (const header in this.requestHeader) {\n\t\t\t\t\trequest.setRequestHeader(header, this.requestHeader[header]);\n\t\t\t\t}\n\n\t\t\t\trequest.send(null);\n\t\t\t}\n\n\t\t\tscope.manager.itemStart(url);\n\t\t\treturn request;\n\t\t}\n\n\t\tsetResponseType(value) {\n\t\t\tthis.responseType = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetMimeType(value) {\n\t\t\tthis.mimeType = value;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass AnimationLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setWithCredentials(this.withCredentials);\n\t\t\tloader.load(url, function (text) {\n\t\t\t\ttry {\n\t\t\t\t\tonLoad(scope.parse(JSON.parse(text)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onError) {\n\t\t\t\t\t\tonError(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t\tparse(json) {\n\t\t\tconst animations = [];\n\n\t\t\tfor (let i = 0; i < json.length; i++) {\n\t\t\t\tconst clip = AnimationClip.parse(json[i]);\n\t\t\t\tanimations.push(clip);\n\t\t\t}\n\n\t\t\treturn animations;\n\t\t}\n\n\t}\n\n\t/**\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\n\t *\n\t * Sub classes have to implement the parse() method which will be used in load().\n\t */\n\n\tclass CompressedTextureLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst images = [];\n\t\t\tconst texture = new CompressedTexture();\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setResponseType('arraybuffer');\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setWithCredentials(scope.withCredentials);\n\t\t\tlet loaded = 0;\n\n\t\t\tfunction loadTexture(i) {\n\t\t\t\tloader.load(url[i], function (buffer) {\n\t\t\t\t\tconst texDatas = scope.parse(buffer, true);\n\t\t\t\t\timages[i] = {\n\t\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t\t};\n\t\t\t\t\tloaded += 1;\n\n\t\t\t\t\tif (loaded === 6) {\n\t\t\t\t\t\tif (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;\n\t\t\t\t\t\ttexture.image = images;\n\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\t\tif (onLoad) onLoad(texture);\n\t\t\t\t\t}\n\t\t\t\t}, onProgress, onError);\n\t\t\t}\n\n\t\t\tif (Array.isArray(url)) {\n\t\t\t\tfor (let i = 0, il = url.length; i < il; ++i) {\n\t\t\t\t\tloadTexture(i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// compressed cubemap texture stored in a single DDS file\n\t\t\t\tloader.load(url, function (buffer) {\n\t\t\t\t\tconst texDatas = scope.parse(buffer, true);\n\n\t\t\t\t\tif (texDatas.isCubemap) {\n\t\t\t\t\t\tconst faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\t\tfor (let f = 0; f < faces; f++) {\n\t\t\t\t\t\t\timages[f] = {\n\t\t\t\t\t\t\t\tmipmaps: []\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tfor (let i = 0; i < texDatas.mipmapCount; i++) {\n\t\t\t\t\t\t\t\timages[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);\n\t\t\t\t\t\t\t\timages[f].format = texDatas.format;\n\t\t\t\t\t\t\t\timages[f].width = texDatas.width;\n\t\t\t\t\t\t\t\timages[f].height = texDatas.height;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttexture.image = images;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (texDatas.mipmapCount === 1) {\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\tif (onLoad) onLoad(texture);\n\t\t\t\t}, onProgress, onError);\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t}\n\n\t}\n\n\tclass ImageLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tif (this.path !== undefined) url = this.path + url;\n\t\t\turl = this.manager.resolveURL(url);\n\t\t\tconst scope = this;\n\t\t\tconst cached = Cache.get(url);\n\n\t\t\tif (cached !== undefined) {\n\t\t\t\tscope.manager.itemStart(url);\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tif (onLoad) onLoad(cached);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, 0);\n\t\t\t\treturn cached;\n\t\t\t}\n\n\t\t\tconst image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');\n\n\t\t\tfunction onImageLoad() {\n\t\t\t\timage.removeEventListener('load', onImageLoad, false);\n\t\t\t\timage.removeEventListener('error', onImageError, false);\n\t\t\t\tCache.add(url, this);\n\t\t\t\tif (onLoad) onLoad(this);\n\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t}\n\n\t\t\tfunction onImageError(event) {\n\t\t\t\timage.removeEventListener('load', onImageLoad, false);\n\t\t\t\timage.removeEventListener('error', onImageError, false);\n\t\t\t\tif (onError) onError(event);\n\t\t\t\tscope.manager.itemError(url);\n\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t}\n\n\t\t\timage.addEventListener('load', onImageLoad, false);\n\t\t\timage.addEventListener('error', onImageError, false);\n\n\t\t\tif (url.substr(0, 5) !== 'data:') {\n\t\t\t\tif (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;\n\t\t\t}\n\n\t\t\tscope.manager.itemStart(url);\n\t\t\timage.src = url;\n\t\t\treturn image;\n\t\t}\n\n\t}\n\n\tclass CubeTextureLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(urls, onLoad, onProgress, onError) {\n\t\t\tconst texture = new CubeTexture();\n\t\t\tconst loader = new ImageLoader(this.manager);\n\t\t\tloader.setCrossOrigin(this.crossOrigin);\n\t\t\tloader.setPath(this.path);\n\t\t\tlet loaded = 0;\n\n\t\t\tfunction loadTexture(i) {\n\t\t\t\tloader.load(urls[i], function (image) {\n\t\t\t\t\ttexture.images[i] = image;\n\t\t\t\t\tloaded++;\n\n\t\t\t\t\tif (loaded === 6) {\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\t\tif (onLoad) onLoad(texture);\n\t\t\t\t\t}\n\t\t\t\t}, undefined, onError);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < urls.length; ++i) {\n\t\t\t\tloadTexture(i);\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t}\n\n\t}\n\n\t/**\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n\t *\n\t * Sub classes have to implement the parse() method which will be used in load().\n\t */\n\n\tclass DataTextureLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst texture = new DataTexture();\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setResponseType('arraybuffer');\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setWithCredentials(scope.withCredentials);\n\t\t\tloader.load(url, function (buffer) {\n\t\t\t\tconst texData = scope.parse(buffer);\n\t\t\t\tif (!texData) return;\n\n\t\t\t\tif (texData.image !== undefined) {\n\t\t\t\t\ttexture.image = texData.image;\n\t\t\t\t} else if (texData.data !== undefined) {\n\t\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\t\ttexture.image.data = texData.data;\n\t\t\t\t}\n\n\t\t\t\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\t\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n\t\t\t\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n\t\t\t\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n\t\t\t\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n\t\t\t\tif (texData.encoding !== undefined) {\n\t\t\t\t\ttexture.encoding = texData.encoding;\n\t\t\t\t}\n\n\t\t\t\tif (texData.flipY !== undefined) {\n\t\t\t\t\ttexture.flipY = texData.flipY;\n\t\t\t\t}\n\n\t\t\t\tif (texData.format !== undefined) {\n\t\t\t\t\ttexture.format = texData.format;\n\t\t\t\t}\n\n\t\t\t\tif (texData.type !== undefined) {\n\t\t\t\t\ttexture.type = texData.type;\n\t\t\t\t}\n\n\t\t\t\tif (texData.mipmaps !== undefined) {\n\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\t\t\t\ttexture.minFilter = LinearMipmapLinearFilter; // presumably...\n\t\t\t\t}\n\n\t\t\t\tif (texData.mipmapCount === 1) {\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t}\n\n\t\t\t\tif (texData.generateMipmaps !== undefined) {\n\t\t\t\t\ttexture.generateMipmaps = texData.generateMipmaps;\n\t\t\t\t}\n\n\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\tif (onLoad) onLoad(texture, texData);\n\t\t\t}, onProgress, onError);\n\t\t\treturn texture;\n\t\t}\n\n\t}\n\n\tclass TextureLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst texture = new Texture();\n\t\t\tconst loader = new ImageLoader(this.manager);\n\t\t\tloader.setCrossOrigin(this.crossOrigin);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.load(url, function (image) {\n\t\t\t\ttexture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\n\t\t\t\tconst isJPEG = url.search(/\\.jpe?g($|\\?)/i) > 0 || url.search(/^data\\:image\\/jpeg/) === 0;\n\t\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif (onLoad !== undefined) {\n\t\t\t\t\tonLoad(texture);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t\treturn texture;\n\t\t}\n\n\t}\n\n\t/**\n\t * Extensible curve object.\n\t *\n\t * Some common of curve methods:\n\t * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n\t * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n\t * .getPoints(), .getSpacedPoints()\n\t * .getLength()\n\t * .updateArcLengths()\n\t *\n\t * This following curves inherit from THREE.Curve:\n\t *\n\t * -- 2D curves --\n\t * THREE.ArcCurve\n\t * THREE.CubicBezierCurve\n\t * THREE.EllipseCurve\n\t * THREE.LineCurve\n\t * THREE.QuadraticBezierCurve\n\t * THREE.SplineCurve\n\t *\n\t * -- 3D curves --\n\t * THREE.CatmullRomCurve3\n\t * THREE.CubicBezierCurve3\n\t * THREE.LineCurve3\n\t * THREE.QuadraticBezierCurve3\n\t *\n\t * A series of curves can be represented as a THREE.CurvePath.\n\t *\n\t **/\n\n\tclass Curve {\n\t\tconstructor() {\n\t\t\tthis.type = 'Curve';\n\t\t\tthis.arcLengthDivisions = 200;\n\t\t} // Virtual base class method to overwrite and implement in subclasses\n\t\t//\t- t [0 .. 1]\n\n\n\t\tgetPoint()\n\t\t/* t, optionalTarget */\n\t\t{\n\t\t\tconsole.warn('THREE.Curve: .getPoint() not implemented.');\n\t\t\treturn null;\n\t\t} // Get point at relative position in curve according to arc length\n\t\t// - u [0 .. 1]\n\n\n\t\tgetPointAt(u, optionalTarget) {\n\t\t\tconst t = this.getUtoTmapping(u);\n\t\t\treturn this.getPoint(t, optionalTarget);\n\t\t} // Get sequence of points using getPoint( t )\n\n\n\t\tgetPoints(divisions = 5) {\n\t\t\tconst points = [];\n\n\t\t\tfor (let d = 0; d <= divisions; d++) {\n\t\t\t\tpoints.push(this.getPoint(d / divisions));\n\t\t\t}\n\n\t\t\treturn points;\n\t\t} // Get sequence of points using getPointAt( u )\n\n\n\t\tgetSpacedPoints(divisions = 5) {\n\t\t\tconst points = [];\n\n\t\t\tfor (let d = 0; d <= divisions; d++) {\n\t\t\t\tpoints.push(this.getPointAt(d / divisions));\n\t\t\t}\n\n\t\t\treturn points;\n\t\t} // Get total curve arc length\n\n\n\t\tgetLength() {\n\t\t\tconst lengths = this.getLengths();\n\t\t\treturn lengths[lengths.length - 1];\n\t\t} // Get list of cumulative segment lengths\n\n\n\t\tgetLengths(divisions = this.arcLengthDivisions) {\n\t\t\tif (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n\t\t\t\treturn this.cacheArcLengths;\n\t\t\t}\n\n\t\t\tthis.needsUpdate = false;\n\t\t\tconst cache = [];\n\t\t\tlet current,\n\t\t\t\t\tlast = this.getPoint(0);\n\t\t\tlet sum = 0;\n\t\t\tcache.push(0);\n\n\t\t\tfor (let p = 1; p <= divisions; p++) {\n\t\t\t\tcurrent = this.getPoint(p / divisions);\n\t\t\t\tsum += current.distanceTo(last);\n\t\t\t\tcache.push(sum);\n\t\t\t\tlast = current;\n\t\t\t}\n\n\t\t\tthis.cacheArcLengths = cache;\n\t\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\t\t}\n\n\t\tupdateArcLengths() {\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.getLengths();\n\t\t} // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\n\t\tgetUtoTmapping(u, distance) {\n\t\t\tconst arcLengths = this.getLengths();\n\t\t\tlet i = 0;\n\t\t\tconst il = arcLengths.length;\n\t\t\tlet targetArcLength; // The targeted u distance value to get\n\n\t\t\tif (distance) {\n\t\t\t\ttargetArcLength = distance;\n\t\t\t} else {\n\t\t\t\ttargetArcLength = u * arcLengths[il - 1];\n\t\t\t} // binary search for the index with largest value smaller than target u distance\n\n\n\t\t\tlet low = 0,\n\t\t\t\t\thigh = il - 1,\n\t\t\t\t\tcomparison;\n\n\t\t\twhile (low <= high) {\n\t\t\t\ti = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\t\tcomparison = arcLengths[i] - targetArcLength;\n\n\t\t\t\tif (comparison < 0) {\n\t\t\t\t\tlow = i + 1;\n\t\t\t\t} else if (comparison > 0) {\n\t\t\t\t\thigh = i - 1;\n\t\t\t\t} else {\n\t\t\t\t\thigh = i;\n\t\t\t\t\tbreak; // DONE\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = high;\n\n\t\t\tif (arcLengths[i] === targetArcLength) {\n\t\t\t\treturn i / (il - 1);\n\t\t\t} // we could get finer grain at lengths, or use simple interpolation between two points\n\n\n\t\t\tconst lengthBefore = arcLengths[i];\n\t\t\tconst lengthAfter = arcLengths[i + 1];\n\t\t\tconst segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points\n\n\t\t\tconst segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t\n\n\t\t\tconst t = (i + segmentFraction) / (il - 1);\n\t\t\treturn t;\n\t\t} // Returns a unit vector tangent at t\n\t\t// In case any sub curve does not implement its tangent derivation,\n\t\t// 2 points a small delta apart will be used to find its gradient\n\t\t// which seems to give a reasonable approximation\n\n\n\t\tgetTangent(t, optionalTarget) {\n\t\t\tconst delta = 0.0001;\n\t\t\tlet t1 = t - delta;\n\t\t\tlet t2 = t + delta; // Capping in case of danger\n\n\t\t\tif (t1 < 0) t1 = 0;\n\t\t\tif (t2 > 1) t2 = 1;\n\t\t\tconst pt1 = this.getPoint(t1);\n\t\t\tconst pt2 = this.getPoint(t2);\n\t\t\tconst tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());\n\t\t\ttangent.copy(pt2).sub(pt1).normalize();\n\t\t\treturn tangent;\n\t\t}\n\n\t\tgetTangentAt(u, optionalTarget) {\n\t\t\tconst t = this.getUtoTmapping(u);\n\t\t\treturn this.getTangent(t, optionalTarget);\n\t\t}\n\n\t\tcomputeFrenetFrames(segments, closed) {\n\t\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\t\t\tconst normal = new Vector3();\n\t\t\tconst tangents = [];\n\t\t\tconst normals = [];\n\t\t\tconst binormals = [];\n\t\t\tconst vec = new Vector3();\n\t\t\tconst mat = new Matrix4(); // compute the tangent vectors for each segment on the curve\n\n\t\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\t\tconst u = i / segments;\n\t\t\t\ttangents[i] = this.getTangentAt(u, new Vector3());\n\t\t\t\ttangents[i].normalize();\n\t\t\t} // select an initial normal vector perpendicular to the first tangent vector,\n\t\t\t// and in the direction of the minimum tangent xyz component\n\n\n\t\t\tnormals[0] = new Vector3();\n\t\t\tbinormals[0] = new Vector3();\n\t\t\tlet min = Number.MAX_VALUE;\n\t\t\tconst tx = Math.abs(tangents[0].x);\n\t\t\tconst ty = Math.abs(tangents[0].y);\n\t\t\tconst tz = Math.abs(tangents[0].z);\n\n\t\t\tif (tx <= min) {\n\t\t\t\tmin = tx;\n\t\t\t\tnormal.set(1, 0, 0);\n\t\t\t}\n\n\t\t\tif (ty <= min) {\n\t\t\t\tmin = ty;\n\t\t\t\tnormal.set(0, 1, 0);\n\t\t\t}\n\n\t\t\tif (tz <= min) {\n\t\t\t\tnormal.set(0, 0, 1);\n\t\t\t}\n\n\t\t\tvec.crossVectors(tangents[0], normal).normalize();\n\t\t\tnormals[0].crossVectors(tangents[0], vec);\n\t\t\tbinormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\t\tfor (let i = 1; i <= segments; i++) {\n\t\t\t\tnormals[i] = normals[i - 1].clone();\n\t\t\t\tbinormals[i] = binormals[i - 1].clone();\n\t\t\t\tvec.crossVectors(tangents[i - 1], tangents[i]);\n\n\t\t\t\tif (vec.length() > Number.EPSILON) {\n\t\t\t\t\tvec.normalize();\n\t\t\t\t\tconst theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors\n\n\t\t\t\t\tnormals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\n\t\t\t\t}\n\n\t\t\t\tbinormals[i].crossVectors(tangents[i], normals[i]);\n\t\t\t} // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\n\t\t\tif (closed === true) {\n\t\t\t\tlet theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));\n\t\t\t\ttheta /= segments;\n\n\t\t\t\tif (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {\n\t\t\t\t\ttheta = -theta;\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 1; i <= segments; i++) {\n\t\t\t\t\t// twist a little...\n\t\t\t\t\tnormals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\n\t\t\t\t\tbinormals[i].crossVectors(tangents[i], normals[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttangents: tangents,\n\t\t\t\tnormals: normals,\n\t\t\t\tbinormals: binormals\n\t\t\t};\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Curve',\n\t\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t\t}\n\t\t\t};\n\t\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\t\tdata.type = this.type;\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass EllipseCurve extends Curve {\n\t\tconstructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {\n\t\t\tsuper();\n\t\t\tthis.type = 'EllipseCurve';\n\t\t\tthis.aX = aX;\n\t\t\tthis.aY = aY;\n\t\t\tthis.xRadius = xRadius;\n\t\t\tthis.yRadius = yRadius;\n\t\t\tthis.aStartAngle = aStartAngle;\n\t\t\tthis.aEndAngle = aEndAngle;\n\t\t\tthis.aClockwise = aClockwise;\n\t\t\tthis.aRotation = aRotation;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget) {\n\t\t\tconst point = optionalTarget || new Vector2();\n\t\t\tconst twoPi = Math.PI * 2;\n\t\t\tlet deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\t\tconst samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI\n\n\t\t\twhile (deltaAngle < 0) deltaAngle += twoPi;\n\n\t\t\twhile (deltaAngle > twoPi) deltaAngle -= twoPi;\n\n\t\t\tif (deltaAngle < Number.EPSILON) {\n\t\t\t\tif (samePoints) {\n\t\t\t\t\tdeltaAngle = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdeltaAngle = twoPi;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.aClockwise === true && !samePoints) {\n\t\t\t\tif (deltaAngle === twoPi) {\n\t\t\t\t\tdeltaAngle = -twoPi;\n\t\t\t\t} else {\n\t\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst angle = this.aStartAngle + t * deltaAngle;\n\t\t\tlet x = this.aX + this.xRadius * Math.cos(angle);\n\t\t\tlet y = this.aY + this.yRadius * Math.sin(angle);\n\n\t\t\tif (this.aRotation !== 0) {\n\t\t\t\tconst cos = Math.cos(this.aRotation);\n\t\t\t\tconst sin = Math.sin(this.aRotation);\n\t\t\t\tconst tx = x - this.aX;\n\t\t\t\tconst ty = y - this.aY; // Rotate the point about the center of the ellipse.\n\n\t\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\t\ty = tx * sin + ty * cos + this.aY;\n\t\t\t}\n\n\t\t\treturn point.set(x, y);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.aX = source.aX;\n\t\t\tthis.aY = source.aY;\n\t\t\tthis.xRadius = source.xRadius;\n\t\t\tthis.yRadius = source.yRadius;\n\t\t\tthis.aStartAngle = source.aStartAngle;\n\t\t\tthis.aEndAngle = source.aEndAngle;\n\t\t\tthis.aClockwise = source.aClockwise;\n\t\t\tthis.aRotation = source.aRotation;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.aX = this.aX;\n\t\t\tdata.aY = this.aY;\n\t\t\tdata.xRadius = this.xRadius;\n\t\t\tdata.yRadius = this.yRadius;\n\t\t\tdata.aStartAngle = this.aStartAngle;\n\t\t\tdata.aEndAngle = this.aEndAngle;\n\t\t\tdata.aClockwise = this.aClockwise;\n\t\t\tdata.aRotation = this.aRotation;\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.aX = json.aX;\n\t\t\tthis.aY = json.aY;\n\t\t\tthis.xRadius = json.xRadius;\n\t\t\tthis.yRadius = json.yRadius;\n\t\t\tthis.aStartAngle = json.aStartAngle;\n\t\t\tthis.aEndAngle = json.aEndAngle;\n\t\t\tthis.aClockwise = json.aClockwise;\n\t\t\tthis.aRotation = json.aRotation;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tEllipseCurve.prototype.isEllipseCurve = true;\n\n\tclass ArcCurve extends EllipseCurve {\n\t\tconstructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n\t\t\tsuper(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n\t\t\tthis.type = 'ArcCurve';\n\t\t}\n\n\t}\n\n\tArcCurve.prototype.isArcCurve = true;\n\n\t/**\n\t * Centripetal CatmullRom Curve - which is useful for avoiding\n\t * cusps and self-intersections in non-uniform catmull rom curves.\n\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\t *\n\t * curve.type accepts centripetal(default), chordal and catmullrom\n\t * curve.tension is used for catmullrom which defaults to 0.5\n\t */\n\n\t/*\n\tBased on an optimized c++ solution in\n\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t - http://ideone.com/NoEbVM\n\n\tThis CubicPoly class could be used for reusing some variables and calculations,\n\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\twhich can be placed in CurveUtils.\n\t*/\n\n\tfunction CubicPoly() {\n\t\tlet c0 = 0,\n\t\t\t\tc1 = 0,\n\t\t\t\tc2 = 0,\n\t\t\t\tc3 = 0;\n\t\t/*\n\t\t * Compute coefficients for a cubic polynomial\n\t\t *\t p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t\t * such that\n\t\t *\t p(0) = x0, p(1) = x1\n\t\t *\tand\n\t\t *\t p'(0) = t0, p'(1) = t1.\n\t\t */\n\n\t\tfunction init(x0, x1, t0, t1) {\n\t\t\tc0 = x0;\n\t\t\tc1 = t0;\n\t\t\tc2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\t\t}\n\n\t\treturn {\n\t\t\tinitCatmullRom: function (x0, x1, x2, x3, tension) {\n\t\t\t\tinit(x1, x2, tension * (x2 - x0), tension * (x3 - x1));\n\t\t\t},\n\t\t\tinitNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {\n\t\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\t\tlet t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;\n\t\t\t\tlet t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]\n\n\t\t\t\tt1 *= dt1;\n\t\t\t\tt2 *= dt1;\n\t\t\t\tinit(x1, x2, t1, t2);\n\t\t\t},\n\t\t\tcalc: function (t) {\n\t\t\t\tconst t2 = t * t;\n\t\t\t\tconst t3 = t2 * t;\n\t\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\t\t\t}\n\t\t};\n\t} //\n\n\n\tconst tmp = new Vector3();\n\tconst px = new CubicPoly(),\n\t\t\t\tpy = new CubicPoly(),\n\t\t\t\tpz = new CubicPoly();\n\n\tclass CatmullRomCurve3 extends Curve {\n\t\tconstructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CatmullRomCurve3';\n\t\t\tthis.points = points;\n\t\t\tthis.closed = closed;\n\t\t\tthis.curveType = curveType;\n\t\t\tthis.tension = tension;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector3()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst points = this.points;\n\t\t\tconst l = points.length;\n\t\t\tconst p = (l - (this.closed ? 0 : 1)) * t;\n\t\t\tlet intPoint = Math.floor(p);\n\t\t\tlet weight = p - intPoint;\n\n\t\t\tif (this.closed) {\n\t\t\t\tintPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;\n\t\t\t} else if (weight === 0 && intPoint === l - 1) {\n\t\t\t\tintPoint = l - 2;\n\t\t\t\tweight = 1;\n\t\t\t}\n\n\t\t\tlet p0, p3; // 4 points (p1 & p2 defined below)\n\n\t\t\tif (this.closed || intPoint > 0) {\n\t\t\t\tp0 = points[(intPoint - 1) % l];\n\t\t\t} else {\n\t\t\t\t// extrapolate first point\n\t\t\t\ttmp.subVectors(points[0], points[1]).add(points[0]);\n\t\t\t\tp0 = tmp;\n\t\t\t}\n\n\t\t\tconst p1 = points[intPoint % l];\n\t\t\tconst p2 = points[(intPoint + 1) % l];\n\n\t\t\tif (this.closed || intPoint + 2 < l) {\n\t\t\t\tp3 = points[(intPoint + 2) % l];\n\t\t\t} else {\n\t\t\t\t// extrapolate last point\n\t\t\t\ttmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);\n\t\t\t\tp3 = tmp;\n\t\t\t}\n\n\t\t\tif (this.curveType === 'centripetal' || this.curveType === 'chordal') {\n\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\tconst pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\t\t\tlet dt0 = Math.pow(p0.distanceToSquared(p1), pow);\n\t\t\t\tlet dt1 = Math.pow(p1.distanceToSquared(p2), pow);\n\t\t\t\tlet dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points\n\n\t\t\t\tif (dt1 < 1e-4) dt1 = 1.0;\n\t\t\t\tif (dt0 < 1e-4) dt0 = dt1;\n\t\t\t\tif (dt2 < 1e-4) dt2 = dt1;\n\t\t\t\tpx.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);\n\t\t\t\tpy.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);\n\t\t\t\tpz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);\n\t\t\t} else if (this.curveType === 'catmullrom') {\n\t\t\t\tpx.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);\n\t\t\t\tpy.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);\n\t\t\t\tpz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);\n\t\t\t}\n\n\t\t\tpoint.set(px.calc(weight), py.calc(weight), pz.calc(weight));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.points = [];\n\n\t\t\tfor (let i = 0, l = source.points.length; i < l; i++) {\n\t\t\t\tconst point = source.points[i];\n\t\t\t\tthis.points.push(point.clone());\n\t\t\t}\n\n\t\t\tthis.closed = source.closed;\n\t\t\tthis.curveType = source.curveType;\n\t\t\tthis.tension = source.tension;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.points = [];\n\n\t\t\tfor (let i = 0, l = this.points.length; i < l; i++) {\n\t\t\t\tconst point = this.points[i];\n\t\t\t\tdata.points.push(point.toArray());\n\t\t\t}\n\n\t\t\tdata.closed = this.closed;\n\t\t\tdata.curveType = this.curveType;\n\t\t\tdata.tension = this.tension;\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.points = [];\n\n\t\t\tfor (let i = 0, l = json.points.length; i < l; i++) {\n\t\t\t\tconst point = json.points[i];\n\t\t\t\tthis.points.push(new Vector3().fromArray(point));\n\t\t\t}\n\n\t\t\tthis.closed = json.closed;\n\t\t\tthis.curveType = json.curveType;\n\t\t\tthis.tension = json.tension;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\n\n\t/**\n\t * Bezier Curves formulas obtained from\n\t * http://en.wikipedia.org/wiki/Bzier_curve\n\t */\n\tfunction CatmullRom(t, p0, p1, p2, p3) {\n\t\tconst v0 = (p2 - p0) * 0.5;\n\t\tconst v1 = (p3 - p1) * 0.5;\n\t\tconst t2 = t * t;\n\t\tconst t3 = t * t2;\n\t\treturn (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t} //\n\n\n\tfunction QuadraticBezierP0(t, p) {\n\t\tconst k = 1 - t;\n\t\treturn k * k * p;\n\t}\n\n\tfunction QuadraticBezierP1(t, p) {\n\t\treturn 2 * (1 - t) * t * p;\n\t}\n\n\tfunction QuadraticBezierP2(t, p) {\n\t\treturn t * t * p;\n\t}\n\n\tfunction QuadraticBezier(t, p0, p1, p2) {\n\t\treturn QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);\n\t} //\n\n\n\tfunction CubicBezierP0(t, p) {\n\t\tconst k = 1 - t;\n\t\treturn k * k * k * p;\n\t}\n\n\tfunction CubicBezierP1(t, p) {\n\t\tconst k = 1 - t;\n\t\treturn 3 * k * k * t * p;\n\t}\n\n\tfunction CubicBezierP2(t, p) {\n\t\treturn 3 * (1 - t) * t * t * p;\n\t}\n\n\tfunction CubicBezierP3(t, p) {\n\t\treturn t * t * t * p;\n\t}\n\n\tfunction CubicBezier(t, p0, p1, p2, p3) {\n\t\treturn CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);\n\t}\n\n\tclass CubicBezierCurve extends Curve {\n\t\tconstructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CubicBezierCurve';\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector2()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst v0 = this.v0,\n\t\t\t\t\t\tv1 = this.v1,\n\t\t\t\t\t\tv2 = this.v2,\n\t\t\t\t\t\tv3 = this.v3;\n\t\t\tpoint.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v0.copy(source.v0);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\tthis.v3.copy(source.v3);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v0 = this.v0.toArray();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\tdata.v3 = this.v3.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v0.fromArray(json.v0);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\tthis.v3.fromArray(json.v3);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tCubicBezierCurve.prototype.isCubicBezierCurve = true;\n\n\tclass CubicBezierCurve3 extends Curve {\n\t\tconstructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CubicBezierCurve3';\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector3()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst v0 = this.v0,\n\t\t\t\t\t\tv1 = this.v1,\n\t\t\t\t\t\tv2 = this.v2,\n\t\t\t\t\t\tv3 = this.v3;\n\t\t\tpoint.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v0.copy(source.v0);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\tthis.v3.copy(source.v3);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v0 = this.v0.toArray();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\tdata.v3 = this.v3.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v0.fromArray(json.v0);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\tthis.v3.fromArray(json.v3);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\n\n\tclass LineCurve extends Curve {\n\t\tconstructor(v1 = new Vector2(), v2 = new Vector2()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'LineCurve';\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector2()) {\n\t\t\tconst point = optionalTarget;\n\n\t\t\tif (t === 1) {\n\t\t\t\tpoint.copy(this.v2);\n\t\t\t} else {\n\t\t\t\tpoint.copy(this.v2).sub(this.v1);\n\t\t\t\tpoint.multiplyScalar(t).add(this.v1);\n\t\t\t}\n\n\t\t\treturn point;\n\t\t} // Line curve is linear, so we can overwrite default getPointAt\n\n\n\t\tgetPointAt(u, optionalTarget) {\n\t\t\treturn this.getPoint(u, optionalTarget);\n\t\t}\n\n\t\tgetTangent(t, optionalTarget) {\n\t\t\tconst tangent = optionalTarget || new Vector2();\n\t\t\ttangent.copy(this.v2).sub(this.v1).normalize();\n\t\t\treturn tangent;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tLineCurve.prototype.isLineCurve = true;\n\n\tclass LineCurve3 extends Curve {\n\t\tconstructor(v1 = new Vector3(), v2 = new Vector3()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'LineCurve3';\n\t\t\tthis.isLineCurve3 = true;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector3()) {\n\t\t\tconst point = optionalTarget;\n\n\t\t\tif (t === 1) {\n\t\t\t\tpoint.copy(this.v2);\n\t\t\t} else {\n\t\t\t\tpoint.copy(this.v2).sub(this.v1);\n\t\t\t\tpoint.multiplyScalar(t).add(this.v1);\n\t\t\t}\n\n\t\t\treturn point;\n\t\t} // Line curve is linear, so we can overwrite default getPointAt\n\n\n\t\tgetPointAt(u, optionalTarget) {\n\t\t\treturn this.getPoint(u, optionalTarget);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass QuadraticBezierCurve extends Curve {\n\t\tconstructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'QuadraticBezierCurve';\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector2()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst v0 = this.v0,\n\t\t\t\t\t\tv1 = this.v1,\n\t\t\t\t\t\tv2 = this.v2;\n\t\t\tpoint.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v0.copy(source.v0);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v0 = this.v0.toArray();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v0.fromArray(json.v0);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\n\n\tclass QuadraticBezierCurve3 extends Curve {\n\t\tconstructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'QuadraticBezierCurve3';\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector3()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst v0 = this.v0,\n\t\t\t\t\t\tv1 = this.v1,\n\t\t\t\t\t\tv2 = this.v2;\n\t\t\tpoint.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v0.copy(source.v0);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v0 = this.v0.toArray();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v0.fromArray(json.v0);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\n\n\tclass SplineCurve extends Curve {\n\t\tconstructor(points = []) {\n\t\t\tsuper();\n\t\t\tthis.type = 'SplineCurve';\n\t\t\tthis.points = points;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector2()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst points = this.points;\n\t\t\tconst p = (points.length - 1) * t;\n\t\t\tconst intPoint = Math.floor(p);\n\t\t\tconst weight = p - intPoint;\n\t\t\tconst p0 = points[intPoint === 0 ? intPoint : intPoint - 1];\n\t\t\tconst p1 = points[intPoint];\n\t\t\tconst p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];\n\t\t\tconst p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];\n\t\t\tpoint.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.points = [];\n\n\t\t\tfor (let i = 0, l = source.points.length; i < l; i++) {\n\t\t\t\tconst point = source.points[i];\n\t\t\t\tthis.points.push(point.clone());\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.points = [];\n\n\t\t\tfor (let i = 0, l = this.points.length; i < l; i++) {\n\t\t\t\tconst point = this.points[i];\n\t\t\t\tdata.points.push(point.toArray());\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.points = [];\n\n\t\t\tfor (let i = 0, l = json.points.length; i < l; i++) {\n\t\t\t\tconst point = json.points[i];\n\t\t\t\tthis.points.push(new Vector2().fromArray(point));\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tSplineCurve.prototype.isSplineCurve = true;\n\n\tvar Curves = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tArcCurve: ArcCurve,\n\t\tCatmullRomCurve3: CatmullRomCurve3,\n\t\tCubicBezierCurve: CubicBezierCurve,\n\t\tCubicBezierCurve3: CubicBezierCurve3,\n\t\tEllipseCurve: EllipseCurve,\n\t\tLineCurve: LineCurve,\n\t\tLineCurve3: LineCurve3,\n\t\tQuadraticBezierCurve: QuadraticBezierCurve,\n\t\tQuadraticBezierCurve3: QuadraticBezierCurve3,\n\t\tSplineCurve: SplineCurve\n\t});\n\n\t/**************************************************************\n\t *\tCurved Path - a curve path is simply a array of connected\n\t *\tcurves, but retains the api of a curve\n\t **************************************************************/\n\n\tclass CurvePath extends Curve {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'CurvePath';\n\t\t\tthis.curves = [];\n\t\t\tthis.autoClose = false; // Automatically closes the path\n\t\t}\n\n\t\tadd(curve) {\n\t\t\tthis.curves.push(curve);\n\t\t}\n\n\t\tclosePath() {\n\t\t\t// Add a line curve if start and end of lines are not connected\n\t\t\tconst startPoint = this.curves[0].getPoint(0);\n\t\t\tconst endPoint = this.curves[this.curves.length - 1].getPoint(1);\n\n\t\t\tif (!startPoint.equals(endPoint)) {\n\t\t\t\tthis.curves.push(new LineCurve(endPoint, startPoint));\n\t\t\t}\n\t\t} // To get accurate point with reference to\n\t\t// entire path distance at time t,\n\t\t// following has to be done:\n\t\t// 1. Length of each sub path have to be known\n\t\t// 2. Locate and identify type of curve\n\t\t// 3. Get t for the curve\n\t\t// 4. Return curve.getPointAt(t')\n\n\n\t\tgetPoint(t) {\n\t\t\tconst d = t * this.getLength();\n\t\t\tconst curveLengths = this.getCurveLengths();\n\t\t\tlet i = 0; // To think about boundaries points.\n\n\t\t\twhile (i < curveLengths.length) {\n\t\t\t\tif (curveLengths[i] >= d) {\n\t\t\t\t\tconst diff = curveLengths[i] - d;\n\t\t\t\t\tconst curve = this.curves[i];\n\t\t\t\t\tconst segmentLength = curve.getLength();\n\t\t\t\t\tconst u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\t\t\t\t\treturn curve.getPointAt(u);\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\treturn null; // loop where sum != 0, sum > d , sum+1 <d\n\t\t} // We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t// getPoint() depends on getLength\n\n\n\t\tgetLength() {\n\t\t\tconst lens = this.getCurveLengths();\n\t\t\treturn lens[lens.length - 1];\n\t\t} // cacheLengths must be recalculated.\n\n\n\t\tupdateArcLengths() {\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.cacheLengths = null;\n\t\t\tthis.getCurveLengths();\n\t\t} // Compute lengths and cache them\n\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\n\t\tgetCurveLengths() {\n\t\t\t// We use cache values if curves and cache array are same length\n\t\t\tif (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\n\t\t\t\treturn this.cacheLengths;\n\t\t\t} // Get length of sub-curve\n\t\t\t// Push sums into cached array\n\n\n\t\t\tconst lengths = [];\n\t\t\tlet sums = 0;\n\n\t\t\tfor (let i = 0, l = this.curves.length; i < l; i++) {\n\t\t\t\tsums += this.curves[i].getLength();\n\t\t\t\tlengths.push(sums);\n\t\t\t}\n\n\t\t\tthis.cacheLengths = lengths;\n\t\t\treturn lengths;\n\t\t}\n\n\t\tgetSpacedPoints(divisions = 40) {\n\t\t\tconst points = [];\n\n\t\t\tfor (let i = 0; i <= divisions; i++) {\n\t\t\t\tpoints.push(this.getPoint(i / divisions));\n\t\t\t}\n\n\t\t\tif (this.autoClose) {\n\t\t\t\tpoints.push(points[0]);\n\t\t\t}\n\n\t\t\treturn points;\n\t\t}\n\n\t\tgetPoints(divisions = 12) {\n\t\t\tconst points = [];\n\t\t\tlet last;\n\n\t\t\tfor (let i = 0, curves = this.curves; i < curves.length; i++) {\n\t\t\t\tconst curve = curves[i];\n\t\t\t\tconst resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;\n\t\t\t\tconst pts = curve.getPoints(resolution);\n\n\t\t\t\tfor (let j = 0; j < pts.length; j++) {\n\t\t\t\t\tconst point = pts[j];\n\t\t\t\t\tif (last && last.equals(point)) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\t\tpoints.push(point);\n\t\t\t\t\tlast = point;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {\n\t\t\t\tpoints.push(points[0]);\n\t\t\t}\n\n\t\t\treturn points;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.curves = [];\n\n\t\t\tfor (let i = 0, l = source.curves.length; i < l; i++) {\n\t\t\t\tconst curve = source.curves[i];\n\t\t\t\tthis.curves.push(curve.clone());\n\t\t\t}\n\n\t\t\tthis.autoClose = source.autoClose;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.autoClose = this.autoClose;\n\t\t\tdata.curves = [];\n\n\t\t\tfor (let i = 0, l = this.curves.length; i < l; i++) {\n\t\t\t\tconst curve = this.curves[i];\n\t\t\t\tdata.curves.push(curve.toJSON());\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.autoClose = json.autoClose;\n\t\t\tthis.curves = [];\n\n\t\t\tfor (let i = 0, l = json.curves.length; i < l; i++) {\n\t\t\t\tconst curve = json.curves[i];\n\t\t\t\tthis.curves.push(new Curves[curve.type]().fromJSON(curve));\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass Path extends CurvePath {\n\t\tconstructor(points) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Path';\n\t\t\tthis.currentPoint = new Vector2();\n\n\t\t\tif (points) {\n\t\t\t\tthis.setFromPoints(points);\n\t\t\t}\n\t\t}\n\n\t\tsetFromPoints(points) {\n\t\t\tthis.moveTo(points[0].x, points[0].y);\n\n\t\t\tfor (let i = 1, l = points.length; i < l; i++) {\n\t\t\t\tthis.lineTo(points[i].x, points[i].y);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tmoveTo(x, y) {\n\t\t\tthis.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?\n\n\t\t\treturn this;\n\t\t}\n\n\t\tlineTo(x, y) {\n\t\t\tconst curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));\n\t\t\tthis.curves.push(curve);\n\t\t\tthis.currentPoint.set(x, y);\n\t\t\treturn this;\n\t\t}\n\n\t\tquadraticCurveTo(aCPx, aCPy, aX, aY) {\n\t\t\tconst curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));\n\t\t\tthis.curves.push(curve);\n\t\t\tthis.currentPoint.set(aX, aY);\n\t\t\treturn this;\n\t\t}\n\n\t\tbezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n\t\t\tconst curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));\n\t\t\tthis.curves.push(curve);\n\t\t\tthis.currentPoint.set(aX, aY);\n\t\t\treturn this;\n\t\t}\n\n\t\tsplineThru(pts\n\t\t/*Array of Vector*/\n\t\t) {\n\t\t\tconst npts = [this.currentPoint.clone()].concat(pts);\n\t\t\tconst curve = new SplineCurve(npts);\n\t\t\tthis.curves.push(curve);\n\t\t\tthis.currentPoint.copy(pts[pts.length - 1]);\n\t\t\treturn this;\n\t\t}\n\n\t\tarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n\t\t\tconst x0 = this.currentPoint.x;\n\t\t\tconst y0 = this.currentPoint.y;\n\t\t\tthis.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);\n\t\t\treturn this;\n\t\t}\n\n\t\tabsarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n\t\t\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n\t\t\treturn this;\n\t\t}\n\n\t\tellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n\t\t\tconst x0 = this.currentPoint.x;\n\t\t\tconst y0 = this.currentPoint.y;\n\t\t\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n\t\t\treturn this;\n\t\t}\n\n\t\tabsellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n\t\t\tconst curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n\n\t\t\tif (this.curves.length > 0) {\n\t\t\t\t// if a previous curve is present, attempt to join\n\t\t\t\tconst firstPoint = curve.getPoint(0);\n\n\t\t\t\tif (!firstPoint.equals(this.currentPoint)) {\n\t\t\t\t\tthis.lineTo(firstPoint.x, firstPoint.y);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.curves.push(curve);\n\t\t\tconst lastPoint = curve.getPoint(1);\n\t\t\tthis.currentPoint.copy(lastPoint);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.currentPoint.copy(source.currentPoint);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.currentPoint = this.currentPoint.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.currentPoint.fromArray(json.currentPoint);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass Shape extends Path {\n\t\tconstructor(points) {\n\t\t\tsuper(points);\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.type = 'Shape';\n\t\t\tthis.holes = [];\n\t\t}\n\n\t\tgetPointsHoles(divisions) {\n\t\t\tconst holesPts = [];\n\n\t\t\tfor (let i = 0, l = this.holes.length; i < l; i++) {\n\t\t\t\tholesPts[i] = this.holes[i].getPoints(divisions);\n\t\t\t}\n\n\t\t\treturn holesPts;\n\t\t} // get points of shape and holes (keypoints based on segments parameter)\n\n\n\t\textractPoints(divisions) {\n\t\t\treturn {\n\t\t\t\tshape: this.getPoints(divisions),\n\t\t\t\tholes: this.getPointsHoles(divisions)\n\t\t\t};\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.holes = [];\n\n\t\t\tfor (let i = 0, l = source.holes.length; i < l; i++) {\n\t\t\t\tconst hole = source.holes[i];\n\t\t\t\tthis.holes.push(hole.clone());\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.holes = [];\n\n\t\t\tfor (let i = 0, l = this.holes.length; i < l; i++) {\n\t\t\t\tconst hole = this.holes[i];\n\t\t\t\tdata.holes.push(hole.toJSON());\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.uuid = json.uuid;\n\t\t\tthis.holes = [];\n\n\t\t\tfor (let i = 0, l = json.holes.length; i < l; i++) {\n\t\t\t\tconst hole = json.holes[i];\n\t\t\t\tthis.holes.push(new Path().fromJSON(hole));\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass Light extends Object3D {\n\t\tconstructor(color, intensity = 1) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Light';\n\t\t\tthis.color = new Color(color);\n\t\t\tthis.intensity = intensity;\n\t\t}\n\n\t\tdispose() {// Empty here in base class; some subclasses override.\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.intensity = source.intensity;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.object.color = this.color.getHex();\n\t\t\tdata.object.intensity = this.intensity;\n\t\t\tif (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();\n\t\t\tif (this.distance !== undefined) data.object.distance = this.distance;\n\t\t\tif (this.angle !== undefined) data.object.angle = this.angle;\n\t\t\tif (this.decay !== undefined) data.object.decay = this.decay;\n\t\t\tif (this.penumbra !== undefined) data.object.penumbra = this.penumbra;\n\t\t\tif (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tLight.prototype.isLight = true;\n\n\tclass HemisphereLight extends Light {\n\t\tconstructor(skyColor, groundColor, intensity) {\n\t\t\tsuper(skyColor, intensity);\n\t\t\tthis.type = 'HemisphereLight';\n\t\t\tthis.position.copy(Object3D.DefaultUp);\n\t\t\tthis.updateMatrix();\n\t\t\tthis.groundColor = new Color(groundColor);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tLight.prototype.copy.call(this, source);\n\t\t\tthis.groundColor.copy(source.groundColor);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tHemisphereLight.prototype.isHemisphereLight = true;\n\n\tconst _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();\n\n\tconst _lightPositionWorld$1 = /*@__PURE__*/new Vector3();\n\n\tconst _lookTarget$1 = /*@__PURE__*/new Vector3();\n\n\tclass LightShadow {\n\t\tconstructor(camera) {\n\t\t\tthis.camera = camera;\n\t\t\tthis.bias = 0;\n\t\t\tthis.normalBias = 0;\n\t\t\tthis.radius = 1;\n\t\t\tthis.mapSize = new Vector2(512, 512);\n\t\t\tthis.map = null;\n\t\t\tthis.mapPass = null;\n\t\t\tthis.matrix = new Matrix4();\n\t\t\tthis.autoUpdate = true;\n\t\t\tthis.needsUpdate = false;\n\t\t\tthis._frustum = new Frustum();\n\t\t\tthis._frameExtents = new Vector2(1, 1);\n\t\t\tthis._viewportCount = 1;\n\t\t\tthis._viewports = [new Vector4(0, 0, 1, 1)];\n\t\t}\n\n\t\tgetViewportCount() {\n\t\t\treturn this._viewportCount;\n\t\t}\n\n\t\tgetFrustum() {\n\t\t\treturn this._frustum;\n\t\t}\n\n\t\tupdateMatrices(light) {\n\t\t\tconst shadowCamera = this.camera;\n\t\t\tconst shadowMatrix = this.matrix;\n\n\t\t\t_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);\n\n\t\t\tshadowCamera.position.copy(_lightPositionWorld$1);\n\n\t\t\t_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);\n\n\t\t\tshadowCamera.lookAt(_lookTarget$1);\n\t\t\tshadowCamera.updateMatrixWorld();\n\n\t\t\t_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);\n\n\t\t\tthis._frustum.setFromProjectionMatrix(_projScreenMatrix$1);\n\n\t\t\tshadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n\t\t\tshadowMatrix.multiply(shadowCamera.projectionMatrix);\n\t\t\tshadowMatrix.multiply(shadowCamera.matrixWorldInverse);\n\t\t}\n\n\t\tgetViewport(viewportIndex) {\n\t\t\treturn this._viewports[viewportIndex];\n\t\t}\n\n\t\tgetFrameExtents() {\n\t\t\treturn this._frameExtents;\n\t\t}\n\n\t\tdispose() {\n\t\t\tif (this.map) {\n\t\t\t\tthis.map.dispose();\n\t\t\t}\n\n\t\t\tif (this.mapPass) {\n\t\t\t\tthis.mapPass.dispose();\n\t\t\t}\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.camera = source.camera.clone();\n\t\t\tthis.bias = source.bias;\n\t\t\tthis.radius = source.radius;\n\t\t\tthis.mapSize.copy(source.mapSize);\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst object = {};\n\t\t\tif (this.bias !== 0) object.bias = this.bias;\n\t\t\tif (this.normalBias !== 0) object.normalBias = this.normalBias;\n\t\t\tif (this.radius !== 1) object.radius = this.radius;\n\t\t\tif (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();\n\t\t\tobject.camera = this.camera.toJSON(false).object;\n\t\t\tdelete object.camera.matrix;\n\t\t\treturn object;\n\t\t}\n\n\t}\n\n\tclass SpotLightShadow extends LightShadow {\n\t\tconstructor() {\n\t\t\tsuper(new PerspectiveCamera(50, 1, 0.5, 500));\n\t\t\tthis.focus = 1;\n\t\t}\n\n\t\tupdateMatrices(light) {\n\t\t\tconst camera = this.camera;\n\t\t\tconst fov = RAD2DEG * 2 * light.angle * this.focus;\n\t\t\tconst aspect = this.mapSize.width / this.mapSize.height;\n\t\t\tconst far = light.distance || camera.far;\n\n\t\t\tif (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {\n\t\t\t\tcamera.fov = fov;\n\t\t\t\tcamera.aspect = aspect;\n\t\t\t\tcamera.far = far;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t}\n\n\t\t\tsuper.updateMatrices(light);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.focus = source.focus;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tSpotLightShadow.prototype.isSpotLightShadow = true;\n\n\tclass SpotLight extends Light {\n\t\tconstructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {\n\t\t\tsuper(color, intensity);\n\t\t\tthis.type = 'SpotLight';\n\t\t\tthis.position.copy(Object3D.DefaultUp);\n\t\t\tthis.updateMatrix();\n\t\t\tthis.target = new Object3D();\n\t\t\tthis.distance = distance;\n\t\t\tthis.angle = angle;\n\t\t\tthis.penumbra = penumbra;\n\t\t\tthis.decay = decay; // for physically correct lights, should be 2.\n\n\t\t\tthis.shadow = new SpotLightShadow();\n\t\t}\n\n\t\tget power() {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\treturn this.intensity * Math.PI;\n\t\t}\n\n\t\tset power(power) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\tthis.intensity = power / Math.PI;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.shadow.dispose();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.angle = source.angle;\n\t\t\tthis.penumbra = source.penumbra;\n\t\t\tthis.decay = source.decay;\n\t\t\tthis.target = source.target.clone();\n\t\t\tthis.shadow = source.shadow.clone();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tSpotLight.prototype.isSpotLight = true;\n\n\tconst _projScreenMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _lightPositionWorld = /*@__PURE__*/new Vector3();\n\n\tconst _lookTarget = /*@__PURE__*/new Vector3();\n\n\tclass PointLightShadow extends LightShadow {\n\t\tconstructor() {\n\t\t\tsuper(new PerspectiveCamera(90, 1, 0.5, 500));\n\t\t\tthis._frameExtents = new Vector2(4, 2);\n\t\t\tthis._viewportCount = 6;\n\t\t\tthis._viewports = [// These viewports map a cube-map onto a 2D texture with the\n\t\t\t// following orientation:\n\t\t\t//\n\t\t\t//\txzXZ\n\t\t\t//\t y Y\n\t\t\t//\n\t\t\t// X - Positive x direction\n\t\t\t// x - Negative x direction\n\t\t\t// Y - Positive y direction\n\t\t\t// y - Negative y direction\n\t\t\t// Z - Positive z direction\n\t\t\t// z - Negative z direction\n\t\t\t// positive X\n\t\t\tnew Vector4(2, 1, 1, 1), // negative X\n\t\t\tnew Vector4(0, 1, 1, 1), // positive Z\n\t\t\tnew Vector4(3, 1, 1, 1), // negative Z\n\t\t\tnew Vector4(1, 1, 1, 1), // positive Y\n\t\t\tnew Vector4(3, 0, 1, 1), // negative Y\n\t\t\tnew Vector4(1, 0, 1, 1)];\n\t\t\tthis._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];\n\t\t\tthis._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];\n\t\t}\n\n\t\tupdateMatrices(light, viewportIndex = 0) {\n\t\t\tconst camera = this.camera;\n\t\t\tconst shadowMatrix = this.matrix;\n\t\t\tconst far = light.distance || camera.far;\n\n\t\t\tif (far !== camera.far) {\n\t\t\t\tcamera.far = far;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t}\n\n\t\t\t_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);\n\n\t\t\tcamera.position.copy(_lightPositionWorld);\n\n\t\t\t_lookTarget.copy(camera.position);\n\n\t\t\t_lookTarget.add(this._cubeDirections[viewportIndex]);\n\n\t\t\tcamera.up.copy(this._cubeUps[viewportIndex]);\n\t\t\tcamera.lookAt(_lookTarget);\n\t\t\tcamera.updateMatrixWorld();\n\t\t\tshadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);\n\n\t\t\t_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n\n\t\t\tthis._frustum.setFromProjectionMatrix(_projScreenMatrix);\n\t\t}\n\n\t}\n\n\tPointLightShadow.prototype.isPointLightShadow = true;\n\n\tclass PointLight extends Light {\n\t\tconstructor(color, intensity, distance = 0, decay = 1) {\n\t\t\tsuper(color, intensity);\n\t\t\tthis.type = 'PointLight';\n\t\t\tthis.distance = distance;\n\t\t\tthis.decay = decay; // for physically correct lights, should be 2.\n\n\t\t\tthis.shadow = new PointLightShadow();\n\t\t}\n\n\t\tget power() {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\treturn this.intensity * 4 * Math.PI;\n\t\t}\n\n\t\tset power(power) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\tthis.intensity = power / (4 * Math.PI);\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.shadow.dispose();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.decay = source.decay;\n\t\t\tthis.shadow = source.shadow.clone();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tPointLight.prototype.isPointLight = true;\n\n\tclass OrthographicCamera extends Camera {\n\t\tconstructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {\n\t\t\tsuper();\n\t\t\tthis.type = 'OrthographicCamera';\n\t\t\tthis.zoom = 1;\n\t\t\tthis.view = null;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t\tthis.top = top;\n\t\t\tthis.bottom = bottom;\n\t\t\tthis.near = near;\n\t\t\tthis.far = far;\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tcopy(source, recursive) {\n\t\t\tsuper.copy(source, recursive);\n\t\t\tthis.left = source.left;\n\t\t\tthis.right = source.right;\n\t\t\tthis.top = source.top;\n\t\t\tthis.bottom = source.bottom;\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\t\t\tthis.zoom = source.zoom;\n\t\t\tthis.view = source.view === null ? null : Object.assign({}, source.view);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetViewOffset(fullWidth, fullHeight, x, y, width, height) {\n\t\t\tif (this.view === null) {\n\t\t\t\tthis.view = {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tfullWidth: 1,\n\t\t\t\t\tfullHeight: 1,\n\t\t\t\t\toffsetX: 0,\n\t\t\t\t\toffsetY: 0,\n\t\t\t\t\twidth: 1,\n\t\t\t\t\theight: 1\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis.view.enabled = true;\n\t\t\tthis.view.fullWidth = fullWidth;\n\t\t\tthis.view.fullHeight = fullHeight;\n\t\t\tthis.view.offsetX = x;\n\t\t\tthis.view.offsetY = y;\n\t\t\tthis.view.width = width;\n\t\t\tthis.view.height = height;\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tclearViewOffset() {\n\t\t\tif (this.view !== null) {\n\t\t\t\tthis.view.enabled = false;\n\t\t\t}\n\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tupdateProjectionMatrix() {\n\t\t\tconst dx = (this.right - this.left) / (2 * this.zoom);\n\t\t\tconst dy = (this.top - this.bottom) / (2 * this.zoom);\n\t\t\tconst cx = (this.right + this.left) / 2;\n\t\t\tconst cy = (this.top + this.bottom) / 2;\n\t\t\tlet left = cx - dx;\n\t\t\tlet right = cx + dx;\n\t\t\tlet top = cy + dy;\n\t\t\tlet bottom = cy - dy;\n\n\t\t\tif (this.view !== null && this.view.enabled) {\n\t\t\t\tconst scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;\n\t\t\t\tconst scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n\t\t\t\tleft += scaleW * this.view.offsetX;\n\t\t\t\tright = left + scaleW * this.view.width;\n\t\t\t\ttop -= scaleH * this.view.offsetY;\n\t\t\t\tbottom = top - scaleH * this.view.height;\n\t\t\t}\n\n\t\t\tthis.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);\n\t\t\tthis.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.object.zoom = this.zoom;\n\t\t\tdata.object.left = this.left;\n\t\t\tdata.object.right = this.right;\n\t\t\tdata.object.top = this.top;\n\t\t\tdata.object.bottom = this.bottom;\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\t\t\tif (this.view !== null) data.object.view = Object.assign({}, this.view);\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tOrthographicCamera.prototype.isOrthographicCamera = true;\n\n\tclass DirectionalLightShadow extends LightShadow {\n\t\tconstructor() {\n\t\t\tsuper(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));\n\t\t}\n\n\t}\n\n\tDirectionalLightShadow.prototype.isDirectionalLightShadow = true;\n\n\tclass DirectionalLight extends Light {\n\t\tconstructor(color, intensity) {\n\t\t\tsuper(color, intensity);\n\t\t\tthis.type = 'DirectionalLight';\n\t\t\tthis.position.copy(Object3D.DefaultUp);\n\t\t\tthis.updateMatrix();\n\t\t\tthis.target = new Object3D();\n\t\t\tthis.shadow = new DirectionalLightShadow();\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.shadow.dispose();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.target = source.target.clone();\n\t\t\tthis.shadow = source.shadow.clone();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tDirectionalLight.prototype.isDirectionalLight = true;\n\n\tclass AmbientLight extends Light {\n\t\tconstructor(color, intensity) {\n\t\t\tsuper(color, intensity);\n\t\t\tthis.type = 'AmbientLight';\n\t\t}\n\n\t}\n\n\tAmbientLight.prototype.isAmbientLight = true;\n\n\tclass RectAreaLight extends Light {\n\t\tconstructor(color, intensity, width = 10, height = 10) {\n\t\t\tsuper(color, intensity);\n\t\t\tthis.type = 'RectAreaLight';\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.object.width = this.width;\n\t\t\tdata.object.height = this.height;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tRectAreaLight.prototype.isRectAreaLight = true;\n\n\t/**\n\t * Primary reference:\n\t *\t https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\t *\n\t * Secondary reference:\n\t *\t https://www.ppsloan.org/publications/StupidSH36.pdf\n\t */\n\t// 3-band SH defined by 9 coefficients\n\n\tclass SphericalHarmonics3 {\n\t\tconstructor() {\n\t\t\tthis.coefficients = [];\n\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients.push(new Vector3());\n\t\t\t}\n\t\t}\n\n\t\tset(coefficients) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].copy(coefficients[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tzero() {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].set(0, 0, 0);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // get the radiance in the direction of the normal\n\t\t// target is a Vector3\n\n\n\t\tgetAt(normal, target) {\n\t\t\t// normal is assumed to be unit length\n\t\t\tconst x = normal.x,\n\t\t\t\t\t\ty = normal.y,\n\t\t\t\t\t\tz = normal.z;\n\t\t\tconst coeff = this.coefficients; // band 0\n\n\t\t\ttarget.copy(coeff[0]).multiplyScalar(0.282095); // band 1\n\n\t\t\ttarget.addScaledVector(coeff[1], 0.488603 * y);\n\t\t\ttarget.addScaledVector(coeff[2], 0.488603 * z);\n\t\t\ttarget.addScaledVector(coeff[3], 0.488603 * x); // band 2\n\n\t\t\ttarget.addScaledVector(coeff[4], 1.092548 * (x * y));\n\t\t\ttarget.addScaledVector(coeff[5], 1.092548 * (y * z));\n\t\t\ttarget.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));\n\t\t\ttarget.addScaledVector(coeff[7], 1.092548 * (x * z));\n\t\t\ttarget.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));\n\t\t\treturn target;\n\t\t} // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n\t\t// target is a Vector3\n\t\t// https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\n\n\t\tgetIrradianceAt(normal, target) {\n\t\t\t// normal is assumed to be unit length\n\t\t\tconst x = normal.x,\n\t\t\t\t\t\ty = normal.y,\n\t\t\t\t\t\tz = normal.z;\n\t\t\tconst coeff = this.coefficients; // band 0\n\n\t\t\ttarget.copy(coeff[0]).multiplyScalar(0.886227); //  * 0.282095\n\t\t\t// band 1\n\n\t\t\ttarget.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 *  / 3 ) * 0.488603\n\n\t\t\ttarget.addScaledVector(coeff[2], 2.0 * 0.511664 * z);\n\t\t\ttarget.addScaledVector(coeff[3], 2.0 * 0.511664 * x); // band 2\n\n\t\t\ttarget.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // (  / 4 ) * 1.092548\n\n\t\t\ttarget.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);\n\t\t\ttarget.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // (  / 4 ) * 0.315392 * 3\n\n\t\t\ttarget.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);\n\t\t\ttarget.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // (  / 4 ) * 0.546274\n\n\t\t\treturn target;\n\t\t}\n\n\t\tadd(sh) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].add(sh.coefficients[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\taddScaledSH(sh, s) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].addScaledVector(sh.coefficients[i], s);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tscale(s) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].multiplyScalar(s);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tlerp(sh, alpha) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].lerp(sh.coefficients[i], alpha);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(sh) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tif (!this.coefficients[i].equals(sh.coefficients[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tcopy(sh) {\n\t\t\treturn this.set(sh.coefficients);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tconst coefficients = this.coefficients;\n\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tcoefficients[i].fromArray(array, offset + i * 3);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tconst coefficients = this.coefficients;\n\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tcoefficients[i].toArray(array, offset + i * 3);\n\t\t\t}\n\n\t\t\treturn array;\n\t\t} // evaluate the basis functions\n\t\t// shBasis is an Array[ 9 ]\n\n\n\t\tstatic getBasisAt(normal, shBasis) {\n\t\t\t// normal is assumed to be unit length\n\t\t\tconst x = normal.x,\n\t\t\t\t\t\ty = normal.y,\n\t\t\t\t\t\tz = normal.z; // band 0\n\n\t\t\tshBasis[0] = 0.282095; // band 1\n\n\t\t\tshBasis[1] = 0.488603 * y;\n\t\t\tshBasis[2] = 0.488603 * z;\n\t\t\tshBasis[3] = 0.488603 * x; // band 2\n\n\t\t\tshBasis[4] = 1.092548 * x * y;\n\t\t\tshBasis[5] = 1.092548 * y * z;\n\t\t\tshBasis[6] = 0.315392 * (3 * z * z - 1);\n\t\t\tshBasis[7] = 1.092548 * x * z;\n\t\t\tshBasis[8] = 0.546274 * (x * x - y * y);\n\t\t}\n\n\t}\n\n\tSphericalHarmonics3.prototype.isSphericalHarmonics3 = true;\n\n\tclass LightProbe extends Light {\n\t\tconstructor(sh = new SphericalHarmonics3(), intensity = 1) {\n\t\t\tsuper(undefined, intensity);\n\t\t\tthis.sh = sh;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.sh.copy(source.sh);\n\t\t\treturn this;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tthis.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();\n\n\t\t\tthis.sh.fromArray(json.sh);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.object.sh = this.sh.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tLightProbe.prototype.isLightProbe = true;\n\n\tclass MaterialLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t\tthis.textures = {};\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst loader = new FileLoader(scope.manager);\n\t\t\tloader.setPath(scope.path);\n\t\t\tloader.setRequestHeader(scope.requestHeader);\n\t\t\tloader.setWithCredentials(scope.withCredentials);\n\t\t\tloader.load(url, function (text) {\n\t\t\t\ttry {\n\t\t\t\t\tonLoad(scope.parse(JSON.parse(text)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onError) {\n\t\t\t\t\t\tonError(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t\tparse(json) {\n\t\t\tconst textures = this.textures;\n\n\t\t\tfunction getTexture(name) {\n\t\t\t\tif (textures[name] === undefined) {\n\t\t\t\t\tconsole.warn('THREE.MaterialLoader: Undefined texture', name);\n\t\t\t\t}\n\n\t\t\t\treturn textures[name];\n\t\t\t}\n\n\t\t\tconst material = new Materials[json.type]();\n\t\t\tif (json.uuid !== undefined) material.uuid = json.uuid;\n\t\t\tif (json.name !== undefined) material.name = json.name;\n\t\t\tif (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);\n\t\t\tif (json.roughness !== undefined) material.roughness = json.roughness;\n\t\t\tif (json.metalness !== undefined) material.metalness = json.metalness;\n\t\t\tif (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);\n\t\t\tif (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);\n\t\t\tif (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);\n\t\t\tif (json.shininess !== undefined) material.shininess = json.shininess;\n\t\t\tif (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;\n\t\t\tif (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;\n\t\t\tif (json.transmission !== undefined) material.transmission = json.transmission;\n\t\t\tif (json.thickness !== undefined) material.thickness = json.thickness;\n\t\t\tif (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;\n\t\t\tif (json.attenuationColor !== undefined && material.attenuationColor !== undefined) material.attenuationColor.setHex(json.attenuationColor);\n\t\t\tif (json.fog !== undefined) material.fog = json.fog;\n\t\t\tif (json.flatShading !== undefined) material.flatShading = json.flatShading;\n\t\t\tif (json.blending !== undefined) material.blending = json.blending;\n\t\t\tif (json.combine !== undefined) material.combine = json.combine;\n\t\t\tif (json.side !== undefined) material.side = json.side;\n\t\t\tif (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;\n\t\t\tif (json.opacity !== undefined) material.opacity = json.opacity;\n\t\t\tif (json.transparent !== undefined) material.transparent = json.transparent;\n\t\t\tif (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;\n\t\t\tif (json.depthTest !== undefined) material.depthTest = json.depthTest;\n\t\t\tif (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;\n\t\t\tif (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;\n\t\t\tif (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;\n\t\t\tif (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;\n\t\t\tif (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;\n\t\t\tif (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;\n\t\t\tif (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;\n\t\t\tif (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;\n\t\t\tif (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;\n\t\t\tif (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;\n\t\t\tif (json.wireframe !== undefined) material.wireframe = json.wireframe;\n\t\t\tif (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\t\tif (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;\n\t\t\tif (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;\n\t\t\tif (json.rotation !== undefined) material.rotation = json.rotation;\n\t\t\tif (json.linewidth !== 1) material.linewidth = json.linewidth;\n\t\t\tif (json.dashSize !== undefined) material.dashSize = json.dashSize;\n\t\t\tif (json.gapSize !== undefined) material.gapSize = json.gapSize;\n\t\t\tif (json.scale !== undefined) material.scale = json.scale;\n\t\t\tif (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;\n\t\t\tif (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;\n\t\t\tif (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;\n\t\t\tif (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;\n\t\t\tif (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;\n\t\t\tif (json.dithering !== undefined) material.dithering = json.dithering;\n\t\t\tif (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;\n\t\t\tif (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;\n\t\t\tif (json.vertexTangents !== undefined) material.vertexTangents = json.vertexTangents;\n\t\t\tif (json.visible !== undefined) material.visible = json.visible;\n\t\t\tif (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;\n\t\t\tif (json.userData !== undefined) material.userData = json.userData;\n\n\t\t\tif (json.vertexColors !== undefined) {\n\t\t\t\tif (typeof json.vertexColors === 'number') {\n\t\t\t\t\tmaterial.vertexColors = json.vertexColors > 0 ? true : false;\n\t\t\t\t} else {\n\t\t\t\t\tmaterial.vertexColors = json.vertexColors;\n\t\t\t\t}\n\t\t\t} // Shader Material\n\n\n\t\t\tif (json.uniforms !== undefined) {\n\t\t\t\tfor (const name in json.uniforms) {\n\t\t\t\t\tconst uniform = json.uniforms[name];\n\t\t\t\t\tmaterial.uniforms[name] = {};\n\n\t\t\t\t\tswitch (uniform.type) {\n\t\t\t\t\t\tcase 't':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = getTexture(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Color().setHex(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'v2':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Vector2().fromArray(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'v3':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Vector3().fromArray(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'v4':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Vector4().fromArray(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'm3':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Matrix3().fromArray(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'm4':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Matrix4().fromArray(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = uniform.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (json.defines !== undefined) material.defines = json.defines;\n\t\t\tif (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;\n\t\t\tif (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;\n\n\t\t\tif (json.extensions !== undefined) {\n\t\t\t\tfor (const key in json.extensions) {\n\t\t\t\t\tmaterial.extensions[key] = json.extensions[key];\n\t\t\t\t}\n\t\t\t} // Deprecated\n\n\n\t\t\tif (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading\n\t\t\t// for PointsMaterial\n\n\t\t\tif (json.size !== undefined) material.size = json.size;\n\t\t\tif (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps\n\n\t\t\tif (json.map !== undefined) material.map = getTexture(json.map);\n\t\t\tif (json.matcap !== undefined) material.matcap = getTexture(json.matcap);\n\t\t\tif (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);\n\t\t\tif (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);\n\t\t\tif (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;\n\t\t\tif (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);\n\t\t\tif (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;\n\n\t\t\tif (json.normalScale !== undefined) {\n\t\t\t\tlet normalScale = json.normalScale;\n\n\t\t\t\tif (Array.isArray(normalScale) === false) {\n\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\t\t\t\t\tnormalScale = [normalScale, normalScale];\n\t\t\t\t}\n\n\t\t\t\tmaterial.normalScale = new Vector2().fromArray(normalScale);\n\t\t\t}\n\n\t\t\tif (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);\n\t\t\tif (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;\n\t\t\tif (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;\n\t\t\tif (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);\n\t\t\tif (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);\n\t\t\tif (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);\n\t\t\tif (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;\n\t\t\tif (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);\n\t\t\tif (json.envMap !== undefined) material.envMap = getTexture(json.envMap);\n\t\t\tif (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;\n\t\t\tif (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;\n\t\t\tif (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;\n\t\t\tif (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);\n\t\t\tif (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;\n\t\t\tif (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);\n\t\t\tif (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;\n\t\t\tif (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);\n\t\t\tif (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);\n\t\t\tif (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);\n\t\t\tif (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);\n\t\t\tif (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);\n\t\t\tif (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);\n\t\t\tif (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);\n\t\t\treturn material;\n\t\t}\n\n\t\tsetTextures(value) {\n\t\t\tthis.textures = value;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass LoaderUtils {\n\t\tstatic decodeText(array) {\n\t\t\tif (typeof TextDecoder !== 'undefined') {\n\t\t\t\treturn new TextDecoder().decode(array);\n\t\t\t} // Avoid the String.fromCharCode.apply(null, array) shortcut, which\n\t\t\t// throws a \"maximum call stack size exceeded\" error for large arrays.\n\n\n\t\t\tlet s = '';\n\n\t\t\tfor (let i = 0, il = array.length; i < il; i++) {\n\t\t\t\t// Implicitly assumes little-endian.\n\t\t\t\ts += String.fromCharCode(array[i]);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// merges multi-byte utf-8 characters.\n\t\t\t\treturn decodeURIComponent(escape(s));\n\t\t\t} catch (e) {\n\t\t\t\t// see #16358\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\n\t\tstatic extractUrlBase(url) {\n\t\t\tconst index = url.lastIndexOf('/');\n\t\t\tif (index === -1) return './';\n\t\t\treturn url.substr(0, index + 1);\n\t\t}\n\n\t}\n\n\tclass InstancedBufferGeometry extends BufferGeometry {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'InstancedBufferGeometry';\n\t\t\tthis.instanceCount = Infinity;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.instanceCount = source.instanceCount;\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON(this);\n\t\t\tdata.instanceCount = this.instanceCount;\n\t\t\tdata.isInstancedBufferGeometry = true;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tInstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;\n\n\tclass InstancedBufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized, meshPerAttribute) {\n\t\t\tif (typeof normalized === 'number') {\n\t\t\t\tmeshPerAttribute = normalized;\n\t\t\t\tnormalized = false;\n\t\t\t\tconsole.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');\n\t\t\t}\n\n\t\t\tsuper(array, itemSize, normalized);\n\t\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.meshPerAttribute = this.meshPerAttribute;\n\t\t\tdata.isInstancedBufferAttribute = true;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tInstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;\n\n\tclass BufferGeometryLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst loader = new FileLoader(scope.manager);\n\t\t\tloader.setPath(scope.path);\n\t\t\tloader.setRequestHeader(scope.requestHeader);\n\t\t\tloader.setWithCredentials(scope.withCredentials);\n\t\t\tloader.load(url, function (text) {\n\t\t\t\ttry {\n\t\t\t\t\tonLoad(scope.parse(JSON.parse(text)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onError) {\n\t\t\t\t\t\tonError(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t\tparse(json) {\n\t\t\tconst interleavedBufferMap = {};\n\t\t\tconst arrayBufferMap = {};\n\n\t\t\tfunction getInterleavedBuffer(json, uuid) {\n\t\t\t\tif (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];\n\t\t\t\tconst interleavedBuffers = json.interleavedBuffers;\n\t\t\t\tconst interleavedBuffer = interleavedBuffers[uuid];\n\t\t\t\tconst buffer = getArrayBuffer(json, interleavedBuffer.buffer);\n\t\t\t\tconst array = getTypedArray(interleavedBuffer.type, buffer);\n\t\t\t\tconst ib = new InterleavedBuffer(array, interleavedBuffer.stride);\n\t\t\t\tib.uuid = interleavedBuffer.uuid;\n\t\t\t\tinterleavedBufferMap[uuid] = ib;\n\t\t\t\treturn ib;\n\t\t\t}\n\n\t\t\tfunction getArrayBuffer(json, uuid) {\n\t\t\t\tif (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];\n\t\t\t\tconst arrayBuffers = json.arrayBuffers;\n\t\t\t\tconst arrayBuffer = arrayBuffers[uuid];\n\t\t\t\tconst ab = new Uint32Array(arrayBuffer).buffer;\n\t\t\t\tarrayBufferMap[uuid] = ab;\n\t\t\t\treturn ab;\n\t\t\t}\n\n\t\t\tconst geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n\t\t\tconst index = json.data.index;\n\n\t\t\tif (index !== undefined) {\n\t\t\t\tconst typedArray = getTypedArray(index.type, index.array);\n\t\t\t\tgeometry.setIndex(new BufferAttribute(typedArray, 1));\n\t\t\t}\n\n\t\t\tconst attributes = json.data.attributes;\n\n\t\t\tfor (const key in attributes) {\n\t\t\t\tconst attribute = attributes[key];\n\t\t\t\tlet bufferAttribute;\n\n\t\t\t\tif (attribute.isInterleavedBufferAttribute) {\n\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);\n\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);\n\t\t\t\t} else {\n\t\t\t\t\tconst typedArray = getTypedArray(attribute.type, attribute.array);\n\t\t\t\t\tconst bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n\t\t\t\t\tbufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);\n\t\t\t\t}\n\n\t\t\t\tif (attribute.name !== undefined) bufferAttribute.name = attribute.name;\n\t\t\t\tif (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);\n\n\t\t\t\tif (attribute.updateRange !== undefined) {\n\t\t\t\t\tbufferAttribute.updateRange.offset = attribute.updateRange.offset;\n\t\t\t\t\tbufferAttribute.updateRange.count = attribute.updateRange.count;\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute(key, bufferAttribute);\n\t\t\t}\n\n\t\t\tconst morphAttributes = json.data.morphAttributes;\n\n\t\t\tif (morphAttributes) {\n\t\t\t\tfor (const key in morphAttributes) {\n\t\t\t\t\tconst attributeArray = morphAttributes[key];\n\t\t\t\t\tconst array = [];\n\n\t\t\t\t\tfor (let i = 0, il = attributeArray.length; i < il; i++) {\n\t\t\t\t\t\tconst attribute = attributeArray[i];\n\t\t\t\t\t\tlet bufferAttribute;\n\n\t\t\t\t\t\tif (attribute.isInterleavedBufferAttribute) {\n\t\t\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);\n\t\t\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst typedArray = getTypedArray(attribute.type, attribute.array);\n\t\t\t\t\t\t\tbufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (attribute.name !== undefined) bufferAttribute.name = attribute.name;\n\t\t\t\t\t\tarray.push(bufferAttribute);\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.morphAttributes[key] = array;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst morphTargetsRelative = json.data.morphTargetsRelative;\n\n\t\t\tif (morphTargetsRelative) {\n\t\t\t\tgeometry.morphTargetsRelative = true;\n\t\t\t}\n\n\t\t\tconst groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\t\tif (groups !== undefined) {\n\t\t\t\tfor (let i = 0, n = groups.length; i !== n; ++i) {\n\t\t\t\t\tconst group = groups[i];\n\t\t\t\t\tgeometry.addGroup(group.start, group.count, group.materialIndex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst boundingSphere = json.data.boundingSphere;\n\n\t\t\tif (boundingSphere !== undefined) {\n\t\t\t\tconst center = new Vector3();\n\n\t\t\t\tif (boundingSphere.center !== undefined) {\n\t\t\t\t\tcenter.fromArray(boundingSphere.center);\n\t\t\t\t}\n\n\t\t\t\tgeometry.boundingSphere = new Sphere(center, boundingSphere.radius);\n\t\t\t}\n\n\t\t\tif (json.name) geometry.name = json.name;\n\t\t\tif (json.userData) geometry.userData = json.userData;\n\t\t\treturn geometry;\n\t\t}\n\n\t}\n\n\tclass ObjectLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n\t\t\tthis.resourcePath = this.resourcePath || path;\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setWithCredentials(this.withCredentials);\n\t\t\tloader.load(url, function (text) {\n\t\t\t\tlet json = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tjson = JSON.parse(text);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (onError !== undefined) onError(error);\n\t\t\t\t\tconsole.error('THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst metadata = json.metadata;\n\n\t\t\t\tif (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {\n\t\t\t\t\tconsole.error('THREE.ObjectLoader: Can\\'t load ' + url);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tscope.parse(json, onLoad);\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t\tparse(json, onLoad) {\n\t\t\tconst animations = this.parseAnimations(json.animations);\n\t\t\tconst shapes = this.parseShapes(json.shapes);\n\t\t\tconst geometries = this.parseGeometries(json.geometries, shapes);\n\t\t\tconst images = this.parseImages(json.images, function () {\n\t\t\t\tif (onLoad !== undefined) onLoad(object);\n\t\t\t});\n\t\t\tconst textures = this.parseTextures(json.textures, images);\n\t\t\tconst materials = this.parseMaterials(json.materials, textures);\n\t\t\tconst object = this.parseObject(json.object, geometries, materials, animations);\n\t\t\tconst skeletons = this.parseSkeletons(json.skeletons, object);\n\t\t\tthis.bindSkeletons(object, skeletons); //\n\n\t\t\tif (onLoad !== undefined) {\n\t\t\t\tlet hasImages = false;\n\n\t\t\t\tfor (const uuid in images) {\n\t\t\t\t\tif (images[uuid] instanceof HTMLImageElement) {\n\t\t\t\t\t\thasImages = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (hasImages === false) onLoad(object);\n\t\t\t}\n\n\t\t\treturn object;\n\t\t}\n\n\t\tparseShapes(json) {\n\t\t\tconst shapes = {};\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tfor (let i = 0, l = json.length; i < l; i++) {\n\t\t\t\t\tconst shape = new Shape().fromJSON(json[i]);\n\t\t\t\t\tshapes[shape.uuid] = shape;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn shapes;\n\t\t}\n\n\t\tparseSkeletons(json, object) {\n\t\t\tconst skeletons = {};\n\t\t\tconst bones = {}; // generate bone lookup table\n\n\t\t\tobject.traverse(function (child) {\n\t\t\t\tif (child.isBone) bones[child.uuid] = child;\n\t\t\t}); // create skeletons\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tfor (let i = 0, l = json.length; i < l; i++) {\n\t\t\t\t\tconst skeleton = new Skeleton().fromJSON(json[i], bones);\n\t\t\t\t\tskeletons[skeleton.uuid] = skeleton;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn skeletons;\n\t\t}\n\n\t\tparseGeometries(json, shapes) {\n\t\t\tconst geometries = {};\n\t\t\tlet geometryShapes;\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tconst bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\t\tfor (let i = 0, l = json.length; i < l; i++) {\n\t\t\t\t\tlet geometry;\n\t\t\t\t\tconst data = json[i];\n\n\t\t\t\t\tswitch (data.type) {\n\t\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\t\tcase 'PlaneBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\t\tcase 'CircleBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\t\tcase 'CylinderBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\t\tcase 'ConeBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\t\tcase 'SphereBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\t\tcase 'DodecahedronBufferGeometry':\n\t\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\t\tcase 'IcosahedronBufferGeometry':\n\t\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\t\tcase 'OctahedronBufferGeometry':\n\t\t\t\t\t\tcase 'TetrahedronGeometry':\n\t\t\t\t\t\tcase 'TetrahedronBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.detail);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\t\tcase 'RingBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\t\tcase 'TorusBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TubeGeometry':\n\t\t\t\t\t\tcase 'TubeBufferGeometry':\n\t\t\t\t\t\t\t// This only works for built-in curves (e.g. CatmullRomCurve3).\n\t\t\t\t\t\t\t// User defined curves or instances of CurvePath will not be deserialized.\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\t\tcase 'LatheBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'PolyhedronGeometry':\n\t\t\t\t\t\tcase 'PolyhedronBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ShapeGeometry':\n\t\t\t\t\t\tcase 'ShapeBufferGeometry':\n\t\t\t\t\t\t\tgeometryShapes = [];\n\n\t\t\t\t\t\t\tfor (let j = 0, jl = data.shapes.length; j < jl; j++) {\n\t\t\t\t\t\t\t\tconst shape = shapes[data.shapes[j]];\n\t\t\t\t\t\t\t\tgeometryShapes.push(shape);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](geometryShapes, data.curveSegments);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ExtrudeGeometry':\n\t\t\t\t\t\tcase 'ExtrudeBufferGeometry':\n\t\t\t\t\t\t\tgeometryShapes = [];\n\n\t\t\t\t\t\t\tfor (let j = 0, jl = data.shapes.length; j < jl; j++) {\n\t\t\t\t\t\t\t\tconst shape = shapes[data.shapes[j]];\n\t\t\t\t\t\t\t\tgeometryShapes.push(shape);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst extrudePath = data.options.extrudePath;\n\n\t\t\t\t\t\t\tif (extrudePath !== undefined) {\n\t\t\t\t\t\t\t\tdata.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](geometryShapes, data.options);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BufferGeometry':\n\t\t\t\t\t\tcase 'InstancedBufferGeometry':\n\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse(data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Geometry':\n\t\t\t\t\t\t\tconsole.error('THREE.ObjectLoader: Loading \"Geometry\" is not supported anymore.');\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn('THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"');\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.uuid = data.uuid;\n\t\t\t\t\tif (data.name !== undefined) geometry.name = data.name;\n\t\t\t\t\tif (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;\n\t\t\t\t\tgeometries[data.uuid] = geometry;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn geometries;\n\t\t}\n\n\t\tparseMaterials(json, textures) {\n\t\t\tconst cache = {}; // MultiMaterial\n\n\t\t\tconst materials = {};\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tconst loader = new MaterialLoader();\n\t\t\t\tloader.setTextures(textures);\n\n\t\t\t\tfor (let i = 0, l = json.length; i < l; i++) {\n\t\t\t\t\tconst data = json[i];\n\n\t\t\t\t\tif (data.type === 'MultiMaterial') {\n\t\t\t\t\t\t// Deprecated\n\t\t\t\t\t\tconst array = [];\n\n\t\t\t\t\t\tfor (let j = 0; j < data.materials.length; j++) {\n\t\t\t\t\t\t\tconst material = data.materials[j];\n\n\t\t\t\t\t\t\tif (cache[material.uuid] === undefined) {\n\t\t\t\t\t\t\t\tcache[material.uuid] = loader.parse(material);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tarray.push(cache[material.uuid]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterials[data.uuid] = array;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cache[data.uuid] === undefined) {\n\t\t\t\t\t\t\tcache[data.uuid] = loader.parse(data);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterials[data.uuid] = cache[data.uuid];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn materials;\n\t\t}\n\n\t\tparseAnimations(json) {\n\t\t\tconst animations = {};\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tfor (let i = 0; i < json.length; i++) {\n\t\t\t\t\tconst data = json[i];\n\t\t\t\t\tconst clip = AnimationClip.parse(data);\n\t\t\t\t\tanimations[clip.uuid] = clip;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn animations;\n\t\t}\n\n\t\tparseImages(json, onLoad) {\n\t\t\tconst scope = this;\n\t\t\tconst images = {};\n\t\t\tlet loader;\n\n\t\t\tfunction loadImage(url) {\n\t\t\t\tscope.manager.itemStart(url);\n\t\t\t\treturn loader.load(url, function () {\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, undefined, function () {\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction deserializeImage(image) {\n\t\t\t\tif (typeof image === 'string') {\n\t\t\t\t\tconst url = image;\n\t\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(url) ? url : scope.resourcePath + url;\n\t\t\t\t\treturn loadImage(path);\n\t\t\t\t} else {\n\t\t\t\t\tif (image.data) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tdata: getTypedArray(image.type, image.data),\n\t\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\t\theight: image.height\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (json !== undefined && json.length > 0) {\n\t\t\t\tconst manager = new LoadingManager(onLoad);\n\t\t\t\tloader = new ImageLoader(manager);\n\t\t\t\tloader.setCrossOrigin(this.crossOrigin);\n\n\t\t\t\tfor (let i = 0, il = json.length; i < il; i++) {\n\t\t\t\t\tconst image = json[i];\n\t\t\t\t\tconst url = image.url;\n\n\t\t\t\t\tif (Array.isArray(url)) {\n\t\t\t\t\t\t// load array of images e.g CubeTexture\n\t\t\t\t\t\timages[image.uuid] = [];\n\n\t\t\t\t\t\tfor (let j = 0, jl = url.length; j < jl; j++) {\n\t\t\t\t\t\t\tconst currentUrl = url[j];\n\t\t\t\t\t\t\tconst deserializedImage = deserializeImage(currentUrl);\n\n\t\t\t\t\t\t\tif (deserializedImage !== null) {\n\t\t\t\t\t\t\t\tif (deserializedImage instanceof HTMLImageElement) {\n\t\t\t\t\t\t\t\t\timages[image.uuid].push(deserializedImage);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\t\t\t\t\t\t\t\t\timages[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// load single image\n\t\t\t\t\t\tconst deserializedImage = deserializeImage(image.url);\n\n\t\t\t\t\t\tif (deserializedImage !== null) {\n\t\t\t\t\t\t\timages[image.uuid] = deserializedImage;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn images;\n\t\t}\n\n\t\tparseTextures(json, images) {\n\t\t\tfunction parseConstant(value, type) {\n\t\t\t\tif (typeof value === 'number') return value;\n\t\t\t\tconsole.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);\n\t\t\t\treturn type[value];\n\t\t\t}\n\n\t\t\tconst textures = {};\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tfor (let i = 0, l = json.length; i < l; i++) {\n\t\t\t\t\tconst data = json[i];\n\n\t\t\t\t\tif (data.image === undefined) {\n\t\t\t\t\t\tconsole.warn('THREE.ObjectLoader: No \"image\" specified for', data.uuid);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (images[data.image] === undefined) {\n\t\t\t\t\t\tconsole.warn('THREE.ObjectLoader: Undefined image', data.image);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet texture;\n\t\t\t\t\tconst image = images[data.image];\n\n\t\t\t\t\tif (Array.isArray(image)) {\n\t\t\t\t\t\ttexture = new CubeTexture(image);\n\t\t\t\t\t\tif (image.length === 6) texture.needsUpdate = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (image && image.data) {\n\t\t\t\t\t\t\ttexture = new DataTexture(image.data, image.width, image.height);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttexture = new Texture(image);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (image) texture.needsUpdate = true; // textures can have undefined image data\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.uuid = data.uuid;\n\t\t\t\t\tif (data.name !== undefined) texture.name = data.name;\n\t\t\t\t\tif (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);\n\t\t\t\t\tif (data.offset !== undefined) texture.offset.fromArray(data.offset);\n\t\t\t\t\tif (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);\n\t\t\t\t\tif (data.center !== undefined) texture.center.fromArray(data.center);\n\t\t\t\t\tif (data.rotation !== undefined) texture.rotation = data.rotation;\n\n\t\t\t\t\tif (data.wrap !== undefined) {\n\t\t\t\t\t\ttexture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);\n\t\t\t\t\t\ttexture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data.format !== undefined) texture.format = data.format;\n\t\t\t\t\tif (data.type !== undefined) texture.type = data.type;\n\t\t\t\t\tif (data.encoding !== undefined) texture.encoding = data.encoding;\n\t\t\t\t\tif (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);\n\t\t\t\t\tif (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);\n\t\t\t\t\tif (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;\n\t\t\t\t\tif (data.flipY !== undefined) texture.flipY = data.flipY;\n\t\t\t\t\tif (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;\n\t\t\t\t\tif (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;\n\t\t\t\t\ttextures[data.uuid] = texture;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn textures;\n\t\t}\n\n\t\tparseObject(data, geometries, materials, animations) {\n\t\t\tlet object;\n\n\t\t\tfunction getGeometry(name) {\n\t\t\t\tif (geometries[name] === undefined) {\n\t\t\t\t\tconsole.warn('THREE.ObjectLoader: Undefined geometry', name);\n\t\t\t\t}\n\n\t\t\t\treturn geometries[name];\n\t\t\t}\n\n\t\t\tfunction getMaterial(name) {\n\t\t\t\tif (name === undefined) return undefined;\n\n\t\t\t\tif (Array.isArray(name)) {\n\t\t\t\t\tconst array = [];\n\n\t\t\t\t\tfor (let i = 0, l = name.length; i < l; i++) {\n\t\t\t\t\t\tconst uuid = name[i];\n\n\t\t\t\t\t\tif (materials[uuid] === undefined) {\n\t\t\t\t\t\t\tconsole.warn('THREE.ObjectLoader: Undefined material', uuid);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tarray.push(materials[uuid]);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn array;\n\t\t\t\t}\n\n\t\t\t\tif (materials[name] === undefined) {\n\t\t\t\t\tconsole.warn('THREE.ObjectLoader: Undefined material', name);\n\t\t\t\t}\n\n\t\t\t\treturn materials[name];\n\t\t\t}\n\n\t\t\tlet geometry, material;\n\n\t\t\tswitch (data.type) {\n\t\t\t\tcase 'Scene':\n\t\t\t\t\tobject = new Scene();\n\n\t\t\t\t\tif (data.background !== undefined) {\n\t\t\t\t\t\tif (Number.isInteger(data.background)) {\n\t\t\t\t\t\t\tobject.background = new Color(data.background);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data.fog !== undefined) {\n\t\t\t\t\t\tif (data.fog.type === 'Fog') {\n\t\t\t\t\t\t\tobject.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);\n\t\t\t\t\t\t} else if (data.fog.type === 'FogExp2') {\n\t\t\t\t\t\t\tobject.fog = new FogExp2(data.fog.color, data.fog.density);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PerspectiveCamera':\n\t\t\t\t\tobject = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);\n\t\t\t\t\tif (data.focus !== undefined) object.focus = data.focus;\n\t\t\t\t\tif (data.zoom !== undefined) object.zoom = data.zoom;\n\t\t\t\t\tif (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;\n\t\t\t\t\tif (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;\n\t\t\t\t\tif (data.view !== undefined) object.view = Object.assign({}, data.view);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'OrthographicCamera':\n\t\t\t\t\tobject = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);\n\t\t\t\t\tif (data.zoom !== undefined) object.zoom = data.zoom;\n\t\t\t\t\tif (data.view !== undefined) object.view = Object.assign({}, data.view);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientLight':\n\t\t\t\t\tobject = new AmbientLight(data.color, data.intensity);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tobject = new DirectionalLight(data.color, data.intensity);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tobject = new PointLight(data.color, data.intensity, data.distance, data.decay);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\tobject = new RectAreaLight(data.color, data.intensity, data.width, data.height);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tobject = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\tobject = new HemisphereLight(data.color, data.groundColor, data.intensity);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LightProbe':\n\t\t\t\t\tobject = new LightProbe().fromJSON(data);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SkinnedMesh':\n\t\t\t\t\tgeometry = getGeometry(data.geometry);\n\t\t\t\t\tmaterial = getMaterial(data.material);\n\t\t\t\t\tobject = new SkinnedMesh(geometry, material);\n\t\t\t\t\tif (data.bindMode !== undefined) object.bindMode = data.bindMode;\n\t\t\t\t\tif (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);\n\t\t\t\t\tif (data.skeleton !== undefined) object.skeleton = data.skeleton;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Mesh':\n\t\t\t\t\tgeometry = getGeometry(data.geometry);\n\t\t\t\t\tmaterial = getMaterial(data.material);\n\t\t\t\t\tobject = new Mesh(geometry, material);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'InstancedMesh':\n\t\t\t\t\tgeometry = getGeometry(data.geometry);\n\t\t\t\t\tmaterial = getMaterial(data.material);\n\t\t\t\t\tconst count = data.count;\n\t\t\t\t\tconst instanceMatrix = data.instanceMatrix;\n\t\t\t\t\tconst instanceColor = data.instanceColor;\n\t\t\t\t\tobject = new InstancedMesh(geometry, material, count);\n\t\t\t\t\tobject.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);\n\t\t\t\t\tif (instanceColor !== undefined) object.instanceColor = new BufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LOD':\n\t\t\t\t\tobject = new LOD();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Line':\n\t\t\t\t\tobject = new Line(getGeometry(data.geometry), getMaterial(data.material));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LineLoop':\n\t\t\t\t\tobject = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LineSegments':\n\t\t\t\t\tobject = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointCloud':\n\t\t\t\tcase 'Points':\n\t\t\t\t\tobject = new Points(getGeometry(data.geometry), getMaterial(data.material));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Sprite':\n\t\t\t\t\tobject = new Sprite(getMaterial(data.material));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Group':\n\t\t\t\t\tobject = new Group();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Bone':\n\t\t\t\t\tobject = new Bone();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tobject = new Object3D();\n\t\t\t}\n\n\t\t\tobject.uuid = data.uuid;\n\t\t\tif (data.name !== undefined) object.name = data.name;\n\n\t\t\tif (data.matrix !== undefined) {\n\t\t\t\tobject.matrix.fromArray(data.matrix);\n\t\t\t\tif (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;\n\t\t\t\tif (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);\n\t\t\t} else {\n\t\t\t\tif (data.position !== undefined) object.position.fromArray(data.position);\n\t\t\t\tif (data.rotation !== undefined) object.rotation.fromArray(data.rotation);\n\t\t\t\tif (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);\n\t\t\t\tif (data.scale !== undefined) object.scale.fromArray(data.scale);\n\t\t\t}\n\n\t\t\tif (data.castShadow !== undefined) object.castShadow = data.castShadow;\n\t\t\tif (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;\n\n\t\t\tif (data.shadow) {\n\t\t\t\tif (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;\n\t\t\t\tif (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;\n\t\t\t\tif (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;\n\t\t\t\tif (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);\n\t\t\t\tif (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);\n\t\t\t}\n\n\t\t\tif (data.visible !== undefined) object.visible = data.visible;\n\t\t\tif (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;\n\t\t\tif (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;\n\t\t\tif (data.userData !== undefined) object.userData = data.userData;\n\t\t\tif (data.layers !== undefined) object.layers.mask = data.layers;\n\n\t\t\tif (data.children !== undefined) {\n\t\t\t\tconst children = data.children;\n\n\t\t\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\t\t\tobject.add(this.parseObject(children[i], geometries, materials, animations));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (data.animations !== undefined) {\n\t\t\t\tconst objectAnimations = data.animations;\n\n\t\t\t\tfor (let i = 0; i < objectAnimations.length; i++) {\n\t\t\t\t\tconst uuid = objectAnimations[i];\n\t\t\t\t\tobject.animations.push(animations[uuid]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (data.type === 'LOD') {\n\t\t\t\tif (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;\n\t\t\t\tconst levels = data.levels;\n\n\t\t\t\tfor (let l = 0; l < levels.length; l++) {\n\t\t\t\t\tconst level = levels[l];\n\t\t\t\t\tconst child = object.getObjectByProperty('uuid', level.object);\n\n\t\t\t\t\tif (child !== undefined) {\n\t\t\t\t\t\tobject.addLevel(child, level.distance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn object;\n\t\t}\n\n\t\tbindSkeletons(object, skeletons) {\n\t\t\tif (Object.keys(skeletons).length === 0) return;\n\t\t\tobject.traverse(function (child) {\n\t\t\t\tif (child.isSkinnedMesh === true && child.skeleton !== undefined) {\n\t\t\t\t\tconst skeleton = skeletons[child.skeleton];\n\n\t\t\t\t\tif (skeleton === undefined) {\n\t\t\t\t\t\tconsole.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchild.bind(skeleton, child.bindMatrix);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t/* DEPRECATED */\n\n\n\t\tsetTexturePath(value) {\n\t\t\tconsole.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');\n\t\t\treturn this.setResourcePath(value);\n\t\t}\n\n\t}\n\n\tconst TEXTURE_MAPPING = {\n\t\tUVMapping: UVMapping,\n\t\tCubeReflectionMapping: CubeReflectionMapping,\n\t\tCubeRefractionMapping: CubeRefractionMapping,\n\t\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\t\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\t\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\t\tCubeUVRefractionMapping: CubeUVRefractionMapping\n\t};\n\tconst TEXTURE_WRAPPING = {\n\t\tRepeatWrapping: RepeatWrapping,\n\t\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\t\tMirroredRepeatWrapping: MirroredRepeatWrapping\n\t};\n\tconst TEXTURE_FILTER = {\n\t\tNearestFilter: NearestFilter,\n\t\tNearestMipmapNearestFilter: NearestMipmapNearestFilter,\n\t\tNearestMipmapLinearFilter: NearestMipmapLinearFilter,\n\t\tLinearFilter: LinearFilter,\n\t\tLinearMipmapNearestFilter: LinearMipmapNearestFilter,\n\t\tLinearMipmapLinearFilter: LinearMipmapLinearFilter\n\t};\n\n\tclass ImageBitmapLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\n\t\t\tif (typeof createImageBitmap === 'undefined') {\n\t\t\t\tconsole.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');\n\t\t\t}\n\n\t\t\tif (typeof fetch === 'undefined') {\n\t\t\t\tconsole.warn('THREE.ImageBitmapLoader: fetch() not supported.');\n\t\t\t}\n\n\t\t\tthis.options = {\n\t\t\t\tpremultiplyAlpha: 'none'\n\t\t\t};\n\t\t}\n\n\t\tsetOptions(options) {\n\t\t\tthis.options = options;\n\t\t\treturn this;\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tif (url === undefined) url = '';\n\t\t\tif (this.path !== undefined) url = this.path + url;\n\t\t\turl = this.manager.resolveURL(url);\n\t\t\tconst scope = this;\n\t\t\tconst cached = Cache.get(url);\n\n\t\t\tif (cached !== undefined) {\n\t\t\t\tscope.manager.itemStart(url);\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tif (onLoad) onLoad(cached);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, 0);\n\t\t\t\treturn cached;\n\t\t\t}\n\n\t\t\tconst fetchOptions = {};\n\t\t\tfetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';\n\t\t\tfetchOptions.headers = this.requestHeader;\n\t\t\tfetch(url, fetchOptions).then(function (res) {\n\t\t\t\treturn res.blob();\n\t\t\t}).then(function (blob) {\n\t\t\t\treturn createImageBitmap(blob, Object.assign(scope.options, {\n\t\t\t\t\tcolorSpaceConversion: 'none'\n\t\t\t\t}));\n\t\t\t}).then(function (imageBitmap) {\n\t\t\t\tCache.add(url, imageBitmap);\n\t\t\t\tif (onLoad) onLoad(imageBitmap);\n\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t}).catch(function (e) {\n\t\t\t\tif (onError) onError(e);\n\t\t\t\tscope.manager.itemError(url);\n\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t});\n\t\t\tscope.manager.itemStart(url);\n\t\t}\n\n\t}\n\n\tImageBitmapLoader.prototype.isImageBitmapLoader = true;\n\n\tclass ShapePath {\n\t\tconstructor() {\n\t\t\tthis.type = 'ShapePath';\n\t\t\tthis.color = new Color();\n\t\t\tthis.subPaths = [];\n\t\t\tthis.currentPath = null;\n\t\t}\n\n\t\tmoveTo(x, y) {\n\t\t\tthis.currentPath = new Path();\n\t\t\tthis.subPaths.push(this.currentPath);\n\t\t\tthis.currentPath.moveTo(x, y);\n\t\t\treturn this;\n\t\t}\n\n\t\tlineTo(x, y) {\n\t\t\tthis.currentPath.lineTo(x, y);\n\t\t\treturn this;\n\t\t}\n\n\t\tquadraticCurveTo(aCPx, aCPy, aX, aY) {\n\t\t\tthis.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);\n\t\t\treturn this;\n\t\t}\n\n\t\tbezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n\t\t\tthis.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);\n\t\t\treturn this;\n\t\t}\n\n\t\tsplineThru(pts) {\n\t\t\tthis.currentPath.splineThru(pts);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoShapes(isCCW, noHoles) {\n\t\t\tfunction toShapesNoHoles(inSubpaths) {\n\t\t\t\tconst shapes = [];\n\n\t\t\t\tfor (let i = 0, l = inSubpaths.length; i < l; i++) {\n\t\t\t\t\tconst tmpPath = inSubpaths[i];\n\t\t\t\t\tconst tmpShape = new Shape();\n\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\t\tshapes.push(tmpShape);\n\t\t\t\t}\n\n\t\t\t\treturn shapes;\n\t\t\t}\n\n\t\t\tfunction isPointInsidePolygon(inPt, inPolygon) {\n\t\t\t\tconst polyLen = inPolygon.length; // inPt on polygon contour => immediate success\t\tor\n\t\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t\t//\twith the horizontal line through inPt, left of inPt\n\t\t\t\t//\tnot counting lowerY endpoints of edges and whole edges on that line\n\n\t\t\t\tlet inside = false;\n\n\t\t\t\tfor (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {\n\t\t\t\t\tlet edgeLowPt = inPolygon[p];\n\t\t\t\t\tlet edgeHighPt = inPolygon[q];\n\t\t\t\t\tlet edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\t\tlet edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\t\tif (Math.abs(edgeDy) > Number.EPSILON) {\n\t\t\t\t\t\t// not parallel\n\t\t\t\t\t\tif (edgeDy < 0) {\n\t\t\t\t\t\t\tedgeLowPt = inPolygon[q];\n\t\t\t\t\t\t\tedgeDx = -edgeDx;\n\t\t\t\t\t\t\tedgeHighPt = inPolygon[p];\n\t\t\t\t\t\t\tedgeDy = -edgeDy;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;\n\n\t\t\t\t\t\tif (inPt.y === edgeLowPt.y) {\n\t\t\t\t\t\t\tif (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?\n\t\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\n\t\t\t\t\t\t\tif (perpEdge === 0) return true; // inPt is on contour ?\n\n\t\t\t\t\t\t\tif (perpEdge < 0) continue;\n\t\t\t\t\t\t\tinside = !inside; // true intersection left of inPt\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\tif (inPt.y !== edgeLowPt.y) continue; // parallel\n\t\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\n\t\t\t\t\t\tif (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !\n\t\t\t\t\t\t// continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn inside;\n\t\t\t}\n\n\t\t\tconst isClockWise = ShapeUtils.isClockWise;\n\t\t\tconst subPaths = this.subPaths;\n\t\t\tif (subPaths.length === 0) return [];\n\t\t\tif (noHoles === true) return toShapesNoHoles(subPaths);\n\t\t\tlet solid, tmpPath, tmpShape;\n\t\t\tconst shapes = [];\n\n\t\t\tif (subPaths.length === 1) {\n\t\t\t\ttmpPath = subPaths[0];\n\t\t\t\ttmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\tshapes.push(tmpShape);\n\t\t\t\treturn shapes;\n\t\t\t}\n\n\t\t\tlet holesFirst = !isClockWise(subPaths[0].getPoints());\n\t\t\tholesFirst = isCCW ? !holesFirst : holesFirst; // console.log(\"Holes first\", holesFirst);\n\n\t\t\tconst betterShapeHoles = [];\n\t\t\tconst newShapes = [];\n\t\t\tlet newShapeHoles = [];\n\t\t\tlet mainIdx = 0;\n\t\t\tlet tmpPoints;\n\t\t\tnewShapes[mainIdx] = undefined;\n\t\t\tnewShapeHoles[mainIdx] = [];\n\n\t\t\tfor (let i = 0, l = subPaths.length; i < l; i++) {\n\t\t\t\ttmpPath = subPaths[i];\n\t\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\t\tsolid = isClockWise(tmpPoints);\n\t\t\t\tsolid = isCCW ? !solid : solid;\n\n\t\t\t\tif (solid) {\n\t\t\t\t\tif (!holesFirst && newShapes[mainIdx]) mainIdx++;\n\t\t\t\t\tnewShapes[mainIdx] = {\n\t\t\t\t\t\ts: new Shape(),\n\t\t\t\t\t\tp: tmpPoints\n\t\t\t\t\t};\n\t\t\t\t\tnewShapes[mainIdx].s.curves = tmpPath.curves;\n\t\t\t\t\tif (holesFirst) mainIdx++;\n\t\t\t\t\tnewShapeHoles[mainIdx] = []; //console.log('cw', i);\n\t\t\t\t} else {\n\t\t\t\t\tnewShapeHoles[mainIdx].push({\n\t\t\t\t\t\th: tmpPath,\n\t\t\t\t\t\tp: tmpPoints[0]\n\t\t\t\t\t}); //console.log('ccw', i);\n\t\t\t\t}\n\t\t\t} // only Holes? -> probably all Shapes with wrong orientation\n\n\n\t\t\tif (!newShapes[0]) return toShapesNoHoles(subPaths);\n\n\t\t\tif (newShapes.length > 1) {\n\t\t\t\tlet ambiguous = false;\n\t\t\t\tconst toChange = [];\n\n\t\t\t\tfor (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n\t\t\t\t\tbetterShapeHoles[sIdx] = [];\n\t\t\t\t}\n\n\t\t\t\tfor (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n\t\t\t\t\tconst sho = newShapeHoles[sIdx];\n\n\t\t\t\t\tfor (let hIdx = 0; hIdx < sho.length; hIdx++) {\n\t\t\t\t\t\tconst ho = sho[hIdx];\n\t\t\t\t\t\tlet hole_unassigned = true;\n\n\t\t\t\t\t\tfor (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {\n\t\t\t\t\t\t\tif (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {\n\t\t\t\t\t\t\t\tif (sIdx !== s2Idx) toChange.push({\n\t\t\t\t\t\t\t\t\tfroms: sIdx,\n\t\t\t\t\t\t\t\t\ttos: s2Idx,\n\t\t\t\t\t\t\t\t\thole: hIdx\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tif (hole_unassigned) {\n\t\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\t\tbetterShapeHoles[s2Idx].push(ho);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tambiguous = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (hole_unassigned) {\n\t\t\t\t\t\t\tbetterShapeHoles[sIdx].push(ho);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // console.log(\"ambiguous: \", ambiguous);\n\n\n\t\t\t\tif (toChange.length > 0) {\n\t\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\t\tif (!ambiguous) newShapeHoles = betterShapeHoles;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet tmpHoles;\n\n\t\t\tfor (let i = 0, il = newShapes.length; i < il; i++) {\n\t\t\t\ttmpShape = newShapes[i].s;\n\t\t\t\tshapes.push(tmpShape);\n\t\t\t\ttmpHoles = newShapeHoles[i];\n\n\t\t\t\tfor (let j = 0, jl = tmpHoles.length; j < jl; j++) {\n\t\t\t\t\ttmpShape.holes.push(tmpHoles[j].h);\n\t\t\t\t}\n\t\t\t} //console.log(\"shape\", shapes);\n\n\n\t\t\treturn shapes;\n\t\t}\n\n\t}\n\n\tclass Font {\n\t\tconstructor(data) {\n\t\t\tthis.type = 'Font';\n\t\t\tthis.data = data;\n\t\t}\n\n\t\tgenerateShapes(text, size = 100) {\n\t\t\tconst shapes = [];\n\t\t\tconst paths = createPaths(text, size, this.data);\n\n\t\t\tfor (let p = 0, pl = paths.length; p < pl; p++) {\n\t\t\t\tArray.prototype.push.apply(shapes, paths[p].toShapes());\n\t\t\t}\n\n\t\t\treturn shapes;\n\t\t}\n\n\t}\n\n\tfunction createPaths(text, size, data) {\n\t\tconst chars = Array.from(text);\n\t\tconst scale = size / data.resolution;\n\t\tconst line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n\t\tconst paths = [];\n\t\tlet offsetX = 0,\n\t\t\t\toffsetY = 0;\n\n\t\tfor (let i = 0; i < chars.length; i++) {\n\t\t\tconst char = chars[i];\n\n\t\t\tif (char === '\\n') {\n\t\t\t\toffsetX = 0;\n\t\t\t\toffsetY -= line_height;\n\t\t\t} else {\n\t\t\t\tconst ret = createPath(char, scale, offsetX, offsetY, data);\n\t\t\t\toffsetX += ret.offsetX;\n\t\t\t\tpaths.push(ret.path);\n\t\t\t}\n\t\t}\n\n\t\treturn paths;\n\t}\n\n\tfunction createPath(char, scale, offsetX, offsetY, data) {\n\t\tconst glyph = data.glyphs[char] || data.glyphs['?'];\n\n\t\tif (!glyph) {\n\t\t\tconsole.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.');\n\t\t\treturn;\n\t\t}\n\n\t\tconst path = new ShapePath();\n\t\tlet x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\n\t\tif (glyph.o) {\n\t\t\tconst outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));\n\n\t\t\tfor (let i = 0, l = outline.length; i < l;) {\n\t\t\t\tconst action = outline[i++];\n\n\t\t\t\tswitch (action) {\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\t// moveTo\n\t\t\t\t\t\tx = outline[i++] * scale + offsetX;\n\t\t\t\t\t\ty = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tpath.moveTo(x, y);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t// lineTo\n\t\t\t\t\t\tx = outline[i++] * scale + offsetX;\n\t\t\t\t\t\ty = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tpath.lineTo(x, y);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\t// quadraticCurveTo\n\t\t\t\t\t\tcpx = outline[i++] * scale + offsetX;\n\t\t\t\t\t\tcpy = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tcpx1 = outline[i++] * scale + offsetX;\n\t\t\t\t\t\tcpy1 = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tpath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t// bezierCurveTo\n\t\t\t\t\t\tcpx = outline[i++] * scale + offsetX;\n\t\t\t\t\t\tcpy = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tcpx1 = outline[i++] * scale + offsetX;\n\t\t\t\t\t\tcpy1 = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tcpx2 = outline[i++] * scale + offsetX;\n\t\t\t\t\t\tcpy2 = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tpath.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\toffsetX: glyph.ha * scale,\n\t\t\tpath: path\n\t\t};\n\t}\n\n\tFont.prototype.isFont = true;\n\n\tclass FontLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setWithCredentials(scope.withCredentials);\n\t\t\tloader.load(url, function (text) {\n\t\t\t\tlet json;\n\n\t\t\t\ttry {\n\t\t\t\t\tjson = JSON.parse(text);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');\n\t\t\t\t\tjson = JSON.parse(text.substring(65, text.length - 2));\n\t\t\t\t}\n\n\t\t\t\tconst font = scope.parse(json);\n\t\t\t\tif (onLoad) onLoad(font);\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t\tparse(json) {\n\t\t\treturn new Font(json);\n\t\t}\n\n\t}\n\n\tlet _context;\n\n\tconst AudioContext = {\n\t\tgetContext: function () {\n\t\t\tif (_context === undefined) {\n\t\t\t\t_context = new (window.AudioContext || window.webkitAudioContext)();\n\t\t\t}\n\n\t\t\treturn _context;\n\t\t},\n\t\tsetContext: function (value) {\n\t\t\t_context = value;\n\t\t}\n\t};\n\n\tclass AudioLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setResponseType('arraybuffer');\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setWithCredentials(this.withCredentials);\n\t\t\tloader.load(url, function (buffer) {\n\t\t\t\ttry {\n\t\t\t\t\t// Create a copy of the buffer. The `decodeAudioData` method\n\t\t\t\t\t// detaches the buffer when complete, preventing reuse.\n\t\t\t\t\tconst bufferCopy = buffer.slice(0);\n\t\t\t\t\tconst context = AudioContext.getContext();\n\t\t\t\t\tcontext.decodeAudioData(bufferCopy, function (audioBuffer) {\n\t\t\t\t\t\tonLoad(audioBuffer);\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onError) {\n\t\t\t\t\t\tonError(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t}\n\n\tclass HemisphereLightProbe extends LightProbe {\n\t\tconstructor(skyColor, groundColor, intensity = 1) {\n\t\t\tsuper(undefined, intensity);\n\t\t\tconst color1 = new Color().set(skyColor);\n\t\t\tconst color2 = new Color().set(groundColor);\n\t\t\tconst sky = new Vector3(color1.r, color1.g, color1.b);\n\t\t\tconst ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );\n\n\t\t\tconst c0 = Math.sqrt(Math.PI);\n\t\t\tconst c1 = c0 * Math.sqrt(0.75);\n\t\t\tthis.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);\n\t\t\tthis.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);\n\t\t}\n\n\t}\n\n\tHemisphereLightProbe.prototype.isHemisphereLightProbe = true;\n\n\tclass AmbientLightProbe extends LightProbe {\n\t\tconstructor(color, intensity = 1) {\n\t\t\tsuper(undefined, intensity);\n\t\t\tconst color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );\n\n\t\t\tthis.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));\n\t\t}\n\n\t}\n\n\tAmbientLightProbe.prototype.isAmbientLightProbe = true;\n\n\tconst _eyeRight = /*@__PURE__*/new Matrix4();\n\n\tconst _eyeLeft = /*@__PURE__*/new Matrix4();\n\n\tclass StereoCamera {\n\t\tconstructor() {\n\t\t\tthis.type = 'StereoCamera';\n\t\t\tthis.aspect = 1;\n\t\t\tthis.eyeSep = 0.064;\n\t\t\tthis.cameraL = new PerspectiveCamera();\n\t\t\tthis.cameraL.layers.enable(1);\n\t\t\tthis.cameraL.matrixAutoUpdate = false;\n\t\t\tthis.cameraR = new PerspectiveCamera();\n\t\t\tthis.cameraR.layers.enable(2);\n\t\t\tthis.cameraR.matrixAutoUpdate = false;\n\t\t\tthis._cache = {\n\t\t\t\tfocus: null,\n\t\t\t\tfov: null,\n\t\t\t\taspect: null,\n\t\t\t\tnear: null,\n\t\t\t\tfar: null,\n\t\t\t\tzoom: null,\n\t\t\t\teyeSep: null\n\t\t\t};\n\t\t}\n\n\t\tupdate(camera) {\n\t\t\tconst cache = this._cache;\n\t\t\tconst needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;\n\n\t\t\tif (needsUpdate) {\n\t\t\t\tcache.focus = camera.focus;\n\t\t\t\tcache.fov = camera.fov;\n\t\t\t\tcache.aspect = camera.aspect * this.aspect;\n\t\t\t\tcache.near = camera.near;\n\t\t\t\tcache.far = camera.far;\n\t\t\t\tcache.zoom = camera.zoom;\n\t\t\t\tcache.eyeSep = this.eyeSep; // Off-axis stereoscopic effect based on\n\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\tconst projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\tconst eyeSepHalf = cache.eyeSep / 2;\n\t\t\t\tconst eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\n\t\t\t\tconst ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;\n\t\t\t\tlet xmin, xmax; // translate xOffset\n\n\t\t\t\t_eyeLeft.elements[12] = -eyeSepHalf;\n\t\t\t\t_eyeRight.elements[12] = eyeSepHalf; // for left eye\n\n\t\t\t\txmin = -ymax * cache.aspect + eyeSepOnProjection;\n\t\t\t\txmax = ymax * cache.aspect + eyeSepOnProjection;\n\t\t\t\tprojectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);\n\t\t\t\tprojectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);\n\t\t\t\tthis.cameraL.projectionMatrix.copy(projectionMatrix); // for right eye\n\n\t\t\t\txmin = -ymax * cache.aspect - eyeSepOnProjection;\n\t\t\t\txmax = ymax * cache.aspect - eyeSepOnProjection;\n\t\t\t\tprojectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);\n\t\t\t\tprojectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);\n\t\t\t\tthis.cameraR.projectionMatrix.copy(projectionMatrix);\n\t\t\t}\n\n\t\t\tthis.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);\n\t\t\tthis.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);\n\t\t}\n\n\t}\n\n\tclass Clock {\n\t\tconstructor(autoStart = true) {\n\t\t\tthis.autoStart = autoStart;\n\t\t\tthis.startTime = 0;\n\t\t\tthis.oldTime = 0;\n\t\t\tthis.elapsedTime = 0;\n\t\t\tthis.running = false;\n\t\t}\n\n\t\tstart() {\n\t\t\tthis.startTime = now();\n\t\t\tthis.oldTime = this.startTime;\n\t\t\tthis.elapsedTime = 0;\n\t\t\tthis.running = true;\n\t\t}\n\n\t\tstop() {\n\t\t\tthis.getElapsedTime();\n\t\t\tthis.running = false;\n\t\t\tthis.autoStart = false;\n\t\t}\n\n\t\tgetElapsedTime() {\n\t\t\tthis.getDelta();\n\t\t\treturn this.elapsedTime;\n\t\t}\n\n\t\tgetDelta() {\n\t\t\tlet diff = 0;\n\n\t\t\tif (this.autoStart && !this.running) {\n\t\t\t\tthis.start();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (this.running) {\n\t\t\t\tconst newTime = now();\n\t\t\t\tdiff = (newTime - this.oldTime) / 1000;\n\t\t\t\tthis.oldTime = newTime;\n\t\t\t\tthis.elapsedTime += diff;\n\t\t\t}\n\n\t\t\treturn diff;\n\t\t}\n\n\t}\n\n\tfunction now() {\n\t\treturn (typeof performance === 'undefined' ? Date : performance).now(); // see #10732\n\t}\n\n\tconst _position$1 = /*@__PURE__*/new Vector3();\n\n\tconst _quaternion$1 = /*@__PURE__*/new Quaternion();\n\n\tconst _scale$1 = /*@__PURE__*/new Vector3();\n\n\tconst _orientation$1 = /*@__PURE__*/new Vector3();\n\n\tclass AudioListener extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'AudioListener';\n\t\t\tthis.context = AudioContext.getContext();\n\t\t\tthis.gain = this.context.createGain();\n\t\t\tthis.gain.connect(this.context.destination);\n\t\t\tthis.filter = null;\n\t\t\tthis.timeDelta = 0; // private\n\n\t\t\tthis._clock = new Clock();\n\t\t}\n\n\t\tgetInput() {\n\t\t\treturn this.gain;\n\t\t}\n\n\t\tremoveFilter() {\n\t\t\tif (this.filter !== null) {\n\t\t\t\tthis.gain.disconnect(this.filter);\n\t\t\t\tthis.filter.disconnect(this.context.destination);\n\t\t\t\tthis.gain.connect(this.context.destination);\n\t\t\t\tthis.filter = null;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetFilter() {\n\t\t\treturn this.filter;\n\t\t}\n\n\t\tsetFilter(value) {\n\t\t\tif (this.filter !== null) {\n\t\t\t\tthis.gain.disconnect(this.filter);\n\t\t\t\tthis.filter.disconnect(this.context.destination);\n\t\t\t} else {\n\t\t\t\tthis.gain.disconnect(this.context.destination);\n\t\t\t}\n\n\t\t\tthis.filter = value;\n\t\t\tthis.gain.connect(this.filter);\n\t\t\tthis.filter.connect(this.context.destination);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetMasterVolume() {\n\t\t\treturn this.gain.gain.value;\n\t\t}\n\n\t\tsetMasterVolume(value) {\n\t\t\tthis.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\n\t\t\treturn this;\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t\tconst listener = this.context.listener;\n\t\t\tconst up = this.up;\n\t\t\tthis.timeDelta = this._clock.getDelta();\n\t\t\tthis.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);\n\n\t\t\t_orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);\n\n\t\t\tif (listener.positionX) {\n\t\t\t\t// code path for Chrome (see #14393)\n\t\t\t\tconst endTime = this.context.currentTime + this.timeDelta;\n\t\t\t\tlistener.positionX.linearRampToValueAtTime(_position$1.x, endTime);\n\t\t\t\tlistener.positionY.linearRampToValueAtTime(_position$1.y, endTime);\n\t\t\t\tlistener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);\n\t\t\t\tlistener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);\n\t\t\t\tlistener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);\n\t\t\t\tlistener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);\n\t\t\t\tlistener.upX.linearRampToValueAtTime(up.x, endTime);\n\t\t\t\tlistener.upY.linearRampToValueAtTime(up.y, endTime);\n\t\t\t\tlistener.upZ.linearRampToValueAtTime(up.z, endTime);\n\t\t\t} else {\n\t\t\t\tlistener.setPosition(_position$1.x, _position$1.y, _position$1.z);\n\t\t\t\tlistener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass Audio extends Object3D {\n\t\tconstructor(listener) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Audio';\n\t\t\tthis.listener = listener;\n\t\t\tthis.context = listener.context;\n\t\t\tthis.gain = this.context.createGain();\n\t\t\tthis.gain.connect(listener.getInput());\n\t\t\tthis.autoplay = false;\n\t\t\tthis.buffer = null;\n\t\t\tthis.detune = 0;\n\t\t\tthis.loop = false;\n\t\t\tthis.loopStart = 0;\n\t\t\tthis.loopEnd = 0;\n\t\t\tthis.offset = 0;\n\t\t\tthis.duration = undefined;\n\t\t\tthis.playbackRate = 1;\n\t\t\tthis.isPlaying = false;\n\t\t\tthis.hasPlaybackControl = true;\n\t\t\tthis.source = null;\n\t\t\tthis.sourceType = 'empty';\n\t\t\tthis._startedAt = 0;\n\t\t\tthis._progress = 0;\n\t\t\tthis._connected = false;\n\t\t\tthis.filters = [];\n\t\t}\n\n\t\tgetOutput() {\n\t\t\treturn this.gain;\n\t\t}\n\n\t\tsetNodeSource(audioNode) {\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'audioNode';\n\t\t\tthis.source = audioNode;\n\t\t\tthis.connect();\n\t\t\treturn this;\n\t\t}\n\n\t\tsetMediaElementSource(mediaElement) {\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'mediaNode';\n\t\t\tthis.source = this.context.createMediaElementSource(mediaElement);\n\t\t\tthis.connect();\n\t\t\treturn this;\n\t\t}\n\n\t\tsetMediaStreamSource(mediaStream) {\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'mediaStreamNode';\n\t\t\tthis.source = this.context.createMediaStreamSource(mediaStream);\n\t\t\tthis.connect();\n\t\t\treturn this;\n\t\t}\n\n\t\tsetBuffer(audioBuffer) {\n\t\t\tthis.buffer = audioBuffer;\n\t\t\tthis.sourceType = 'buffer';\n\t\t\tif (this.autoplay) this.play();\n\t\t\treturn this;\n\t\t}\n\n\t\tplay(delay = 0) {\n\t\t\tif (this.isPlaying === true) {\n\t\t\t\tconsole.warn('THREE.Audio: Audio is already playing.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._startedAt = this.context.currentTime + delay;\n\t\t\tconst source = this.context.createBufferSource();\n\t\t\tsource.buffer = this.buffer;\n\t\t\tsource.loop = this.loop;\n\t\t\tsource.loopStart = this.loopStart;\n\t\t\tsource.loopEnd = this.loopEnd;\n\t\t\tsource.onended = this.onEnded.bind(this);\n\t\t\tsource.start(this._startedAt, this._progress + this.offset, this.duration);\n\t\t\tthis.isPlaying = true;\n\t\t\tthis.source = source;\n\t\t\tthis.setDetune(this.detune);\n\t\t\tthis.setPlaybackRate(this.playbackRate);\n\t\t\treturn this.connect();\n\t\t}\n\n\t\tpause() {\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.isPlaying === true) {\n\t\t\t\t// update current progress\n\t\t\t\tthis._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;\n\n\t\t\t\tif (this.loop === true) {\n\t\t\t\t\t// ensure _progress does not exceed duration with looped audios\n\t\t\t\t\tthis._progress = this._progress % (this.duration || this.buffer.duration);\n\t\t\t\t}\n\n\t\t\t\tthis.source.stop();\n\t\t\t\tthis.source.onended = null;\n\t\t\t\tthis.isPlaying = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tstop() {\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._progress = 0;\n\t\t\tthis.source.stop();\n\t\t\tthis.source.onended = null;\n\t\t\tthis.isPlaying = false;\n\t\t\treturn this;\n\t\t}\n\n\t\tconnect() {\n\t\t\tif (this.filters.length > 0) {\n\t\t\t\tthis.source.connect(this.filters[0]);\n\n\t\t\t\tfor (let i = 1, l = this.filters.length; i < l; i++) {\n\t\t\t\t\tthis.filters[i - 1].connect(this.filters[i]);\n\t\t\t\t}\n\n\t\t\t\tthis.filters[this.filters.length - 1].connect(this.getOutput());\n\t\t\t} else {\n\t\t\t\tthis.source.connect(this.getOutput());\n\t\t\t}\n\n\t\t\tthis._connected = true;\n\t\t\treturn this;\n\t\t}\n\n\t\tdisconnect() {\n\t\t\tif (this.filters.length > 0) {\n\t\t\t\tthis.source.disconnect(this.filters[0]);\n\n\t\t\t\tfor (let i = 1, l = this.filters.length; i < l; i++) {\n\t\t\t\t\tthis.filters[i - 1].disconnect(this.filters[i]);\n\t\t\t\t}\n\n\t\t\t\tthis.filters[this.filters.length - 1].disconnect(this.getOutput());\n\t\t\t} else {\n\t\t\t\tthis.source.disconnect(this.getOutput());\n\t\t\t}\n\n\t\t\tthis._connected = false;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetFilters() {\n\t\t\treturn this.filters;\n\t\t}\n\n\t\tsetFilters(value) {\n\t\t\tif (!value) value = [];\n\n\t\t\tif (this._connected === true) {\n\t\t\t\tthis.disconnect();\n\t\t\t\tthis.filters = value.slice();\n\t\t\t\tthis.connect();\n\t\t\t} else {\n\t\t\t\tthis.filters = value.slice();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetDetune(value) {\n\t\t\tthis.detune = value;\n\t\t\tif (this.source.detune === undefined) return; // only set detune when available\n\n\t\t\tif (this.isPlaying === true) {\n\t\t\t\tthis.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetDetune() {\n\t\t\treturn this.detune;\n\t\t}\n\n\t\tgetFilter() {\n\t\t\treturn this.getFilters()[0];\n\t\t}\n\n\t\tsetFilter(filter) {\n\t\t\treturn this.setFilters(filter ? [filter] : []);\n\t\t}\n\n\t\tsetPlaybackRate(value) {\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.playbackRate = value;\n\n\t\t\tif (this.isPlaying === true) {\n\t\t\t\tthis.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetPlaybackRate() {\n\t\t\treturn this.playbackRate;\n\t\t}\n\n\t\tonEnded() {\n\t\t\tthis.isPlaying = false;\n\t\t}\n\n\t\tgetLoop() {\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn this.loop;\n\t\t}\n\n\t\tsetLoop(value) {\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.loop = value;\n\n\t\t\tif (this.isPlaying === true) {\n\t\t\t\tthis.source.loop = this.loop;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetLoopStart(value) {\n\t\t\tthis.loopStart = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetLoopEnd(value) {\n\t\t\tthis.loopEnd = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetVolume() {\n\t\t\treturn this.gain.gain.value;\n\t\t}\n\n\t\tsetVolume(value) {\n\t\t\tthis.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tconst _position = /*@__PURE__*/new Vector3();\n\n\tconst _quaternion = /*@__PURE__*/new Quaternion();\n\n\tconst _scale = /*@__PURE__*/new Vector3();\n\n\tconst _orientation = /*@__PURE__*/new Vector3();\n\n\tclass PositionalAudio extends Audio {\n\t\tconstructor(listener) {\n\t\t\tsuper(listener);\n\t\t\tthis.panner = this.context.createPanner();\n\t\t\tthis.panner.panningModel = 'HRTF';\n\t\t\tthis.panner.connect(this.gain);\n\t\t}\n\n\t\tgetOutput() {\n\t\t\treturn this.panner;\n\t\t}\n\n\t\tgetRefDistance() {\n\t\t\treturn this.panner.refDistance;\n\t\t}\n\n\t\tsetRefDistance(value) {\n\t\t\tthis.panner.refDistance = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetRolloffFactor() {\n\t\t\treturn this.panner.rolloffFactor;\n\t\t}\n\n\t\tsetRolloffFactor(value) {\n\t\t\tthis.panner.rolloffFactor = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetDistanceModel() {\n\t\t\treturn this.panner.distanceModel;\n\t\t}\n\n\t\tsetDistanceModel(value) {\n\t\t\tthis.panner.distanceModel = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetMaxDistance() {\n\t\t\treturn this.panner.maxDistance;\n\t\t}\n\n\t\tsetMaxDistance(value) {\n\t\t\tthis.panner.maxDistance = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {\n\t\t\tthis.panner.coneInnerAngle = coneInnerAngle;\n\t\t\tthis.panner.coneOuterAngle = coneOuterAngle;\n\t\t\tthis.panner.coneOuterGain = coneOuterGain;\n\t\t\treturn this;\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t\tif (this.hasPlaybackControl === true && this.isPlaying === false) return;\n\t\t\tthis.matrixWorld.decompose(_position, _quaternion, _scale);\n\n\t\t\t_orientation.set(0, 0, 1).applyQuaternion(_quaternion);\n\n\t\t\tconst panner = this.panner;\n\n\t\t\tif (panner.positionX) {\n\t\t\t\t// code path for Chrome and Firefox (see #14393)\n\t\t\t\tconst endTime = this.context.currentTime + this.listener.timeDelta;\n\t\t\t\tpanner.positionX.linearRampToValueAtTime(_position.x, endTime);\n\t\t\t\tpanner.positionY.linearRampToValueAtTime(_position.y, endTime);\n\t\t\t\tpanner.positionZ.linearRampToValueAtTime(_position.z, endTime);\n\t\t\t\tpanner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);\n\t\t\t\tpanner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);\n\t\t\t\tpanner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);\n\t\t\t} else {\n\t\t\t\tpanner.setPosition(_position.x, _position.y, _position.z);\n\t\t\t\tpanner.setOrientation(_orientation.x, _orientation.y, _orientation.z);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass AudioAnalyser {\n\t\tconstructor(audio, fftSize = 2048) {\n\t\t\tthis.analyser = audio.context.createAnalyser();\n\t\t\tthis.analyser.fftSize = fftSize;\n\t\t\tthis.data = new Uint8Array(this.analyser.frequencyBinCount);\n\t\t\taudio.getOutput().connect(this.analyser);\n\t\t}\n\n\t\tgetFrequencyData() {\n\t\t\tthis.analyser.getByteFrequencyData(this.data);\n\t\t\treturn this.data;\n\t\t}\n\n\t\tgetAverageFrequency() {\n\t\t\tlet value = 0;\n\t\t\tconst data = this.getFrequencyData();\n\n\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\tvalue += data[i];\n\t\t\t}\n\n\t\t\treturn value / data.length;\n\t\t}\n\n\t}\n\n\tclass PropertyMixer {\n\t\tconstructor(binding, typeName, valueSize) {\n\t\t\tthis.binding = binding;\n\t\t\tthis.valueSize = valueSize;\n\t\t\tlet mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t\t\t//\n\t\t\t// interpolators can use .buffer as their .result\n\t\t\t// the data then goes to 'incoming'\n\t\t\t//\n\t\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t\t// the cumulative result and are compared to detect\n\t\t\t// changes\n\t\t\t//\n\t\t\t// 'orig' stores the original state of the property\n\t\t\t//\n\t\t\t// 'add' is used for additive cumulative results\n\t\t\t//\n\t\t\t// 'work' is optional and is only present for quaternion types. It is used\n\t\t\t// to store intermediate quaternion multiplication results\n\n\t\t\tswitch (typeName) {\n\t\t\t\tcase 'quaternion':\n\t\t\t\t\tmixFunction = this._slerp;\n\t\t\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\t\t\t\t\tthis.buffer = new Float64Array(valueSize * 6);\n\t\t\t\t\tthis._workIndex = 5;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'string':\n\t\t\t\tcase 'bool':\n\t\t\t\t\tmixFunction = this._select; // Use the regular mix function and for additive on these types,\n\t\t\t\t\t// additive is not relevant for non-numeric types\n\n\t\t\t\t\tmixFunctionAdditive = this._select;\n\t\t\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\t\t\t\t\tthis.buffer = new Array(valueSize * 5);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmixFunction = this._lerp;\n\t\t\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\t\t\t\t\tthis.buffer = new Float64Array(valueSize * 5);\n\t\t\t}\n\n\t\t\tthis._mixBufferRegion = mixFunction;\n\t\t\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\t\t\tthis._setIdentity = setIdentity;\n\t\t\tthis._origIndex = 3;\n\t\t\tthis._addIndex = 4;\n\t\t\tthis.cumulativeWeight = 0;\n\t\t\tthis.cumulativeWeightAdditive = 0;\n\t\t\tthis.useCount = 0;\n\t\t\tthis.referenceCount = 0;\n\t\t} // accumulate data in the 'incoming' region into 'accu<i>'\n\n\n\t\taccumulate(accuIndex, weight) {\n\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t\t// the weight and shouldn't have made the call in the first place\n\t\t\tconst buffer = this.buffer,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\toffset = accuIndex * stride + stride;\n\t\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\t\tif (currentWeight === 0) {\n\t\t\t\t// accuN := incoming * weight\n\t\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\t\tbuffer[offset + i] = buffer[i];\n\t\t\t\t}\n\n\t\t\t\tcurrentWeight = weight;\n\t\t\t} else {\n\t\t\t\t// accuN := accuN + incoming * weight\n\t\t\t\tcurrentWeight += weight;\n\t\t\t\tconst mix = weight / currentWeight;\n\n\t\t\t\tthis._mixBufferRegion(buffer, offset, 0, mix, stride);\n\t\t\t}\n\n\t\t\tthis.cumulativeWeight = currentWeight;\n\t\t} // accumulate data in the 'incoming' region into 'add'\n\n\n\t\taccumulateAdditive(weight) {\n\t\t\tconst buffer = this.buffer,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\toffset = stride * this._addIndex;\n\n\t\t\tif (this.cumulativeWeightAdditive === 0) {\n\t\t\t\t// add = identity\n\t\t\t\tthis._setIdentity();\n\t\t\t} // add := add + incoming * weight\n\n\n\t\t\tthis._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);\n\n\t\t\tthis.cumulativeWeightAdditive += weight;\n\t\t} // apply the state of 'accu<i>' to the binding when accus differ\n\n\n\t\tapply(accuIndex) {\n\t\t\tconst stride = this.valueSize,\n\t\t\t\t\t\tbuffer = this.buffer,\n\t\t\t\t\t\toffset = accuIndex * stride + stride,\n\t\t\t\t\t\tweight = this.cumulativeWeight,\n\t\t\t\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\t\t\t\t\t\tbinding = this.binding;\n\t\t\tthis.cumulativeWeight = 0;\n\t\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\t\tif (weight < 1) {\n\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\t\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\t\tthis._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);\n\t\t\t}\n\n\t\t\tif (weightAdditive > 0) {\n\t\t\t\t// accuN := accuN + additive accuN\n\t\t\t\tthis._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);\n\t\t\t}\n\n\t\t\tfor (let i = stride, e = stride + stride; i !== e; ++i) {\n\t\t\t\tif (buffer[i] !== buffer[i + stride]) {\n\t\t\t\t\t// value has changed -> update scene graph\n\t\t\t\t\tbinding.setValue(buffer, offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} // remember the state of the bound property and copy it to both accus\n\n\n\t\tsaveOriginalState() {\n\t\t\tconst binding = this.binding;\n\t\t\tconst buffer = this.buffer,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\toriginalValueOffset = stride * this._origIndex;\n\t\t\tbinding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original\n\n\t\t\tfor (let i = stride, e = originalValueOffset; i !== e; ++i) {\n\t\t\t\tbuffer[i] = buffer[originalValueOffset + i % stride];\n\t\t\t} // Add to identity for additive\n\n\n\t\t\tthis._setIdentity();\n\n\t\t\tthis.cumulativeWeight = 0;\n\t\t\tthis.cumulativeWeightAdditive = 0;\n\t\t} // apply the state previously taken via 'saveOriginalState' to the binding\n\n\n\t\trestoreOriginalState() {\n\t\t\tconst originalValueOffset = this.valueSize * 3;\n\t\t\tthis.binding.setValue(this.buffer, originalValueOffset);\n\t\t}\n\n\t\t_setAdditiveIdentityNumeric() {\n\t\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\t\tthis.buffer[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t_setAdditiveIdentityQuaternion() {\n\t\t\tthis._setAdditiveIdentityNumeric();\n\n\t\t\tthis.buffer[this._addIndex * this.valueSize + 3] = 1;\n\t\t}\n\n\t\t_setAdditiveIdentityOther() {\n\t\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\t\tfor (let i = 0; i < this.valueSize; i++) {\n\t\t\t\tthis.buffer[targetIndex + i] = this.buffer[startIndex + i];\n\t\t\t}\n\t\t} // mix functions\n\n\n\t\t_select(buffer, dstOffset, srcOffset, t, stride) {\n\t\t\tif (t >= 0.5) {\n\t\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\t\tbuffer[dstOffset + i] = buffer[srcOffset + i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_slerp(buffer, dstOffset, srcOffset, t) {\n\t\t\tQuaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);\n\t\t}\n\n\t\t_slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n\t\t\tconst workOffset = this._workIndex * stride; // Store result in intermediate buffer offset\n\n\t\t\tQuaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result\n\n\t\t\tQuaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);\n\t\t}\n\n\t\t_lerp(buffer, dstOffset, srcOffset, t, stride) {\n\t\t\tconst s = 1 - t;\n\n\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\tconst j = dstOffset + i;\n\t\t\t\tbuffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;\n\t\t\t}\n\t\t}\n\n\t\t_lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\tconst j = dstOffset + i;\n\t\t\t\tbuffer[j] = buffer[j] + buffer[srcOffset + i] * t;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// Characters [].:/ are reserved for track binding syntax.\n\tconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\n\n\tconst _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\\w` regexp matches\n\t// only latin characters, and the unicode \\p{L} is not yet supported. So\n\t// instead, we exclude reserved characters and match everything else.\n\n\n\tconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\n\n\tconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must\n\t// be matched to parse the rest of the track name.\n\n\n\tconst _directoryRe = /((?:WC+[\\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\n\n\n\tconst _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved\n\t// characters. Accessor may contain any character except closing bracket.\n\n\n\tconst _objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may\n\t// contain any non-bracket characters.\n\n\n\tconst _propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace('WC', _wordChar);\n\n\tconst _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');\n\n\tconst _supportedObjectNames = ['material', 'materials', 'bones'];\n\n\tclass Composite {\n\t\tconstructor(targetGroup, path, optionalParsedPath) {\n\t\t\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);\n\t\t\tthis._targetGroup = targetGroup;\n\t\t\tthis._bindings = targetGroup.subscribe_(path, parsedPath);\n\t\t}\n\n\t\tgetValue(array, offset) {\n\t\t\tthis.bind(); // bind all binding\n\n\t\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t\tbinding = this._bindings[firstValidIndex]; // and only call .getValue on the first\n\n\t\t\tif (binding !== undefined) binding.getValue(array, offset);\n\t\t}\n\n\t\tsetValue(array, offset) {\n\t\t\tconst bindings = this._bindings;\n\n\t\t\tfor (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n\t\t\t\tbindings[i].setValue(array, offset);\n\t\t\t}\n\t\t}\n\n\t\tbind() {\n\t\t\tconst bindings = this._bindings;\n\n\t\t\tfor (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n\t\t\t\tbindings[i].bind();\n\t\t\t}\n\t\t}\n\n\t\tunbind() {\n\t\t\tconst bindings = this._bindings;\n\n\t\t\tfor (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n\t\t\t\tbindings[i].unbind();\n\t\t\t}\n\t\t}\n\n\t} // Note: This class uses a State pattern on a per-method basis:\n\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t// prototype version of these methods with one that represents\n\t// the bound state. When the property is not found, the methods\n\t// become no-ops.\n\n\n\tclass PropertyBinding {\n\t\tconstructor(rootNode, path, parsedPath) {\n\t\t\tthis.path = path;\n\t\t\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);\n\t\t\tthis.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;\n\t\t\tthis.rootNode = rootNode; // initial state of these methods that calls 'bind'\n\n\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\tthis.setValue = this._setValue_unbound;\n\t\t}\n\n\t\tstatic create(root, path, parsedPath) {\n\t\t\tif (!(root && root.isAnimationObjectGroup)) {\n\t\t\t\treturn new PropertyBinding(root, path, parsedPath);\n\t\t\t} else {\n\t\t\t\treturn new PropertyBinding.Composite(root, path, parsedPath);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Replaces spaces with underscores and removes unsupported characters from\n\t\t * node names, to ensure compatibility with parseTrackName().\n\t\t *\n\t\t * @param {string} name Node name to be sanitized.\n\t\t * @return {string}\n\t\t */\n\n\n\t\tstatic sanitizeNodeName(name) {\n\t\t\treturn name.replace(/\\s/g, '_').replace(_reservedRe, '');\n\t\t}\n\n\t\tstatic parseTrackName(trackName) {\n\t\t\tconst matches = _trackRe.exec(trackName);\n\n\t\t\tif (!matches) {\n\t\t\t\tthrow new Error('PropertyBinding: Cannot parse trackName: ' + trackName);\n\t\t\t}\n\n\t\t\tconst results = {\n\t\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\t\tnodeName: matches[2],\n\t\t\t\tobjectName: matches[3],\n\t\t\t\tobjectIndex: matches[4],\n\t\t\t\tpropertyName: matches[5],\n\t\t\t\t// required\n\t\t\t\tpropertyIndex: matches[6]\n\t\t\t};\n\t\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf('.');\n\n\t\t\tif (lastDot !== undefined && lastDot !== -1) {\n\t\t\t\tconst objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there\n\t\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t\t// include '.' characters).\n\n\t\t\t\tif (_supportedObjectNames.indexOf(objectName) !== -1) {\n\t\t\t\t\tresults.nodeName = results.nodeName.substring(0, lastDot);\n\t\t\t\t\tresults.objectName = objectName;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (results.propertyName === null || results.propertyName.length === 0) {\n\t\t\t\tthrow new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);\n\t\t\t}\n\n\t\t\treturn results;\n\t\t}\n\n\t\tstatic findNode(root, nodeName) {\n\t\t\tif (!nodeName || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {\n\t\t\t\treturn root;\n\t\t\t} // search into skeleton bones.\n\n\n\t\t\tif (root.skeleton) {\n\t\t\t\tconst bone = root.skeleton.getBoneByName(nodeName);\n\n\t\t\t\tif (bone !== undefined) {\n\t\t\t\t\treturn bone;\n\t\t\t\t}\n\t\t\t} // search into node subtree.\n\n\n\t\t\tif (root.children) {\n\t\t\t\tconst searchNodeSubtree = function (children) {\n\t\t\t\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\t\t\t\tconst childNode = children[i];\n\n\t\t\t\t\t\tif (childNode.name === nodeName || childNode.uuid === nodeName) {\n\t\t\t\t\t\t\treturn childNode;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst result = searchNodeSubtree(childNode.children);\n\t\t\t\t\t\tif (result) return result;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tconst subTreeNode = searchNodeSubtree(root.children);\n\n\t\t\t\tif (subTreeNode) {\n\t\t\t\t\treturn subTreeNode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t} // these are used to \"bind\" a nonexistent property\n\n\n\t\t_getValue_unavailable() {}\n\n\t\t_setValue_unavailable() {} // Getters\n\n\n\t\t_getValue_direct(buffer, offset) {\n\t\t\tbuffer[offset] = this.node[this.propertyName];\n\t\t}\n\n\t\t_getValue_array(buffer, offset) {\n\t\t\tconst source = this.resolvedProperty;\n\n\t\t\tfor (let i = 0, n = source.length; i !== n; ++i) {\n\t\t\t\tbuffer[offset++] = source[i];\n\t\t\t}\n\t\t}\n\n\t\t_getValue_arrayElement(buffer, offset) {\n\t\t\tbuffer[offset] = this.resolvedProperty[this.propertyIndex];\n\t\t}\n\n\t\t_getValue_toArray(buffer, offset) {\n\t\t\tthis.resolvedProperty.toArray(buffer, offset);\n\t\t} // Direct\n\n\n\t\t_setValue_direct(buffer, offset) {\n\t\t\tthis.targetObject[this.propertyName] = buffer[offset];\n\t\t}\n\n\t\t_setValue_direct_setNeedsUpdate(buffer, offset) {\n\t\t\tthis.targetObject[this.propertyName] = buffer[offset];\n\t\t\tthis.targetObject.needsUpdate = true;\n\t\t}\n\n\t\t_setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {\n\t\t\tthis.targetObject[this.propertyName] = buffer[offset];\n\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\t} // EntireArray\n\n\n\t\t_setValue_array(buffer, offset) {\n\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\tfor (let i = 0, n = dest.length; i !== n; ++i) {\n\t\t\t\tdest[i] = buffer[offset++];\n\t\t\t}\n\t\t}\n\n\t\t_setValue_array_setNeedsUpdate(buffer, offset) {\n\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\tfor (let i = 0, n = dest.length; i !== n; ++i) {\n\t\t\t\tdest[i] = buffer[offset++];\n\t\t\t}\n\n\t\t\tthis.targetObject.needsUpdate = true;\n\t\t}\n\n\t\t_setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {\n\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\tfor (let i = 0, n = dest.length; i !== n; ++i) {\n\t\t\t\tdest[i] = buffer[offset++];\n\t\t\t}\n\n\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\t} // ArrayElement\n\n\n\t\t_setValue_arrayElement(buffer, offset) {\n\t\t\tthis.resolvedProperty[this.propertyIndex] = buffer[offset];\n\t\t}\n\n\t\t_setValue_arrayElement_setNeedsUpdate(buffer, offset) {\n\t\t\tthis.resolvedProperty[this.propertyIndex] = buffer[offset];\n\t\t\tthis.targetObject.needsUpdate = true;\n\t\t}\n\n\t\t_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {\n\t\t\tthis.resolvedProperty[this.propertyIndex] = buffer[offset];\n\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\t} // HasToFromArray\n\n\n\t\t_setValue_fromArray(buffer, offset) {\n\t\t\tthis.resolvedProperty.fromArray(buffer, offset);\n\t\t}\n\n\t\t_setValue_fromArray_setNeedsUpdate(buffer, offset) {\n\t\t\tthis.resolvedProperty.fromArray(buffer, offset);\n\t\t\tthis.targetObject.needsUpdate = true;\n\t\t}\n\n\t\t_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {\n\t\t\tthis.resolvedProperty.fromArray(buffer, offset);\n\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\t}\n\n\t\t_getValue_unbound(targetArray, offset) {\n\t\t\tthis.bind();\n\t\t\tthis.getValue(targetArray, offset);\n\t\t}\n\n\t\t_setValue_unbound(sourceArray, offset) {\n\t\t\tthis.bind();\n\t\t\tthis.setValue(sourceArray, offset);\n\t\t} // create getter / setter pair for a property in the scene graph\n\n\n\t\tbind() {\n\t\t\tlet targetObject = this.node;\n\t\t\tconst parsedPath = this.parsedPath;\n\t\t\tconst objectName = parsedPath.objectName;\n\t\t\tconst propertyName = parsedPath.propertyName;\n\t\t\tlet propertyIndex = parsedPath.propertyIndex;\n\n\t\t\tif (!targetObject) {\n\t\t\t\ttargetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;\n\t\t\t\tthis.node = targetObject;\n\t\t\t} // set fail state so we can just 'return' on error\n\n\n\t\t\tthis.getValue = this._getValue_unavailable;\n\t\t\tthis.setValue = this._setValue_unavailable; // ensure there is a value node\n\n\t\t\tif (!targetObject) {\n\t\t\t\tconsole.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (objectName) {\n\t\t\t\tlet objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....\n\n\t\t\t\tswitch (objectName) {\n\t\t\t\t\tcase 'materials':\n\t\t\t\t\t\tif (!targetObject.material) {\n\t\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!targetObject.material.materials) {\n\t\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject.material.materials;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bones':\n\t\t\t\t\t\tif (!targetObject.skeleton) {\n\t\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} // potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t\t// and convert the integer string to a true integer.\n\n\n\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.\n\n\t\t\t\t\t\tfor (let i = 0; i < targetObject.length; i++) {\n\t\t\t\t\t\t\tif (targetObject[i].name === objectIndex) {\n\t\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (targetObject[objectName] === undefined) {\n\t\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject[objectName];\n\t\t\t\t}\n\n\t\t\t\tif (objectIndex !== undefined) {\n\t\t\t\t\tif (targetObject[objectIndex] === undefined) {\n\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[objectIndex];\n\t\t\t\t}\n\t\t\t} // resolve property\n\n\n\t\t\tconst nodeProperty = targetObject[propertyName];\n\n\t\t\tif (nodeProperty === undefined) {\n\t\t\t\tconst nodeName = parsedPath.nodeName;\n\t\t\t\tconsole.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\\'t found.', targetObject);\n\t\t\t\treturn;\n\t\t\t} // determine versioning scheme\n\n\n\t\t\tlet versioning = this.Versioning.None;\n\t\t\tthis.targetObject = targetObject;\n\n\t\t\tif (targetObject.needsUpdate !== undefined) {\n\t\t\t\t// material\n\t\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\t} else if (targetObject.matrixWorldNeedsUpdate !== undefined) {\n\t\t\t\t// node transform\n\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\t} // determine how the property gets bound\n\n\n\t\t\tlet bindingType = this.BindingType.Direct;\n\n\t\t\tif (propertyIndex !== undefined) {\n\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\t\t\t\tif (propertyName === 'morphTargetInfluences') {\n\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tif (!targetObject.geometry) {\n\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (targetObject.geometry.isBufferGeometry) {\n\t\t\t\t\t\tif (!targetObject.geometry.morphAttributes) {\n\t\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {\n\t\t\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[propertyIndex];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbindingType = this.BindingType.ArrayElement;\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t\tthis.propertyIndex = propertyIndex;\n\t\t\t} else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {\n\t\t\t\t// must use copy for Object3D.Euler/Quaternion\n\t\t\t\tbindingType = this.BindingType.HasFromToArray;\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t} else if (Array.isArray(nodeProperty)) {\n\t\t\t\tbindingType = this.BindingType.EntireArray;\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t} else {\n\t\t\t\tthis.propertyName = propertyName;\n\t\t\t} // select getter / setter\n\n\n\t\t\tthis.getValue = this.GetterByBindingType[bindingType];\n\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];\n\t\t}\n\n\t\tunbind() {\n\t\t\tthis.node = null; // back to the prototype version of getValue / setValue\n\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\n\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\tthis.setValue = this._setValue_unbound;\n\t\t}\n\n\t}\n\n\tPropertyBinding.Composite = Composite;\n\tPropertyBinding.prototype.BindingType = {\n\t\tDirect: 0,\n\t\tEntireArray: 1,\n\t\tArrayElement: 2,\n\t\tHasFromToArray: 3\n\t};\n\tPropertyBinding.prototype.Versioning = {\n\t\tNone: 0,\n\t\tNeedsUpdate: 1,\n\t\tMatrixWorldNeedsUpdate: 2\n\t};\n\tPropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];\n\tPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[// Direct\n\tPropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [// EntireArray\n\tPropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [// ArrayElement\n\tPropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [// HasToFromArray\n\tPropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];\n\n\t/**\n\t *\n\t * A group of objects that receives a shared animation state.\n\t *\n\t * Usage:\n\t *\n\t *\t- Add objects you would otherwise pass as 'root' to the\n\t *\t\tconstructor or the .clipAction method of AnimationMixer.\n\t *\n\t *\t- Instead pass this object as 'root'.\n\t *\n\t *\t- You can also add and remove objects later when the mixer\n\t *\t\tis running.\n\t *\n\t * Note:\n\t *\n\t *\t\tObjects of this class appear as one object to the mixer,\n\t *\t\tso cache control of the individual objects must be done\n\t *\t\ton the group.\n\t *\n\t * Limitation:\n\t *\n\t *\t- The animated properties must be compatible among the\n\t *\t\tall objects in the group.\n\t *\n\t *\t- A single property can either be controlled through a\n\t *\t\ttarget group or directly, but not both.\n\t */\n\n\tclass AnimationObjectGroup {\n\t\tconstructor() {\n\t\t\tthis.uuid = generateUUID(); // cached objects followed by the active ones\n\n\t\t\tthis._objects = Array.prototype.slice.call(arguments);\n\t\t\tthis.nCachedObjects_ = 0; // threshold\n\t\t\t// note: read by PropertyBinding.Composite\n\n\t\t\tconst indices = {};\n\t\t\tthis._indicesByUUID = indices; // for bookkeeping\n\n\t\t\tfor (let i = 0, n = arguments.length; i !== n; ++i) {\n\t\t\t\tindices[arguments[i].uuid] = i;\n\t\t\t}\n\n\t\t\tthis._paths = []; // inside: string\n\n\t\t\tthis._parsedPaths = []; // inside: { we don't care, here }\n\n\t\t\tthis._bindings = []; // inside: Array< PropertyBinding >\n\n\t\t\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\t\t\tconst scope = this;\n\t\t\tthis.stats = {\n\t\t\t\tobjects: {\n\t\t\t\t\tget total() {\n\t\t\t\t\t\treturn scope._objects.length;\n\t\t\t\t\t},\n\n\t\t\t\t\tget inUse() {\n\t\t\t\t\t\treturn this.total - scope.nCachedObjects_;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tget bindingsPerObject() {\n\t\t\t\t\treturn scope._bindings.length;\n\t\t\t\t}\n\n\t\t\t};\n\t\t}\n\n\t\tadd() {\n\t\t\tconst objects = this._objects,\n\t\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\t\tpaths = this._paths,\n\t\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\t\tnBindings = bindings.length;\n\t\t\tlet knownObject = undefined,\n\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_;\n\n\t\t\tfor (let i = 0, n = arguments.length; i !== n; ++i) {\n\t\t\t\tconst object = arguments[i],\n\t\t\t\t\t\t\tuuid = object.uuid;\n\t\t\t\tlet index = indicesByUUID[uuid];\n\n\t\t\t\tif (index === undefined) {\n\t\t\t\t\t// unknown object -> add it to the ACTIVE region\n\t\t\t\t\tindex = nObjects++;\n\t\t\t\t\tindicesByUUID[uuid] = index;\n\t\t\t\t\tobjects.push(object); // accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor (let j = 0, m = nBindings; j !== m; ++j) {\n\t\t\t\t\t\tbindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));\n\t\t\t\t\t}\n\t\t\t\t} else if (index < nCachedObjects) {\n\t\t\t\t\tknownObject = objects[index]; // move existing object to the ACTIVE region\n\n\t\t\t\t\tconst firstActiveIndex = --nCachedObjects,\n\t\t\t\t\t\t\t\tlastCachedObject = objects[firstActiveIndex];\n\t\t\t\t\tindicesByUUID[lastCachedObject.uuid] = index;\n\t\t\t\t\tobjects[index] = lastCachedObject;\n\t\t\t\t\tindicesByUUID[uuid] = firstActiveIndex;\n\t\t\t\t\tobjects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor (let j = 0, m = nBindings; j !== m; ++j) {\n\t\t\t\t\t\tconst bindingsForPath = bindings[j],\n\t\t\t\t\t\t\t\t\tlastCached = bindingsForPath[firstActiveIndex];\n\t\t\t\t\t\tlet binding = bindingsForPath[index];\n\t\t\t\t\t\tbindingsForPath[index] = lastCached;\n\n\t\t\t\t\t\tif (binding === undefined) {\n\t\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t\t// or may not exist\n\t\t\t\t\t\t\tbinding = new PropertyBinding(object, paths[j], parsedPaths[j]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbindingsForPath[firstActiveIndex] = binding;\n\t\t\t\t\t}\n\t\t\t\t} else if (objects[index] !== knownObject) {\n\t\t\t\t\tconsole.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');\n\t\t\t\t} // else the object is already where we want it to be\n\n\t\t\t} // for arguments\n\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\t}\n\n\t\tremove() {\n\t\t\tconst objects = this._objects,\n\t\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\t\tnBindings = bindings.length;\n\t\t\tlet nCachedObjects = this.nCachedObjects_;\n\n\t\t\tfor (let i = 0, n = arguments.length; i !== n; ++i) {\n\t\t\t\tconst object = arguments[i],\n\t\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\t\tindex = indicesByUUID[uuid];\n\n\t\t\t\tif (index !== undefined && index >= nCachedObjects) {\n\t\t\t\t\t// move existing object into the CACHED region\n\t\t\t\t\tconst lastCachedIndex = nCachedObjects++,\n\t\t\t\t\t\t\t\tfirstActiveObject = objects[lastCachedIndex];\n\t\t\t\t\tindicesByUUID[firstActiveObject.uuid] = index;\n\t\t\t\t\tobjects[index] = firstActiveObject;\n\t\t\t\t\tindicesByUUID[uuid] = lastCachedIndex;\n\t\t\t\t\tobjects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor (let j = 0, m = nBindings; j !== m; ++j) {\n\t\t\t\t\t\tconst bindingsForPath = bindings[j],\n\t\t\t\t\t\t\t\t\tfirstActive = bindingsForPath[lastCachedIndex],\n\t\t\t\t\t\t\t\t\tbinding = bindingsForPath[index];\n\t\t\t\t\t\tbindingsForPath[index] = firstActive;\n\t\t\t\t\t\tbindingsForPath[lastCachedIndex] = binding;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // for arguments\n\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\t} // remove & forget\n\n\n\t\tuncache() {\n\t\t\tconst objects = this._objects,\n\t\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\t\tnBindings = bindings.length;\n\t\t\tlet nCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tnObjects = objects.length;\n\n\t\t\tfor (let i = 0, n = arguments.length; i !== n; ++i) {\n\t\t\t\tconst object = arguments[i],\n\t\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\t\tindex = indicesByUUID[uuid];\n\n\t\t\t\tif (index !== undefined) {\n\t\t\t\t\tdelete indicesByUUID[uuid];\n\n\t\t\t\t\tif (index < nCachedObjects) {\n\t\t\t\t\t\t// object is cached, shrink the CACHED region\n\t\t\t\t\t\tconst firstActiveIndex = --nCachedObjects,\n\t\t\t\t\t\t\t\t\tlastCachedObject = objects[firstActiveIndex],\n\t\t\t\t\t\t\t\t\tlastIndex = --nObjects,\n\t\t\t\t\t\t\t\t\tlastObject = objects[lastIndex]; // last cached object takes this object's place\n\n\t\t\t\t\t\tindicesByUUID[lastCachedObject.uuid] = index;\n\t\t\t\t\t\tobjects[index] = lastCachedObject; // last object goes to the activated slot and pop\n\n\t\t\t\t\t\tindicesByUUID[lastObject.uuid] = firstActiveIndex;\n\t\t\t\t\t\tobjects[firstActiveIndex] = lastObject;\n\t\t\t\t\t\tobjects.pop(); // accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor (let j = 0, m = nBindings; j !== m; ++j) {\n\t\t\t\t\t\t\tconst bindingsForPath = bindings[j],\n\t\t\t\t\t\t\t\t\t\tlastCached = bindingsForPath[firstActiveIndex],\n\t\t\t\t\t\t\t\t\t\tlast = bindingsForPath[lastIndex];\n\t\t\t\t\t\t\tbindingsForPath[index] = lastCached;\n\t\t\t\t\t\t\tbindingsForPath[firstActiveIndex] = last;\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// object is active, just swap with the last and pop\n\t\t\t\t\t\tconst lastIndex = --nObjects,\n\t\t\t\t\t\t\t\t\tlastObject = objects[lastIndex];\n\n\t\t\t\t\t\tif (lastIndex > 0) {\n\t\t\t\t\t\t\tindicesByUUID[lastObject.uuid] = index;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobjects[index] = lastObject;\n\t\t\t\t\t\tobjects.pop(); // accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor (let j = 0, m = nBindings; j !== m; ++j) {\n\t\t\t\t\t\t\tconst bindingsForPath = bindings[j];\n\t\t\t\t\t\t\tbindingsForPath[index] = bindingsForPath[lastIndex];\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} // cached or active\n\n\t\t\t\t} // if object is known\n\n\t\t\t} // for arguments\n\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\t} // Internal interface used by befriended PropertyBinding.Composite:\n\n\n\t\tsubscribe_(path, parsedPath) {\n\t\t\t// returns an array of bindings for the given path that is changed\n\t\t\t// according to the contained objects in the group\n\t\t\tconst indicesByPath = this._bindingsIndicesByPath;\n\t\t\tlet index = indicesByPath[path];\n\t\t\tconst bindings = this._bindings;\n\t\t\tif (index !== undefined) return bindings[index];\n\t\t\tconst paths = this._paths,\n\t\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\t\tobjects = this._objects,\n\t\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\t\tbindingsForPath = new Array(nObjects);\n\t\t\tindex = bindings.length;\n\t\t\tindicesByPath[path] = index;\n\t\t\tpaths.push(path);\n\t\t\tparsedPaths.push(parsedPath);\n\t\t\tbindings.push(bindingsForPath);\n\n\t\t\tfor (let i = nCachedObjects, n = objects.length; i !== n; ++i) {\n\t\t\t\tconst object = objects[i];\n\t\t\t\tbindingsForPath[i] = new PropertyBinding(object, path, parsedPath);\n\t\t\t}\n\n\t\t\treturn bindingsForPath;\n\t\t}\n\n\t\tunsubscribe_(path) {\n\t\t\t// tells the group to forget about a property path and no longer\n\t\t\t// update the array previously obtained with 'subscribe_'\n\t\t\tconst indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\t\t\tindex = indicesByPath[path];\n\n\t\t\tif (index !== undefined) {\n\t\t\t\tconst paths = this._paths,\n\t\t\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\t\t\t\tlastBindings = bindings[lastBindingsIndex],\n\t\t\t\t\t\t\tlastBindingsPath = path[lastBindingsIndex];\n\t\t\t\tindicesByPath[lastBindingsPath] = index;\n\t\t\t\tbindings[index] = lastBindings;\n\t\t\t\tbindings.pop();\n\t\t\t\tparsedPaths[index] = parsedPaths[lastBindingsIndex];\n\t\t\t\tparsedPaths.pop();\n\t\t\t\tpaths[index] = paths[lastBindingsIndex];\n\t\t\t\tpaths.pop();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tAnimationObjectGroup.prototype.isAnimationObjectGroup = true;\n\n\tclass AnimationAction {\n\t\tconstructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {\n\t\t\tthis._mixer = mixer;\n\t\t\tthis._clip = clip;\n\t\t\tthis._localRoot = localRoot;\n\t\t\tthis.blendMode = blendMode;\n\t\t\tconst tracks = clip.tracks,\n\t\t\t\t\t\tnTracks = tracks.length,\n\t\t\t\t\t\tinterpolants = new Array(nTracks);\n\t\t\tconst interpolantSettings = {\n\t\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t\t};\n\n\t\t\tfor (let i = 0; i !== nTracks; ++i) {\n\t\t\t\tconst interpolant = tracks[i].createInterpolant(null);\n\t\t\t\tinterpolants[i] = interpolant;\n\t\t\t\tinterpolant.settings = interpolantSettings;\n\t\t\t}\n\n\t\t\tthis._interpolantSettings = interpolantSettings;\n\t\t\tthis._interpolants = interpolants; // bound by the mixer\n\t\t\t// inside: PropertyMixer (managed by the mixer)\n\n\t\t\tthis._propertyBindings = new Array(nTracks);\n\t\t\tthis._cacheIndex = null; // for the memory manager\n\n\t\t\tthis._byClipCacheIndex = null; // for the memory manager\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis.loop = LoopRepeat;\n\t\t\tthis._loopCount = -1; // global mixer time when the action is to be started\n\t\t\t// it's set back to 'null' upon start of the action\n\n\t\t\tthis._startTime = null; // scaled local time of the action\n\t\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\n\t\t\tthis.time = 0;\n\t\t\tthis.timeScale = 1;\n\t\t\tthis._effectiveTimeScale = 1;\n\t\t\tthis.weight = 1;\n\t\t\tthis._effectiveWeight = 1;\n\t\t\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\t\t\tthis.paused = false; // true -> zero effective time scale\n\n\t\t\tthis.enabled = true; // false -> zero effective weight\n\n\t\t\tthis.clampWhenFinished = false; // keep feeding the last frame?\n\n\t\t\tthis.zeroSlopeAtStart = true; // for smooth interpolation w/o separate\n\n\t\t\tthis.zeroSlopeAtEnd = true; // clips for start, loop and end\n\t\t} // State & Scheduling\n\n\n\t\tplay() {\n\t\t\tthis._mixer._activateAction(this);\n\n\t\t\treturn this;\n\t\t}\n\n\t\tstop() {\n\t\t\tthis._mixer._deactivateAction(this);\n\n\t\t\treturn this.reset();\n\t\t}\n\n\t\treset() {\n\t\t\tthis.paused = false;\n\t\t\tthis.enabled = true;\n\t\t\tthis.time = 0; // restart clip\n\n\t\t\tthis._loopCount = -1; // forget previous loops\n\n\t\t\tthis._startTime = null; // forget scheduling\n\n\t\t\treturn this.stopFading().stopWarping();\n\t\t}\n\n\t\tisRunning() {\n\t\t\treturn this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);\n\t\t} // return true when play has been called\n\n\n\t\tisScheduled() {\n\t\t\treturn this._mixer._isActiveAction(this);\n\t\t}\n\n\t\tstartAt(time) {\n\t\t\tthis._startTime = time;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetLoop(mode, repetitions) {\n\t\t\tthis.loop = mode;\n\t\t\tthis.repetitions = repetitions;\n\t\t\treturn this;\n\t\t} // Weight\n\t\t// set the weight stopping any scheduled fading\n\t\t// although .enabled = false yields an effective weight of zero, this\n\t\t// method does *not* change .enabled, because it would be confusing\n\n\n\t\tsetEffectiveWeight(weight) {\n\t\t\tthis.weight = weight; // note: same logic as when updated at runtime\n\n\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\t\t\treturn this.stopFading();\n\t\t} // return the weight considering fading and .enabled\n\n\n\t\tgetEffectiveWeight() {\n\t\t\treturn this._effectiveWeight;\n\t\t}\n\n\t\tfadeIn(duration) {\n\t\t\treturn this._scheduleFading(duration, 0, 1);\n\t\t}\n\n\t\tfadeOut(duration) {\n\t\t\treturn this._scheduleFading(duration, 1, 0);\n\t\t}\n\n\t\tcrossFadeFrom(fadeOutAction, duration, warp) {\n\t\t\tfadeOutAction.fadeOut(duration);\n\t\t\tthis.fadeIn(duration);\n\n\t\t\tif (warp) {\n\t\t\t\tconst fadeInDuration = this._clip.duration,\n\t\t\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\t\t\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\t\t\t\tfadeOutAction.warp(1.0, startEndRatio, duration);\n\t\t\t\tthis.warp(endStartRatio, 1.0, duration);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcrossFadeTo(fadeInAction, duration, warp) {\n\t\t\treturn fadeInAction.crossFadeFrom(this, duration, warp);\n\t\t}\n\n\t\tstopFading() {\n\t\t\tconst weightInterpolant = this._weightInterpolant;\n\n\t\t\tif (weightInterpolant !== null) {\n\t\t\t\tthis._weightInterpolant = null;\n\n\t\t\t\tthis._mixer._takeBackControlInterpolant(weightInterpolant);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // Time Scale Control\n\t\t// set the time scale stopping any scheduled warping\n\t\t// although .paused = true yields an effective time scale of zero, this\n\t\t// method does *not* change .paused, because it would be confusing\n\n\n\t\tsetEffectiveTimeScale(timeScale) {\n\t\t\tthis.timeScale = timeScale;\n\t\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\t\t\treturn this.stopWarping();\n\t\t} // return the time scale considering warping and .paused\n\n\n\t\tgetEffectiveTimeScale() {\n\t\t\treturn this._effectiveTimeScale;\n\t\t}\n\n\t\tsetDuration(duration) {\n\t\t\tthis.timeScale = this._clip.duration / duration;\n\t\t\treturn this.stopWarping();\n\t\t}\n\n\t\tsyncWith(action) {\n\t\t\tthis.time = action.time;\n\t\t\tthis.timeScale = action.timeScale;\n\t\t\treturn this.stopWarping();\n\t\t}\n\n\t\thalt(duration) {\n\t\t\treturn this.warp(this._effectiveTimeScale, 0, duration);\n\t\t}\n\n\t\twarp(startTimeScale, endTimeScale, duration) {\n\t\t\tconst mixer = this._mixer,\n\t\t\t\t\t\tnow = mixer.time,\n\t\t\t\t\t\ttimeScale = this.timeScale;\n\t\t\tlet interpolant = this._timeScaleInterpolant;\n\n\t\t\tif (interpolant === null) {\n\t\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\t\tthis._timeScaleInterpolant = interpolant;\n\t\t\t}\n\n\t\t\tconst times = interpolant.parameterPositions,\n\t\t\t\t\t\tvalues = interpolant.sampleValues;\n\t\t\ttimes[0] = now;\n\t\t\ttimes[1] = now + duration;\n\t\t\tvalues[0] = startTimeScale / timeScale;\n\t\t\tvalues[1] = endTimeScale / timeScale;\n\t\t\treturn this;\n\t\t}\n\n\t\tstopWarping() {\n\t\t\tconst timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\t\tif (timeScaleInterpolant !== null) {\n\t\t\t\tthis._timeScaleInterpolant = null;\n\n\t\t\t\tthis._mixer._takeBackControlInterpolant(timeScaleInterpolant);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // Object Accessors\n\n\n\t\tgetMixer() {\n\t\t\treturn this._mixer;\n\t\t}\n\n\t\tgetClip() {\n\t\t\treturn this._clip;\n\t\t}\n\n\t\tgetRoot() {\n\t\t\treturn this._localRoot || this._mixer._root;\n\t\t} // Interna\n\n\n\t\t_update(time, deltaTime, timeDirection, accuIndex) {\n\t\t\t// called by the mixer\n\t\t\tif (!this.enabled) {\n\t\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\t\t\t\tthis._updateWeight(time);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst startTime = this._startTime;\n\n\t\t\tif (startTime !== null) {\n\t\t\t\t// check for scheduled start of action\n\t\t\t\tconst timeRunning = (time - startTime) * timeDirection;\n\n\t\t\t\tif (timeRunning < 0 || timeDirection === 0) {\n\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\t\t\t\t} // start\n\n\n\t\t\t\tthis._startTime = null; // unschedule\n\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\t\t\t} // apply time scale and advance time\n\n\n\t\t\tdeltaTime *= this._updateTimeScale(time);\n\n\t\t\tconst clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in\n\t\t\t// an effective weight of 0\n\n\n\t\t\tconst weight = this._updateWeight(time);\n\n\t\t\tif (weight > 0) {\n\t\t\t\tconst interpolants = this._interpolants;\n\t\t\t\tconst propertyMixers = this._propertyBindings;\n\n\t\t\t\tswitch (this.blendMode) {\n\t\t\t\t\tcase AdditiveAnimationBlendMode:\n\t\t\t\t\t\tfor (let j = 0, m = interpolants.length; j !== m; ++j) {\n\t\t\t\t\t\t\tinterpolants[j].evaluate(clipTime);\n\t\t\t\t\t\t\tpropertyMixers[j].accumulateAdditive(weight);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase NormalAnimationBlendMode:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfor (let j = 0, m = interpolants.length; j !== m; ++j) {\n\t\t\t\t\t\t\tinterpolants[j].evaluate(clipTime);\n\t\t\t\t\t\t\tpropertyMixers[j].accumulate(accuIndex, weight);\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_updateWeight(time) {\n\t\t\tlet weight = 0;\n\n\t\t\tif (this.enabled) {\n\t\t\t\tweight = this.weight;\n\t\t\t\tconst interpolant = this._weightInterpolant;\n\n\t\t\t\tif (interpolant !== null) {\n\t\t\t\t\tconst interpolantValue = interpolant.evaluate(time)[0];\n\t\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\t\tif (time > interpolant.parameterPositions[1]) {\n\t\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\t\tif (interpolantValue === 0) {\n\t\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\t\tthis.enabled = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._effectiveWeight = weight;\n\t\t\treturn weight;\n\t\t}\n\n\t\t_updateTimeScale(time) {\n\t\t\tlet timeScale = 0;\n\n\t\t\tif (!this.paused) {\n\t\t\t\ttimeScale = this.timeScale;\n\t\t\t\tconst interpolant = this._timeScaleInterpolant;\n\n\t\t\t\tif (interpolant !== null) {\n\t\t\t\t\tconst interpolantValue = interpolant.evaluate(time)[0];\n\t\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\t\tif (time > interpolant.parameterPositions[1]) {\n\t\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\t\tif (timeScale === 0) {\n\t\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\t\tthis.paused = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\t\tthis.timeScale = timeScale;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._effectiveTimeScale = timeScale;\n\t\t\treturn timeScale;\n\t\t}\n\n\t\t_updateTime(deltaTime) {\n\t\t\tconst duration = this._clip.duration;\n\t\t\tconst loop = this.loop;\n\t\t\tlet time = this.time + deltaTime;\n\t\t\tlet loopCount = this._loopCount;\n\t\t\tconst pingPong = loop === LoopPingPong;\n\n\t\t\tif (deltaTime === 0) {\n\t\t\t\tif (loopCount === -1) return time;\n\t\t\t\treturn pingPong && (loopCount & 1) === 1 ? duration - time : time;\n\t\t\t}\n\n\t\t\tif (loop === LoopOnce) {\n\t\t\t\tif (loopCount === -1) {\n\t\t\t\t\t// just started\n\t\t\t\t\tthis._loopCount = 0;\n\n\t\t\t\t\tthis._setEndings(true, true, false);\n\t\t\t\t}\n\n\t\t\t\thandle_stop: {\n\t\t\t\t\tif (time >= duration) {\n\t\t\t\t\t\ttime = duration;\n\t\t\t\t\t} else if (time < 0) {\n\t\t\t\t\t\ttime = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.time = time;\n\t\t\t\t\t\tbreak handle_stop;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.clampWhenFinished) this.paused = true;else this.enabled = false;\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent({\n\t\t\t\t\t\ttype: 'finished',\n\t\t\t\t\t\taction: this,\n\t\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// repetitive Repeat or PingPong\n\t\t\t\tif (loopCount === -1) {\n\t\t\t\t\t// just started\n\t\t\t\t\tif (deltaTime >= 0) {\n\t\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\t\tthis._setEndings(true, this.repetitions === 0, pingPong);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t\t// so leave loopCount at -1\n\t\t\t\t\t\tthis._setEndings(this.repetitions === 0, true, pingPong);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (time >= duration || time < 0) {\n\t\t\t\t\t// wrap around\n\t\t\t\t\tconst loopDelta = Math.floor(time / duration); // signed\n\n\t\t\t\t\ttime -= duration * loopDelta;\n\t\t\t\t\tloopCount += Math.abs(loopDelta);\n\t\t\t\t\tconst pending = this.repetitions - loopCount;\n\n\t\t\t\t\tif (pending <= 0) {\n\t\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\t\t\t\t\t\tif (this.clampWhenFinished) this.paused = true;else this.enabled = false;\n\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\t\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'finished',\n\t\t\t\t\t\t\taction: this,\n\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// keep running\n\t\t\t\t\t\tif (pending === 1) {\n\t\t\t\t\t\t\t// entering the last round\n\t\t\t\t\t\t\tconst atStart = deltaTime < 0;\n\n\t\t\t\t\t\t\tthis._setEndings(atStart, !atStart, pingPong);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._setEndings(false, false, pingPong);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._loopCount = loopCount;\n\t\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'loop',\n\t\t\t\t\t\t\taction: this,\n\t\t\t\t\t\t\tloopDelta: loopDelta\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.time = time;\n\t\t\t\t}\n\n\t\t\t\tif (pingPong && (loopCount & 1) === 1) {\n\t\t\t\t\t// invert time for the \"pong round\"\n\t\t\t\t\treturn duration - time;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn time;\n\t\t}\n\n\t\t_setEndings(atStart, atEnd, pingPong) {\n\t\t\tconst settings = this._interpolantSettings;\n\n\t\t\tif (pingPong) {\n\t\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\t\t\t} else {\n\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\t\t\t\tif (atStart) {\n\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\t\t\t\t} else {\n\t\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\t\t\t\t}\n\n\t\t\t\tif (atEnd) {\n\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\t\t\t\t} else {\n\t\t\t\t\tsettings.endingEnd = WrapAroundEnding;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_scheduleFading(duration, weightNow, weightThen) {\n\t\t\tconst mixer = this._mixer,\n\t\t\t\t\t\tnow = mixer.time;\n\t\t\tlet interpolant = this._weightInterpolant;\n\n\t\t\tif (interpolant === null) {\n\t\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\t\tthis._weightInterpolant = interpolant;\n\t\t\t}\n\n\t\t\tconst times = interpolant.parameterPositions,\n\t\t\t\t\t\tvalues = interpolant.sampleValues;\n\t\t\ttimes[0] = now;\n\t\t\tvalues[0] = weightNow;\n\t\t\ttimes[1] = now + duration;\n\t\t\tvalues[1] = weightThen;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass AnimationMixer extends EventDispatcher {\n\t\tconstructor(root) {\n\t\t\tsuper();\n\t\t\tthis._root = root;\n\n\t\t\tthis._initMemoryManager();\n\n\t\t\tthis._accuIndex = 0;\n\t\t\tthis.time = 0;\n\t\t\tthis.timeScale = 1.0;\n\t\t}\n\n\t\t_bindAction(action, prototypeAction) {\n\t\t\tconst root = action._localRoot || this._root,\n\t\t\t\t\t\ttracks = action._clip.tracks,\n\t\t\t\t\t\tnTracks = tracks.length,\n\t\t\t\t\t\tbindings = action._propertyBindings,\n\t\t\t\t\t\tinterpolants = action._interpolants,\n\t\t\t\t\t\trootUuid = root.uuid,\n\t\t\t\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\t\t\tlet bindingsByName = bindingsByRoot[rootUuid];\n\n\t\t\tif (bindingsByName === undefined) {\n\t\t\t\tbindingsByName = {};\n\t\t\t\tbindingsByRoot[rootUuid] = bindingsByName;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i !== nTracks; ++i) {\n\t\t\t\tconst track = tracks[i],\n\t\t\t\t\t\t\ttrackName = track.name;\n\t\t\t\tlet binding = bindingsByName[trackName];\n\n\t\t\t\tif (binding !== undefined) {\n\t\t\t\t\tbindings[i] = binding;\n\t\t\t\t} else {\n\t\t\t\t\tbinding = bindings[i];\n\n\t\t\t\t\tif (binding !== undefined) {\n\t\t\t\t\t\t// existing binding, make sure the cache knows\n\t\t\t\t\t\tif (binding._cacheIndex === null) {\n\t\t\t\t\t\t\t++binding.referenceCount;\n\n\t\t\t\t\t\t\tthis._addInactiveBinding(binding, rootUuid, trackName);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;\n\t\t\t\t\tbinding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());\n\t\t\t\t\t++binding.referenceCount;\n\n\t\t\t\t\tthis._addInactiveBinding(binding, rootUuid, trackName);\n\n\t\t\t\t\tbindings[i] = binding;\n\t\t\t\t}\n\n\t\t\t\tinterpolants[i].resultBuffer = binding.buffer;\n\t\t\t}\n\t\t}\n\n\t\t_activateAction(action) {\n\t\t\tif (!this._isActiveAction(action)) {\n\t\t\t\tif (action._cacheIndex === null) {\n\t\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t\t// appears to be still using it -> rebind\n\t\t\t\t\tconst rootUuid = (action._localRoot || this._root).uuid,\n\t\t\t\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\t\t\t\tactionsForClip = this._actionsByClip[clipUuid];\n\n\t\t\t\t\tthis._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);\n\n\t\t\t\t\tthis._addInactiveAction(action, clipUuid, rootUuid);\n\t\t\t\t}\n\n\t\t\t\tconst bindings = action._propertyBindings; // increment reference counts / sort out state\n\n\t\t\t\tfor (let i = 0, n = bindings.length; i !== n; ++i) {\n\t\t\t\t\tconst binding = bindings[i];\n\n\t\t\t\t\tif (binding.useCount++ === 0) {\n\t\t\t\t\t\tthis._lendBinding(binding);\n\n\t\t\t\t\t\tbinding.saveOriginalState();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._lendAction(action);\n\t\t\t}\n\t\t}\n\n\t\t_deactivateAction(action) {\n\t\t\tif (this._isActiveAction(action)) {\n\t\t\t\tconst bindings = action._propertyBindings; // decrement reference counts / sort out state\n\n\t\t\t\tfor (let i = 0, n = bindings.length; i !== n; ++i) {\n\t\t\t\t\tconst binding = bindings[i];\n\n\t\t\t\t\tif (--binding.useCount === 0) {\n\t\t\t\t\t\tbinding.restoreOriginalState();\n\n\t\t\t\t\t\tthis._takeBackBinding(binding);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._takeBackAction(action);\n\t\t\t}\n\t\t} // Memory manager\n\n\n\t\t_initMemoryManager() {\n\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\n\t\t\tthis._nActiveActions = 0;\n\t\t\tthis._actionsByClip = {}; // inside:\n\t\t\t// {\n\t\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t\t// }\n\n\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\n\t\t\tthis._nActiveBindings = 0;\n\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\t\t\tthis._controlInterpolants = []; // same game as above\n\n\t\t\tthis._nActiveControlInterpolants = 0;\n\t\t\tconst scope = this;\n\t\t\tthis.stats = {\n\t\t\t\tactions: {\n\t\t\t\t\tget total() {\n\t\t\t\t\t\treturn scope._actions.length;\n\t\t\t\t\t},\n\n\t\t\t\t\tget inUse() {\n\t\t\t\t\t\treturn scope._nActiveActions;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\t\t\t\tbindings: {\n\t\t\t\t\tget total() {\n\t\t\t\t\t\treturn scope._bindings.length;\n\t\t\t\t\t},\n\n\t\t\t\t\tget inUse() {\n\t\t\t\t\t\treturn scope._nActiveBindings;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\t\t\t\tcontrolInterpolants: {\n\t\t\t\t\tget total() {\n\t\t\t\t\t\treturn scope._controlInterpolants.length;\n\t\t\t\t\t},\n\n\t\t\t\t\tget inUse() {\n\t\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t};\n\t\t} // Memory management for AnimationAction objects\n\n\n\t\t_isActiveAction(action) {\n\t\t\tconst index = action._cacheIndex;\n\t\t\treturn index !== null && index < this._nActiveActions;\n\t\t}\n\n\t\t_addInactiveAction(action, clipUuid, rootUuid) {\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tactionsByClip = this._actionsByClip;\n\t\t\tlet actionsForClip = actionsByClip[clipUuid];\n\n\t\t\tif (actionsForClip === undefined) {\n\t\t\t\tactionsForClip = {\n\t\t\t\t\tknownActions: [action],\n\t\t\t\t\tactionByRoot: {}\n\t\t\t\t};\n\t\t\t\taction._byClipCacheIndex = 0;\n\t\t\t\tactionsByClip[clipUuid] = actionsForClip;\n\t\t\t} else {\n\t\t\t\tconst knownActions = actionsForClip.knownActions;\n\t\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\t\tknownActions.push(action);\n\t\t\t}\n\n\t\t\taction._cacheIndex = actions.length;\n\t\t\tactions.push(action);\n\t\t\tactionsForClip.actionByRoot[rootUuid] = action;\n\t\t}\n\n\t\t_removeInactiveAction(action) {\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tlastInactiveAction = actions[actions.length - 1],\n\t\t\t\t\t\tcacheIndex = action._cacheIndex;\n\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\tactions[cacheIndex] = lastInactiveAction;\n\t\t\tactions.pop();\n\t\t\taction._cacheIndex = null;\n\t\t\tconst clipUuid = action._clip.uuid,\n\t\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\t\tactionsForClip = actionsByClip[clipUuid],\n\t\t\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\t\t\t\t\t\tlastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],\n\t\t\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\t\tknownActionsForClip[byClipCacheIndex] = lastKnownAction;\n\t\t\tknownActionsForClip.pop();\n\t\t\taction._byClipCacheIndex = null;\n\t\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\t\t\t\trootUuid = (action._localRoot || this._root).uuid;\n\t\t\tdelete actionByRoot[rootUuid];\n\n\t\t\tif (knownActionsForClip.length === 0) {\n\t\t\t\tdelete actionsByClip[clipUuid];\n\t\t\t}\n\n\t\t\tthis._removeInactiveBindingsForAction(action);\n\t\t}\n\n\t\t_removeInactiveBindingsForAction(action) {\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\tfor (let i = 0, n = bindings.length; i !== n; ++i) {\n\t\t\t\tconst binding = bindings[i];\n\n\t\t\t\tif (--binding.referenceCount === 0) {\n\t\t\t\t\tthis._removeInactiveBinding(binding);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_lendAction(action) {\n\t\t\t// [ active actions |\tinactive actions\t]\n\t\t\t// [\tactive actions >| inactive actions ]\n\t\t\t//\t\t\t\t\t\t\t\t s\t\t\t\ta\n\t\t\t//\t\t\t\t\t\t\t\t\t<-swap->\n\t\t\t//\t\t\t\t\t\t\t\t a\t\t\t\ts\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tprevIndex = action._cacheIndex,\n\t\t\t\t\t\tlastActiveIndex = this._nActiveActions++,\n\t\t\t\t\t\tfirstInactiveAction = actions[lastActiveIndex];\n\t\t\taction._cacheIndex = lastActiveIndex;\n\t\t\tactions[lastActiveIndex] = action;\n\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\t\tactions[prevIndex] = firstInactiveAction;\n\t\t}\n\n\t\t_takeBackAction(action) {\n\t\t\t// [\tactive actions\t| inactive actions ]\n\t\t\t// [ active actions |< inactive actions\t]\n\t\t\t//\t\t\t\ta\t\t\t\ts\n\t\t\t//\t\t\t\t <-swap->\n\t\t\t//\t\t\t\ts\t\t\t\ta\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tprevIndex = action._cacheIndex,\n\t\t\t\t\t\tfirstInactiveIndex = --this._nActiveActions,\n\t\t\t\t\t\tlastActiveAction = actions[firstInactiveIndex];\n\t\t\taction._cacheIndex = firstInactiveIndex;\n\t\t\tactions[firstInactiveIndex] = action;\n\t\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\t\tactions[prevIndex] = lastActiveAction;\n\t\t} // Memory management for PropertyMixer objects\n\n\n\t\t_addInactiveBinding(binding, rootUuid, trackName) {\n\t\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\t\tbindings = this._bindings;\n\t\t\tlet bindingByName = bindingsByRoot[rootUuid];\n\n\t\t\tif (bindingByName === undefined) {\n\t\t\t\tbindingByName = {};\n\t\t\t\tbindingsByRoot[rootUuid] = bindingByName;\n\t\t\t}\n\n\t\t\tbindingByName[trackName] = binding;\n\t\t\tbinding._cacheIndex = bindings.length;\n\t\t\tbindings.push(binding);\n\t\t}\n\n\t\t_removeInactiveBinding(binding) {\n\t\t\tconst bindings = this._bindings,\n\t\t\t\t\t\tpropBinding = binding.binding,\n\t\t\t\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\t\t\t\ttrackName = propBinding.path,\n\t\t\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\t\tbindingByName = bindingsByRoot[rootUuid],\n\t\t\t\t\t\tlastInactiveBinding = bindings[bindings.length - 1],\n\t\t\t\t\t\tcacheIndex = binding._cacheIndex;\n\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\t\tbindings[cacheIndex] = lastInactiveBinding;\n\t\t\tbindings.pop();\n\t\t\tdelete bindingByName[trackName];\n\n\t\t\tif (Object.keys(bindingByName).length === 0) {\n\t\t\t\tdelete bindingsByRoot[rootUuid];\n\t\t\t}\n\t\t}\n\n\t\t_lendBinding(binding) {\n\t\t\tconst bindings = this._bindings,\n\t\t\t\t\t\tprevIndex = binding._cacheIndex,\n\t\t\t\t\t\tlastActiveIndex = this._nActiveBindings++,\n\t\t\t\t\t\tfirstInactiveBinding = bindings[lastActiveIndex];\n\t\t\tbinding._cacheIndex = lastActiveIndex;\n\t\t\tbindings[lastActiveIndex] = binding;\n\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[prevIndex] = firstInactiveBinding;\n\t\t}\n\n\t\t_takeBackBinding(binding) {\n\t\t\tconst bindings = this._bindings,\n\t\t\t\t\t\tprevIndex = binding._cacheIndex,\n\t\t\t\t\t\tfirstInactiveIndex = --this._nActiveBindings,\n\t\t\t\t\t\tlastActiveBinding = bindings[firstInactiveIndex];\n\t\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\t\tbindings[firstInactiveIndex] = binding;\n\t\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[prevIndex] = lastActiveBinding;\n\t\t} // Memory management of Interpolants for weight and time scale\n\n\n\t\t_lendControlInterpolant() {\n\t\t\tconst interpolants = this._controlInterpolants,\n\t\t\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants++;\n\t\t\tlet interpolant = interpolants[lastActiveIndex];\n\n\t\t\tif (interpolant === undefined) {\n\t\t\t\tinterpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);\n\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\t\tinterpolants[lastActiveIndex] = interpolant;\n\t\t\t}\n\n\t\t\treturn interpolant;\n\t\t}\n\n\t\t_takeBackControlInterpolant(interpolant) {\n\t\t\tconst interpolants = this._controlInterpolants,\n\t\t\t\t\t\tprevIndex = interpolant.__cacheIndex,\n\t\t\t\t\t\tfirstInactiveIndex = --this._nActiveControlInterpolants,\n\t\t\t\t\t\tlastActiveInterpolant = interpolants[firstInactiveIndex];\n\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\t\tinterpolants[firstInactiveIndex] = interpolant;\n\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\t\tinterpolants[prevIndex] = lastActiveInterpolant;\n\t\t} // return an action for a clip optionally using a custom root target\n\t\t// object (this method allocates a lot of dynamic memory in case a\n\t\t// previously unknown clip/root combination is specified)\n\n\n\t\tclipAction(clip, optionalRoot, blendMode) {\n\t\t\tconst root = optionalRoot || this._root,\n\t\t\t\t\t\trootUuid = root.uuid;\n\t\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;\n\t\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\t\t\tconst actionsForClip = this._actionsByClip[clipUuid];\n\t\t\tlet prototypeAction = null;\n\n\t\t\tif (blendMode === undefined) {\n\t\t\t\tif (clipObject !== null) {\n\t\t\t\t\tblendMode = clipObject.blendMode;\n\t\t\t\t} else {\n\t\t\t\t\tblendMode = NormalAnimationBlendMode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (actionsForClip !== undefined) {\n\t\t\t\tconst existingAction = actionsForClip.actionByRoot[rootUuid];\n\n\t\t\t\tif (existingAction !== undefined && existingAction.blendMode === blendMode) {\n\t\t\t\t\treturn existingAction;\n\t\t\t\t} // we know the clip, so we don't have to parse all\n\t\t\t\t// the bindings again but can just copy\n\n\n\t\t\t\tprototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action\n\n\t\t\t\tif (clipObject === null) clipObject = prototypeAction._clip;\n\t\t\t} // clip must be known when specified via string\n\n\n\t\t\tif (clipObject === null) return null; // allocate all resources required to run it\n\n\t\t\tconst newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);\n\n\t\t\tthis._bindAction(newAction, prototypeAction); // and make the action known to the memory manager\n\n\n\t\t\tthis._addInactiveAction(newAction, clipUuid, rootUuid);\n\n\t\t\treturn newAction;\n\t\t} // get an existing action\n\n\n\t\texistingAction(clip, optionalRoot) {\n\t\t\tconst root = optionalRoot || this._root,\n\t\t\t\t\t\trootUuid = root.uuid,\n\t\t\t\t\t\tclipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,\n\t\t\t\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\t\t\t\t\t\tactionsForClip = this._actionsByClip[clipUuid];\n\n\t\t\tif (actionsForClip !== undefined) {\n\t\t\t\treturn actionsForClip.actionByRoot[rootUuid] || null;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t} // deactivates all previously scheduled actions\n\n\n\t\tstopAllAction() {\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tnActions = this._nActiveActions;\n\n\t\t\tfor (let i = nActions - 1; i >= 0; --i) {\n\t\t\t\tactions[i].stop();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // advance the time and update apply the animation\n\n\n\t\tupdate(deltaTime) {\n\t\t\tdeltaTime *= this.timeScale;\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tnActions = this._nActiveActions,\n\t\t\t\t\t\ttime = this.time += deltaTime,\n\t\t\t\t\t\ttimeDirection = Math.sign(deltaTime),\n\t\t\t\t\t\taccuIndex = this._accuIndex ^= 1; // run active actions\n\n\t\t\tfor (let i = 0; i !== nActions; ++i) {\n\t\t\t\tconst action = actions[i];\n\n\t\t\t\taction._update(time, deltaTime, timeDirection, accuIndex);\n\t\t\t} // update scene graph\n\n\n\t\t\tconst bindings = this._bindings,\n\t\t\t\t\t\tnBindings = this._nActiveBindings;\n\n\t\t\tfor (let i = 0; i !== nBindings; ++i) {\n\t\t\t\tbindings[i].apply(accuIndex);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // Allows you to seek to a specific time in an animation.\n\n\n\t\tsetTime(timeInSeconds) {\n\t\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\n\t\t\tfor (let i = 0; i < this._actions.length; i++) {\n\t\t\t\tthis._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\t\t\t}\n\n\t\t\treturn this.update(timeInSeconds); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\t\t} // return this mixer's root target object\n\n\n\t\tgetRoot() {\n\t\t\treturn this._root;\n\t\t} // free all resources specific to a particular clip\n\n\n\t\tuncacheClip(clip) {\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tclipUuid = clip.uuid,\n\t\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\t\tactionsForClip = actionsByClip[clipUuid];\n\n\t\t\tif (actionsForClip !== undefined) {\n\t\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t\t// iteration state and also require updating the state we can\n\t\t\t\t// just throw away\n\t\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\t\tfor (let i = 0, n = actionsToRemove.length; i !== n; ++i) {\n\t\t\t\t\tconst action = actionsToRemove[i];\n\n\t\t\t\t\tthis._deactivateAction(action);\n\n\t\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\t\t\t\tlastInactiveAction = actions[actions.length - 1];\n\t\t\t\t\taction._cacheIndex = null;\n\t\t\t\t\taction._byClipCacheIndex = null;\n\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\t\tactions[cacheIndex] = lastInactiveAction;\n\t\t\t\t\tactions.pop();\n\n\t\t\t\t\tthis._removeInactiveBindingsForAction(action);\n\t\t\t\t}\n\n\t\t\t\tdelete actionsByClip[clipUuid];\n\t\t\t}\n\t\t} // free all resources specific to a particular root target object\n\n\n\t\tuncacheRoot(root) {\n\t\t\tconst rootUuid = root.uuid,\n\t\t\t\t\t\tactionsByClip = this._actionsByClip;\n\n\t\t\tfor (const clipUuid in actionsByClip) {\n\t\t\t\tconst actionByRoot = actionsByClip[clipUuid].actionByRoot,\n\t\t\t\t\t\t\taction = actionByRoot[rootUuid];\n\n\t\t\t\tif (action !== undefined) {\n\t\t\t\t\tthis._deactivateAction(action);\n\n\t\t\t\t\tthis._removeInactiveAction(action);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\t\tbindingByName = bindingsByRoot[rootUuid];\n\n\t\t\tif (bindingByName !== undefined) {\n\t\t\t\tfor (const trackName in bindingByName) {\n\t\t\t\t\tconst binding = bindingByName[trackName];\n\t\t\t\t\tbinding.restoreOriginalState();\n\n\t\t\t\t\tthis._removeInactiveBinding(binding);\n\t\t\t\t}\n\t\t\t}\n\t\t} // remove a targeted clip from the cache\n\n\n\t\tuncacheAction(clip, optionalRoot) {\n\t\t\tconst action = this.existingAction(clip, optionalRoot);\n\n\t\t\tif (action !== null) {\n\t\t\t\tthis._deactivateAction(action);\n\n\t\t\t\tthis._removeInactiveAction(action);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tAnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);\n\n\tclass Uniform {\n\t\tconstructor(value) {\n\t\t\tif (typeof value === 'string') {\n\t\t\t\tconsole.warn('THREE.Uniform: Type parameter is no longer needed.');\n\t\t\t\tvalue = arguments[1];\n\t\t\t}\n\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new Uniform(this.value.clone === undefined ? this.value : this.value.clone());\n\t\t}\n\n\t}\n\n\tclass InstancedInterleavedBuffer extends InterleavedBuffer {\n\t\tconstructor(array, stride, meshPerAttribute = 1) {\n\t\t\tsuper(array, stride);\n\t\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\t\treturn this;\n\t\t}\n\n\t\tclone(data) {\n\t\t\tconst ib = super.clone(data);\n\t\t\tib.meshPerAttribute = this.meshPerAttribute;\n\t\t\treturn ib;\n\t\t}\n\n\t\ttoJSON(data) {\n\t\t\tconst json = super.toJSON(data);\n\t\t\tjson.isInstancedInterleavedBuffer = true;\n\t\t\tjson.meshPerAttribute = this.meshPerAttribute;\n\t\t\treturn json;\n\t\t}\n\n\t}\n\n\tInstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;\n\n\tclass GLBufferAttribute {\n\t\tconstructor(buffer, type, itemSize, elementSize, count) {\n\t\t\tthis.buffer = buffer;\n\t\t\tthis.type = type;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.elementSize = elementSize;\n\t\t\tthis.count = count;\n\t\t\tthis.version = 0;\n\t\t}\n\n\t\tset needsUpdate(value) {\n\t\t\tif (value === true) this.version++;\n\t\t}\n\n\t\tsetBuffer(buffer) {\n\t\t\tthis.buffer = buffer;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetType(type, elementSize) {\n\t\t\tthis.type = type;\n\t\t\tthis.elementSize = elementSize;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetItemSize(itemSize) {\n\t\t\tthis.itemSize = itemSize;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetCount(count) {\n\t\t\tthis.count = count;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tGLBufferAttribute.prototype.isGLBufferAttribute = true;\n\n\tclass Raycaster {\n\t\tconstructor(origin, direction, near = 0, far = Infinity) {\n\t\t\tthis.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)\n\n\t\t\tthis.near = near;\n\t\t\tthis.far = far;\n\t\t\tthis.camera = null;\n\t\t\tthis.layers = new Layers();\n\t\t\tthis.params = {\n\t\t\t\tMesh: {},\n\t\t\t\tLine: {\n\t\t\t\t\tthreshold: 1\n\t\t\t\t},\n\t\t\t\tLOD: {},\n\t\t\t\tPoints: {\n\t\t\t\t\tthreshold: 1\n\t\t\t\t},\n\t\t\t\tSprite: {}\n\t\t\t};\n\t\t}\n\n\t\tset(origin, direction) {\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\t\t\tthis.ray.set(origin, direction);\n\t\t}\n\n\t\tsetFromCamera(coords, camera) {\n\t\t\tif (camera && camera.isPerspectiveCamera) {\n\t\t\t\tthis.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n\t\t\t\tthis.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();\n\t\t\t\tthis.camera = camera;\n\t\t\t} else if (camera && camera.isOrthographicCamera) {\n\t\t\t\tthis.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera\n\n\t\t\t\tthis.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n\t\t\t\tthis.camera = camera;\n\t\t\t} else {\n\t\t\t\tconsole.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);\n\t\t\t}\n\t\t}\n\n\t\tintersectObject(object, recursive = false, intersects = []) {\n\t\t\tintersectObject(object, this, intersects, recursive);\n\t\t\tintersects.sort(ascSort);\n\t\t\treturn intersects;\n\t\t}\n\n\t\tintersectObjects(objects, recursive = false, intersects = []) {\n\t\t\tfor (let i = 0, l = objects.length; i < l; i++) {\n\t\t\t\tintersectObject(objects[i], this, intersects, recursive);\n\t\t\t}\n\n\t\t\tintersects.sort(ascSort);\n\t\t\treturn intersects;\n\t\t}\n\n\t}\n\n\tfunction ascSort(a, b) {\n\t\treturn a.distance - b.distance;\n\t}\n\n\tfunction intersectObject(object, raycaster, intersects, recursive) {\n\t\tif (object.layers.test(raycaster.layers)) {\n\t\t\tobject.raycast(raycaster, intersects);\n\t\t}\n\n\t\tif (recursive === true) {\n\t\t\tconst children = object.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tintersectObject(children[i], raycaster, intersects, true);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n\t *\n\t * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\n\t * The azimuthal angle (theta) is measured from the positive z-axis.\n\t */\n\n\tclass Spherical {\n\t\tconstructor(radius = 1, phi = 0, theta = 0) {\n\t\t\tthis.radius = radius;\n\t\t\tthis.phi = phi; // polar angle\n\n\t\t\tthis.theta = theta; // azimuthal angle\n\n\t\t\treturn this;\n\t\t}\n\n\t\tset(radius, phi, theta) {\n\t\t\tthis.radius = radius;\n\t\t\tthis.phi = phi;\n\t\t\tthis.theta = theta;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(other) {\n\t\t\tthis.radius = other.radius;\n\t\t\tthis.phi = other.phi;\n\t\t\tthis.theta = other.theta;\n\t\t\treturn this;\n\t\t} // restrict phi to be betwee EPS and PI-EPS\n\n\n\t\tmakeSafe() {\n\t\t\tconst EPS = 0.000001;\n\t\t\tthis.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromVector3(v) {\n\t\t\treturn this.setFromCartesianCoords(v.x, v.y, v.z);\n\t\t}\n\n\t\tsetFromCartesianCoords(x, y, z) {\n\t\t\tthis.radius = Math.sqrt(x * x + y * y + z * z);\n\n\t\t\tif (this.radius === 0) {\n\t\t\t\tthis.theta = 0;\n\t\t\t\tthis.phi = 0;\n\t\t\t} else {\n\t\t\t\tthis.theta = Math.atan2(x, z);\n\t\t\t\tthis.phi = Math.acos(clamp(y / this.radius, -1, 1));\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\t/**\n\t * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n\t */\n\tclass Cylindrical {\n\t\tconstructor(radius = 1, theta = 0, y = 0) {\n\t\t\tthis.radius = radius; // distance from the origin to a point in the x-z plane\n\n\t\t\tthis.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n\n\t\t\tthis.y = y; // height above the x-z plane\n\n\t\t\treturn this;\n\t\t}\n\n\t\tset(radius, theta, y) {\n\t\t\tthis.radius = radius;\n\t\t\tthis.theta = theta;\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(other) {\n\t\t\tthis.radius = other.radius;\n\t\t\tthis.theta = other.theta;\n\t\t\tthis.y = other.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromVector3(v) {\n\t\t\treturn this.setFromCartesianCoords(v.x, v.y, v.z);\n\t\t}\n\n\t\tsetFromCartesianCoords(x, y, z) {\n\t\t\tthis.radius = Math.sqrt(x * x + z * z);\n\t\t\tthis.theta = Math.atan2(x, z);\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tconst _vector$4 = /*@__PURE__*/new Vector2();\n\n\tclass Box2 {\n\t\tconstructor(min = new Vector2(+Infinity, +Infinity), max = new Vector2(-Infinity, -Infinity)) {\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\t\t}\n\n\t\tset(min, max) {\n\t\t\tthis.min.copy(min);\n\t\t\tthis.max.copy(max);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromPoints(points) {\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor (let i = 0, il = points.length; i < il; i++) {\n\t\t\t\tthis.expandByPoint(points[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromCenterAndSize(center, size) {\n\t\t\tconst halfSize = _vector$4.copy(size).multiplyScalar(0.5);\n\n\t\t\tthis.min.copy(center).sub(halfSize);\n\t\t\tthis.max.copy(center).add(halfSize);\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(box) {\n\t\t\tthis.min.copy(box.min);\n\t\t\tthis.max.copy(box.max);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeEmpty() {\n\t\t\tthis.min.x = this.min.y = +Infinity;\n\t\t\tthis.max.x = this.max.y = -Infinity;\n\t\t\treturn this;\n\t\t}\n\n\t\tisEmpty() {\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\t\treturn this.max.x < this.min.x || this.max.y < this.min.y;\n\t\t}\n\n\t\tgetCenter(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box2: .getCenter() target is now required');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n\t\t}\n\n\t\tgetSize(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box2: .getSize() target is now required');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);\n\t\t}\n\n\t\texpandByPoint(point) {\n\t\t\tthis.min.min(point);\n\t\t\tthis.max.max(point);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByVector(vector) {\n\t\t\tthis.min.sub(vector);\n\t\t\tthis.max.add(vector);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByScalar(scalar) {\n\t\t\tthis.min.addScalar(-scalar);\n\t\t\tthis.max.addScalar(scalar);\n\t\t\treturn this;\n\t\t}\n\n\t\tcontainsPoint(point) {\n\t\t\treturn point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;\n\t\t}\n\n\t\tcontainsBox(box) {\n\t\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;\n\t\t}\n\n\t\tgetParameter(point, target) {\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box2: .getParameter() target is now required');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\t// using 4 splitting planes to rule out intersections\n\t\t\treturn box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;\n\t\t}\n\n\t\tclampPoint(point, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box2: .clampPoint() target is now required');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn target.copy(point).clamp(this.min, this.max);\n\t\t}\n\n\t\tdistanceToPoint(point) {\n\t\t\tconst clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);\n\n\t\t\treturn clampedPoint.sub(point).length();\n\t\t}\n\n\t\tintersect(box) {\n\t\t\tthis.min.max(box.min);\n\t\t\tthis.max.min(box.max);\n\t\t\treturn this;\n\t\t}\n\n\t\tunion(box) {\n\t\t\tthis.min.min(box.min);\n\t\t\tthis.max.max(box.max);\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(offset) {\n\t\t\tthis.min.add(offset);\n\t\t\tthis.max.add(offset);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(box) {\n\t\t\treturn box.min.equals(this.min) && box.max.equals(this.max);\n\t\t}\n\n\t}\n\n\tBox2.prototype.isBox2 = true;\n\n\tconst _startP = /*@__PURE__*/new Vector3();\n\n\tconst _startEnd = /*@__PURE__*/new Vector3();\n\n\tclass Line3 {\n\t\tconstructor(start = new Vector3(), end = new Vector3()) {\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\tset(start, end) {\n\t\t\tthis.start.copy(start);\n\t\t\tthis.end.copy(end);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(line) {\n\t\t\tthis.start.copy(line.start);\n\t\t\tthis.end.copy(line.end);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetCenter(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Line3: .getCenter() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.addVectors(this.start, this.end).multiplyScalar(0.5);\n\t\t}\n\n\t\tdelta(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Line3: .delta() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.subVectors(this.end, this.start);\n\t\t}\n\n\t\tdistanceSq() {\n\t\t\treturn this.start.distanceToSquared(this.end);\n\t\t}\n\n\t\tdistance() {\n\t\t\treturn this.start.distanceTo(this.end);\n\t\t}\n\n\t\tat(t, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Line3: .at() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn this.delta(target).multiplyScalar(t).add(this.start);\n\t\t}\n\n\t\tclosestPointToPointParameter(point, clampToLine) {\n\t\t\t_startP.subVectors(point, this.start);\n\n\t\t\t_startEnd.subVectors(this.end, this.start);\n\n\t\t\tconst startEnd2 = _startEnd.dot(_startEnd);\n\n\t\t\tconst startEnd_startP = _startEnd.dot(_startP);\n\n\t\t\tlet t = startEnd_startP / startEnd2;\n\n\t\t\tif (clampToLine) {\n\t\t\t\tt = clamp(t, 0, 1);\n\t\t\t}\n\n\t\t\treturn t;\n\t\t}\n\n\t\tclosestPointToPoint(point, clampToLine, target) {\n\t\t\tconst t = this.closestPointToPointParameter(point, clampToLine);\n\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Line3: .closestPointToPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn this.delta(target).multiplyScalar(t).add(this.start);\n\t\t}\n\n\t\tapplyMatrix4(matrix) {\n\t\t\tthis.start.applyMatrix4(matrix);\n\t\t\tthis.end.applyMatrix4(matrix);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(line) {\n\t\t\treturn line.start.equals(this.start) && line.end.equals(this.end);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tclass ImmediateRenderObject extends Object3D {\n\t\tconstructor(material) {\n\t\t\tsuper();\n\t\t\tthis.material = material;\n\n\t\t\tthis.render = function ()\n\t\t\t/* renderCallback */\n\t\t\t{};\n\n\t\t\tthis.hasPositions = false;\n\t\t\tthis.hasNormals = false;\n\t\t\tthis.hasColors = false;\n\t\t\tthis.hasUvs = false;\n\t\t\tthis.positionArray = null;\n\t\t\tthis.normalArray = null;\n\t\t\tthis.colorArray = null;\n\t\t\tthis.uvArray = null;\n\t\t\tthis.count = 0;\n\t\t}\n\n\t}\n\n\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\n\tconst _vector$3 = /*@__PURE__*/new Vector3();\n\n\tclass SpotLightHelper extends Object3D {\n\t\tconstructor(light, color) {\n\t\t\tsuper();\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.color = color;\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];\n\n\t\t\tfor (let i = 0, j = 1, l = 32; i < l; i++, j++) {\n\t\t\t\tconst p1 = i / l * Math.PI * 2;\n\t\t\t\tconst p2 = j / l * Math.PI * 2;\n\t\t\t\tpositions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);\n\t\t\t}\n\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tfog: false,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tthis.cone = new LineSegments(geometry, material);\n\t\t\tthis.add(this.cone);\n\t\t\tthis.update();\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.cone.geometry.dispose();\n\t\t\tthis.cone.material.dispose();\n\t\t}\n\n\t\tupdate() {\n\t\t\tthis.light.updateMatrixWorld();\n\t\t\tconst coneLength = this.light.distance ? this.light.distance : 1000;\n\t\t\tconst coneWidth = coneLength * Math.tan(this.light.angle);\n\t\t\tthis.cone.scale.set(coneWidth, coneWidth, coneLength);\n\n\t\t\t_vector$3.setFromMatrixPosition(this.light.target.matrixWorld);\n\n\t\t\tthis.cone.lookAt(_vector$3);\n\n\t\t\tif (this.color !== undefined) {\n\t\t\t\tthis.cone.material.color.set(this.color);\n\t\t\t} else {\n\t\t\t\tthis.cone.material.color.copy(this.light.color);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tconst _vector$2 = /*@__PURE__*/new Vector3();\n\n\tconst _boneMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _matrixWorldInv = /*@__PURE__*/new Matrix4();\n\n\tclass SkeletonHelper extends LineSegments {\n\t\tconstructor(object) {\n\t\t\tconst bones = getBoneList(object);\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst vertices = [];\n\t\t\tconst colors = [];\n\t\t\tconst color1 = new Color(0, 0, 1);\n\t\t\tconst color2 = new Color(0, 1, 0);\n\n\t\t\tfor (let i = 0; i < bones.length; i++) {\n\t\t\t\tconst bone = bones[i];\n\n\t\t\t\tif (bone.parent && bone.parent.isBone) {\n\t\t\t\t\tvertices.push(0, 0, 0);\n\t\t\t\t\tvertices.push(0, 0, 0);\n\t\t\t\t\tcolors.push(color1.r, color1.g, color1.b);\n\t\t\t\t\tcolors.push(color2.r, color2.g, color2.b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tvertexColors: true,\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\ttoneMapped: false,\n\t\t\t\ttransparent: true\n\t\t\t});\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'SkeletonHelper';\n\t\t\tthis.isSkeletonHelper = true;\n\t\t\tthis.root = object;\n\t\t\tthis.bones = bones;\n\t\t\tthis.matrix = object.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tconst bones = this.bones;\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst position = geometry.getAttribute('position');\n\n\t\t\t_matrixWorldInv.copy(this.root.matrixWorld).invert();\n\n\t\t\tfor (let i = 0, j = 0; i < bones.length; i++) {\n\t\t\t\tconst bone = bones[i];\n\n\t\t\t\tif (bone.parent && bone.parent.isBone) {\n\t\t\t\t\t_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);\n\n\t\t\t\t\t_vector$2.setFromMatrixPosition(_boneMatrix);\n\n\t\t\t\t\tposition.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);\n\n\t\t\t\t\t_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);\n\n\t\t\t\t\t_vector$2.setFromMatrixPosition(_boneMatrix);\n\n\t\t\t\t\tposition.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);\n\t\t\t\t\tj += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgeometry.getAttribute('position').needsUpdate = true;\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t}\n\n\t}\n\n\tfunction getBoneList(object) {\n\t\tconst boneList = [];\n\n\t\tif (object && object.isBone) {\n\t\t\tboneList.push(object);\n\t\t}\n\n\t\tfor (let i = 0; i < object.children.length; i++) {\n\t\t\tboneList.push.apply(boneList, getBoneList(object.children[i]));\n\t\t}\n\n\t\treturn boneList;\n\t}\n\n\tclass PointLightHelper extends Mesh {\n\t\tconstructor(light, sphereSize, color) {\n\t\t\tconst geometry = new SphereGeometry(sphereSize, 4, 2);\n\t\t\tconst material = new MeshBasicMaterial({\n\t\t\t\twireframe: true,\n\t\t\t\tfog: false,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tsuper(geometry, material);\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\t\tthis.color = color;\n\t\t\tthis.type = 'PointLightHelper';\n\t\t\tthis.matrix = this.light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.update();\n\t\t\t/*\n\t\t\t// TODO: delete this comment?\n\t\t\tconst distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );\n\t\t\tconst distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\t\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\t\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\t\t\tconst d = light.distance;\n\t\t\tif ( d === 0.0 ) {\n\t\t\t\tthis.lightDistance.visible = false;\n\t\t\t} else {\n\t\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\t\t}\n\t\t\tthis.add( this.lightDistance );\n\t\t\t*/\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.geometry.dispose();\n\t\t\tthis.material.dispose();\n\t\t}\n\n\t\tupdate() {\n\t\t\tif (this.color !== undefined) {\n\t\t\t\tthis.material.color.set(this.color);\n\t\t\t} else {\n\t\t\t\tthis.material.color.copy(this.light.color);\n\t\t\t}\n\t\t\t/*\n\t\t\tconst d = this.light.distance;\n\t\t\t\tif ( d === 0.0 ) {\n\t\t\t\t\tthis.lightDistance.visible = false;\n\t\t\t\t} else {\n\t\t\t\t\tthis.lightDistance.visible = true;\n\t\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\t\t\t}\n\t\t\t*/\n\n\t\t}\n\n\t}\n\n\tconst _vector$1 = /*@__PURE__*/new Vector3();\n\n\tconst _color1 = /*@__PURE__*/new Color();\n\n\tconst _color2 = /*@__PURE__*/new Color();\n\n\tclass HemisphereLightHelper extends Object3D {\n\t\tconstructor(light, size, color) {\n\t\t\tsuper();\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.color = color;\n\t\t\tconst geometry = new OctahedronGeometry(size);\n\t\t\tgeometry.rotateY(Math.PI * 0.5);\n\t\t\tthis.material = new MeshBasicMaterial({\n\t\t\t\twireframe: true,\n\t\t\t\tfog: false,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tif (this.color === undefined) this.material.vertexColors = true;\n\t\t\tconst position = geometry.getAttribute('position');\n\t\t\tconst colors = new Float32Array(position.count * 3);\n\t\t\tgeometry.setAttribute('color', new BufferAttribute(colors, 3));\n\t\t\tthis.add(new Mesh(geometry, this.material));\n\t\t\tthis.update();\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.children[0].geometry.dispose();\n\t\t\tthis.children[0].material.dispose();\n\t\t}\n\n\t\tupdate() {\n\t\t\tconst mesh = this.children[0];\n\n\t\t\tif (this.color !== undefined) {\n\t\t\t\tthis.material.color.set(this.color);\n\t\t\t} else {\n\t\t\t\tconst colors = mesh.geometry.getAttribute('color');\n\n\t\t\t\t_color1.copy(this.light.color);\n\n\t\t\t\t_color2.copy(this.light.groundColor);\n\n\t\t\t\tfor (let i = 0, l = colors.count; i < l; i++) {\n\t\t\t\t\tconst color = i < l / 2 ? _color1 : _color2;\n\t\t\t\t\tcolors.setXYZ(i, color.r, color.g, color.b);\n\t\t\t\t}\n\n\t\t\t\tcolors.needsUpdate = true;\n\t\t\t}\n\n\t\t\tmesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());\n\t\t}\n\n\t}\n\n\tclass GridHelper extends LineSegments {\n\t\tconstructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {\n\t\t\tcolor1 = new Color(color1);\n\t\t\tcolor2 = new Color(color2);\n\t\t\tconst center = divisions / 2;\n\t\t\tconst step = size / divisions;\n\t\t\tconst halfSize = size / 2;\n\t\t\tconst vertices = [],\n\t\t\t\t\t\tcolors = [];\n\n\t\t\tfor (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {\n\t\t\t\tvertices.push(-halfSize, 0, k, halfSize, 0, k);\n\t\t\t\tvertices.push(k, 0, -halfSize, k, 0, halfSize);\n\t\t\t\tconst color = i === center ? color1 : color2;\n\t\t\t\tcolor.toArray(colors, j);\n\t\t\t\tj += 3;\n\t\t\t\tcolor.toArray(colors, j);\n\t\t\t\tj += 3;\n\t\t\t\tcolor.toArray(colors, j);\n\t\t\t\tj += 3;\n\t\t\t\tcolor.toArray(colors, j);\n\t\t\t\tj += 3;\n\t\t\t}\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tvertexColors: true,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'GridHelper';\n\t\t}\n\n\t}\n\n\tclass PolarGridHelper extends LineSegments {\n\t\tconstructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888) {\n\t\t\tcolor1 = new Color(color1);\n\t\t\tcolor2 = new Color(color2);\n\t\t\tconst vertices = [];\n\t\t\tconst colors = []; // create the radials\n\n\t\t\tfor (let i = 0; i <= radials; i++) {\n\t\t\t\tconst v = i / radials * (Math.PI * 2);\n\t\t\t\tconst x = Math.sin(v) * radius;\n\t\t\t\tconst z = Math.cos(v) * radius;\n\t\t\t\tvertices.push(0, 0, 0);\n\t\t\t\tvertices.push(x, 0, z);\n\t\t\t\tconst color = i & 1 ? color1 : color2;\n\t\t\t\tcolors.push(color.r, color.g, color.b);\n\t\t\t\tcolors.push(color.r, color.g, color.b);\n\t\t\t} // create the circles\n\n\n\t\t\tfor (let i = 0; i <= circles; i++) {\n\t\t\t\tconst color = i & 1 ? color1 : color2;\n\t\t\t\tconst r = radius - radius / circles * i;\n\n\t\t\t\tfor (let j = 0; j < divisions; j++) {\n\t\t\t\t\t// first vertex\n\t\t\t\t\tlet v = j / divisions * (Math.PI * 2);\n\t\t\t\t\tlet x = Math.sin(v) * r;\n\t\t\t\t\tlet z = Math.cos(v) * r;\n\t\t\t\t\tvertices.push(x, 0, z);\n\t\t\t\t\tcolors.push(color.r, color.g, color.b); // second vertex\n\n\t\t\t\t\tv = (j + 1) / divisions * (Math.PI * 2);\n\t\t\t\t\tx = Math.sin(v) * r;\n\t\t\t\t\tz = Math.cos(v) * r;\n\t\t\t\t\tvertices.push(x, 0, z);\n\t\t\t\t\tcolors.push(color.r, color.g, color.b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tvertexColors: true,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'PolarGridHelper';\n\t\t}\n\n\t}\n\n\tconst _v1 = /*@__PURE__*/new Vector3();\n\n\tconst _v2 = /*@__PURE__*/new Vector3();\n\n\tconst _v3 = /*@__PURE__*/new Vector3();\n\n\tclass DirectionalLightHelper extends Object3D {\n\t\tconstructor(light, size, color) {\n\t\t\tsuper();\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.color = color;\n\t\t\tif (size === undefined) size = 1;\n\t\t\tlet geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tfog: false,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tthis.lightPlane = new Line(geometry, material);\n\t\t\tthis.add(this.lightPlane);\n\t\t\tgeometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));\n\t\t\tthis.targetLine = new Line(geometry, material);\n\t\t\tthis.add(this.targetLine);\n\t\t\tthis.update();\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.lightPlane.geometry.dispose();\n\t\t\tthis.lightPlane.material.dispose();\n\t\t\tthis.targetLine.geometry.dispose();\n\t\t\tthis.targetLine.material.dispose();\n\t\t}\n\n\t\tupdate() {\n\t\t\t_v1.setFromMatrixPosition(this.light.matrixWorld);\n\n\t\t\t_v2.setFromMatrixPosition(this.light.target.matrixWorld);\n\n\t\t\t_v3.subVectors(_v2, _v1);\n\n\t\t\tthis.lightPlane.lookAt(_v2);\n\n\t\t\tif (this.color !== undefined) {\n\t\t\t\tthis.lightPlane.material.color.set(this.color);\n\t\t\t\tthis.targetLine.material.color.set(this.color);\n\t\t\t} else {\n\t\t\t\tthis.lightPlane.material.color.copy(this.light.color);\n\t\t\t\tthis.targetLine.material.color.copy(this.light.color);\n\t\t\t}\n\n\t\t\tthis.targetLine.lookAt(_v2);\n\t\t\tthis.targetLine.scale.z = _v3.length();\n\t\t}\n\n\t}\n\n\tconst _vector = /*@__PURE__*/new Vector3();\n\n\tconst _camera = /*@__PURE__*/new Camera();\n\t/**\n\t *\t- shows frustum, line of sight and up of the camera\n\t *\t- suitable for fast updates\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\t */\n\n\n\tclass CameraHelper extends LineSegments {\n\t\tconstructor(camera) {\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tcolor: 0xffffff,\n\t\t\t\tvertexColors: true,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tconst vertices = [];\n\t\t\tconst colors = [];\n\t\t\tconst pointMap = {}; // colors\n\n\t\t\tconst colorFrustum = new Color(0xffaa00);\n\t\t\tconst colorCone = new Color(0xff0000);\n\t\t\tconst colorUp = new Color(0x00aaff);\n\t\t\tconst colorTarget = new Color(0xffffff);\n\t\t\tconst colorCross = new Color(0x333333); // near\n\n\t\t\taddLine('n1', 'n2', colorFrustum);\n\t\t\taddLine('n2', 'n4', colorFrustum);\n\t\t\taddLine('n4', 'n3', colorFrustum);\n\t\t\taddLine('n3', 'n1', colorFrustum); // far\n\n\t\t\taddLine('f1', 'f2', colorFrustum);\n\t\t\taddLine('f2', 'f4', colorFrustum);\n\t\t\taddLine('f4', 'f3', colorFrustum);\n\t\t\taddLine('f3', 'f1', colorFrustum); // sides\n\n\t\t\taddLine('n1', 'f1', colorFrustum);\n\t\t\taddLine('n2', 'f2', colorFrustum);\n\t\t\taddLine('n3', 'f3', colorFrustum);\n\t\t\taddLine('n4', 'f4', colorFrustum); // cone\n\n\t\t\taddLine('p', 'n1', colorCone);\n\t\t\taddLine('p', 'n2', colorCone);\n\t\t\taddLine('p', 'n3', colorCone);\n\t\t\taddLine('p', 'n4', colorCone); // up\n\n\t\t\taddLine('u1', 'u2', colorUp);\n\t\t\taddLine('u2', 'u3', colorUp);\n\t\t\taddLine('u3', 'u1', colorUp); // target\n\n\t\t\taddLine('c', 't', colorTarget);\n\t\t\taddLine('p', 'c', colorCross); // cross\n\n\t\t\taddLine('cn1', 'cn2', colorCross);\n\t\t\taddLine('cn3', 'cn4', colorCross);\n\t\t\taddLine('cf1', 'cf2', colorCross);\n\t\t\taddLine('cf3', 'cf4', colorCross);\n\n\t\t\tfunction addLine(a, b, color) {\n\t\t\t\taddPoint(a, color);\n\t\t\t\taddPoint(b, color);\n\t\t\t}\n\n\t\t\tfunction addPoint(id, color) {\n\t\t\t\tvertices.push(0, 0, 0);\n\t\t\t\tcolors.push(color.r, color.g, color.b);\n\n\t\t\t\tif (pointMap[id] === undefined) {\n\t\t\t\t\tpointMap[id] = [];\n\t\t\t\t}\n\n\t\t\t\tpointMap[id].push(vertices.length / 3 - 1);\n\t\t\t}\n\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'CameraHelper';\n\t\t\tthis.camera = camera;\n\t\t\tif (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();\n\t\t\tthis.matrix = camera.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.pointMap = pointMap;\n\t\t\tthis.update();\n\t\t}\n\n\t\tupdate() {\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst pointMap = this.pointMap;\n\t\t\tconst w = 1,\n\t\t\t\t\t\th = 1; // we need just camera projection matrix inverse\n\t\t\t// world matrix must be identity\n\n\t\t\t_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target\n\n\n\t\t\tsetPoint('c', pointMap, geometry, _camera, 0, 0, -1);\n\t\t\tsetPoint('t', pointMap, geometry, _camera, 0, 0, 1); // near\n\n\t\t\tsetPoint('n1', pointMap, geometry, _camera, -w, -h, -1);\n\t\t\tsetPoint('n2', pointMap, geometry, _camera, w, -h, -1);\n\t\t\tsetPoint('n3', pointMap, geometry, _camera, -w, h, -1);\n\t\t\tsetPoint('n4', pointMap, geometry, _camera, w, h, -1); // far\n\n\t\t\tsetPoint('f1', pointMap, geometry, _camera, -w, -h, 1);\n\t\t\tsetPoint('f2', pointMap, geometry, _camera, w, -h, 1);\n\t\t\tsetPoint('f3', pointMap, geometry, _camera, -w, h, 1);\n\t\t\tsetPoint('f4', pointMap, geometry, _camera, w, h, 1); // up\n\n\t\t\tsetPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);\n\t\t\tsetPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);\n\t\t\tsetPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1); // cross\n\n\t\t\tsetPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);\n\t\t\tsetPoint('cf2', pointMap, geometry, _camera, w, 0, 1);\n\t\t\tsetPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);\n\t\t\tsetPoint('cf4', pointMap, geometry, _camera, 0, h, 1);\n\t\t\tsetPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);\n\t\t\tsetPoint('cn2', pointMap, geometry, _camera, w, 0, -1);\n\t\t\tsetPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);\n\t\t\tsetPoint('cn4', pointMap, geometry, _camera, 0, h, -1);\n\t\t\tgeometry.getAttribute('position').needsUpdate = true;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.geometry.dispose();\n\t\t\tthis.material.dispose();\n\t\t}\n\n\t}\n\n\tfunction setPoint(point, pointMap, geometry, camera, x, y, z) {\n\t\t_vector.set(x, y, z).unproject(camera);\n\n\t\tconst points = pointMap[point];\n\n\t\tif (points !== undefined) {\n\t\t\tconst position = geometry.getAttribute('position');\n\n\t\t\tfor (let i = 0, l = points.length; i < l; i++) {\n\t\t\t\tposition.setXYZ(points[i], _vector.x, _vector.y, _vector.z);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst _box = /*@__PURE__*/new Box3();\n\n\tclass BoxHelper extends LineSegments {\n\t\tconstructor(object, color = 0xffff00) {\n\t\t\tconst indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\n\t\t\tconst positions = new Float32Array(8 * 3);\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setIndex(new BufferAttribute(indices, 1));\n\t\t\tgeometry.setAttribute('position', new BufferAttribute(positions, 3));\n\t\t\tsuper(geometry, new LineBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\ttoneMapped: false\n\t\t\t}));\n\t\t\tthis.object = object;\n\t\t\tthis.type = 'BoxHelper';\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.update();\n\t\t}\n\n\t\tupdate(object) {\n\t\t\tif (object !== undefined) {\n\t\t\t\tconsole.warn('THREE.BoxHelper: .update() has no longer arguments.');\n\t\t\t}\n\n\t\t\tif (this.object !== undefined) {\n\t\t\t\t_box.setFromObject(this.object);\n\t\t\t}\n\n\t\t\tif (_box.isEmpty()) return;\n\t\t\tconst min = _box.min;\n\t\t\tconst max = _box.max;\n\t\t\t/*\n\t\t\t\t5____4\n\t\t\t1/___0/|\n\t\t\t| 6__|_7\n\t\t\t2/___3/\n\t\t\t\t0: max.x, max.y, max.z\n\t\t\t1: min.x, max.y, max.z\n\t\t\t2: min.x, min.y, max.z\n\t\t\t3: max.x, min.y, max.z\n\t\t\t4: max.x, max.y, min.z\n\t\t\t5: min.x, max.y, min.z\n\t\t\t6: min.x, min.y, min.z\n\t\t\t7: max.x, min.y, min.z\n\t\t\t*/\n\n\t\t\tconst position = this.geometry.attributes.position;\n\t\t\tconst array = position.array;\n\t\t\tarray[0] = max.x;\n\t\t\tarray[1] = max.y;\n\t\t\tarray[2] = max.z;\n\t\t\tarray[3] = min.x;\n\t\t\tarray[4] = max.y;\n\t\t\tarray[5] = max.z;\n\t\t\tarray[6] = min.x;\n\t\t\tarray[7] = min.y;\n\t\t\tarray[8] = max.z;\n\t\t\tarray[9] = max.x;\n\t\t\tarray[10] = min.y;\n\t\t\tarray[11] = max.z;\n\t\t\tarray[12] = max.x;\n\t\t\tarray[13] = max.y;\n\t\t\tarray[14] = min.z;\n\t\t\tarray[15] = min.x;\n\t\t\tarray[16] = max.y;\n\t\t\tarray[17] = min.z;\n\t\t\tarray[18] = min.x;\n\t\t\tarray[19] = min.y;\n\t\t\tarray[20] = min.z;\n\t\t\tarray[21] = max.x;\n\t\t\tarray[22] = min.y;\n\t\t\tarray[23] = min.z;\n\t\t\tposition.needsUpdate = true;\n\t\t\tthis.geometry.computeBoundingSphere();\n\t\t}\n\n\t\tsetFromObject(object) {\n\t\t\tthis.object = object;\n\t\t\tthis.update();\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tLineSegments.prototype.copy.call(this, source);\n\t\t\tthis.object = source.object;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass Box3Helper extends LineSegments {\n\t\tconstructor(box, color = 0xffff00) {\n\t\t\tconst indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\n\t\t\tconst positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setIndex(new BufferAttribute(indices, 1));\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t\t\tsuper(geometry, new LineBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\ttoneMapped: false\n\t\t\t}));\n\t\t\tthis.box = box;\n\t\t\tthis.type = 'Box3Helper';\n\t\t\tthis.geometry.computeBoundingSphere();\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tconst box = this.box;\n\t\t\tif (box.isEmpty()) return;\n\t\t\tbox.getCenter(this.position);\n\t\t\tbox.getSize(this.scale);\n\t\t\tthis.scale.multiplyScalar(0.5);\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t}\n\n\t}\n\n\tclass PlaneHelper extends Line {\n\t\tconstructor(plane, size = 1, hex = 0xffff00) {\n\t\t\tconst color = hex;\n\t\t\tconst positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t\t\tgeometry.computeBoundingSphere();\n\t\t\tsuper(geometry, new LineBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\ttoneMapped: false\n\t\t\t}));\n\t\t\tthis.type = 'PlaneHelper';\n\t\t\tthis.plane = plane;\n\t\t\tthis.size = size;\n\t\t\tconst positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];\n\t\t\tconst geometry2 = new BufferGeometry();\n\t\t\tgeometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));\n\t\t\tgeometry2.computeBoundingSphere();\n\t\t\tthis.add(new Mesh(geometry2, new MeshBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\topacity: 0.2,\n\t\t\t\ttransparent: true,\n\t\t\t\tdepthWrite: false,\n\t\t\t\ttoneMapped: false\n\t\t\t})));\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tlet scale = -this.plane.constant;\n\t\t\tif (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter\n\n\t\t\tthis.scale.set(0.5 * this.size, 0.5 * this.size, scale);\n\t\t\tthis.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here\n\n\t\t\tthis.lookAt(this.plane.normal);\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t}\n\n\t}\n\n\tconst _axis = /*@__PURE__*/new Vector3();\n\n\tlet _lineGeometry, _coneGeometry;\n\n\tclass ArrowHelper extends Object3D {\n\t\t// dir is assumed to be normalized\n\t\tconstructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ArrowHelper';\n\n\t\t\tif (_lineGeometry === undefined) {\n\t\t\t\t_lineGeometry = new BufferGeometry();\n\n\t\t\t\t_lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));\n\n\t\t\t\t_coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);\n\n\t\t\t\t_coneGeometry.translate(0, -0.5, 0);\n\t\t\t}\n\n\t\t\tthis.position.copy(origin);\n\t\t\tthis.line = new Line(_lineGeometry, new LineBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\ttoneMapped: false\n\t\t\t}));\n\t\t\tthis.line.matrixAutoUpdate = false;\n\t\t\tthis.add(this.line);\n\t\t\tthis.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\ttoneMapped: false\n\t\t\t}));\n\t\t\tthis.cone.matrixAutoUpdate = false;\n\t\t\tthis.add(this.cone);\n\t\t\tthis.setDirection(dir);\n\t\t\tthis.setLength(length, headLength, headWidth);\n\t\t}\n\n\t\tsetDirection(dir) {\n\t\t\t// dir is assumed to be normalized\n\t\t\tif (dir.y > 0.99999) {\n\t\t\t\tthis.quaternion.set(0, 0, 0, 1);\n\t\t\t} else if (dir.y < -0.99999) {\n\t\t\t\tthis.quaternion.set(1, 0, 0, 0);\n\t\t\t} else {\n\t\t\t\t_axis.set(dir.z, 0, -dir.x).normalize();\n\n\t\t\t\tconst radians = Math.acos(dir.y);\n\t\t\t\tthis.quaternion.setFromAxisAngle(_axis, radians);\n\t\t\t}\n\t\t}\n\n\t\tsetLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {\n\t\t\tthis.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458\n\n\t\t\tthis.line.updateMatrix();\n\t\t\tthis.cone.scale.set(headWidth, headLength, headWidth);\n\t\t\tthis.cone.position.y = length;\n\t\t\tthis.cone.updateMatrix();\n\t\t}\n\n\t\tsetColor(color) {\n\t\t\tthis.line.material.color.set(color);\n\t\t\tthis.cone.material.color.set(color);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source, false);\n\t\t\tthis.line.copy(source.line);\n\t\t\tthis.cone.copy(source.cone);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass AxesHelper extends LineSegments {\n\t\tconstructor(size = 1) {\n\t\t\tconst vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];\n\t\t\tconst colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tvertexColors: true,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'AxesHelper';\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.geometry.dispose();\n\t\t\tthis.material.dispose();\n\t\t}\n\n\t}\n\n\tconst _floatView = new Float32Array(1);\n\n\tconst _int32View = new Int32Array(_floatView.buffer);\n\n\tclass DataUtils {\n\t\t// Converts float32 to float16 (stored as uint16 value).\n\t\tstatic toHalfFloat(val) {\n\t\t\t// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\n\n\t\t\t/* This method is faster than the OpenEXR implementation (very often\n\t\t\t* used, eg. in Ogre), with the additional benefit of rounding, inspired\n\t\t\t* by James Tursa?s half-precision code. */\n\t\t\t_floatView[0] = val;\n\t\t\tconst x = _int32View[0];\n\t\t\tlet bits = x >> 16 & 0x8000;\n\t\t\t/* Get the sign */\n\n\t\t\tlet m = x >> 12 & 0x07ff;\n\t\t\t/* Keep one extra bit for rounding */\n\n\t\t\tconst e = x >> 23 & 0xff;\n\t\t\t/* Using int is faster here */\n\n\t\t\t/* If zero, or denormal, or exponent underflows too much for a denormal\n\t\t\t\t* half, return signed zero. */\n\n\t\t\tif (e < 103) return bits;\n\t\t\t/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\n\t\t\tif (e > 142) {\n\t\t\t\tbits |= 0x7c00;\n\t\t\t\t/* If exponent was 0xff and one mantissa bit was set, it means NaN,\n\t\t\t\t\t\t\t* not Inf, so make sure we set one mantissa bit too. */\n\n\t\t\t\tbits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n\t\t\t\treturn bits;\n\t\t\t}\n\t\t\t/* If exponent underflows but not too much, return a denormal */\n\n\n\t\t\tif (e < 113) {\n\t\t\t\tm |= 0x0800;\n\t\t\t\t/* Extra rounding may overflow and set mantissa to 0 and exponent\n\t\t\t\t\t* to 1, which is OK. */\n\n\t\t\t\tbits |= (m >> 114 - e) + (m >> 113 - e & 1);\n\t\t\t\treturn bits;\n\t\t\t}\n\n\t\t\tbits |= e - 112 << 10 | m >> 1;\n\t\t\t/* Extra rounding. An overflow will set mantissa to 0 and increment\n\t\t\t\t* the exponent, which is OK. */\n\n\t\t\tbits += m & 1;\n\t\t\treturn bits;\n\t\t}\n\n\t}\n\n\tconst LOD_MIN = 4;\n\tconst LOD_MAX = 8;\n\tconst SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are\n\t// chosen to approximate a Trowbridge-Reitz distribution function times the\n\t// geometric shadowing function. These sigma values squared must match the\n\t// variance #defines in cube_uv_reflection_fragment.glsl.js.\n\n\tconst EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\n\tconst TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer\n\t// samples and exit early, but not recompile the shader.\n\n\tconst MAX_SAMPLES = 20;\n\tconst ENCODINGS = {\n\t\t[LinearEncoding]: 0,\n\t\t[sRGBEncoding]: 1,\n\t\t[RGBEEncoding]: 2,\n\t\t[RGBM7Encoding]: 3,\n\t\t[RGBM16Encoding]: 4,\n\t\t[RGBDEncoding]: 5,\n\t\t[GammaEncoding]: 6\n\t};\n\tconst backgroundMaterial = new MeshBasicMaterial({\n\t\tside: BackSide,\n\t\tdepthWrite: false,\n\t\tdepthTest: false\n\t});\n\tconst backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);\n\n\tconst _flatCamera = /*@__PURE__*/new OrthographicCamera();\n\n\tconst {\n\t\t_lodPlanes,\n\t\t_sizeLods,\n\t\t_sigmas\n\t} = /*@__PURE__*/_createPlanes();\n\n\tconst _clearColor = /*@__PURE__*/new Color();\n\n\tlet _oldTarget = null; // Golden Ratio\n\n\tconst PHI = (1 + Math.sqrt(5)) / 2;\n\tconst INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the\n\t// same axis), used as axis directions evenly spread on a sphere.\n\n\tconst _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];\n\t/**\n\t * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n\t * (PMREM) from a cubeMap environment texture. This allows different levels of\n\t * blur to be quickly accessed based on material roughness. It is packed into a\n\t * special CubeUV format that allows us to perform custom interpolation so that\n\t * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n\t * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n\t * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n\t * higher roughness levels. In this way we maintain resolution to smoothly\n\t * interpolate diffuse lighting while limiting sampling computation.\n\t *\n\t * Paper: Fast, Accurate Image-Based Lighting\n\t * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n\t*/\n\n\tfunction convertLinearToRGBE(color) {\n\t\tconst maxComponent = Math.max(color.r, color.g, color.b);\n\t\tconst fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);\n\t\tcolor.multiplyScalar(Math.pow(2.0, -fExp));\n\t\tconst alpha = (fExp + 128.0) / 255.0;\n\t\treturn alpha;\n\t}\n\n\tclass PMREMGenerator {\n\t\tconstructor(renderer) {\n\t\t\tthis._renderer = renderer;\n\t\t\tthis._pingPongRenderTarget = null;\n\t\t\tthis._blurMaterial = _getBlurShader(MAX_SAMPLES);\n\t\t\tthis._equirectShader = null;\n\t\t\tthis._cubemapShader = null;\n\n\t\t\tthis._compileMaterial(this._blurMaterial);\n\t\t}\n\t\t/**\n\t\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t\t * is placed at the origin).\n\t\t */\n\n\n\t\tfromScene(scene, sigma = 0, near = 0.1, far = 100) {\n\t\t\t_oldTarget = this._renderer.getRenderTarget();\n\n\t\t\tconst cubeUVRenderTarget = this._allocateTargets();\n\n\t\t\tthis._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n\n\t\t\tif (sigma > 0) {\n\t\t\t\tthis._blur(cubeUVRenderTarget, 0, 0, sigma);\n\t\t\t}\n\n\t\t\tthis._applyPMREM(cubeUVRenderTarget);\n\n\t\t\tthis._cleanup(cubeUVRenderTarget);\n\n\t\t\treturn cubeUVRenderTarget;\n\t\t}\n\t\t/**\n\t\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t\t * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),\n\t\t * as this matches best with the 256 x 256 cubemap output.\n\t\t */\n\n\n\t\tfromEquirectangular(equirectangular) {\n\t\t\treturn this._fromTexture(equirectangular);\n\t\t}\n\t\t/**\n\t\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t\t * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,\n\t\t * as this matches best with the 256 x 256 cubemap output.\n\t\t */\n\n\n\t\tfromCubemap(cubemap) {\n\t\t\treturn this._fromTexture(cubemap);\n\t\t}\n\t\t/**\n\t\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t\t * your texture's network fetch for increased concurrency.\n\t\t */\n\n\n\t\tcompileCubemapShader() {\n\t\t\tif (this._cubemapShader === null) {\n\t\t\t\tthis._cubemapShader = _getCubemapShader();\n\n\t\t\t\tthis._compileMaterial(this._cubemapShader);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t\t * your texture's network fetch for increased concurrency.\n\t\t */\n\n\n\t\tcompileEquirectangularShader() {\n\t\t\tif (this._equirectShader === null) {\n\t\t\t\tthis._equirectShader = _getEquirectShader();\n\n\t\t\t\tthis._compileMaterial(this._equirectShader);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t\t * one of them will cause any others to also become unusable.\n\t\t */\n\n\n\t\tdispose() {\n\t\t\tthis._blurMaterial.dispose();\n\n\t\t\tif (this._cubemapShader !== null) this._cubemapShader.dispose();\n\t\t\tif (this._equirectShader !== null) this._equirectShader.dispose();\n\n\t\t\tfor (let i = 0; i < _lodPlanes.length; i++) {\n\t\t\t\t_lodPlanes[i].dispose();\n\t\t\t}\n\t\t} // private interface\n\n\n\t\t_cleanup(outputTarget) {\n\t\t\tthis._pingPongRenderTarget.dispose();\n\n\t\t\tthis._renderer.setRenderTarget(_oldTarget);\n\n\t\t\toutputTarget.scissorTest = false;\n\n\t\t\t_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n\t\t}\n\n\t\t_fromTexture(texture) {\n\t\t\t_oldTarget = this._renderer.getRenderTarget();\n\n\t\t\tconst cubeUVRenderTarget = this._allocateTargets(texture);\n\n\t\t\tthis._textureToCubeUV(texture, cubeUVRenderTarget);\n\n\t\t\tthis._applyPMREM(cubeUVRenderTarget);\n\n\t\t\tthis._cleanup(cubeUVRenderTarget);\n\n\t\t\treturn cubeUVRenderTarget;\n\t\t}\n\n\t\t_allocateTargets(texture) {\n\t\t\t// warning: null texture is valid\n\t\t\tconst params = {\n\t\t\t\tmagFilter: NearestFilter,\n\t\t\t\tminFilter: NearestFilter,\n\t\t\t\tgenerateMipmaps: false,\n\t\t\t\ttype: UnsignedByteType,\n\t\t\t\tformat: RGBEFormat,\n\t\t\t\tencoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,\n\t\t\t\tdepthBuffer: false\n\t\t\t};\n\n\t\t\tconst cubeUVRenderTarget = _createRenderTarget(params);\n\n\t\t\tcubeUVRenderTarget.depthBuffer = texture ? false : true;\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget(params);\n\t\t\treturn cubeUVRenderTarget;\n\t\t}\n\n\t\t_compileMaterial(material) {\n\t\t\tconst tmpMesh = new Mesh(_lodPlanes[0], material);\n\n\t\t\tthis._renderer.compile(tmpMesh, _flatCamera);\n\t\t}\n\n\t\t_sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n\t\t\tconst fov = 90;\n\t\t\tconst aspect = 1;\n\t\t\tconst cubeCamera = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tconst upSign = [1, -1, 1, 1, 1, 1];\n\t\t\tconst forwardSign = [1, 1, 1, -1, -1, -1];\n\t\t\tconst renderer = this._renderer;\n\t\t\tconst originalAutoClear = renderer.autoClear;\n\t\t\tconst outputEncoding = renderer.outputEncoding;\n\t\t\tconst toneMapping = renderer.toneMapping;\n\t\t\trenderer.getClearColor(_clearColor);\n\t\t\trenderer.toneMapping = NoToneMapping;\n\t\t\trenderer.outputEncoding = LinearEncoding;\n\t\t\trenderer.autoClear = false;\n\t\t\tlet useSolidColor = false;\n\t\t\tconst background = scene.background;\n\n\t\t\tif (background) {\n\t\t\t\tif (background.isColor) {\n\t\t\t\t\tbackgroundMaterial.color.copy(background).convertSRGBToLinear();\n\t\t\t\t\tscene.background = null;\n\t\t\t\t\tconst alpha = convertLinearToRGBE(backgroundMaterial.color);\n\t\t\t\t\tbackgroundMaterial.opacity = alpha;\n\t\t\t\t\tuseSolidColor = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbackgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();\n\t\t\t\tconst alpha = convertLinearToRGBE(backgroundMaterial.color);\n\t\t\t\tbackgroundMaterial.opacity = alpha;\n\t\t\t\tuseSolidColor = true;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tconst col = i % 3;\n\n\t\t\t\tif (col == 0) {\n\t\t\t\t\tcubeCamera.up.set(0, upSign[i], 0);\n\t\t\t\t\tcubeCamera.lookAt(forwardSign[i], 0, 0);\n\t\t\t\t} else if (col == 1) {\n\t\t\t\t\tcubeCamera.up.set(0, 0, upSign[i]);\n\t\t\t\t\tcubeCamera.lookAt(0, forwardSign[i], 0);\n\t\t\t\t} else {\n\t\t\t\t\tcubeCamera.up.set(0, upSign[i], 0);\n\t\t\t\t\tcubeCamera.lookAt(0, 0, forwardSign[i]);\n\t\t\t\t}\n\n\t\t\t\t_setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);\n\n\t\t\t\trenderer.setRenderTarget(cubeUVRenderTarget);\n\n\t\t\t\tif (useSolidColor) {\n\t\t\t\t\trenderer.render(backgroundBox, cubeCamera);\n\t\t\t\t}\n\n\t\t\t\trenderer.render(scene, cubeCamera);\n\t\t\t}\n\n\t\t\trenderer.toneMapping = toneMapping;\n\t\t\trenderer.outputEncoding = outputEncoding;\n\t\t\trenderer.autoClear = originalAutoClear;\n\t\t}\n\n\t\t_textureToCubeUV(texture, cubeUVRenderTarget) {\n\t\t\tconst renderer = this._renderer;\n\n\t\t\tif (texture.isCubeTexture) {\n\t\t\t\tif (this._cubemapShader == null) {\n\t\t\t\t\tthis._cubemapShader = _getCubemapShader();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this._equirectShader == null) {\n\t\t\t\t\tthis._equirectShader = _getEquirectShader();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;\n\t\t\tconst mesh = new Mesh(_lodPlanes[0], material);\n\t\t\tconst uniforms = material.uniforms;\n\t\t\tuniforms['envMap'].value = texture;\n\n\t\t\tif (!texture.isCubeTexture) {\n\t\t\t\tuniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);\n\t\t\t}\n\n\t\t\tuniforms['inputEncoding'].value = ENCODINGS[texture.encoding];\n\t\t\tuniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];\n\n\t\t\t_setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);\n\n\t\t\trenderer.setRenderTarget(cubeUVRenderTarget);\n\t\t\trenderer.render(mesh, _flatCamera);\n\t\t}\n\n\t\t_applyPMREM(cubeUVRenderTarget) {\n\t\t\tconst renderer = this._renderer;\n\t\t\tconst autoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = false;\n\n\t\t\tfor (let i = 1; i < TOTAL_LODS; i++) {\n\t\t\t\tconst sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);\n\t\t\t\tconst poleAxis = _axisDirections[(i - 1) % _axisDirections.length];\n\n\t\t\t\tthis._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n\t\t\t}\n\n\t\t\trenderer.autoClear = autoClear;\n\t\t}\n\t\t/**\n\t\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t\t * accurate at the poles, but still does a decent job.\n\t\t */\n\n\n\t\t_blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n\t\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\t\tthis._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);\n\n\t\t\tthis._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);\n\t\t}\n\n\t\t_halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n\t\t\tconst renderer = this._renderer;\n\t\t\tconst blurMaterial = this._blurMaterial;\n\n\t\t\tif (direction !== 'latitudinal' && direction !== 'longitudinal') {\n\t\t\t\tconsole.error('blur direction must be either latitudinal or longitudinal!');\n\t\t\t} // Number of standard deviations at which to cut off the discrete approximation.\n\n\n\t\t\tconst STANDARD_DEVIATIONS = 3;\n\t\t\tconst blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);\n\t\t\tconst blurUniforms = blurMaterial.uniforms;\n\t\t\tconst pixels = _sizeLods[lodIn] - 1;\n\t\t\tconst radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n\t\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\t\tconst samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n\n\t\t\tif (samples > MAX_SAMPLES) {\n\t\t\t\tconsole.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n\t\t\t}\n\n\t\t\tconst weights = [];\n\t\t\tlet sum = 0;\n\n\t\t\tfor (let i = 0; i < MAX_SAMPLES; ++i) {\n\t\t\t\tconst x = i / sigmaPixels;\n\t\t\t\tconst weight = Math.exp(-x * x / 2);\n\t\t\t\tweights.push(weight);\n\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tsum += weight;\n\t\t\t\t} else if (i < samples) {\n\t\t\t\t\tsum += 2 * weight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < weights.length; i++) {\n\t\t\t\tweights[i] = weights[i] / sum;\n\t\t\t}\n\n\t\t\tblurUniforms['envMap'].value = targetIn.texture;\n\t\t\tblurUniforms['samples'].value = samples;\n\t\t\tblurUniforms['weights'].value = weights;\n\t\t\tblurUniforms['latitudinal'].value = direction === 'latitudinal';\n\n\t\t\tif (poleAxis) {\n\t\t\t\tblurUniforms['poleAxis'].value = poleAxis;\n\t\t\t}\n\n\t\t\tblurUniforms['dTheta'].value = radiansPerPixel;\n\t\t\tblurUniforms['mipInt'].value = LOD_MAX - lodIn;\n\t\t\tblurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];\n\t\t\tblurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];\n\t\t\tconst outputSize = _sizeLods[lodOut];\n\t\t\tconst x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);\n\t\t\tconst y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);\n\n\t\t\t_setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n\n\t\t\trenderer.setRenderTarget(targetOut);\n\t\t\trenderer.render(blurMesh, _flatCamera);\n\t\t}\n\n\t}\n\n\tfunction _isLDR(texture) {\n\t\tif (texture === undefined || texture.type !== UnsignedByteType) return false;\n\t\treturn texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;\n\t}\n\n\tfunction _createPlanes() {\n\t\tconst _lodPlanes = [];\n\t\tconst _sizeLods = [];\n\t\tconst _sigmas = [];\n\t\tlet lod = LOD_MAX;\n\n\t\tfor (let i = 0; i < TOTAL_LODS; i++) {\n\t\t\tconst sizeLod = Math.pow(2, lod);\n\n\t\t\t_sizeLods.push(sizeLod);\n\n\t\t\tlet sigma = 1.0 / sizeLod;\n\n\t\t\tif (i > LOD_MAX - LOD_MIN) {\n\t\t\t\tsigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];\n\t\t\t} else if (i == 0) {\n\t\t\t\tsigma = 0;\n\t\t\t}\n\n\t\t\t_sigmas.push(sigma);\n\n\t\t\tconst texelSize = 1.0 / (sizeLod - 1);\n\t\t\tconst min = -texelSize / 2;\n\t\t\tconst max = 1 + texelSize / 2;\n\t\t\tconst uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n\t\t\tconst cubeFaces = 6;\n\t\t\tconst vertices = 6;\n\t\t\tconst positionSize = 3;\n\t\t\tconst uvSize = 2;\n\t\t\tconst faceIndexSize = 1;\n\t\t\tconst position = new Float32Array(positionSize * vertices * cubeFaces);\n\t\t\tconst uv = new Float32Array(uvSize * vertices * cubeFaces);\n\t\t\tconst faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n\n\t\t\tfor (let face = 0; face < cubeFaces; face++) {\n\t\t\t\tconst x = face % 3 * 2 / 3 - 1;\n\t\t\t\tconst y = face > 2 ? 0 : -1;\n\t\t\t\tconst coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n\t\t\t\tposition.set(coordinates, positionSize * vertices * face);\n\t\t\t\tuv.set(uv1, uvSize * vertices * face);\n\t\t\t\tconst fill = [face, face, face, face, face, face];\n\t\t\t\tfaceIndex.set(fill, faceIndexSize * vertices * face);\n\t\t\t}\n\n\t\t\tconst planes = new BufferGeometry();\n\t\t\tplanes.setAttribute('position', new BufferAttribute(position, positionSize));\n\t\t\tplanes.setAttribute('uv', new BufferAttribute(uv, uvSize));\n\t\t\tplanes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));\n\n\t\t\t_lodPlanes.push(planes);\n\n\t\t\tif (lod > LOD_MIN) {\n\t\t\t\tlod--;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\t_lodPlanes,\n\t\t\t_sizeLods,\n\t\t\t_sigmas\n\t\t};\n\t}\n\n\tfunction _createRenderTarget(params) {\n\t\tconst cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);\n\t\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\t\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\t\tcubeUVRenderTarget.scissorTest = true;\n\t\treturn cubeUVRenderTarget;\n\t}\n\n\tfunction _setViewport(target, x, y, width, height) {\n\t\ttarget.viewport.set(x, y, width, height);\n\t\ttarget.scissor.set(x, y, width, height);\n\t}\n\n\tfunction _getBlurShader(maxSamples) {\n\t\tconst weights = new Float32Array(maxSamples);\n\t\tconst poleAxis = new Vector3(0, 1, 0);\n\t\tconst shaderMaterial = new RawShaderMaterial({\n\t\t\tname: 'SphericalGaussianBlur',\n\t\t\tdefines: {\n\t\t\t\t'n': maxSamples\n\t\t\t},\n\t\t\tuniforms: {\n\t\t\t\t'envMap': {\n\t\t\t\t\tvalue: null\n\t\t\t\t},\n\t\t\t\t'samples': {\n\t\t\t\t\tvalue: 1\n\t\t\t\t},\n\t\t\t\t'weights': {\n\t\t\t\t\tvalue: weights\n\t\t\t\t},\n\t\t\t\t'latitudinal': {\n\t\t\t\t\tvalue: false\n\t\t\t\t},\n\t\t\t\t'dTheta': {\n\t\t\t\t\tvalue: 0\n\t\t\t\t},\n\t\t\t\t'mipInt': {\n\t\t\t\t\tvalue: 0\n\t\t\t\t},\n\t\t\t\t'poleAxis': {\n\t\t\t\t\tvalue: poleAxis\n\t\t\t\t},\n\t\t\t\t'inputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t},\n\t\t\t\t'outputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: _getCommonVertexShader(),\n\t\t\tfragmentShader:\n\t\t\t/* glsl */\n\t\t\t`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\t\t\tblending: NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false\n\t\t});\n\t\treturn shaderMaterial;\n\t}\n\n\tfunction _getEquirectShader() {\n\t\tconst texelSize = new Vector2(1, 1);\n\t\tconst shaderMaterial = new RawShaderMaterial({\n\t\t\tname: 'EquirectangularToCubeUV',\n\t\t\tuniforms: {\n\t\t\t\t'envMap': {\n\t\t\t\t\tvalue: null\n\t\t\t\t},\n\t\t\t\t'texelSize': {\n\t\t\t\t\tvalue: texelSize\n\t\t\t\t},\n\t\t\t\t'inputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t},\n\t\t\t\t'outputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: _getCommonVertexShader(),\n\t\t\tfragmentShader:\n\t\t\t/* glsl */\n\t\t\t`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\t\t\tblending: NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false\n\t\t});\n\t\treturn shaderMaterial;\n\t}\n\n\tfunction _getCubemapShader() {\n\t\tconst shaderMaterial = new RawShaderMaterial({\n\t\t\tname: 'CubemapToCubeUV',\n\t\t\tuniforms: {\n\t\t\t\t'envMap': {\n\t\t\t\t\tvalue: null\n\t\t\t\t},\n\t\t\t\t'inputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t},\n\t\t\t\t'outputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: _getCommonVertexShader(),\n\t\t\tfragmentShader:\n\t\t\t/* glsl */\n\t\t\t`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${_getEncodings()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\t\t\tblending: NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false\n\t\t});\n\t\treturn shaderMaterial;\n\t}\n\n\tfunction _getCommonVertexShader() {\n\t\treturn (\n\t\t\t/* glsl */\n\t\t\t`\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`\n\t\t);\n\t}\n\n\tfunction _getEncodings() {\n\t\treturn (\n\t\t\t/* glsl */\n\t\t\t`\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t`\n\t\t);\n\t}\n\n\tconst LineStrip = 0;\n\tconst LinePieces = 1;\n\tconst NoColors = 0;\n\tconst FaceColors = 1;\n\tconst VertexColors = 2;\n\tfunction MeshFaceMaterial(materials) {\n\t\tconsole.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');\n\t\treturn materials;\n\t}\n\tfunction MultiMaterial(materials = []) {\n\t\tconsole.warn('THREE.MultiMaterial has been removed. Use an Array instead.');\n\t\tmaterials.isMultiMaterial = true;\n\t\tmaterials.materials = materials;\n\n\t\tmaterials.clone = function () {\n\t\t\treturn materials.slice();\n\t\t};\n\n\t\treturn materials;\n\t}\n\tfunction PointCloud(geometry, material) {\n\t\tconsole.warn('THREE.PointCloud has been renamed to THREE.Points.');\n\t\treturn new Points(geometry, material);\n\t}\n\tfunction Particle(material) {\n\t\tconsole.warn('THREE.Particle has been renamed to THREE.Sprite.');\n\t\treturn new Sprite(material);\n\t}\n\tfunction ParticleSystem(geometry, material) {\n\t\tconsole.warn('THREE.ParticleSystem has been renamed to THREE.Points.');\n\t\treturn new Points(geometry, material);\n\t}\n\tfunction PointCloudMaterial(parameters) {\n\t\tconsole.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');\n\t\treturn new PointsMaterial(parameters);\n\t}\n\tfunction ParticleBasicMaterial(parameters) {\n\t\tconsole.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');\n\t\treturn new PointsMaterial(parameters);\n\t}\n\tfunction ParticleSystemMaterial(parameters) {\n\t\tconsole.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');\n\t\treturn new PointsMaterial(parameters);\n\t}\n\tfunction Vertex(x, y, z) {\n\t\tconsole.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');\n\t\treturn new Vector3(x, y, z);\n\t} //\n\n\tfunction DynamicBufferAttribute(array, itemSize) {\n\t\tconsole.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');\n\t\treturn new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);\n\t}\n\tfunction Int8Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');\n\t\treturn new Int8BufferAttribute(array, itemSize);\n\t}\n\tfunction Uint8Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');\n\t\treturn new Uint8BufferAttribute(array, itemSize);\n\t}\n\tfunction Uint8ClampedAttribute(array, itemSize) {\n\t\tconsole.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');\n\t\treturn new Uint8ClampedBufferAttribute(array, itemSize);\n\t}\n\tfunction Int16Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');\n\t\treturn new Int16BufferAttribute(array, itemSize);\n\t}\n\tfunction Uint16Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');\n\t\treturn new Uint16BufferAttribute(array, itemSize);\n\t}\n\tfunction Int32Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');\n\t\treturn new Int32BufferAttribute(array, itemSize);\n\t}\n\tfunction Uint32Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');\n\t\treturn new Uint32BufferAttribute(array, itemSize);\n\t}\n\tfunction Float32Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');\n\t\treturn new Float32BufferAttribute(array, itemSize);\n\t}\n\tfunction Float64Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');\n\t\treturn new Float64BufferAttribute(array, itemSize);\n\t} //\n\n\tCurve.create = function (construct, getPoint) {\n\t\tconsole.log('THREE.Curve.create() has been deprecated');\n\t\tconstruct.prototype = Object.create(Curve.prototype);\n\t\tconstruct.prototype.constructor = construct;\n\t\tconstruct.prototype.getPoint = getPoint;\n\t\treturn construct;\n\t}; //\n\n\n\tPath.prototype.fromPoints = function (points) {\n\t\tconsole.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');\n\t\treturn this.setFromPoints(points);\n\t}; //\n\n\n\tfunction AxisHelper(size) {\n\t\tconsole.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');\n\t\treturn new AxesHelper(size);\n\t}\n\tfunction BoundingBoxHelper(object, color) {\n\t\tconsole.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');\n\t\treturn new BoxHelper(object, color);\n\t}\n\tfunction EdgesHelper(object, hex) {\n\t\tconsole.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');\n\t\treturn new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({\n\t\t\tcolor: hex !== undefined ? hex : 0xffffff\n\t\t}));\n\t}\n\n\tGridHelper.prototype.setColors = function () {\n\t\tconsole.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');\n\t};\n\n\tSkeletonHelper.prototype.update = function () {\n\t\tconsole.error('THREE.SkeletonHelper: update() no longer needs to be called.');\n\t};\n\n\tfunction WireframeHelper(object, hex) {\n\t\tconsole.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');\n\t\treturn new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({\n\t\t\tcolor: hex !== undefined ? hex : 0xffffff\n\t\t}));\n\t} //\n\n\tLoader.prototype.extractUrlBase = function (url) {\n\t\tconsole.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');\n\t\treturn LoaderUtils.extractUrlBase(url);\n\t};\n\n\tLoader.Handlers = {\n\t\tadd: function ()\n\t\t/* regex, loader */\n\t\t{\n\t\t\tconsole.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');\n\t\t},\n\t\tget: function ()\n\t\t/* file */\n\t\t{\n\t\t\tconsole.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');\n\t\t}\n\t};\n\tfunction XHRLoader(manager) {\n\t\tconsole.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');\n\t\treturn new FileLoader(manager);\n\t}\n\tfunction BinaryTextureLoader(manager) {\n\t\tconsole.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');\n\t\treturn new DataTextureLoader(manager);\n\t} //\n\n\tBox2.prototype.center = function (optionalTarget) {\n\t\tconsole.warn('THREE.Box2: .center() has been renamed to .getCenter().');\n\t\treturn this.getCenter(optionalTarget);\n\t};\n\n\tBox2.prototype.empty = function () {\n\t\tconsole.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');\n\t\treturn this.isEmpty();\n\t};\n\n\tBox2.prototype.isIntersectionBox = function (box) {\n\t\tconsole.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');\n\t\treturn this.intersectsBox(box);\n\t};\n\n\tBox2.prototype.size = function (optionalTarget) {\n\t\tconsole.warn('THREE.Box2: .size() has been renamed to .getSize().');\n\t\treturn this.getSize(optionalTarget);\n\t}; //\n\n\n\tBox3.prototype.center = function (optionalTarget) {\n\t\tconsole.warn('THREE.Box3: .center() has been renamed to .getCenter().');\n\t\treturn this.getCenter(optionalTarget);\n\t};\n\n\tBox3.prototype.empty = function () {\n\t\tconsole.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');\n\t\treturn this.isEmpty();\n\t};\n\n\tBox3.prototype.isIntersectionBox = function (box) {\n\t\tconsole.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');\n\t\treturn this.intersectsBox(box);\n\t};\n\n\tBox3.prototype.isIntersectionSphere = function (sphere) {\n\t\tconsole.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');\n\t\treturn this.intersectsSphere(sphere);\n\t};\n\n\tBox3.prototype.size = function (optionalTarget) {\n\t\tconsole.warn('THREE.Box3: .size() has been renamed to .getSize().');\n\t\treturn this.getSize(optionalTarget);\n\t}; //\n\n\n\tSphere.prototype.empty = function () {\n\t\tconsole.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');\n\t\treturn this.isEmpty();\n\t}; //\n\n\n\tFrustum.prototype.setFromMatrix = function (m) {\n\t\tconsole.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');\n\t\treturn this.setFromProjectionMatrix(m);\n\t}; //\n\n\n\tLine3.prototype.center = function (optionalTarget) {\n\t\tconsole.warn('THREE.Line3: .center() has been renamed to .getCenter().');\n\t\treturn this.getCenter(optionalTarget);\n\t}; //\n\n\n\tMatrix3.prototype.flattenToArrayOffset = function (array, offset) {\n\t\tconsole.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');\n\t\treturn this.toArray(array, offset);\n\t};\n\n\tMatrix3.prototype.multiplyVector3 = function (vector) {\n\t\tconsole.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');\n\t\treturn vector.applyMatrix3(this);\n\t};\n\n\tMatrix3.prototype.multiplyVector3Array = function ()\n\t/* a */\n\t{\n\t\tconsole.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');\n\t};\n\n\tMatrix3.prototype.applyToBufferAttribute = function (attribute) {\n\t\tconsole.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');\n\t\treturn attribute.applyMatrix3(this);\n\t};\n\n\tMatrix3.prototype.applyToVector3Array = function ()\n\t/* array, offset, length */\n\t{\n\t\tconsole.error('THREE.Matrix3: .applyToVector3Array() has been removed.');\n\t};\n\n\tMatrix3.prototype.getInverse = function (matrix) {\n\t\tconsole.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');\n\t\treturn this.copy(matrix).invert();\n\t}; //\n\n\n\tMatrix4.prototype.extractPosition = function (m) {\n\t\tconsole.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');\n\t\treturn this.copyPosition(m);\n\t};\n\n\tMatrix4.prototype.flattenToArrayOffset = function (array, offset) {\n\t\tconsole.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');\n\t\treturn this.toArray(array, offset);\n\t};\n\n\tMatrix4.prototype.getPosition = function () {\n\t\tconsole.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');\n\t\treturn new Vector3().setFromMatrixColumn(this, 3);\n\t};\n\n\tMatrix4.prototype.setRotationFromQuaternion = function (q) {\n\t\tconsole.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');\n\t\treturn this.makeRotationFromQuaternion(q);\n\t};\n\n\tMatrix4.prototype.multiplyToArray = function () {\n\t\tconsole.warn('THREE.Matrix4: .multiplyToArray() has been removed.');\n\t};\n\n\tMatrix4.prototype.multiplyVector3 = function (vector) {\n\t\tconsole.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');\n\t\treturn vector.applyMatrix4(this);\n\t};\n\n\tMatrix4.prototype.multiplyVector4 = function (vector) {\n\t\tconsole.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');\n\t\treturn vector.applyMatrix4(this);\n\t};\n\n\tMatrix4.prototype.multiplyVector3Array = function ()\n\t/* a */\n\t{\n\t\tconsole.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');\n\t};\n\n\tMatrix4.prototype.rotateAxis = function (v) {\n\t\tconsole.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');\n\t\tv.transformDirection(this);\n\t};\n\n\tMatrix4.prototype.crossVector = function (vector) {\n\t\tconsole.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');\n\t\treturn vector.applyMatrix4(this);\n\t};\n\n\tMatrix4.prototype.translate = function () {\n\t\tconsole.error('THREE.Matrix4: .translate() has been removed.');\n\t};\n\n\tMatrix4.prototype.rotateX = function () {\n\t\tconsole.error('THREE.Matrix4: .rotateX() has been removed.');\n\t};\n\n\tMatrix4.prototype.rotateY = function () {\n\t\tconsole.error('THREE.Matrix4: .rotateY() has been removed.');\n\t};\n\n\tMatrix4.prototype.rotateZ = function () {\n\t\tconsole.error('THREE.Matrix4: .rotateZ() has been removed.');\n\t};\n\n\tMatrix4.prototype.rotateByAxis = function () {\n\t\tconsole.error('THREE.Matrix4: .rotateByAxis() has been removed.');\n\t};\n\n\tMatrix4.prototype.applyToBufferAttribute = function (attribute) {\n\t\tconsole.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');\n\t\treturn attribute.applyMatrix4(this);\n\t};\n\n\tMatrix4.prototype.applyToVector3Array = function ()\n\t/* array, offset, length */\n\t{\n\t\tconsole.error('THREE.Matrix4: .applyToVector3Array() has been removed.');\n\t};\n\n\tMatrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {\n\t\tconsole.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');\n\t\treturn this.makePerspective(left, right, top, bottom, near, far);\n\t};\n\n\tMatrix4.prototype.getInverse = function (matrix) {\n\t\tconsole.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');\n\t\treturn this.copy(matrix).invert();\n\t}; //\n\n\n\tPlane.prototype.isIntersectionLine = function (line) {\n\t\tconsole.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');\n\t\treturn this.intersectsLine(line);\n\t}; //\n\n\n\tQuaternion.prototype.multiplyVector3 = function (vector) {\n\t\tconsole.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');\n\t\treturn vector.applyQuaternion(this);\n\t};\n\n\tQuaternion.prototype.inverse = function () {\n\t\tconsole.warn('THREE.Quaternion: .inverse() has been renamed to invert().');\n\t\treturn this.invert();\n\t}; //\n\n\n\tRay.prototype.isIntersectionBox = function (box) {\n\t\tconsole.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');\n\t\treturn this.intersectsBox(box);\n\t};\n\n\tRay.prototype.isIntersectionPlane = function (plane) {\n\t\tconsole.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');\n\t\treturn this.intersectsPlane(plane);\n\t};\n\n\tRay.prototype.isIntersectionSphere = function (sphere) {\n\t\tconsole.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');\n\t\treturn this.intersectsSphere(sphere);\n\t}; //\n\n\n\tTriangle.prototype.area = function () {\n\t\tconsole.warn('THREE.Triangle: .area() has been renamed to .getArea().');\n\t\treturn this.getArea();\n\t};\n\n\tTriangle.prototype.barycoordFromPoint = function (point, target) {\n\t\tconsole.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');\n\t\treturn this.getBarycoord(point, target);\n\t};\n\n\tTriangle.prototype.midpoint = function (target) {\n\t\tconsole.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');\n\t\treturn this.getMidpoint(target);\n\t};\n\n\tTriangle.prototypenormal = function (target) {\n\t\tconsole.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');\n\t\treturn this.getNormal(target);\n\t};\n\n\tTriangle.prototype.plane = function (target) {\n\t\tconsole.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');\n\t\treturn this.getPlane(target);\n\t};\n\n\tTriangle.barycoordFromPoint = function (point, a, b, c, target) {\n\t\tconsole.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');\n\t\treturn Triangle.getBarycoord(point, a, b, c, target);\n\t};\n\n\tTriangle.normal = function (a, b, c, target) {\n\t\tconsole.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');\n\t\treturn Triangle.getNormal(a, b, c, target);\n\t}; //\n\n\n\tShape.prototype.extractAllPoints = function (divisions) {\n\t\tconsole.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');\n\t\treturn this.extractPoints(divisions);\n\t};\n\n\tShape.prototype.extrude = function (options) {\n\t\tconsole.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');\n\t\treturn new ExtrudeGeometry(this, options);\n\t};\n\n\tShape.prototype.makeGeometry = function (options) {\n\t\tconsole.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');\n\t\treturn new ShapeGeometry(this, options);\n\t}; //\n\n\n\tVector2.prototype.fromAttribute = function (attribute, index, offset) {\n\t\tconsole.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');\n\t\treturn this.fromBufferAttribute(attribute, index, offset);\n\t};\n\n\tVector2.prototype.distanceToManhattan = function (v) {\n\t\tconsole.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');\n\t\treturn this.manhattanDistanceTo(v);\n\t};\n\n\tVector2.prototype.lengthManhattan = function () {\n\t\tconsole.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');\n\t\treturn this.manhattanLength();\n\t}; //\n\n\n\tVector3.prototype.setEulerFromRotationMatrix = function () {\n\t\tconsole.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');\n\t};\n\n\tVector3.prototype.setEulerFromQuaternion = function () {\n\t\tconsole.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');\n\t};\n\n\tVector3.prototype.getPositionFromMatrix = function (m) {\n\t\tconsole.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');\n\t\treturn this.setFromMatrixPosition(m);\n\t};\n\n\tVector3.prototype.getScaleFromMatrix = function (m) {\n\t\tconsole.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');\n\t\treturn this.setFromMatrixScale(m);\n\t};\n\n\tVector3.prototype.getColumnFromMatrix = function (index, matrix) {\n\t\tconsole.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');\n\t\treturn this.setFromMatrixColumn(matrix, index);\n\t};\n\n\tVector3.prototype.applyProjection = function (m) {\n\t\tconsole.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');\n\t\treturn this.applyMatrix4(m);\n\t};\n\n\tVector3.prototype.fromAttribute = function (attribute, index, offset) {\n\t\tconsole.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');\n\t\treturn this.fromBufferAttribute(attribute, index, offset);\n\t};\n\n\tVector3.prototype.distanceToManhattan = function (v) {\n\t\tconsole.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');\n\t\treturn this.manhattanDistanceTo(v);\n\t};\n\n\tVector3.prototype.lengthManhattan = function () {\n\t\tconsole.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');\n\t\treturn this.manhattanLength();\n\t}; //\n\n\n\tVector4.prototype.fromAttribute = function (attribute, index, offset) {\n\t\tconsole.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');\n\t\treturn this.fromBufferAttribute(attribute, index, offset);\n\t};\n\n\tVector4.prototype.lengthManhattan = function () {\n\t\tconsole.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');\n\t\treturn this.manhattanLength();\n\t}; //\n\n\n\tObject3D.prototype.getChildByName = function (name) {\n\t\tconsole.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');\n\t\treturn this.getObjectByName(name);\n\t};\n\n\tObject3D.prototype.renderDepth = function () {\n\t\tconsole.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');\n\t};\n\n\tObject3D.prototype.translate = function (distance, axis) {\n\t\tconsole.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');\n\t\treturn this.translateOnAxis(axis, distance);\n\t};\n\n\tObject3D.prototype.getWorldRotation = function () {\n\t\tconsole.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');\n\t};\n\n\tObject3D.prototype.applyMatrix = function (matrix) {\n\t\tconsole.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');\n\t\treturn this.applyMatrix4(matrix);\n\t};\n\n\tObject.defineProperties(Object3D.prototype, {\n\t\teulerOrder: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');\n\t\t\t\treturn this.rotation.order;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');\n\t\t\t\tthis.rotation.order = value;\n\t\t\t}\n\t\t},\n\t\tuseQuaternion: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');\n\t\t\t}\n\t\t}\n\t});\n\n\tMesh.prototype.setDrawMode = function () {\n\t\tconsole.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');\n\t};\n\n\tObject.defineProperties(Mesh.prototype, {\n\t\tdrawMode: {\n\t\t\tget: function () {\n\t\t\t\tconsole.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');\n\t\t\t\treturn TrianglesDrawMode;\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');\n\t\t\t}\n\t\t}\n\t});\n\n\tSkinnedMesh.prototype.initBones = function () {\n\t\tconsole.error('THREE.SkinnedMesh: initBones() has been removed.');\n\t}; //\n\n\n\tPerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {\n\t\tconsole.warn('THREE.PerspectiveCamera.setLens is deprecated. ' + 'Use .setFocalLength and .filmGauge for a photographic setup.');\n\t\tif (filmGauge !== undefined) this.filmGauge = filmGauge;\n\t\tthis.setFocalLength(focalLength);\n\t}; //\n\n\n\tObject.defineProperties(Light.prototype, {\n\t\tonlyShadow: {\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Light: .onlyShadow has been removed.');\n\t\t\t}\n\t\t},\n\t\tshadowCameraFov: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');\n\t\t\t\tthis.shadow.camera.fov = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraLeft: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');\n\t\t\t\tthis.shadow.camera.left = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraRight: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');\n\t\t\t\tthis.shadow.camera.right = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraTop: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');\n\t\t\t\tthis.shadow.camera.top = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraBottom: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');\n\t\t\t\tthis.shadow.camera.bottom = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraNear: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');\n\t\t\t\tthis.shadow.camera.near = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraFar: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');\n\t\t\t\tthis.shadow.camera.far = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraVisible: {\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');\n\t\t\t}\n\t\t},\n\t\tshadowBias: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowBias is now .shadow.bias.');\n\t\t\t\tthis.shadow.bias = value;\n\t\t\t}\n\t\t},\n\t\tshadowDarkness: {\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Light: .shadowDarkness has been removed.');\n\t\t\t}\n\t\t},\n\t\tshadowMapWidth: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');\n\t\t\t\tthis.shadow.mapSize.width = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapHeight: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');\n\t\t\t\tthis.shadow.mapSize.height = value;\n\t\t\t}\n\t\t}\n\t}); //\n\n\tObject.defineProperties(BufferAttribute.prototype, {\n\t\tlength: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');\n\t\t\t\treturn this.array.length;\n\t\t\t}\n\t\t},\n\t\tdynamic: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');\n\t\t\t\treturn this.usage === DynamicDrawUsage;\n\t\t\t},\n\t\t\tset: function ()\n\t\t\t/* value */\n\t\t\t{\n\t\t\t\tconsole.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');\n\t\t\t\tthis.setUsage(DynamicDrawUsage);\n\t\t\t}\n\t\t}\n\t});\n\n\tBufferAttribute.prototype.setDynamic = function (value) {\n\t\tconsole.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');\n\t\tthis.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);\n\t\treturn this;\n\t};\n\n\tBufferAttribute.prototype.copyIndicesArray = function ()\n\t/* indices */\n\t{\n\t\tconsole.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');\n\t}, BufferAttribute.prototype.setArray = function ()\n\t/* array */\n\t{\n\t\tconsole.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');\n\t}; //\n\n\tBufferGeometry.prototype.addIndex = function (index) {\n\t\tconsole.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');\n\t\tthis.setIndex(index);\n\t};\n\n\tBufferGeometry.prototype.addAttribute = function (name, attribute) {\n\t\tconsole.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');\n\n\t\tif (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {\n\t\t\tconsole.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');\n\t\t\treturn this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));\n\t\t}\n\n\t\tif (name === 'index') {\n\t\t\tconsole.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');\n\t\t\tthis.setIndex(attribute);\n\t\t\treturn this;\n\t\t}\n\n\t\treturn this.setAttribute(name, attribute);\n\t};\n\n\tBufferGeometry.prototype.addDrawCall = function (start, count, indexOffset) {\n\t\tif (indexOffset !== undefined) {\n\t\t\tconsole.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');\n\t\t}\n\n\t\tconsole.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');\n\t\tthis.addGroup(start, count);\n\t};\n\n\tBufferGeometry.prototype.clearDrawCalls = function () {\n\t\tconsole.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');\n\t\tthis.clearGroups();\n\t};\n\n\tBufferGeometry.prototype.computeOffsets = function () {\n\t\tconsole.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');\n\t};\n\n\tBufferGeometry.prototype.removeAttribute = function (name) {\n\t\tconsole.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');\n\t\treturn this.deleteAttribute(name);\n\t};\n\n\tBufferGeometry.prototype.applyMatrix = function (matrix) {\n\t\tconsole.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');\n\t\treturn this.applyMatrix4(matrix);\n\t};\n\n\tObject.defineProperties(BufferGeometry.prototype, {\n\t\tdrawcalls: {\n\t\t\tget: function () {\n\t\t\t\tconsole.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t},\n\t\toffsets: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t}\n\t});\n\n\tInterleavedBuffer.prototype.setDynamic = function (value) {\n\t\tconsole.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');\n\t\tthis.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);\n\t\treturn this;\n\t};\n\n\tInterleavedBuffer.prototype.setArray = function ()\n\t/* array */\n\t{\n\t\tconsole.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');\n\t}; //\n\n\n\tExtrudeGeometry.prototype.getArrays = function () {\n\t\tconsole.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');\n\t};\n\n\tExtrudeGeometry.prototype.addShapeList = function () {\n\t\tconsole.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');\n\t};\n\n\tExtrudeGeometry.prototype.addShape = function () {\n\t\tconsole.error('THREE.ExtrudeGeometry: .addShape() has been removed.');\n\t}; //\n\n\n\tScene.prototype.dispose = function () {\n\t\tconsole.error('THREE.Scene: .dispose() has been removed.');\n\t}; //\n\n\n\tUniform.prototype.onUpdate = function () {\n\t\tconsole.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');\n\t\treturn this;\n\t}; //\n\n\n\tObject.defineProperties(Material.prototype, {\n\t\twrapAround: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.Material: .wrapAround has been removed.');\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Material: .wrapAround has been removed.');\n\t\t\t}\n\t\t},\n\t\toverdraw: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.Material: .overdraw has been removed.');\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Material: .overdraw has been removed.');\n\t\t\t}\n\t\t},\n\t\twrapRGB: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.Material: .wrapRGB has been removed.');\n\t\t\t\treturn new Color();\n\t\t\t}\n\t\t},\n\t\tshading: {\n\t\t\tget: function () {\n\t\t\t\tconsole.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');\n\t\t\t\tthis.flatShading = value === FlatShading;\n\t\t\t}\n\t\t},\n\t\tstencilMask: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');\n\t\t\t\treturn this.stencilFuncMask;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');\n\t\t\t\tthis.stencilFuncMask = value;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperties(ShaderMaterial.prototype, {\n\t\tderivatives: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');\n\t\t\t\treturn this.extensions.derivatives;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');\n\t\t\t\tthis.extensions.derivatives = value;\n\t\t\t}\n\t\t}\n\t}); //\n\n\tWebGLRenderer.prototype.clearTarget = function (renderTarget, color, depth, stencil) {\n\t\tconsole.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');\n\t\tthis.setRenderTarget(renderTarget);\n\t\tthis.clear(color, depth, stencil);\n\t};\n\n\tWebGLRenderer.prototype.animate = function (callback) {\n\t\tconsole.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');\n\t\tthis.setAnimationLoop(callback);\n\t};\n\n\tWebGLRenderer.prototype.getCurrentRenderTarget = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');\n\t\treturn this.getRenderTarget();\n\t};\n\n\tWebGLRenderer.prototype.getMaxAnisotropy = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');\n\t\treturn this.capabilities.getMaxAnisotropy();\n\t};\n\n\tWebGLRenderer.prototype.getPrecision = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');\n\t\treturn this.capabilities.precision;\n\t};\n\n\tWebGLRenderer.prototype.resetGLState = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');\n\t\treturn this.state.reset();\n\t};\n\n\tWebGLRenderer.prototype.supportsFloatTextures = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).');\n\t\treturn this.extensions.get('OES_texture_float');\n\t};\n\n\tWebGLRenderer.prototype.supportsHalfFloatTextures = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).');\n\t\treturn this.extensions.get('OES_texture_half_float');\n\t};\n\n\tWebGLRenderer.prototype.supportsStandardDerivatives = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).');\n\t\treturn this.extensions.get('OES_standard_derivatives');\n\t};\n\n\tWebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).');\n\t\treturn this.extensions.get('WEBGL_compressed_texture_s3tc');\n\t};\n\n\tWebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).');\n\t\treturn this.extensions.get('WEBGL_compressed_texture_pvrtc');\n\t};\n\n\tWebGLRenderer.prototype.supportsBlendMinMax = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).');\n\t\treturn this.extensions.get('EXT_blend_minmax');\n\t};\n\n\tWebGLRenderer.prototype.supportsVertexTextures = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');\n\t\treturn this.capabilities.vertexTextures;\n\t};\n\n\tWebGLRenderer.prototype.supportsInstancedArrays = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).');\n\t\treturn this.extensions.get('ANGLE_instanced_arrays');\n\t};\n\n\tWebGLRenderer.prototype.enableScissorTest = function (boolean) {\n\t\tconsole.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');\n\t\tthis.setScissorTest(boolean);\n\t};\n\n\tWebGLRenderer.prototype.initMaterial = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.addPrePlugin = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.addPostPlugin = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.updateShadowMap = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.setFaceCulling = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.allocTextureUnit = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.setTexture = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .setTexture() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.setTexture2D = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.setTextureCube = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.getActiveMipMapLevel = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');\n\t\treturn this.getActiveMipmapLevel();\n\t};\n\n\tObject.defineProperties(WebGLRenderer.prototype, {\n\t\tshadowMapEnabled: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.enabled;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');\n\t\t\t\tthis.shadowMap.enabled = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapType: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.type;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');\n\t\t\t\tthis.shadowMap.type = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapCullFace: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');\n\t\t\t\treturn undefined;\n\t\t\t},\n\t\t\tset: function ()\n\t\t\t/* value */\n\t\t\t{\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');\n\t\t\t}\n\t\t},\n\t\tcontext: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');\n\t\t\t\treturn this.getContext();\n\t\t\t}\n\t\t},\n\t\tvr: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');\n\t\t\t\treturn this.xr;\n\t\t\t}\n\t\t},\n\t\tgammaInput: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');\n\t\t\t}\n\t\t},\n\t\tgammaOutput: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');\n\t\t\t\tthis.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;\n\t\t\t}\n\t\t},\n\t\ttoneMappingWhitePoint: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');\n\t\t\t\treturn 1.0;\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperties(WebGLShadowMap.prototype, {\n\t\tcullFace: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');\n\t\t\t\treturn undefined;\n\t\t\t},\n\t\t\tset: function ()\n\t\t\t/* cullFace */\n\t\t\t{\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');\n\t\t\t}\n\t\t},\n\t\trenderReverseSided: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');\n\t\t\t\treturn undefined;\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');\n\t\t\t}\n\t\t},\n\t\trenderSingleSided: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');\n\t\t\t\treturn undefined;\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');\n\t\t\t}\n\t\t}\n\t});\n\tfunction WebGLRenderTargetCube(width, height, options) {\n\t\tconsole.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');\n\t\treturn new WebGLCubeRenderTarget(width, options);\n\t} //\n\n\tObject.defineProperties(WebGLRenderTarget.prototype, {\n\t\twrapS: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');\n\t\t\t\treturn this.texture.wrapS;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');\n\t\t\t\tthis.texture.wrapS = value;\n\t\t\t}\n\t\t},\n\t\twrapT: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');\n\t\t\t\treturn this.texture.wrapT;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');\n\t\t\t\tthis.texture.wrapT = value;\n\t\t\t}\n\t\t},\n\t\tmagFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');\n\t\t\t\treturn this.texture.magFilter;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');\n\t\t\t\tthis.texture.magFilter = value;\n\t\t\t}\n\t\t},\n\t\tminFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');\n\t\t\t\treturn this.texture.minFilter;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');\n\t\t\t\tthis.texture.minFilter = value;\n\t\t\t}\n\t\t},\n\t\tanisotropy: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');\n\t\t\t\treturn this.texture.anisotropy;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');\n\t\t\t\tthis.texture.anisotropy = value;\n\t\t\t}\n\t\t},\n\t\toffset: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');\n\t\t\t\treturn this.texture.offset;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');\n\t\t\t\tthis.texture.offset = value;\n\t\t\t}\n\t\t},\n\t\trepeat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');\n\t\t\t\treturn this.texture.repeat;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');\n\t\t\t\tthis.texture.repeat = value;\n\t\t\t}\n\t\t},\n\t\tformat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');\n\t\t\t\treturn this.texture.format;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');\n\t\t\t\tthis.texture.format = value;\n\t\t\t}\n\t\t},\n\t\ttype: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');\n\t\t\t\treturn this.texture.type;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');\n\t\t\t\tthis.texture.type = value;\n\t\t\t}\n\t\t},\n\t\tgenerateMipmaps: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');\n\t\t\t\treturn this.texture.generateMipmaps;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');\n\t\t\t\tthis.texture.generateMipmaps = value;\n\t\t\t}\n\t\t}\n\t}); //\n\n\tAudio.prototype.load = function (file) {\n\t\tconsole.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');\n\t\tconst scope = this;\n\t\tconst audioLoader = new AudioLoader();\n\t\taudioLoader.load(file, function (buffer) {\n\t\t\tscope.setBuffer(buffer);\n\t\t});\n\t\treturn this;\n\t};\n\n\tAudioAnalyser.prototype.getData = function () {\n\t\tconsole.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');\n\t\treturn this.getFrequencyData();\n\t}; //\n\n\n\tCubeCamera.prototype.updateCubeMap = function (renderer, scene) {\n\t\tconsole.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');\n\t\treturn this.update(renderer, scene);\n\t};\n\n\tCubeCamera.prototype.clear = function (renderer, color, depth, stencil) {\n\t\tconsole.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');\n\t\treturn this.renderTarget.clear(renderer, color, depth, stencil);\n\t};\n\n\tImageUtils.crossOrigin = undefined;\n\n\tImageUtils.loadTexture = function (url, mapping, onLoad, onError) {\n\t\tconsole.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');\n\t\tconst loader = new TextureLoader();\n\t\tloader.setCrossOrigin(this.crossOrigin);\n\t\tconst texture = loader.load(url, onLoad, undefined, onError);\n\t\tif (mapping) texture.mapping = mapping;\n\t\treturn texture;\n\t};\n\n\tImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {\n\t\tconsole.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');\n\t\tconst loader = new CubeTextureLoader();\n\t\tloader.setCrossOrigin(this.crossOrigin);\n\t\tconst texture = loader.load(urls, onLoad, undefined, onError);\n\t\tif (mapping) texture.mapping = mapping;\n\t\treturn texture;\n\t};\n\n\tImageUtils.loadCompressedTexture = function () {\n\t\tconsole.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');\n\t};\n\n\tImageUtils.loadCompressedTextureCube = function () {\n\t\tconsole.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');\n\t}; //\n\n\n\tfunction CanvasRenderer() {\n\t\tconsole.error('THREE.CanvasRenderer has been removed');\n\t} //\n\n\tfunction JSONLoader() {\n\t\tconsole.error('THREE.JSONLoader has been removed.');\n\t} //\n\n\tconst SceneUtils = {\n\t\tcreateMultiMaterialObject: function ()\n\t\t/* geometry, materials */\n\t\t{\n\t\t\tconsole.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');\n\t\t},\n\t\tdetach: function ()\n\t\t/* child, parent, scene */\n\t\t{\n\t\t\tconsole.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');\n\t\t},\n\t\tattach: function ()\n\t\t/* child, scene, parent */\n\t\t{\n\t\t\tconsole.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');\n\t\t}\n\t}; //\n\n\tfunction LensFlare() {\n\t\tconsole.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');\n\t}\n\n\tif (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n\t\t/* eslint-disable no-undef */\n\t\t__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {\n\t\t\tdetail: {\n\t\t\t\trevision: REVISION\n\t\t\t}\n\t\t}));\n\t\t/* eslint-enable no-undef */\n\n\t}\n\n\tif (typeof window !== 'undefined') {\n\t\tif (window.__THREE__) {\n\t\t\tconsole.warn('WARNING: Multiple instances of Three.js being imported.');\n\t\t} else {\n\t\t\twindow.__THREE__ = REVISION;\n\t\t}\n\t}\n\n\texports.ACESFilmicToneMapping = ACESFilmicToneMapping;\n\texports.AddEquation = AddEquation;\n\texports.AddOperation = AddOperation;\n\texports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;\n\texports.AdditiveBlending = AdditiveBlending;\n\texports.AlphaFormat = AlphaFormat;\n\texports.AlwaysDepth = AlwaysDepth;\n\texports.AlwaysStencilFunc = AlwaysStencilFunc;\n\texports.AmbientLight = AmbientLight;\n\texports.AmbientLightProbe = AmbientLightProbe;\n\texports.AnimationClip = AnimationClip;\n\texports.AnimationLoader = AnimationLoader;\n\texports.AnimationMixer = AnimationMixer;\n\texports.AnimationObjectGroup = AnimationObjectGroup;\n\texports.AnimationUtils = AnimationUtils;\n\texports.ArcCurve = ArcCurve;\n\texports.ArrayCamera = ArrayCamera;\n\texports.ArrowHelper = ArrowHelper;\n\texports.Audio = Audio;\n\texports.AudioAnalyser = AudioAnalyser;\n\texports.AudioContext = AudioContext;\n\texports.AudioListener = AudioListener;\n\texports.AudioLoader = AudioLoader;\n\texports.AxesHelper = AxesHelper;\n\texports.AxisHelper = AxisHelper;\n\texports.BackSide = BackSide;\n\texports.BasicDepthPacking = BasicDepthPacking;\n\texports.BasicShadowMap = BasicShadowMap;\n\texports.BinaryTextureLoader = BinaryTextureLoader;\n\texports.Bone = Bone;\n\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\n\texports.BoundingBoxHelper = BoundingBoxHelper;\n\texports.Box2 = Box2;\n\texports.Box3 = Box3;\n\texports.Box3Helper = Box3Helper;\n\texports.BoxBufferGeometry = BoxGeometry;\n\texports.BoxGeometry = BoxGeometry;\n\texports.BoxHelper = BoxHelper;\n\texports.BufferAttribute = BufferAttribute;\n\texports.BufferGeometry = BufferGeometry;\n\texports.BufferGeometryLoader = BufferGeometryLoader;\n\texports.ByteType = ByteType;\n\texports.Cache = Cache;\n\texports.Camera = Camera;\n\texports.CameraHelper = CameraHelper;\n\texports.CanvasRenderer = CanvasRenderer;\n\texports.CanvasTexture = CanvasTexture;\n\texports.CatmullRomCurve3 = CatmullRomCurve3;\n\texports.CineonToneMapping = CineonToneMapping;\n\texports.CircleBufferGeometry = CircleGeometry;\n\texports.CircleGeometry = CircleGeometry;\n\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\n\texports.Clock = Clock;\n\texports.Color = Color;\n\texports.ColorKeyframeTrack = ColorKeyframeTrack;\n\texports.CompressedTexture = CompressedTexture;\n\texports.CompressedTextureLoader = CompressedTextureLoader;\n\texports.ConeBufferGeometry = ConeGeometry;\n\texports.ConeGeometry = ConeGeometry;\n\texports.CubeCamera = CubeCamera;\n\texports.CubeReflectionMapping = CubeReflectionMapping;\n\texports.CubeRefractionMapping = CubeRefractionMapping;\n\texports.CubeTexture = CubeTexture;\n\texports.CubeTextureLoader = CubeTextureLoader;\n\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\n\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\n\texports.CubicBezierCurve = CubicBezierCurve;\n\texports.CubicBezierCurve3 = CubicBezierCurve3;\n\texports.CubicInterpolant = CubicInterpolant;\n\texports.CullFaceBack = CullFaceBack;\n\texports.CullFaceFront = CullFaceFront;\n\texports.CullFaceFrontBack = CullFaceFrontBack;\n\texports.CullFaceNone = CullFaceNone;\n\texports.Curve = Curve;\n\texports.CurvePath = CurvePath;\n\texports.CustomBlending = CustomBlending;\n\texports.CustomToneMapping = CustomToneMapping;\n\texports.CylinderBufferGeometry = CylinderGeometry;\n\texports.CylinderGeometry = CylinderGeometry;\n\texports.Cylindrical = Cylindrical;\n\texports.DataTexture = DataTexture;\n\texports.DataTexture2DArray = DataTexture2DArray;\n\texports.DataTexture3D = DataTexture3D;\n\texports.DataTextureLoader = DataTextureLoader;\n\texports.DataUtils = DataUtils;\n\texports.DecrementStencilOp = DecrementStencilOp;\n\texports.DecrementWrapStencilOp = DecrementWrapStencilOp;\n\texports.DefaultLoadingManager = DefaultLoadingManager;\n\texports.DepthFormat = DepthFormat;\n\texports.DepthStencilFormat = DepthStencilFormat;\n\texports.DepthTexture = DepthTexture;\n\texports.DirectionalLight = DirectionalLight;\n\texports.DirectionalLightHelper = DirectionalLightHelper;\n\texports.DiscreteInterpolant = DiscreteInterpolant;\n\texports.DodecahedronBufferGeometry = DodecahedronGeometry;\n\texports.DodecahedronGeometry = DodecahedronGeometry;\n\texports.DoubleSide = DoubleSide;\n\texports.DstAlphaFactor = DstAlphaFactor;\n\texports.DstColorFactor = DstColorFactor;\n\texports.DynamicBufferAttribute = DynamicBufferAttribute;\n\texports.DynamicCopyUsage = DynamicCopyUsage;\n\texports.DynamicDrawUsage = DynamicDrawUsage;\n\texports.DynamicReadUsage = DynamicReadUsage;\n\texports.EdgesGeometry = EdgesGeometry;\n\texports.EdgesHelper = EdgesHelper;\n\texports.EllipseCurve = EllipseCurve;\n\texports.EqualDepth = EqualDepth;\n\texports.EqualStencilFunc = EqualStencilFunc;\n\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\n\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\n\texports.Euler = Euler;\n\texports.EventDispatcher = EventDispatcher;\n\texports.ExtrudeBufferGeometry = ExtrudeGeometry;\n\texports.ExtrudeGeometry = ExtrudeGeometry;\n\texports.FaceColors = FaceColors;\n\texports.FileLoader = FileLoader;\n\texports.FlatShading = FlatShading;\n\texports.Float16BufferAttribute = Float16BufferAttribute;\n\texports.Float32Attribute = Float32Attribute;\n\texports.Float32BufferAttribute = Float32BufferAttribute;\n\texports.Float64Attribute = Float64Attribute;\n\texports.Float64BufferAttribute = Float64BufferAttribute;\n\texports.FloatType = FloatType;\n\texports.Fog = Fog;\n\texports.FogExp2 = FogExp2;\n\texports.Font = Font;\n\texports.FontLoader = FontLoader;\n\texports.FrontSide = FrontSide;\n\texports.Frustum = Frustum;\n\texports.GLBufferAttribute = GLBufferAttribute;\n\texports.GLSL1 = GLSL1;\n\texports.GLSL3 = GLSL3;\n\texports.GammaEncoding = GammaEncoding;\n\texports.GreaterDepth = GreaterDepth;\n\texports.GreaterEqualDepth = GreaterEqualDepth;\n\texports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;\n\texports.GreaterStencilFunc = GreaterStencilFunc;\n\texports.GridHelper = GridHelper;\n\texports.Group = Group;\n\texports.HalfFloatType = HalfFloatType;\n\texports.HemisphereLight = HemisphereLight;\n\texports.HemisphereLightHelper = HemisphereLightHelper;\n\texports.HemisphereLightProbe = HemisphereLightProbe;\n\texports.IcosahedronBufferGeometry = IcosahedronGeometry;\n\texports.IcosahedronGeometry = IcosahedronGeometry;\n\texports.ImageBitmapLoader = ImageBitmapLoader;\n\texports.ImageLoader = ImageLoader;\n\texports.ImageUtils = ImageUtils;\n\texports.ImmediateRenderObject = ImmediateRenderObject;\n\texports.IncrementStencilOp = IncrementStencilOp;\n\texports.IncrementWrapStencilOp = IncrementWrapStencilOp;\n\texports.InstancedBufferAttribute = InstancedBufferAttribute;\n\texports.InstancedBufferGeometry = InstancedBufferGeometry;\n\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\n\texports.InstancedMesh = InstancedMesh;\n\texports.Int16Attribute = Int16Attribute;\n\texports.Int16BufferAttribute = Int16BufferAttribute;\n\texports.Int32Attribute = Int32Attribute;\n\texports.Int32BufferAttribute = Int32BufferAttribute;\n\texports.Int8Attribute = Int8Attribute;\n\texports.Int8BufferAttribute = Int8BufferAttribute;\n\texports.IntType = IntType;\n\texports.InterleavedBuffer = InterleavedBuffer;\n\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\n\texports.Interpolant = Interpolant;\n\texports.InterpolateDiscrete = InterpolateDiscrete;\n\texports.InterpolateLinear = InterpolateLinear;\n\texports.InterpolateSmooth = InterpolateSmooth;\n\texports.InvertStencilOp = InvertStencilOp;\n\texports.JSONLoader = JSONLoader;\n\texports.KeepStencilOp = KeepStencilOp;\n\texports.KeyframeTrack = KeyframeTrack;\n\texports.LOD = LOD;\n\texports.LatheBufferGeometry = LatheGeometry;\n\texports.LatheGeometry = LatheGeometry;\n\texports.Layers = Layers;\n\texports.LensFlare = LensFlare;\n\texports.LessDepth = LessDepth;\n\texports.LessEqualDepth = LessEqualDepth;\n\texports.LessEqualStencilFunc = LessEqualStencilFunc;\n\texports.LessStencilFunc = LessStencilFunc;\n\texports.Light = Light;\n\texports.LightProbe = LightProbe;\n\texports.Line = Line;\n\texports.Line3 = Line3;\n\texports.LineBasicMaterial = LineBasicMaterial;\n\texports.LineCurve = LineCurve;\n\texports.LineCurve3 = LineCurve3;\n\texports.LineDashedMaterial = LineDashedMaterial;\n\texports.LineLoop = LineLoop;\n\texports.LinePieces = LinePieces;\n\texports.LineSegments = LineSegments;\n\texports.LineStrip = LineStrip;\n\texports.LinearEncoding = LinearEncoding;\n\texports.LinearFilter = LinearFilter;\n\texports.LinearInterpolant = LinearInterpolant;\n\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\n\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\n\texports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;\n\texports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;\n\texports.LinearToneMapping = LinearToneMapping;\n\texports.Loader = Loader;\n\texports.LoaderUtils = LoaderUtils;\n\texports.LoadingManager = LoadingManager;\n\texports.LogLuvEncoding = LogLuvEncoding;\n\texports.LoopOnce = LoopOnce;\n\texports.LoopPingPong = LoopPingPong;\n\texports.LoopRepeat = LoopRepeat;\n\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\n\texports.LuminanceFormat = LuminanceFormat;\n\texports.MOUSE = MOUSE;\n\texports.Material = Material;\n\texports.MaterialLoader = MaterialLoader;\n\texports.Math = MathUtils;\n\texports.MathUtils = MathUtils;\n\texports.Matrix3 = Matrix3;\n\texports.Matrix4 = Matrix4;\n\texports.MaxEquation = MaxEquation;\n\texports.Mesh = Mesh;\n\texports.MeshBasicMaterial = MeshBasicMaterial;\n\texports.MeshDepthMaterial = MeshDepthMaterial;\n\texports.MeshDistanceMaterial = MeshDistanceMaterial;\n\texports.MeshFaceMaterial = MeshFaceMaterial;\n\texports.MeshLambertMaterial = MeshLambertMaterial;\n\texports.MeshMatcapMaterial = MeshMatcapMaterial;\n\texports.MeshNormalMaterial = MeshNormalMaterial;\n\texports.MeshPhongMaterial = MeshPhongMaterial;\n\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\n\texports.MeshStandardMaterial = MeshStandardMaterial;\n\texports.MeshToonMaterial = MeshToonMaterial;\n\texports.MinEquation = MinEquation;\n\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\n\texports.MixOperation = MixOperation;\n\texports.MultiMaterial = MultiMaterial;\n\texports.MultiplyBlending = MultiplyBlending;\n\texports.MultiplyOperation = MultiplyOperation;\n\texports.NearestFilter = NearestFilter;\n\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\n\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\n\texports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;\n\texports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;\n\texports.NeverDepth = NeverDepth;\n\texports.NeverStencilFunc = NeverStencilFunc;\n\texports.NoBlending = NoBlending;\n\texports.NoColors = NoColors;\n\texports.NoToneMapping = NoToneMapping;\n\texports.NormalAnimationBlendMode = NormalAnimationBlendMode;\n\texports.NormalBlending = NormalBlending;\n\texports.NotEqualDepth = NotEqualDepth;\n\texports.NotEqualStencilFunc = NotEqualStencilFunc;\n\texports.NumberKeyframeTrack = NumberKeyframeTrack;\n\texports.Object3D = Object3D;\n\texports.ObjectLoader = ObjectLoader;\n\texports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;\n\texports.OctahedronBufferGeometry = OctahedronGeometry;\n\texports.OctahedronGeometry = OctahedronGeometry;\n\texports.OneFactor = OneFactor;\n\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\n\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\n\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\n\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\n\texports.OrthographicCamera = OrthographicCamera;\n\texports.PCFShadowMap = PCFShadowMap;\n\texports.PCFSoftShadowMap = PCFSoftShadowMap;\n\texports.PMREMGenerator = PMREMGenerator;\n\texports.ParametricBufferGeometry = ParametricGeometry;\n\texports.ParametricGeometry = ParametricGeometry;\n\texports.Particle = Particle;\n\texports.ParticleBasicMaterial = ParticleBasicMaterial;\n\texports.ParticleSystem = ParticleSystem;\n\texports.ParticleSystemMaterial = ParticleSystemMaterial;\n\texports.Path = Path;\n\texports.PerspectiveCamera = PerspectiveCamera;\n\texports.Plane = Plane;\n\texports.PlaneBufferGeometry = PlaneGeometry;\n\texports.PlaneGeometry = PlaneGeometry;\n\texports.PlaneHelper = PlaneHelper;\n\texports.PointCloud = PointCloud;\n\texports.PointCloudMaterial = PointCloudMaterial;\n\texports.PointLight = PointLight;\n\texports.PointLightHelper = PointLightHelper;\n\texports.Points = Points;\n\texports.PointsMaterial = PointsMaterial;\n\texports.PolarGridHelper = PolarGridHelper;\n\texports.PolyhedronBufferGeometry = PolyhedronGeometry;\n\texports.PolyhedronGeometry = PolyhedronGeometry;\n\texports.PositionalAudio = PositionalAudio;\n\texports.PropertyBinding = PropertyBinding;\n\texports.PropertyMixer = PropertyMixer;\n\texports.QuadraticBezierCurve = QuadraticBezierCurve;\n\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\n\texports.Quaternion = Quaternion;\n\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\n\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\n\texports.REVISION = REVISION;\n\texports.RGBADepthPacking = RGBADepthPacking;\n\texports.RGBAFormat = RGBAFormat;\n\texports.RGBAIntegerFormat = RGBAIntegerFormat;\n\texports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;\n\texports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;\n\texports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;\n\texports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;\n\texports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;\n\texports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;\n\texports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;\n\texports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;\n\texports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;\n\texports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;\n\texports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;\n\texports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;\n\texports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;\n\texports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;\n\texports.RGBA_BPTC_Format = RGBA_BPTC_Format;\n\texports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;\n\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\n\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\n\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\n\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\n\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\n\texports.RGBDEncoding = RGBDEncoding;\n\texports.RGBEEncoding = RGBEEncoding;\n\texports.RGBEFormat = RGBEFormat;\n\texports.RGBFormat = RGBFormat;\n\texports.RGBIntegerFormat = RGBIntegerFormat;\n\texports.RGBM16Encoding = RGBM16Encoding;\n\texports.RGBM7Encoding = RGBM7Encoding;\n\texports.RGB_ETC1_Format = RGB_ETC1_Format;\n\texports.RGB_ETC2_Format = RGB_ETC2_Format;\n\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\n\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\n\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\n\texports.RGFormat = RGFormat;\n\texports.RGIntegerFormat = RGIntegerFormat;\n\texports.RawShaderMaterial = RawShaderMaterial;\n\texports.Ray = Ray;\n\texports.Raycaster = Raycaster;\n\texports.RectAreaLight = RectAreaLight;\n\texports.RedFormat = RedFormat;\n\texports.RedIntegerFormat = RedIntegerFormat;\n\texports.ReinhardToneMapping = ReinhardToneMapping;\n\texports.RepeatWrapping = RepeatWrapping;\n\texports.ReplaceStencilOp = ReplaceStencilOp;\n\texports.ReverseSubtractEquation = ReverseSubtractEquation;\n\texports.RingBufferGeometry = RingGeometry;\n\texports.RingGeometry = RingGeometry;\n\texports.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;\n\texports.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;\n\texports.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;\n\texports.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;\n\texports.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;\n\texports.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;\n\texports.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;\n\texports.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;\n\texports.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;\n\texports.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;\n\texports.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;\n\texports.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;\n\texports.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;\n\texports.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;\n\texports.Scene = Scene;\n\texports.SceneUtils = SceneUtils;\n\texports.ShaderChunk = ShaderChunk;\n\texports.ShaderLib = ShaderLib;\n\texports.ShaderMaterial = ShaderMaterial;\n\texports.ShadowMaterial = ShadowMaterial;\n\texports.Shape = Shape;\n\texports.ShapeBufferGeometry = ShapeGeometry;\n\texports.ShapeGeometry = ShapeGeometry;\n\texports.ShapePath = ShapePath;\n\texports.ShapeUtils = ShapeUtils;\n\texports.ShortType = ShortType;\n\texports.Skeleton = Skeleton;\n\texports.SkeletonHelper = SkeletonHelper;\n\texports.SkinnedMesh = SkinnedMesh;\n\texports.SmoothShading = SmoothShading;\n\texports.Sphere = Sphere;\n\texports.SphereBufferGeometry = SphereGeometry;\n\texports.SphereGeometry = SphereGeometry;\n\texports.Spherical = Spherical;\n\texports.SphericalHarmonics3 = SphericalHarmonics3;\n\texports.SplineCurve = SplineCurve;\n\texports.SpotLight = SpotLight;\n\texports.SpotLightHelper = SpotLightHelper;\n\texports.Sprite = Sprite;\n\texports.SpriteMaterial = SpriteMaterial;\n\texports.SrcAlphaFactor = SrcAlphaFactor;\n\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\n\texports.SrcColorFactor = SrcColorFactor;\n\texports.StaticCopyUsage = StaticCopyUsage;\n\texports.StaticDrawUsage = StaticDrawUsage;\n\texports.StaticReadUsage = StaticReadUsage;\n\texports.StereoCamera = StereoCamera;\n\texports.StreamCopyUsage = StreamCopyUsage;\n\texports.StreamDrawUsage = StreamDrawUsage;\n\texports.StreamReadUsage = StreamReadUsage;\n\texports.StringKeyframeTrack = StringKeyframeTrack;\n\texports.SubtractEquation = SubtractEquation;\n\texports.SubtractiveBlending = SubtractiveBlending;\n\texports.TOUCH = TOUCH;\n\texports.TangentSpaceNormalMap = TangentSpaceNormalMap;\n\texports.TetrahedronBufferGeometry = TetrahedronGeometry;\n\texports.TetrahedronGeometry = TetrahedronGeometry;\n\texports.TextBufferGeometry = TextGeometry;\n\texports.TextGeometry = TextGeometry;\n\texports.Texture = Texture;\n\texports.TextureLoader = TextureLoader;\n\texports.TorusBufferGeometry = TorusGeometry;\n\texports.TorusGeometry = TorusGeometry;\n\texports.TorusKnotBufferGeometry = TorusKnotGeometry;\n\texports.TorusKnotGeometry = TorusKnotGeometry;\n\texports.Triangle = Triangle;\n\texports.TriangleFanDrawMode = TriangleFanDrawMode;\n\texports.TriangleStripDrawMode = TriangleStripDrawMode;\n\texports.TrianglesDrawMode = TrianglesDrawMode;\n\texports.TubeBufferGeometry = TubeGeometry;\n\texports.TubeGeometry = TubeGeometry;\n\texports.UVMapping = UVMapping;\n\texports.Uint16Attribute = Uint16Attribute;\n\texports.Uint16BufferAttribute = Uint16BufferAttribute;\n\texports.Uint32Attribute = Uint32Attribute;\n\texports.Uint32BufferAttribute = Uint32BufferAttribute;\n\texports.Uint8Attribute = Uint8Attribute;\n\texports.Uint8BufferAttribute = Uint8BufferAttribute;\n\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\n\texports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;\n\texports.Uniform = Uniform;\n\texports.UniformsLib = UniformsLib;\n\texports.UniformsUtils = UniformsUtils;\n\texports.UnsignedByteType = UnsignedByteType;\n\texports.UnsignedInt248Type = UnsignedInt248Type;\n\texports.UnsignedIntType = UnsignedIntType;\n\texports.UnsignedShort4444Type = UnsignedShort4444Type;\n\texports.UnsignedShort5551Type = UnsignedShort5551Type;\n\texports.UnsignedShort565Type = UnsignedShort565Type;\n\texports.UnsignedShortType = UnsignedShortType;\n\texports.VSMShadowMap = VSMShadowMap;\n\texports.Vector2 = Vector2;\n\texports.Vector3 = Vector3;\n\texports.Vector4 = Vector4;\n\texports.VectorKeyframeTrack = VectorKeyframeTrack;\n\texports.Vertex = Vertex;\n\texports.VertexColors = VertexColors;\n\texports.VideoTexture = VideoTexture;\n\texports.WebGL1Renderer = WebGL1Renderer;\n\texports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;\n\texports.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;\n\texports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;\n\texports.WebGLRenderTarget = WebGLRenderTarget;\n\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\n\texports.WebGLRenderer = WebGLRenderer;\n\texports.WebGLUtils = WebGLUtils;\n\texports.WireframeGeometry = WireframeGeometry;\n\texports.WireframeHelper = WireframeHelper;\n\texports.WrapAroundEnding = WrapAroundEnding;\n\texports.XHRLoader = XHRLoader;\n\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\n\texports.ZeroFactor = ZeroFactor;\n\texports.ZeroSlopeEnding = ZeroSlopeEnding;\n\texports.ZeroStencilOp = ZeroStencilOp;\n\texports.sRGBEncoding = sRGBEncoding;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n",null,"module.exports = function( THREE ) {\n\t/**\n\t * @author qiao / https://github.com/qiao\n\t * @author mrdoob / http://mrdoob.com\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author erich666 / http://erichaines.com\n\t */\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\n\tfunction OrbitControls( object, domElement ) {\n\n\t\tthis.object = object;\n\n\t\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t\t// Set to false to disable this control\n\t\tthis.enabled = true;\n\n\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\tthis.target = new THREE.Vector3();\n\n\t\t// How far you can dolly in and out ( PerspectiveCamera only )\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\n\t\t// How far you can zoom in and out ( OrthographicCamera only )\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t// Range is 0 to Math.PI radians.\n\t\tthis.minPolarAngle = 0; // radians\n\t\tthis.maxPolarAngle = Math.PI; // radians\n\n\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t\t// Set to true to enable damping (inertia)\n\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.25;\n\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t\t// Set to false to disable zooming\n\t\tthis.enableZoom = true;\n\t\tthis.zoomSpeed = 1.0;\n\n\t\t// Set to false to disable rotating\n\t\tthis.enableRotate = true;\n\t\tthis.rotateSpeed = 1.0;\n\n\t\t// Set to false to disable panning\n\t\tthis.enablePan = true;\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t\t// Set to true to automatically rotate around the target\n\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\tthis.autoRotate = false;\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t\t// Set to false to disable use of the keys\n\t\tthis.enableKeys = true;\n\n\t\t// The four arrow keys\n\t\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t\t// Mouse buttons\n\t\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\n\t\t// for reset\n\t\tthis.target0 = this.target.clone();\n\t\tthis.position0 = this.object.position.clone();\n\t\tthis.zoom0 = this.object.zoom;\n\n\t\t//\n\t\t// public methods\n\t\t//\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn spherical.phi;\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn spherical.theta;\n\n\t\t};\n\n\t\tthis.reset = function () {\n\n\t\t\tscope.target.copy( scope.target0 );\n\t\t\tscope.object.position.copy( scope.position0 );\n\t\t\tscope.object.zoom = scope.zoom0;\n\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tscope.dispatchEvent( changeEvent );\n\n\t\t\tscope.update();\n\n\t\t\tstate = STATE.NONE;\n\n\t\t};\n\n\t\t// this method is exposed, but perhaps it would be better if we can make it private...\n\t\tthis.update = function() {\n\n\t\t\tvar offset = new THREE.Vector3();\n\n\t\t\t// so camera.up is the orbit axis\n\t\t\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\n\t\t\tvar quatInverse = quat.clone().inverse();\n\n\t\t\tvar lastPosition = new THREE.Vector3();\n\t\t\tvar lastQuaternion = new THREE.Quaternion();\n\n\t\t\treturn function update () {\n\n\t\t\t\tvar position = scope.object.position;\n\n\t\t\t\toffset.copy( position ).sub( scope.target );\n\n\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t\t// angle from z-axis around y-axis\n\t\t\t\tspherical.setFromVector3( offset );\n\n\t\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\t\trotateLeft( getAutoRotationAngle() );\n\n\t\t\t\t}\n\n\t\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t\t// restrict theta to be between desired limits\n\t\t\t\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\n\n\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\n\t\t\t\tspherical.makeSafe();\n\n\n\t\t\t\tspherical.radius *= scale;\n\n\t\t\t\t// restrict radius to be between desired limits\n\t\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\n\n\t\t\t\t// move target to panned location\n\t\t\t\tscope.target.add( panOffset );\n\n\t\t\t\toffset.setFromSpherical( spherical );\n\n\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\t\tposition.copy( scope.target ).add( offset );\n\n\t\t\t\tscope.object.lookAt( scope.target );\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tscale = 1;\n\t\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t\t// update condition is:\n\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\n\n\t\t\t\t\tscope.dispatchEvent( changeEvent );\n\n\t\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\t\tzoomChanged = false;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t}();\n\n\t\tthis.dispose = function() {\n\n\t\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\n\t\t\tscope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\n\t\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\n\n\t\t\tscope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\n\t\t\tscope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\n\t\t\tscope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\n\n\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\twindow.removeEventListener( 'keydown', onKeyDown, false );\n\n\t\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n\t\t};\n\n\t\t//\n\t\t// internals\n\t\t//\n\n\t\tvar scope = this;\n\n\t\tvar changeEvent = { type: 'change' };\n\t\tvar startEvent = { type: 'start' };\n\t\tvar endEvent = { type: 'end' };\n\n\t\tvar STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\n\t\tvar state = STATE.NONE;\n\n\t\tvar EPS = 0.000001;\n\n\t\t// current position in spherical coordinates\n\t\tvar spherical = new THREE.Spherical();\n\t\tvar sphericalDelta = new THREE.Spherical();\n\n\t\tvar scale = 1;\n\t\tvar panOffset = new THREE.Vector3();\n\t\tvar zoomChanged = false;\n\n\t\tvar rotateStart = new THREE.Vector2();\n\t\tvar rotateEnd = new THREE.Vector2();\n\t\tvar rotateDelta = new THREE.Vector2();\n\n\t\tvar panStart = new THREE.Vector2();\n\t\tvar panEnd = new THREE.Vector2();\n\t\tvar panDelta = new THREE.Vector2();\n\n\t\tvar dollyStart = new THREE.Vector2();\n\t\tvar dollyEnd = new THREE.Vector2();\n\t\tvar dollyDelta = new THREE.Vector2();\n\n\t\tfunction getAutoRotationAngle() {\n\n\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t\t}\n\n\t\tfunction getZoomScale() {\n\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t\t}\n\n\t\tfunction rotateLeft( angle ) {\n\n\t\t\tsphericalDelta.theta -= angle;\n\n\t\t}\n\n\t\tfunction rotateUp( angle ) {\n\n\t\t\tsphericalDelta.phi -= angle;\n\n\t\t}\n\n\t\tvar panLeft = function() {\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\treturn function panLeft( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\t\tv.multiplyScalar( - distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\tvar panUp = function() {\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\treturn function panUp( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\n\t\t\t\tv.multiplyScalar( distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// deltaX and deltaY are in pixels; right and down are positive\n\t\tvar pan = function() {\n\n\t\t\tvar offset = new THREE.Vector3();\n\n\t\t\treturn function pan ( deltaX, deltaY ) {\n\n\t\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\t\t// perspective\n\t\t\t\t\tvar position = scope.object.position;\n\t\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\t\tvar targetDistance = offset.length();\n\n\t\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\t\t// orthographic\n\t\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\t\tscope.enablePan = false;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}();\n\n\t\tfunction dollyIn( dollyScale ) {\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tscale /= dollyScale;\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction dollyOut( dollyScale ) {\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tscale *= dollyScale;\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\t\t// event callbacks - update the object state\n\t\t//\n\n\t\tfunction handleMouseDownRotate( event ) {\n\n\t\t\t//console.log( 'handleMouseDownRotate' );\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownDolly( event ) {\n\n\t\t\t//console.log( 'handleMouseDownDolly' );\n\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownPan( event ) {\n\n\t\t\t//console.log( 'handleMouseDownPan' );\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseMoveRotate( event ) {\n\n\t\t\t//console.log( 'handleMouseMoveRotate' );\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMoveDolly( event ) {\n\n\t\t\t//console.log( 'handleMouseMoveDolly' );\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMovePan( event ) {\n\n\t\t\t//console.log( 'handleMouseMovePan' );\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseUp( event ) {\n\n\t\t\t//console.log( 'handleMouseUp' );\n\n\t\t}\n\n\t\tfunction handleMouseWheel( event ) {\n\n\t\t\t//console.log( 'handleMouseWheel' );\n\n\t\t\tif ( event.deltaY < 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleKeyDown( event ) {\n\n\t\t\t//console.log( 'handleKeyDown' );\n\n\t\t\tswitch ( event.keyCode ) {\n\n\t\t\t\tcase scope.keys.UP:\n\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartRotate( event ) {\n\n\t\t\t//console.log( 'handleTouchStartRotate' );\n\n\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t}\n\n\t\tfunction handleTouchStartDolly( event ) {\n\n\t\t\t//console.log( 'handleTouchStartDolly' );\n\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyStart.set( 0, distance );\n\n\t\t}\n\n\t\tfunction handleTouchStartPan( event ) {\n\n\t\t\t//console.log( 'handleTouchStartPan' );\n\n\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t}\n\n\t\tfunction handleTouchMoveRotate( event ) {\n\n\t\t\t//console.log( 'handleTouchMoveRotate' );\n\n\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleTouchMoveDolly( event ) {\n\n\t\t\t//console.log( 'handleTouchMoveDolly' );\n\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyEnd.set( 0, distance );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleTouchMovePan( event ) {\n\n\t\t\t//console.log( 'handleTouchMovePan' );\n\n\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleTouchEnd( event ) {\n\n\t\t\t//console.log( 'handleTouchEnd' );\n\n\t\t}\n\n\t\t//\n\t\t// event handlers - FSM: listen for events and reset state\n\t\t//\n\n\t\tfunction onMouseDown( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tif ( event.button === scope.mouseButtons.ORBIT ) {\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t} else if ( event.button === scope.mouseButtons.ZOOM ) {\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\thandleMouseDownDolly( event );\n\n\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t} else if ( event.button === scope.mouseButtons.PAN ) {\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\tstate = STATE.PAN;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\n\t\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\t\tscope.dispatchEvent( startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tif ( state === STATE.ROTATE ) {\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\thandleMouseMoveRotate( event );\n\n\t\t\t} else if ( state === STATE.DOLLY ) {\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\thandleMouseMoveDolly( event );\n\n\t\t\t} else if ( state === STATE.PAN ) {\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\thandleMouseMovePan( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseUp( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\thandleMouseUp( event );\n\n\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onMouseWheel( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\thandleMouseWheel( event );\n\n\t\t\tscope.dispatchEvent( startEvent ); // not sure why these are here...\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\n\n\t\t\thandleKeyDown( event );\n\n\t\t}\n\n\t\tfunction onTouchStart( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tswitch ( event.touches.length ) {\n\n\t\t\t\tcase 1:\t// one-fingered touch: rotate\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchStartRotate( event );\n\n\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\t// two-fingered touch: dolly\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleTouchStartDolly( event );\n\n\t\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchStartPan( event );\n\n\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tswitch ( event.touches.length ) {\n\n\t\t\t\tcase 1: // one-fingered touch: rotate\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\n\n\t\t\t\t\thandleTouchMoveRotate( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // two-fingered touch: dolly\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\n\n\t\t\t\t\thandleTouchMoveDolly( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\n\n\t\t\t\t\thandleTouchMovePan( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchEnd( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\thandleTouchEnd( event );\n\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onContextMenu( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t}\n\n\t\t//\n\n\t\tscope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\n\n\t\tscope.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\t\tscope.domElement.addEventListener( 'wheel', onMouseWheel, false );\n\n\t\tscope.domElement.addEventListener( 'touchstart', onTouchStart, false );\n\t\tscope.domElement.addEventListener( 'touchend', onTouchEnd, false );\n\t\tscope.domElement.addEventListener( 'touchmove', onTouchMove, false );\n\n\t\twindow.addEventListener( 'keydown', onKeyDown, false );\n\n\t\t// force an update at start\n\n\t\tthis.update();\n\n\t};\n\n\tOrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n\tOrbitControls.prototype.constructor = OrbitControls;\n\n\tObject.defineProperties( OrbitControls.prototype, {\n\n\t\tcenter: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .center has been renamed to .target' );\n\t\t\t\treturn this.target;\n\n\t\t\t}\n\n\t\t},\n\n\t\t// backward compatibility\n\n\t\tnoZoom: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\treturn ! this.enableZoom;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\tthis.enableZoom = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoRotate: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\treturn ! this.enableRotate;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\tthis.enableRotate = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoPan: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\treturn ! this.enablePan;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\tthis.enablePan = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoKeys: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\treturn ! this.enableKeys;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\tthis.enableKeys = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tstaticMoving : {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\treturn ! this.enableDamping;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\tthis.enableDamping = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdynamicDampingFactor : {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\treturn this.dampingFactor;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\tthis.dampingFactor = value;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn OrbitControls;\n};\n",null,null,null,null,null],"names":["HMR_HOST","HMR_PORT","HMR_SECURE","HMR_ENV_HASH","module","bundle","HMR_BUNDLE_ID","OVERLAY_ID","OldModule","Module","moduleName","call","hot","data","hotData","_acceptCallbacks","_disposeCallbacks","accept","fn","push","dispose","undefined","checkedAssets","acceptedAssets","assetsToAccept","location","protocol","indexOf","hostname","port","parent","isParcelRequire","WebSocket","getHostname","getPort","test","ws","onmessage","event","JSON","parse","type","removeErrorOverlay","assets","filter","asset","envHash","handled","forEach","didAccept","hmrAcceptCheck","root","id","depsByBundle","console","clear","hmrApply","i","length","hmrAcceptRun","window","reload","ansiDiagnostic","diagnostics","ansi","stack","codeframe","error","message","hints","join","overlay","createErrorOverlay","html","document","body","appendChild","onerror","e","onclose","warn","getElementById","remove","log","createElement","errorHTML","diagnostic","map","hint","innerHTML","modules","parents","k","d","dep","Array","isArray","concat","getParents","link","newLink","cloneNode","onload","parentNode","removeChild","setAttribute","getAttribute","split","Date","now","insertBefore","nextSibling","cssTimeout","setTimeout","links","querySelectorAll","href","servedFromHMRServer","RegExp","absolute","origin","updateLink","reloadCSS","deps","Function","output","cached","cache","some","v","cb","assetsToAlsoAccept","apply","getRandomNum","max","min","Math","floor","random","constructor","inGroup","velocity","THREE","Vector3","acceleration","wonderTheta","maxSpeed","boost","Start","radius","theta","degToRad","phi","mesh","position","x","sin","cos","y","z","Update","time","ApplyForce","multiplyScalar","add","clampLength","head","clone","lookAt","BuildMesh","geometry","CylinderGeometry","rotateX","material","MeshNormalMaterial","Mesh","f","count","params","seek","maxForce","align","effectiveRange","separate","choesin","group","Group","agents","agent","Agent","Align","Separate","Cohesion","AvoidBoxContainer","currAgent","sumVec","steer","otherAgent","dist","distanceTo","divideScalar","normalize","subVectors","closeVec","Seek","target","toGoalVector","Avoid","wall","computeBoundingSphere","boundingSphere","distance","pow","rangeWidth","rangeHeight","rangeDepth","Boid","addEventListener","className","scene","options","name","Entity","Error","_id","_scene","Add","entities","Scene","cameraController","SetupScene","renderer","setAnimationLoop","ambientLight","AmbientLight","intensity","fog","Fog","entity","global","factory","exports","define","amd","globalThis","self","REVISION","MOUSE","LEFT","MIDDLE","RIGHT","ROTATE","DOLLY","PAN","TOUCH","DOLLY_PAN","DOLLY_ROTATE","CullFaceNone","CullFaceBack","CullFaceFront","CullFaceFrontBack","BasicShadowMap","PCFShadowMap","PCFSoftShadowMap","VSMShadowMap","FrontSide","BackSide","DoubleSide","FlatShading","SmoothShading","NoBlending","NormalBlending","AdditiveBlending","SubtractiveBlending","MultiplyBlending","CustomBlending","AddEquation","SubtractEquation","ReverseSubtractEquation","MinEquation","MaxEquation","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","OneMinusDstAlphaFactor","DstColorFactor","OneMinusDstColorFactor","SrcAlphaSaturateFactor","NeverDepth","AlwaysDepth","LessDepth","LessEqualDepth","EqualDepth","GreaterEqualDepth","GreaterDepth","NotEqualDepth","MultiplyOperation","MixOperation","AddOperation","NoToneMapping","LinearToneMapping","ReinhardToneMapping","CineonToneMapping","ACESFilmicToneMapping","CustomToneMapping","UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","RepeatWrapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipmapNearestFilter","NearestMipMapNearestFilter","NearestMipmapLinearFilter","NearestMipMapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipMapNearestFilter","LinearMipmapLinearFilter","LinearMipMapLinearFilter","UnsignedByteType","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","FloatType","HalfFloatType","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedShort565Type","UnsignedInt248Type","AlphaFormat","RGBFormat","RGBAFormat","LuminanceFormat","LuminanceAlphaFormat","RGBEFormat","DepthFormat","DepthStencilFormat","RedFormat","RedIntegerFormat","RGFormat","RGIntegerFormat","RGBIntegerFormat","RGBAIntegerFormat","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","RGB_ETC1_Format","RGB_ETC2_Format","RGBA_ETC2_EAC_Format","RGBA_ASTC_4x4_Format","RGBA_ASTC_5x4_Format","RGBA_ASTC_5x5_Format","RGBA_ASTC_6x5_Format","RGBA_ASTC_6x6_Format","RGBA_ASTC_8x5_Format","RGBA_ASTC_8x6_Format","RGBA_ASTC_8x8_Format","RGBA_ASTC_10x5_Format","RGBA_ASTC_10x6_Format","RGBA_ASTC_10x8_Format","RGBA_ASTC_10x10_Format","RGBA_ASTC_12x10_Format","RGBA_ASTC_12x12_Format","RGBA_BPTC_Format","SRGB8_ALPHA8_ASTC_4x4_Format","SRGB8_ALPHA8_ASTC_5x4_Format","SRGB8_ALPHA8_ASTC_5x5_Format","SRGB8_ALPHA8_ASTC_6x5_Format","SRGB8_ALPHA8_ASTC_6x6_Format","SRGB8_ALPHA8_ASTC_8x5_Format","SRGB8_ALPHA8_ASTC_8x6_Format","SRGB8_ALPHA8_ASTC_8x8_Format","SRGB8_ALPHA8_ASTC_10x5_Format","SRGB8_ALPHA8_ASTC_10x6_Format","SRGB8_ALPHA8_ASTC_10x8_Format","SRGB8_ALPHA8_ASTC_10x10_Format","SRGB8_ALPHA8_ASTC_12x10_Format","SRGB8_ALPHA8_ASTC_12x12_Format","LoopOnce","LoopRepeat","LoopPingPong","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","ZeroCurvatureEnding","ZeroSlopeEnding","WrapAroundEnding","NormalAnimationBlendMode","AdditiveAnimationBlendMode","TrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","LinearEncoding","sRGBEncoding","GammaEncoding","RGBEEncoding","LogLuvEncoding","RGBM7Encoding","RGBM16Encoding","RGBDEncoding","BasicDepthPacking","RGBADepthPacking","TangentSpaceNormalMap","ObjectSpaceNormalMap","ZeroStencilOp","KeepStencilOp","ReplaceStencilOp","IncrementStencilOp","DecrementStencilOp","IncrementWrapStencilOp","DecrementWrapStencilOp","InvertStencilOp","NeverStencilFunc","LessStencilFunc","EqualStencilFunc","LessEqualStencilFunc","GreaterStencilFunc","NotEqualStencilFunc","GreaterEqualStencilFunc","AlwaysStencilFunc","StaticDrawUsage","DynamicDrawUsage","StreamDrawUsage","StaticReadUsage","DynamicReadUsage","StreamReadUsage","StaticCopyUsage","DynamicCopyUsage","StreamCopyUsage","GLSL1","GLSL3","listener","_listeners","listeners","hasEventListener","removeEventListener","listenerArray","index","splice","dispatchEvent","array","slice","l","_lut","toString","_seed","DEG2RAD","PI","RAD2DEG","d0","d1","d2","d3","uuid","toUpperCase","value","n","m","a1","a2","b1","b2","t","lambda","dt","lerp","exp","abs","euclideanModulo","low","high","range","s","degrees","radians","ceil","LN2","q","a","b","c","order","c2","s2","c13","s13","c1_3","s1_3","c3_1","s3_1","set","MathUtils","Object","freeze","__proto__","generateUUID","clamp","mapLinear","inverseLerp","damp","pingpong","smoothstep","smootherstep","randInt","randFloat","randFloatSpread","seededRandom","radToDeg","isPowerOfTwo","ceilPowerOfTwo","floorPowerOfTwo","setQuaternionFromProperEuler","width","height","setScalar","scalar","setX","setY","setComponent","getComponent","copy","w","addVectors","addScalar","addScaledVector","sub","subScalar","multiply","divide","applyMatrix3","elements","clampScalar","minVal","maxVal","round","roundToZero","negate","dot","cross","lengthSq","sqrt","manhattanLength","angle","atan2","distanceToSquared","dx","dy","manhattanDistanceTo","setLength","alpha","lerpVectors","v1","v2","equals","fromArray","offset","toArray","fromBufferAttribute","attribute","getX","getY","rotateAround","center","Vector2","prototype","isVector2","arguments","n11","n12","n13","n21","n22","n23","n31","n32","n33","te","identity","me","extractBasis","xAxis","yAxis","zAxis","setFromMatrix3Column","setFromMatrix4","multiplyMatrices","premultiply","ae","be","a11","a12","a13","a21","a22","a23","a31","a32","a33","b11","b12","b13","b21","b22","b23","b31","b32","b33","determinant","g","h","invert","t11","t12","t13","det","detInv","transpose","tmp","getNormalMatrix","matrix4","transposeIntoArray","r","setUvTransform","tx","ty","sx","sy","rotation","cx","cy","scale","rotate","translate","matrix","Matrix3","isMatrix3","_canvas","getDataURL","image","src","HTMLCanvasElement","canvas","createElementNS","context","getContext","ImageData","putImageData","drawImage","toDataURL","textureId","EventDispatcher","Texture","DEFAULT_IMAGE","mapping","DEFAULT_MAPPING","wrapS","wrapT","magFilter","minFilter","format","anisotropy","encoding","defineProperty","mipmaps","internalFormat","repeat","matrixAutoUpdate","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","version","onUpdate","updateMatrix","source","toJSON","meta","isRootObject","textures","metadata","generator","wrap","images","url","isDataTexture","serializeImage","transformUv","uv","needsUpdate","isTexture","HTMLImageElement","ImageBitmap","ImageUtils","setZ","setW","applyMatrix4","setAxisAngleFromQuaternion","acos","setAxisAngleFromRotationMatrix","epsilon","epsilon2","m11","m12","m13","m21","m22","m23","m31","m32","m33","xx","yy","zz","xy","xz","yz","getZ","getW","Vector4","isVector4","depth","scissor","scissorTest","viewport","texture","depthBuffer","stencilBuffer","depthTexture","setTexture","setSize","WebGLRenderTarget","isWebGLRenderTarget","il","WebGLMultipleRenderTargets","isWebGLMultipleRenderTargets","samples","WebGLMultisampleRenderTarget","isWebGLMultisampleRenderTarget","_x","_y","_z","_w","slerp","qa","qb","qm","slerpQuaternions","slerpFlat","dst","dstOffset","src0","srcOffset0","src1","srcOffset1","x0","y0","z0","w0","x1","y1","z1","w1","dir","sqrSin","Number","EPSILON","len","tDir","multiplyQuaternionsFlat","_onChangeCallback","quaternion","setFromEuler","euler","update","isEuler","_order","c1","c3","s1","s3","setFromAxisAngle","axis","halfAngle","setFromRotationMatrix","trace","setFromUnitVectors","vFrom","vTo","angleTo","rotateTowards","step","conjugate","p","multiplyQuaternions","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","cosHalfTheta","sqrSinHalfTheta","sinHalfTheta","halfTheta","ratioA","ratioB","_onChange","callback","Quaternion","isQuaternion","multiplyVectors","applyEuler","applyQuaternion","_quaternion$4","applyAxisAngle","applyNormalMatrix","qx","qy","qz","qw","ix","iy","iz","iw","project","camera","matrixWorldInverse","projectionMatrix","unproject","projectionMatrixInverse","matrixWorld","transformDirection","crossVectors","ax","ay","az","bx","by","bz","projectOnVector","denominator","projectOnPlane","planeNormal","_vector$c","reflect","normal","dz","setFromSpherical","setFromSphericalCoords","sinPhiRadius","setFromCylindrical","setFromCylindricalCoords","setFromMatrixPosition","setFromMatrixScale","setFromMatrixColumn","sz","isVector3","Infinity","setFromArray","minX","minY","minZ","maxX","maxY","maxZ","setFromBufferAttribute","setFromPoints","points","makeEmpty","expandByPoint","setFromCenterAndSize","size","halfSize","_vector$b","setFromObject","object","expandByObject","box","isEmpty","getCenter","getSize","point","expandByVector","vector","expandByScalar","updateWorldMatrix","boundingBox","computeBoundingBox","_box$3","union","children","containsPoint","containsBox","getParameter","intersectsBox","intersectsSphere","sphere","clampPoint","intersectsPlane","plane","constant","intersectsTriangle","triangle","_center","_extents","_v0$2","_v1$7","_v2$3","_f0","_f1","_f2","axes","satForAxes","_triangleNormal","distanceToPoint","clampedPoint","getBoundingSphere","intersect","_points","Box3","isBox3","_testAxis","v0","extents","j","p0","p1","p2","_box$2","_v1$6","_toFarthestPoint","_toPoint","optionalCenter","maxRadiusSq","radiusSum","deltaLengthSq","getBoundingBox","getMaxScaleOnAxis","missingRadiusHalf","_vector$a","_segCenter","_segDir","_diff","_edge1","_edge2","_normal$1","direction","ray","at","recast","closestPointToPoint","directionDistance","distanceSqToPoint","distanceSqToSegment","optionalPointOnRay","optionalPointOnSegment","segExtent","a01","b0","s0","sqrDist","extDet","invDet","intersectSphere","tca","radius2","thc","t0","t1","distanceToPlane","intersectPlane","distToPoint","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","backfaceCulling","DdN","sign","DdQxE2","DdE1xQ","QdN","n14","n24","n34","n41","n42","n43","n44","Matrix4","copyPosition","setFromMatrix3","makeBasis","extractRotation","scaleX","_v1$5","scaleY","scaleZ","makeRotationFromEuler","af","bf","ce","cf","de","df","ac","ad","bc","bd","makeRotationFromQuaternion","compose","_zero","_one","eye","up","a14","a24","a34","a41","a42","a43","a44","b14","b24","b34","b41","b42","b43","b44","setPosition","t14","scaleXSq","scaleYSq","scaleZSq","makeTranslation","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","makeScale","makeShear","yx","zx","zy","x2","y2","z2","wx","wy","wz","decompose","_m1$2","invSX","invSY","invSZ","makePerspective","left","right","top","bottom","near","far","makeOrthographic","isMatrix4","_matrix$1","_quaternion$3","Euler","DefaultOrder","asin","setFromQuaternion","setFromVector3","reorder","newOrder","toVector3","optionalResult","RotationOrders","mask","channel","enable","enableAll","toggle","disable","disableAll","layers","_object3DId","_v1$4","_q1","_m1$1","_target","_position$3","_scale$2","_quaternion$2","_xAxis","_yAxis","_zAxis","_addedEvent","_removedEvent","Object3D","DefaultUp","onRotationChange","onQuaternionChange","defineProperties","configurable","enumerable","modelViewMatrix","normalMatrix","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","Layers","visible","castShadow","receiveShadow","frustumCulled","renderOrder","animations","userData","onBeforeRender","onAfterRender","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","rotateOnWorldAxis","rotateY","rotateZ","translateOnAxis","translateX","translateY","translateZ","localToWorld","worldToLocal","isCamera","isLight","isObject3D","removeFromParent","attach","getObjectById","getObjectByProperty","getObjectByName","child","getWorldPosition","getWorldQuaternion","getWorldScale","getWorldDirection","raycast","traverse","traverseVisible","traverseAncestors","updateMatrixWorld","force","updateParents","updateChildren","geometries","materials","shapes","skeletons","stringify","isInstancedMesh","instanceMatrix","instanceColor","library","element","isMesh","isLine","isPoints","serialize","parameters","shape","isSkinnedMesh","bindMode","bindMatrix","skeleton","uuids","animation","extractFromCache","values","key","recursive","_vector1","_vector2$1","_normalMatrix","setComponents","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","intersectLine","line","delta","start","intersectsLine","startSign","endSign","end","coplanarPoint","optionalNormalMatrix","referencePoint","Plane","isPlane","_v0$1","_v1$3","_v2$2","_v3$1","_vab","_vac","_vbc","_vap","_vbp","_vcp","getNormal","targetLengthSq","getBarycoord","dot00","dot01","dot02","dot11","dot12","denom","invDenom","u","getUV","p3","uv1","uv2","uv3","isFrontFacing","setFromPointsAndIndices","i0","i1","i2","getArea","getMidpoint","Triangle","getPlane","d4","vc","d5","d6","vb","va","materialId","blending","side","vertexColors","opacity","transparent","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","depthFunc","depthTest","depthWrite","stencilWriteMask","stencilFunc","stencilRef","stencilFuncMask","stencilFail","stencilZFail","stencilZPass","stencilWrite","clippingPlanes","clipIntersection","clipShadows","shadowSide","colorWrite","precision","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","dithering","alphaTest","alphaToCoverage","premultipliedAlpha","toneMapped","onBuild","onBeforeCompile","customProgramCacheKey","setValues","newValue","flatShading","currentValue","isColor","isRoot","color","getHex","roughness","metalness","sheen","emissive","emissiveIntensity","specular","shininess","clearcoat","clearcoatRoughness","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","clearcoatNormalScale","matcap","alphaMap","lightMap","lightMapIntensity","aoMap","aoMapIntensity","bumpMap","bumpScale","normalMap","normalMapType","normalScale","displacementMap","displacementScale","displacementBias","roughnessMap","metalnessMap","emissiveMap","specularMap","envMap","combine","envMapIntensity","reflectivity","refractionRatio","gradientMap","transmission","transmissionMap","thickness","thicknessMap","attenuationDistance","attenuationColor","sizeAttenuation","linewidth","dashSize","gapSize","wireframe","wireframeLinewidth","wireframeLinecap","wireframeLinejoin","morphTargets","morphNormals","srcPlanes","dstPlanes","Material","isMaterial","_colorKeywords","_hslA","_hslB","setRGB","setHex","setStyle","hex","setHSL","hue2rgb","style","string","parseFloat","exec","components","parseInt","handleAlpha","charAt","setColorName","toLowerCase","copyGammaToLinear","gammaFactor","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","copySRGBToLinear","SRGBToLinear","copyLinearToSRGB","LinearToSRGB","convertSRGBToLinear","convertLinearToSRGB","getHexString","getHSL","hue","saturation","lightness","getStyle","offsetHSL","addColors","color1","color2","lerpColors","lerpHSL","normalized","Color","NAMES","MeshBasicMaterial","isMeshBasicMaterial","_vector$9","_vector2","itemSize","TypeError","usage","updateRange","onUploadCallback","setUsage","copyAt","index1","index2","copyArray","copyColorsArray","colors","copyVector2sArray","vectors","copyVector3sArray","copyVector4sArray","setXY","setXYZ","setXYZW","onUpload","BufferAttribute","isBufferAttribute","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float16BufferAttribute","isFloat16BufferAttribute","Float32Array","Float64Array","TYPED_ARRAYS","buffer","_m1","_obj","_offset","_box$1","_boxMorphTargets","_vector$8","attributes","morphAttributes","morphTargetsRelative","groups","drawRange","getIndex","setIndex","arrayMax","Uint32BufferAttribute","Uint16BufferAttribute","deleteAttribute","hasAttribute","addGroup","materialIndex","clearGroups","setDrawRange","tangent","Float32BufferAttribute","morphAttributesPosition","isGLBufferAttribute","morphAttribute","isNaN","Sphere","jl","computeFaceNormals","computeTangents","indices","positions","normals","uvs","nVertices","tangents","tan1","tan2","vA","vB","vC","uvA","uvB","uvC","sdir","tdir","isFinite","handleTriangle","tmp2","n2","handleVertex","computeVertexNormals","positionAttribute","normalAttribute","pA","pB","pC","nA","nB","nC","ab","normalizeNormals","merge","isBufferGeometry","attribute1","attributeArray1","attribute2","attributeArray2","attributeOffset","toNonIndexed","array2","geometry2","BufferGeometry","newAttribute","convertBufferAttribute","morphArray","keys","hasMorphAttributes","attributeArray","_inverseMatrix$2","_ray$2","Ray","_sphere$3","_vA$1","_vB$1","_vC$1","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_uvA$1","_uvB$1","_uvC$1","_intersectionPoint","_intersectionPointWorld","updateMorphTargets","morphTargetInfluences","morphTargetDictionary","assign","ml","String","raycaster","intersects","intersection","morphPosition","groupMaterial","checkBufferGeometryIntersection","faceIndex","face","isGeometry","morphInfluences","influence","boneTransform","checkIntersection","widthSegments","heightSegments","depthSegments","scope","vertices","numberOfVertices","groupStart","buildPlane","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","groupCount","property","uniforms","merged","cloneUniforms","UniformsUtils","mergeUniforms","default_vertex","default_fragment","defines","vertexShader","fragmentShader","lights","clipping","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","index0AttributeName","uniformsNeedUpdate","glslVersion","uniform","ShaderMaterial","isShaderMaterial","Camera","fov","aspect","zoom","focus","view","filmGauge","filmOffset","updateProjectionMatrix","setFocalLength","focalLength","vExtentSlope","getFilmHeight","atan","getFocalLength","tan","getEffectiveFOV","getFilmWidth","setViewOffset","fullWidth","fullHeight","enabled","offsetX","offsetY","clearViewOffset","skew","PerspectiveCamera","isPerspectiveCamera","renderTarget","isWebGLCubeRenderTarget","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","currentXrEnabled","xr","currentRenderTarget","getRenderTarget","setRenderTarget","render","_needsFlipEnvMap","CubeTexture","isCubeTexture","dummy","isInteger","fromEquirectangularTexture","shader","tEquirect","BoxGeometry","currentMinFilter","CubeCamera","stencil","WebGLCubeRenderTarget","_sphere$2","_vector$7","p4","p5","planes","frustum","setFromProjectionMatrix","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","intersectsObject","intersectsSprite","sprite","negRadius","isAnimating","animationLoop","requestId","frame","requestAnimationFrame","onAnimationFrame","stop","cancelAnimationFrame","setContext","gl","capabilities","isWebGL2","buffers","WeakMap","bufferType","createBuffer","bindBuffer","bufferData","FLOAT","HALF_FLOAT","UNSIGNED_SHORT","SHORT","UNSIGNED_INT","INT","BYTE","UNSIGNED_BYTE","bytesPerElement","BYTES_PER_ELEMENT","bufferSubData","subarray","isInterleavedBufferAttribute","get","deleteBuffer","delete","elementSize","updateBuffer","width_half","height_half","segment_width","segment_height","alphamap_fragment","alphamap_pars_fragment","alphatest_fragment","aomap_fragment","aomap_pars_fragment","begin_vertex","beginnormal_vertex","bsdfs","bumpmap_pars_fragment","clipping_planes_fragment","clipping_planes_pars_fragment","clipping_planes_pars_vertex","clipping_planes_vertex","color_fragment","color_pars_fragment","color_pars_vertex","color_vertex","common","cube_uv_reflection_fragment","defaultnormal_vertex","displacementmap_pars_vertex","displacementmap_vertex","emissivemap_fragment","emissivemap_pars_fragment","encodings_fragment","encodings_pars_fragment","envmap_fragment","envmap_common_pars_fragment","envmap_pars_fragment","envmap_pars_vertex","envmap_vertex","fog_vertex","fog_pars_vertex","fog_fragment","fog_pars_fragment","gradientmap_pars_fragment","lightmap_fragment","lightmap_pars_fragment","lights_lambert_vertex","lights_pars_begin","envmap_physical_pars_fragment","lights_toon_fragment","lights_toon_pars_fragment","lights_phong_fragment","lights_phong_pars_fragment","lights_physical_fragment","lights_physical_pars_fragment","lights_fragment_begin","lights_fragment_maps","lights_fragment_end","logdepthbuf_fragment","logdepthbuf_pars_fragment","logdepthbuf_pars_vertex","logdepthbuf_vertex","map_fragment","map_pars_fragment","map_particle_fragment","map_particle_pars_fragment","metalnessmap_fragment","metalnessmap_pars_fragment","morphnormal_vertex","morphtarget_pars_vertex","morphtarget_vertex","normal_fragment_begin","normal_fragment_maps","normalmap_pars_fragment","clearcoat_normal_fragment_begin","clearcoat_normal_fragment_maps","clearcoat_pars_fragment","packing","premultiplied_alpha_fragment","project_vertex","dithering_fragment","dithering_pars_fragment","roughnessmap_fragment","roughnessmap_pars_fragment","shadowmap_pars_fragment","shadowmap_pars_vertex","shadowmap_vertex","shadowmask_pars_fragment","skinbase_vertex","skinning_pars_vertex","skinning_vertex","skinnormal_vertex","specularmap_fragment","specularmap_pars_fragment","tonemapping_fragment","tonemapping_pars_fragment","transmission_fragment","transmission_pars_fragment","uv_pars_fragment","uv_pars_vertex","uv_vertex","uv2_pars_fragment","uv2_pars_vertex","uv2_vertex","worldpos_vertex","background_frag","background_vert","cube_frag","cube_vert","depth_frag","depth_vert","distanceRGBA_frag","distanceRGBA_vert","equirect_frag","equirect_vert","linedashed_frag","linedashed_vert","meshbasic_frag","meshbasic_vert","meshlambert_frag","meshlambert_vert","meshmatcap_frag","meshmatcap_vert","meshtoon_frag","meshtoon_vert","meshphong_frag","meshphong_vert","meshphysical_frag","meshphysical_vert","normal_frag","normal_vert","points_frag","points_vert","shadow_frag","shadow_vert","sprite_frag","sprite_vert","ShaderChunk","UniformsLib","diffuse","uvTransform","uv2Transform","specularmap","envmap","flipEnvMap","maxMipLevel","aomap","lightmap","emissivemap","bumpmap","normalmap","displacementmap","roughnessmap","metalnessmap","gradientmap","fogDensity","fogNear","fogFar","fogColor","ambientLightColor","lightProbe","directionalLights","properties","directionalLightShadows","shadowBias","shadowNormalBias","shadowRadius","shadowMapSize","directionalShadowMap","directionalShadowMatrix","spotLights","coneCos","penumbraCos","decay","spotLightShadows","spotShadowMap","spotShadowMatrix","pointLights","pointLightShadows","shadowCameraNear","shadowCameraFar","pointShadowMap","pointShadowMatrix","hemisphereLights","skyColor","groundColor","rectAreaLights","ltc_1","ltc_2","ShaderLib","basic","lambert","phong","standard","toon","dashed","totalSize","background","t2D","cube","equirect","distanceRGBA","referencePosition","nearDistance","farDistance","shadow","physical","transmissionSamplerSize","transmissionSamplerMap","cubemaps","state","objects","clearColor","clearAlpha","planeMesh","boxMesh","currentBackground","currentBackgroundVersion","currentTonemapping","renderList","forceClear","isScene","session","getSession","environmentBlendMode","setClear","autoClear","autoClearColor","autoClearDepth","autoClearStencil","toneMapping","unshift","PlaneGeometry","getClearColor","setClearColor","getClearAlpha","setClearAlpha","maxVertexAttributes","MAX_VERTEX_ATTRIBS","extension","vaoAvailable","bindingStates","defaultState","createBindingState","currentState","program","updateBuffers","getBindingState","bindVertexArrayObject","saveCache","ELEMENT_ARRAY_BUFFER","setupVertexAttributes","createVertexArray","createVertexArrayOES","vao","bindVertexArray","bindVertexArrayOES","deleteVertexArray","deleteVertexArrayOES","programMap","stateMap","createVertexArrayObject","newAttributes","enabledAttributes","attributeDivisors","cachedAttributes","geometryAttributes","attributesNum","cachedAttribute","geometryAttribute","enableAttributeAndDivisor","meshPerAttribute","enableVertexAttribArray","disableVertexAttribArray","stride","vertexAttribIPointer","vertexAttribPointer","isInstancedBufferGeometry","initAttributes","programAttributes","getAttributes","materialDefaultAttributeValues","programAttribute","isInstancedInterleavedBuffer","_maxInstanceCount","enableAttribute","ARRAY_BUFFER","isInstancedBufferAttribute","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","disableUnusedAttributes","reset","geometryId","programId","deleteVertexArrayObject","resetDefaultState","setup","releaseStatesOfGeometry","releaseStatesOfProgram","info","mode","drawArrays","primcount","methodName","setMode","renderInstances","maxAnisotropy","has","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getShaderPrecisionFormat","VERTEX_SHADER","HIGH_FLOAT","FRAGMENT_SHADER","MEDIUM_FLOAT","WebGL2RenderingContext","WebGL2ComputeRenderingContext","maxPrecision","getMaxPrecision","logarithmicDepthBuffer","maxTextures","MAX_TEXTURE_IMAGE_UNITS","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","maxTextureSize","MAX_TEXTURE_SIZE","maxCubemapSize","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","maxVertexUniforms","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","vertexTextures","floatFragmentTextures","floatVertexTextures","maxSamples","MAX_SAMPLES","getMaxAnisotropy","globalState","numGlobalPlanes","localClippingEnabled","renderingShadows","viewNormalMatrix","numPlanes","numIntersection","init","enableLocalClipping","projectPlanes","beginShadows","endShadows","resetGlobalState","setState","useCache","materialProperties","nGlobal","lGlobal","dstArray","clippingState","skipTransform","nPlanes","flatSize","viewMatrix","i4","cubemap","mapTextureMapping","onTextureDispose","getExtension","wireframeAttributes","onGeometryDispose","memory","geometryIndex","geometryPosition","previousAttribute","currentAttribute","updateWireframeAttribute","getWireframeAttribute","drawElements","calls","triangles","lines","instanceCount","TRIANGLES","LINES","LINE_STRIP","LINE_LOOP","POINTS","programs","autoReset","influencesList","workInfluences","objectInfluences","influences","sort","absNumericalSort","MAX_SAFE_INTEGER","numericalSort","morphInfluencesSum","morphBaseInfluence","getUniforms","setValue","updateMap","buffergeometry","onInstancedMeshDispose","instancedMesh","wrapR","DataTexture2DArray","isDataTexture2DArray","DataTexture3D","isDataTexture3D","emptyTexture","emptyTexture2dArray","emptyTexture3d","emptyCubeTexture","arrayCacheF32","arrayCacheI32","mat4array","mat3array","mat2array","nBlocks","blockSize","firstElem","allocateTextureUnit","uniform1f","addr","uniform2f","arraysEqual","uniform2fv","uniform3f","uniform3fv","uniform4f","uniform4fv","uniformMatrix2fv","uniformMatrix3fv","uniformMatrix4fv","uniform1i","uniform2iv","uniform3iv","uniform4iv","uniform1ui","uniform2uiv","uniform3uiv","uniform4uiv","unit","safeSetTexture2D","setTexture3D","safeSetTextureCube","setTexture2DArray","setValueV1f","setValueV2f","setValueV3f","setValueV4f","setValueM2","setValueM3","setValueM4","setValueV1i","setValueV2i","setValueV3i","setValueV4i","setValueV1ui","setValueV2ui","setValueV3ui","setValueV4ui","setValueT1","setValueT3D1","setValueT6","setValueT2DArray1","uniform1fv","flatten","uniform1iv","uniform1uiv","units","allocTexUnits","setValueV1fArray","setValueV2fArray","setValueV3fArray","setValueV4fArray","setValueM2Array","setValueM3Array","setValueM4Array","setValueV1iArray","setValueV2iArray","setValueV3iArray","setValueV4iArray","setValueV1uiArray","setValueV2uiArray","setValueV3uiArray","setValueV4uiArray","setValueT1Array","setValueT6Array","activeInfo","getSingularSetter","getPureArraySetter","PureArrayUniform","updateCache","seq","StructuredUniform","RePathPart","container","uniformObject","path","pathLength","lastIndex","match","matchEnd","idIsIndex","subscript","addUniform","SingleUniform","next","getProgramParameter","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","parseUniform","WebGLUniforms","setOptional","upload","seqWithValue","createShader","shaderSource","compileShader","programIdCount","status","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","trim","getShaderSource","addLineNumbers","functionName","getEncodingComponents","toneMappingName","chunks","extensionDerivatives","envMapCubeUV","tangentSpaceNormalMap","shaderID","extensionFragDepth","rendererExtensionFragDepth","extensionDrawBuffers","rendererExtensionDrawBuffers","extensionShaderTextureLOD","rendererExtensionShaderTextureLod","filterEmptyLine","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","replace","numDirLights","numSpotLights","numRectAreaLights","numPointLights","numHemiLights","numDirLightShadows","numSpotLightShadows","numPointLightShadows","numClippingPlanes","numClipIntersection","includePattern","includeReplacer","include","resolveIncludes","deprecatedUnrollLoopPattern","unrollLoopPattern","loopReplacer","deprecatedLoopReplacer","snippet","precisionstring","shadowMapTypeDefine","shadowMapType","envMapTypeDefine","envMapMode","envMapModeDefine","envMapBlendingDefine","cacheKey","generateShadowMapTypeDefine","generateEnvMapTypeDefine","generateEnvMapModeDefine","generateEnvMapBlendingDefine","gammaFactorDefine","customExtensions","generateExtensions","customDefines","generateDefines","createProgram","prefixVertex","prefixFragment","versionString","isRawShaderMaterial","generatePrecision","shaderName","instancing","instancingColor","supportsVertexTextures","maxBones","useFog","fogExp2","objectSpaceNormalMap","vertexTangents","vertexAlphas","vertexUvs","uvsVertexOnly","skinning","useVertexTexture","doubleSided","flipSided","shadowMapEnabled","physicallyCorrectLights","getToneMappingFunction","getTexelDecodingFunction","mapEncoding","matcapEncoding","envMapEncoding","emissiveMapEncoding","lightMapEncoding","getTexelEncodingFunction","outputEncoding","depthPacking","replaceLightNums","replaceClippingPlaneNums","unrollLoops","vertexGlsl","fragmentGlsl","glVertexShader","WebGLShader","glFragmentShader","attachShader","bindAttribLocation","linkProgram","debug","checkShaderErrors","programLog","getProgramInfoLog","vertexLog","fragmentLog","runnable","haveDiagnostics","LINK_STATUS","vertexErrors","getShaderErrors","fragmentErrors","getError","VALIDATE_STATUS","prefix","deleteShader","cachedUniforms","fetchAttributeLocations","destroy","deleteProgram","usedTimes","shaderIDs","MeshDepthMaterial","MeshDistanceMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial","MeshStandardMaterial","MeshPhysicalMaterial","MeshMatcapMaterial","LineBasicMaterial","LineDashedMaterial","PointsMaterial","ShadowMaterial","SpriteMaterial","parameterNames","bones","nVertexUniforms","nVertexMatrices","shadows","environment","isMeshStandardMaterial","getMaxBones","getTextureEncodingFromMap","isFogExp2","directional","spot","rectArea","hemi","shadowMap","pl","preexistingProgram","WebGLProgram","pop","getParameters","getProgramCacheKey","acquireProgram","releaseProgram","groupOrder","renderItems","renderItemsIndex","opaque","transmissive","defaultProgram","renderItem","getNextRenderItem","customOpaqueSort","customTransparentSort","painterSortStable","reversePainterSortStable","finish","lists","renderCallDepth","list","WebGLRenderList","light","halfWidth","halfHeight","nextVersion","lightA","lightB","UniformsCache","shadowCache","ShadowUniformsCache","hash","directionalLength","pointLength","spotLength","rectAreaLength","hemiLength","numDirectionalShadows","numPointShadows","numSpotShadows","ambient","probe","directionalShadow","spotShadow","rectAreaLTC1","rectAreaLTC2","pointShadow","vector3","matrix42","shadowCastingLightsFirst","isAmbientLight","isLightProbe","sh","coefficients","isDirectionalLight","shadowUniforms","bias","normalBias","mapSize","isSpotLight","penumbra","isRectAreaLight","isPointLight","isHemisphereLight","LTC_FLOAT_1","LTC_FLOAT_2","LTC_HALF_1","LTC_HALF_2","setupView","WebGLLights","lightsArray","shadowsArray","shadowLight","setupLights","setupLightsView","pushLight","pushShadow","renderStates","renderState","WebGLRenderState","isMeshDepthMaterial","isMeshDistanceMaterial","vsm_frag","vsm_vert","_renderer","_objects","_capabilities","_frustum","Frustum","_shadowMapSize","_viewportSize","_viewport","_depthMaterials","_distanceMaterials","_materialCache","_maxTextureSize","shadowMaterialVertical","SAMPLE_RATE","HALF_SAMPLE_RATE","shadow_pass","resolution","shadowMaterialHorizontal","HORIZONTAL_PASS","fullScreenTri","fullScreenMesh","autoUpdate","activeCubeFace","getActiveCubeFace","activeMipmapLevel","getActiveMipmapLevel","_state","setBlending","setTest","setScissorTest","shadowFrameExtents","getFrameExtents","isPointLightShadow","pars","mapPass","viewportCount","getViewportCount","vp","getViewport","updateMatrices","getFrustum","renderObject","VSMPass","renderBufferDirect","useMorphing","result","getMaterialVariant","getDepthMaterialVariant","customMaterial","customDepthMaterial","getDistanceMaterialVariant","customDistanceMaterial","keyA","keyB","materialsForVariant","cachedMaterial","shadowCamera","kl","depthMaterial","getDepthMaterial","locked","currentColorMask","currentColorClear","setMask","colorMask","setLocked","lock","currentDepthMask","currentDepthFunc","currentDepthClear","DEPTH_TEST","depthMask","setFunc","NEVER","ALWAYS","LESS","LEQUAL","EQUAL","GEQUAL","GREATER","NOTEQUAL","clearDepth","currentStencilMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilClear","stencilTest","STENCIL_TEST","stencilMask","setOp","stencilOp","clearStencil","colorBuffer","ColorBuffer","DepthBuffer","StencilBuffer","enabledCapabilities","xrFramebuffer","currentBoundFramebuffers","currentProgram","currentBlendingEnabled","currentBlending","currentBlendEquation","currentBlendSrc","currentBlendDst","currentBlendEquationAlpha","currentBlendSrcAlpha","currentBlendDstAlpha","currentPremultipledAlpha","currentFlipSided","currentCullFace","currentLineWidth","currentPolygonOffsetFactor","currentPolygonOffsetUnits","MAX_COMBINED_TEXTURE_IMAGE_UNITS","lineWidthAvailable","glVersion","VERSION","currentTextureSlot","currentBoundTextures","scissorParam","SCISSOR_BOX","viewportParam","VIEWPORT","currentScissor","currentViewport","createTexture","bindTexture","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","texImage2D","RGBA","emptyTextures","TEXTURE_2D","TEXTURE_CUBE_MAP","TEXTURE_CUBE_MAP_POSITIVE_X","setFlipSided","setCullFace","CULL_FACE","framebuffer","bindFramebuffer","FRAMEBUFFER","DRAW_FRAMEBUFFER","useProgram","equationToGL","FUNC_ADD","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","MIN","MAX","MIN_EXT","MAX_EXT","factorToGL","ZERO","ONE","SRC_COLOR","SRC_ALPHA","SRC_ALPHA_SATURATE","DST_COLOR","DST_ALPHA","ONE_MINUS_SRC_COLOR","ONE_MINUS_SRC_ALPHA","ONE_MINUS_DST_COLOR","ONE_MINUS_DST_ALPHA","BLEND","blendFuncSeparate","blendFunc","blendEquationSeparate","frontFaceCW","setPolygonOffset","SAMPLE_ALPHA_TO_COVERAGE","frontFace","CW","CCW","cullFace","BACK","FRONT","FRONT_AND_BACK","lineWidth","factor","POLYGON_OFFSET_FILL","SCISSOR_TEST","webglSlot","TEXTURE0","activeTexture","webglType","webglTexture","boundTexture","compressedTexImage2D","texImage3D","KEEP","READ_FRAMEBUFFER","bindXRFramebuffer","setMaterial","setLineWidth","unbindTexture","_gl","utils","_videoTextures","useOffscreenCanvas","OffscreenCanvas","err","needsPowerOfTwo","needsNewCanvas","maxSize","createCanvas","supportsMips","generateMipmap","textureProperties","__maxMipLevel","log2","internalFormatName","glFormat","glType","RED","R32F","R16F","R8","RGB","RGB32F","RGB16F","RGB8","RGBA32F","RGBA16F","RGBA8","LINEAR","deallocateTexture","isVideoTexture","onRenderTargetDispose","deallocateRenderTarget","__webglInit","deleteTexture","__webglTexture","renderTargetProperties","deleteFramebuffer","__webglFramebuffer","__webglDepthbuffer","deleteRenderbuffer","__webglMultisampledFramebuffer","__webglColorRenderbuffer","__webglDepthRenderbuffer","attachmentProperties","textureUnits","textureUnit","slot","updateVideoTexture","__version","complete","uploadTexture","TEXTURE_2D_ARRAY","TEXTURE_3D","uploadCubeTexture","wrappingToGL","REPEAT","CLAMP_TO_EDGE","MIRRORED_REPEAT","filterToGL","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","textureType","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXTURE_WRAP_R","filterFallback","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","initTexture","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","UNPACK_COLORSPACE_CONVERSION_WEBGL","NONE","textureNeedsPowerOfTwo","isPowerOfTwo$1","resizeImage","convert","glInternalFormat","getInternalFormat","setTextureParameters","mipmap","isDepthTexture","DEPTH_COMPONENT","DEPTH_COMPONENT32F","DEPTH_COMPONENT24","DEPTH24_STENCIL8","DEPTH_COMPONENT16","DEPTH_STENCIL","isCompressedTexture","textureNeedsGenerateMipmaps","isCompressed","cubeImage","mipmapImage","attachment","textureTarget","framebufferTexture2D","renderbuffer","isMultisample","bindRenderbuffer","RENDERBUFFER","getRenderTargetSamples","renderbufferStorageMultisample","renderbufferStorage","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL_ATTACHMENT","isCube","setTexture2D","webglDepthTexture","setupDepthTexture","createRenderbuffer","setupRenderBufferStorage","isMultipleRenderTargets","isRenderTarget3D","createFramebuffer","COLOR_ATTACHMENT0","setupFrameBufferTexture","glTextureType","isTexture3D","setupDepthRenderbuffer","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","blitFramebuffer","warnedTexture2D","warnedTextureCube","setTextureCube","resetTextureUnits","setupRenderTarget","updateRenderTargetMipmap","updateMultisampleRenderTarget","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","HALF_FLOAT_OES","ALPHA","LUMINANCE","LUMINANCE_ALPHA","RED_INTEGER","RG","RG_INTEGER","RGB_INTEGER","RGBA_INTEGER","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","COMPRESSED_RGB_ETC1_WEBGL","COMPRESSED_RGB8_ETC2","COMPRESSED_RGBA8_ETC2_EAC","UNSIGNED_INT_24_8","UNSIGNED_INT_24_8_WEBGL","cameras","ArrayCamera","isArrayCamera","isGroup","_moveEvent","_targetRay","_grip","_hand","getHandSpace","joints","inputState","pinching","getTargetRaySpace","hasLinearVelocity","linearVelocity","hasAngularVelocity","angularVelocity","getGripSpace","disconnect","inputSource","referenceSpace","inputPose","gripPose","handPose","targetRay","grip","hand","visibilityState","getPose","targetRaySpace","transform","inputjoint","jointPose","getJointPose","jointName","joint","jointRadius","indexTip","thumbTip","distanceToPinch","threshold","handedness","gripSpace","framebufferScaleFactor","referenceSpaceType","pose","controllers","inputSourcesMap","Map","cameraL","cameraR","cameraVR","_currentDepthNear","_currentDepthFar","cameraAutoUpdate","isPresenting","getController","controller","WebXRController","getControllerGrip","getHand","setFramebufferScaleFactor","setReferenceSpaceType","getReferenceSpace","setSession","onSessionEvent","onSessionEnd","onInputSourcesChange","getContextAttributes","xrCompatible","makeXRCompatible","layerInit","antialias","baseLayer","XRWebGLLayer","updateRenderState","requestReferenceSpace","inputSources","removed","added","cameraLPos","cameraRPos","ipd","projL","projR","topFov","bottomFov","leftFov","rightFov","zOffset","xOffset","near2","far2","left2","right2","top2","bottom2","updateCamera","depthNear","depthFar","setProjectionFromUnion","getCamera","onAnimationFrameCallback","getViewerPose","views","cameraVRNeedsUpdate","WebGLAnimation","isFog","density","pixelRatio","transmissionRenderTarget","refreshUniformsCommon","isMeshLambertMaterial","refreshUniformsLambert","isMeshToonMaterial","refreshUniformsToon","isMeshPhongMaterial","refreshUniformsPhong","isMeshPhysicalMaterial","refreshUniformsPhysical","refreshUniformsStandard","isMeshMatcapMaterial","refreshUniformsMatcap","refreshUniformsDepth","refreshUniformsDistance","isMeshNormalMaterial","refreshUniformsNormal","isLineBasicMaterial","refreshUniformsLine","isLineDashedMaterial","refreshUniformsDash","isPointsMaterial","refreshUniformsPoints","isSpriteMaterial","refreshUniformsSprites","isShadowMaterial","uvScaleMap","uv2ScaleMap","refreshFogUniforms","refreshMaterialUniforms","display","createCanvasElement","_context","_alpha","_depth","_stencil","_antialias","_premultipliedAlpha","_preserveDrawingBuffer","preserveDrawingBuffer","_powerPreference","powerPreference","_failIfMajorPerformanceCaveat","failIfMajorPerformanceCaveat","currentRenderList","currentRenderState","renderListStack","renderStateStack","domElement","sortObjects","toneMappingExposure","_this","_isContextLost","_currentActiveCubeFace","_currentActiveMipmapLevel","_currentRenderTarget","_currentMaterialId","_currentCamera","_currentViewport","_currentScissor","_currentScissorTest","_width","_height","_pixelRatio","_opaqueSort","_transparentSort","_scissor","_scissorTest","_currentDrawBuffers","_clippingEnabled","_localClippingEnabled","_transmissionRenderTarget","_projScreenMatrix","_vector3","_emptyScene","overrideMaterial","contextNames","contextAttributes","contextName","onContextLost","onContextRestore","isWebGL1Renderer","shift","programCache","renderLists","morphtargets","bufferRenderer","indexedBufferRenderer","WebGLExtensions","WebGLCapabilities","WebGLUtils","WebGLState","WebGLInfo","WebGLProperties","WebGLTextures","WebGLCubeMaps","WebGLAttributes","WebGLBindingStates","WebGLGeometries","WebGLObjects","WebGLMorphtargets","WebGLClipping","WebGLPrograms","WebGLMaterials","WebGLRenderLists","WebGLRenderStates","WebGLBackground","WebGLShadowMap","WebGLBufferRenderer","WebGLIndexedBufferRenderer","initGLContext","WebXRManager","forceContextLoss","loseContext","forceContextRestore","restoreContext","getPixelRatio","setPixelRatio","updateStyle","setViewport","getDrawingBufferSize","setDrawingBufferSize","getCurrentViewport","getScissor","setScissor","getScissorTest","boolean","setOpaqueSort","method","setTransparentSort","bits","onXRSessionStart","onXRSessionEnd","preventDefault","infoAutoReset","shadowMapAutoUpdate","shadowMapNeedsUpdate","onMaterialDispose","deallocateMaterial","releaseMaterialProgramReferences","renderBufferImmediate","hasPositions","hasNormals","hasUvs","hasColors","positionArray","DYNAMIC_DRAW","normalArray","uvArray","colorArray","setProgram","rangeFactor","dataCount","rangeStart","rangeCount","drawStart","drawEnd","drawCount","getTargetPixelRatio","isLineSegments","isLineLoop","isSprite","compile","material2","getProgram","projectObject","opaqueObjects","transmissiveObjects","transparentObjects","renderObjects","renderTransmissiveObjects","isLOD","isImmediateRenderObject","camera2","renderObjectImmediate","lightsStateVersion","programCacheKey","updateCommonMaterialProperties","needsLights","materialNeedsLights","progUniforms","uniformsList","needsProgramChange","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","uCamPos","cameraPosition","isOrthographicCamera","boneTexture","computeBoneTexture","boneTextureSize","markUniformsLightsNeedsUpdate","framebufferBound","drawBuffersWEBGL","layer","framebufferTextureLayer","readRenderTargetPixels","activeCubeFaceIndex","textureFormat","IMPLEMENTATION_COLOR_READ_FORMAT","halfFloatSupportedByExt","IMPLEMENTATION_COLOR_READ_TYPE","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","copyFramebufferToTexture","level","levelScale","copyTexImage2D","copyTextureToTexture","srcTexture","dstTexture","texSubImage2D","compressedTexSubImage2D","copyTextureToTexture3D","sourceBox","glTarget","unpackRowLen","UNPACK_ROW_LENGTH","unpackImageHeight","UNPACK_IMAGE_HEIGHT","unpackSkipPixels","UNPACK_SKIP_PIXELS","unpackSkipRows","UNPACK_SKIP_ROWS","unpackSkipImages","UNPACK_SKIP_IMAGES","texSubImage3D","resetState","__THREE_DEVTOOLS__","CustomEvent","detail","WebGLRenderer","WebGL1Renderer","FogExp2","arrayBuffers","_uuid","ib","InterleavedBuffer","isInterleavedBuffer","_vector$6","interleavedBuffer","interleavedBuffers","InterleavedBufferAttribute","_geometry","_intersectPoint","_worldScale","_mvPosition","_alignedPosition","_rotatedPosition","_viewWorldMatrix","_vA","_vB","_vC","_uvA","_uvB","_uvC","float32Array","transformVertex","Sprite","vertexPosition","mvPosition","_v1$2","_v2$1","_currentLevel","levels","addLevel","getCurrentLevel","getObjectForDistance","_basePosition","_skinIndex","_skinWeight","_vector$5","_matrix","bindMatrixInverse","bind","calculateInverses","normalizeSkinWeights","skinWeight","skinIndex","weight","boneIndex","boneInverses","SkinnedMesh","Bone","isBone","DataTexture","_offsetMatrix","_identityMatrix","boneMatrices","inverse","bone","Skeleton","getBoneByName","fromJSON","json","boneInverse","_instanceLocalMatrix","_instanceWorldMatrix","_instanceIntersects","_mesh","getColorAt","getMatrixAt","raycastTimes","instanceId","setColorAt","setMatrixAt","InstancedMesh","linecap","linejoin","_start$1","_end$1","_inverseMatrix$1","_ray$1","_sphere$1","computeLineDistances","lineDistances","Line","localThreshold","localThresholdSq","vStart","vEnd","interSegment","interRay","distSq","_start","_end","LineSegments","LineLoop","_inverseMatrix","_ray","_sphere","_position$2","Points","testPoint","rayPointDistanceSq","intersectPoint","distanceToRay","video","requestVideoFrameCallback","updateVideo","hasVideoFrameCallback","readyState","HAVE_CURRENT_DATA","VideoTexture","CompressedTexture","CanvasTexture","isCanvasTexture","DepthTexture","segments","thetaStart","thetaLength","vertex","segment","radiusTop","radiusBottom","radialSegments","openEnded","indexArray","generateTorso","generateCap","slope","indexRow","sinTheta","cosTheta","centerIndexStart","centerIndexEnd","vertexBuffer","uvBuffer","subdivide","applyRadius","generateUVs","getVertexByIndex","subdivideFace","cols","aj","bj","rows","pushVertex","azimuth","inclination","correctUVs","correctSeam","centroid","azi","correctUV","PolyhedronGeometry","_v0","_v1$1","_normal","_triangle","thresholdAngle","precisionPoints","thresholdDot","indexAttr","positionAttr","indexCount","indexArr","vertKeys","hashes","edgeData","jNext","vecHash0","vecHash1","reverseHash","index0","Earcut","triangulate","holeIndices","dim","hasHoles","outerLen","outerNode","linkedList","prev","invSize","eliminateHoles","earcutLinked","clockwise","last","signedArea","insertNode","removeNode","again","steiner","area","ear","pass","indexCurve","isEarHashed","isEar","filterPoints","cureLocalIntersections","splitEarcut","pointInTriangle","minTX","minTY","maxTX","maxTY","zOrder","prevZ","nextZ","locallyInside","isValidDiagonal","splitPolygon","queue","getLeftmost","compareX","eliminateHole","hole","findHoleBridge","hx","hy","mx","my","tanMin","sectorContainsSector","sortLinked","tail","numMerges","pSize","qSize","inSize","leftmost","px","py","intersectsPolygon","middleInside","q1","q2","o1","o2","o3","o4","onSegment","num","inside","Node","an","bp","sum","contour","isClockWise","pts","ShapeUtils","triangulateShape","holes","faces","removeDupEndPts","addContour","holeIndex","verticesArray","addShape","placeholder","curveSegments","steps","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","extrudePath","uvgen","UVGenerator","WorldUVGenerator","amount","extrudePts","extrudeByPath","splineTube","binormal","position2","getSpacedPoints","computeFrenetFrames","shapePoints","extractPoints","reverse","hl","ahole","pt","vec","vlen","flen","inPt","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","contourMovements","getBevelVec","holesMovements","oneHoleMovements","verticesMovements","bs","vert","scalePt2","binormals","buildLidFaces","buildSideFaces","f3","layeroffset","sidewalls","sl","slen1","slen2","f4","addVertex","nextIndex","generateTopUV","addUV","generateSideWallUV","vector2","toJSON$1","indexA","indexB","indexC","a_x","a_y","b_x","b_y","c_x","c_y","indexD","a_z","b_z","c_z","d_x","d_y","d_z","phiStart","phiLength","inverseSegments","base","n1","func","slices","stacks","EPS","pu","pv","sliceCount","innerRadius","outerRadius","thetaSegments","phiSegments","radiusStep","thetaSegmentLevel","indexOffset","shapeVertices","shapeHoles","shapeHole","thetaEnd","grid","verticesRow","uOffset","ExtrudeGeometry","text","font","isFont","generateShapes","tube","tubularSegments","arc","P1","P2","B","T","N","calculatePositionOnCurve","cu","su","quOverP","cs","closed","frames","P","generateBufferData","generateSegment","generateIndices","getPointAt","edge","edges","o","ol","edge1","edge2","Geometries","BoxBufferGeometry","CircleGeometry","CircleBufferGeometry","ConeGeometry","ConeBufferGeometry","CylinderBufferGeometry","DodecahedronGeometry","DodecahedronBufferGeometry","EdgesGeometry","ExtrudeBufferGeometry","IcosahedronGeometry","IcosahedronBufferGeometry","LatheGeometry","LatheBufferGeometry","OctahedronGeometry","OctahedronBufferGeometry","ParametricGeometry","ParametricBufferGeometry","PlaneBufferGeometry","PolyhedronBufferGeometry","RingGeometry","RingBufferGeometry","ShapeGeometry","ShapeBufferGeometry","SphereGeometry","SphereBufferGeometry","TetrahedronGeometry","TetrahedronBufferGeometry","TextGeometry","TextBufferGeometry","TorusGeometry","TorusBufferGeometry","TorusKnotGeometry","TorusKnotBufferGeometry","TubeGeometry","TubeBufferGeometry","WireframeGeometry","RawShaderMaterial","ior","Materials","AnimationUtils","arraySlice","from","to","isTypedArray","convertArray","forceClone","ArrayBuffer","isView","DataView","getKeyframeOrder","times","compareTime","sortedArray","nValues","srcOffset","flattenJSON","jsonKeys","valuePropertyName","subclip","sourceClip","startFrame","endFrame","fps","clip","tracks","track","valueSize","getValueSize","minStartTime","resetDuration","makeClipAdditive","targetClip","referenceFrame","referenceClip","numTracks","referenceTime","referenceTrack","referenceTrackType","ValueTypeName","targetTrack","find","referenceOffset","referenceValueSize","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","targetOffset","targetValueSize","referenceValue","startIndex","endIndex","interpolant","evaluate","resultBuffer","referenceQuat","numTimes","valueStart","valueEnd","blendMode","parameterPositions","sampleValues","sampleSize","_cachedIndex","settings","DefaultSettings_","pp","validate_interval","linear_scan","forward_scan","giveUpAt","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","getSettings_","copySampleValue_","Interpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","endingStart","endingEnd","iPrev","iNext","tPrev","tNext","halfDt","o0","oP","oN","wP","wN","ppp","sP","sN","offset1","offset0","weight1","weight0","interpolation","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","trackType","getInterpolation","InterpolantFactoryMethodDiscrete","DiscreteInterpolant","InterpolantFactoryMethodLinear","LinearInterpolant","InterpolantFactoryMethodSmooth","CubicInterpolant","factoryMethod","timeOffset","timeScale","startTime","endTime","nKeys","validate","valid","prevTime","currTime","optimize","smoothInterpolation","writeIndex","keep","timeNext","offsetP","offsetN","readOffset","writeOffset","TypedKeyframeTrack","KeyframeTrack","BooleanKeyframeTrack","ColorKeyframeTrack","NumberKeyframeTrack","QuaternionLinearInterpolant","QuaternionKeyframeTrack","StringKeyframeTrack","VectorKeyframeTrack","duration","jsonTracks","frameTime","parseKeyframeTrack","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","findByName","objectOrClipArray","clipArray","CreateClipsFromMorphTargetSequences","animationToMorphTargets","pattern","morphTarget","parts","animationMorphTargets","clips","parseAnimation","addNonemptyTrack","trackName","animationKeys","propertyName","destTracks","clipName","hierarchyTracks","hierarchy","morphTargetNames","morphTargetName","animationKey","boneName","typeName","getTrackTypeForValueTypeName","Cache","files","file","onLoad","onProgress","onError","isLoading","itemsLoaded","itemsTotal","urlModifier","handlers","onStart","itemStart","itemEnd","itemError","resolveURL","setURLModifier","addHandler","regex","loader","removeHandler","getHandler","DefaultLoadingManager","LoadingManager","manager","crossOrigin","withCredentials","resourcePath","requestHeader","load","loadAsync","Promise","resolve","reject","setCrossOrigin","setWithCredentials","setPath","setResourcePath","setRequestHeader","loading","Loader","dataUriRegex","dataUriRegexResult","request","mimeType","isBase64","decodeURIComponent","atob","response","responseType","charCodeAt","Blob","parser","DOMParser","parseFromString","XMLHttpRequest","open","callbacks","overrideMimeType","header","send","setResponseType","setMimeType","FileLoader","AnimationClip","loaded","texDatas","mipmapCount","loadTexture","isCubemap","onImageLoad","onImageError","substr","urls","ImageLoader","texData","isJPEG","search","arcLengthDivisions","getPoint","optionalTarget","getUtoTmapping","getPoints","divisions","getLength","lengths","getLengths","cacheArcLengths","current","updateArcLengths","arcLengths","targetArcLength","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","t2","pt1","pt2","getTangentAt","mat","MAX_VALUE","tz","Curve","aX","aY","xRadius","yRadius","aStartAngle","aEndAngle","aClockwise","aRotation","twoPi","deltaAngle","samePoints","EllipseCurve","isEllipseCurve","aRadius","ArcCurve","isArcCurve","c0","initCatmullRom","x3","tension","initNonuniformCatmullRom","dt0","dt1","dt2","calc","t3","CubicPoly","pz","curveType","intPoint","CatmullRomCurve3","isCatmullRomCurve3","QuadraticBezierP0","QuadraticBezierP1","QuadraticBezierP2","CubicBezierP0","CubicBezierP1","CubicBezierP2","CubicBezierP3","v3","CubicBezier","CubicBezierCurve","isCubicBezierCurve","CubicBezierCurve3","isCubicBezierCurve3","LineCurve","isLineCurve","isLineCurve3","QuadraticBezier","QuadraticBezierCurve","isQuadraticBezierCurve","QuadraticBezierCurve3","isQuadraticBezierCurve3","CatmullRom","SplineCurve","isSplineCurve","Curves","LineCurve3","curves","autoClose","curve","closePath","startPoint","endPoint","curveLengths","getCurveLengths","diff","lens","cacheLengths","sums","CurvePath","currentPoint","moveTo","lineTo","quadraticCurveTo","aCPx","aCPy","bezierCurveTo","aCP1x","aCP1y","aCP2x","aCP2y","splineThru","npts","absarc","absellipse","ellipse","firstPoint","lastPoint","Path","getPointsHoles","holesPts","Light","HemisphereLight","_projScreenMatrix$1","_lightPositionWorld$1","_lookTarget$1","_frameExtents","_viewportCount","_viewports","shadowMatrix","viewportIndex","LightShadow","SpotLightShadow","isSpotLightShadow","power","SpotLight","_lightPositionWorld","_lookTarget","_cubeDirections","_cubeUps","PointLightShadow","PointLight","scaleW","scaleH","OrthographicCamera","DirectionalLightShadow","isDirectionalLightShadow","DirectionalLight","RectAreaLight","zero","getAt","coeff","getIrradianceAt","addScaledSH","getBasisAt","shBasis","SphericalHarmonics3","isSphericalHarmonics3","LightProbe","getTexture","shading","setTextures","decodeText","TextDecoder","decode","fromCharCode","escape","extractUrlBase","lastIndexOf","InstancedBufferGeometry","InstancedBufferAttribute","interleavedBufferMap","arrayBufferMap","getArrayBuffer","getTypedArray","arrayBuffer","typedArray","bufferAttribute","getInterleavedBuffer","bufferAttributeConstr","drawcalls","offsets","LoaderUtils","parseAnimations","parseShapes","parseGeometries","parseImages","parseTextures","parseMaterials","parseObject","parseSkeletons","bindSkeletons","hasImages","Shape","geometryShapes","bufferGeometryLoader","BufferGeometryLoader","details","MaterialLoader","loadImage","currentUrl","deserializedImage","deserializeImage","parseConstant","TEXTURE_MAPPING","TEXTURE_WRAPPING","TEXTURE_FILTER","getGeometry","getMaterial","LOD","objectAnimations","setTexturePath","createImageBitmap","fetch","setOptions","fetchOptions","credentials","headers","then","res","blob","colorSpaceConversion","imageBitmap","catch","ImageBitmapLoader","isImageBitmapLoader","subPaths","currentPath","toShapes","isCCW","noHoles","inSubpaths","tmpPath","tmpShape","inPolygon","polyLen","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","toShapesNoHoles","solid","holesFirst","betterShapeHoles","newShapes","newShapeHoles","mainIdx","tmpPoints","ambiguous","toChange","sIdx","sLen","sho","hIdx","ho","hole_unassigned","s2Idx","isPointInsidePolygon","froms","tos","tmpHoles","paths","createPaths","chars","line_height","yMax","yMin","underlineThickness","char","ret","createPath","glyph","glyphs","familyName","ShapePath","cpx","cpy","cpx1","cpy1","cpx2","cpy2","outline","_cachedOutline","action","ha","Font","substring","AudioContext","webkitAudioContext","bufferCopy","decodeAudioData","audioBuffer","sky","ground","HemisphereLightProbe","isHemisphereLightProbe","AmbientLightProbe","isAmbientLightProbe","_eyeRight","_eyeLeft","eyeSep","_cache","eyeSepHalf","eyeSepOnProjection","ymax","xmin","xmax","autoStart","oldTime","elapsedTime","running","getElapsedTime","getDelta","newTime","performance","_position$1","_quaternion$1","_scale$1","_orientation$1","gain","createGain","connect","destination","timeDelta","_clock","Clock","getInput","removeFilter","getFilter","setFilter","getMasterVolume","setMasterVolume","setTargetAtTime","currentTime","positionX","linearRampToValueAtTime","positionY","positionZ","forwardX","forwardY","forwardZ","upX","upY","upZ","setOrientation","autoplay","detune","loop","loopStart","loopEnd","playbackRate","isPlaying","hasPlaybackControl","sourceType","_startedAt","_progress","_connected","filters","getOutput","setNodeSource","audioNode","setMediaElementSource","mediaElement","createMediaElementSource","setMediaStreamSource","mediaStream","createMediaStreamSource","setBuffer","play","delay","createBufferSource","onended","onEnded","setDetune","setPlaybackRate","pause","getFilters","setFilters","getDetune","getPlaybackRate","getLoop","setLoop","setLoopStart","setLoopEnd","getVolume","setVolume","_position","_quaternion","_scale","_orientation","Audio","panner","createPanner","panningModel","getRefDistance","refDistance","setRefDistance","getRolloffFactor","rolloffFactor","setRolloffFactor","getDistanceModel","distanceModel","setDistanceModel","getMaxDistance","maxDistance","setMaxDistance","setDirectionalCone","coneInnerAngle","coneOuterAngle","coneOuterGain","orientationX","orientationY","orientationZ","audio","fftSize","analyser","createAnalyser","frequencyBinCount","getFrequencyData","getByteFrequencyData","getAverageFrequency","binding","mixFunction","mixFunctionAdditive","setIdentity","_slerp","_slerpAdditive","_setAdditiveIdentityQuaternion","_workIndex","_select","_setAdditiveIdentityOther","_lerp","_lerpAdditive","_setAdditiveIdentityNumeric","_mixBufferRegion","_mixBufferRegionAdditive","_setIdentity","_origIndex","_addIndex","cumulativeWeight","cumulativeWeightAdditive","useCount","referenceCount","accumulate","accuIndex","currentWeight","mix","accumulateAdditive","weightAdditive","originalValueOffset","saveOriginalState","getValue","restoreOriginalState","targetIndex","workOffset","_RESERVED_CHARS_RE","_reservedRe","_wordChar","_wordCharOrDot","_directoryRe","_nodeRe","_objectRe","_propertyRe","_trackRe","_supportedObjectNames","targetGroup","optionalParsedPath","parsedPath","PropertyBinding","parseTrackName","_targetGroup","_bindings","subscribe_","firstValidIndex","nCachedObjects_","bindings","unbind","rootNode","node","findNode","nodeName","_getValue_unbound","_setValue_unbound","create","isAnimationObjectGroup","Composite","sanitizeNodeName","matches","results","objectName","objectIndex","propertyIndex","lastDot","searchNodeSubtree","childNode","subTreeNode","_getValue_unavailable","_setValue_unavailable","_getValue_direct","_getValue_array","resolvedProperty","_getValue_arrayElement","_getValue_toArray","_setValue_direct","targetObject","_setValue_direct_setNeedsUpdate","_setValue_direct_setMatrixWorldNeedsUpdate","_setValue_array","dest","_setValue_array_setNeedsUpdate","_setValue_array_setMatrixWorldNeedsUpdate","_setValue_arrayElement","_setValue_arrayElement_setNeedsUpdate","_setValue_arrayElement_setMatrixWorldNeedsUpdate","_setValue_fromArray","_setValue_fromArray_setNeedsUpdate","_setValue_fromArray_setMatrixWorldNeedsUpdate","targetArray","sourceArray","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","ArrayElement","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","_indicesByUUID","_paths","_parsedPaths","_bindingsIndicesByPath","stats","total","inUse","bindingsPerObject","indicesByUUID","parsedPaths","nBindings","knownObject","nObjects","nCachedObjects","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","lastCachedIndex","firstActiveObject","firstActive","uncache","lastObject","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath","AnimationObjectGroup","mixer","localRoot","_mixer","_clip","_localRoot","nTracks","interpolants","interpolantSettings","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","_loopCount","_startTime","_effectiveTimeScale","_effectiveWeight","repetitions","paused","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","_activateAction","_deactivateAction","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setEffectiveWeight","getEffectiveWeight","fadeIn","_scheduleFading","fadeOut","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","halt","startTimeScale","endTimeScale","_lendControlInterpolant","timeScaleInterpolant","getMixer","getClip","getRoot","_root","_update","deltaTime","timeDirection","_updateWeight","timeRunning","_updateTimeScale","clipTime","_updateTime","propertyMixers","interpolantValue","loopCount","pingPong","_setEndings","handle_stop","loopDelta","pending","atStart","atEnd","weightNow","weightThen","_initMemoryManager","_accuIndex","_bindAction","prototypeAction","rootUuid","bindingsByRoot","_bindingsByRootAndName","bindingsByName","_addInactiveBinding","PropertyMixer","clipUuid","actionsForClip","_actionsByClip","knownActions","_addInactiveAction","_lendBinding","_lendAction","_takeBackBinding","_takeBackAction","_actions","_nActiveActions","_nActiveBindings","_controlInterpolants","_nActiveControlInterpolants","actions","controlInterpolants","actionsByClip","actionByRoot","_removeInactiveAction","lastInactiveAction","cacheIndex","knownActionsForClip","lastKnownAction","byClipCacheIndex","_removeInactiveBindingsForAction","_removeInactiveBinding","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","bindingByName","propBinding","lastInactiveBinding","firstInactiveBinding","lastActiveBinding","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","clipAction","optionalRoot","clipObject","existingAction","newAction","AnimationAction","stopAllAction","nActions","setTime","timeInSeconds","uncacheClip","actionsToRemove","uncacheRoot","uncacheAction","AnimationMixer","Uniform","InstancedInterleavedBuffer","setType","setItemSize","setCount","GLBufferAttribute","setFromCamera","coords","intersectObject","ascSort","intersectObjects","other","makeSafe","setFromCartesianCoords","_vector$4","Box2","isBox2","_startP","_startEnd","distanceSq","closestPointToPointParameter","clampToLine","startEnd2","startEnd_startP","ImmediateRenderObject","_vector$3","cone","coneLength","coneWidth","_vector$2","_boneMatrix","_matrixWorldInv","getBoneList","isSkeletonHelper","boneList","sphereSize","_vector$1","_color1","_color2","radials","circles","_v1","_v2","_v3","lightPlane","targetLine","_vector","_camera","pointMap","colorFrustum","colorCone","colorUp","colorTarget","colorCross","addLine","addPoint","setPoint","_box","positions2","_axis","_lineGeometry","_coneGeometry","headLength","headWidth","setDirection","setColor","_floatView","_int32View","toHalfFloat","val","LOD_MIN","LOD_MAX","SIZE_MAX","EXTRA_LOD_SIGMA","TOTAL_LODS","ENCODINGS","backgroundMaterial","backgroundBox","_flatCamera","_lodPlanes","_sizeLods","_sigmas","_createPlanes","_clearColor","_oldTarget","PHI","INV_PHI","_axisDirections","maxComponent","fExp","_pingPongRenderTarget","_blurMaterial","_getBlurShader","_equirectShader","_cubemapShader","_compileMaterial","fromScene","sigma","cubeUVRenderTarget","_allocateTargets","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","fromEquirectangular","equirectangular","_fromTexture","fromCubemap","compileCubemapShader","_getCubemapShader","compileEquirectangularShader","_getEquirectShader","outputTarget","_setViewport","_textureToCubeUV","_isLDR","_createRenderTarget","tmpMesh","cubeCamera","upSign","forwardSign","originalAutoClear","useSolidColor","convertLinearToRGBE","col","poleAxis","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","blurMaterial","STANDARD_DEVIATIONS","blurMesh","blurUniforms","pixels","radiansPerPixel","sigmaPixels","weights","outputSize","lod","sizeLod","texelSize","cubeFaces","positionSize","uvSize","faceIndexSize","coordinates","fill","shaderMaterial","_getCommonVertexShader","_getEncodings","LineStrip","LinePieces","NoColors","FaceColors","VertexColors","isMultiMaterial","Int8BufferAttribute","Uint8BufferAttribute","Uint8ClampedBufferAttribute","Int16BufferAttribute","Int32BufferAttribute","Float64BufferAttribute","construct","fromPoints","AxesHelper","BoxHelper","GridHelper","setColors","SkeletonHelper","Handlers","DataTextureLoader","empty","isIntersectionBox","isIntersectionSphere","setFromMatrix","Line3","flattenToArrayOffset","multiplyVector3","multiplyVector3Array","applyToBufferAttribute","applyToVector3Array","getInverse","extractPosition","getPosition","multiplyToArray","multiplyVector4","rotateAxis","crossVector","rotateByAxis","makeFrustum","isIntersectionLine","isIntersectionPlane","barycoordFromPoint","midpoint","prototypenormal","extractAllPoints","extrude","makeGeometry","fromAttribute","distanceToManhattan","lengthManhattan","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","getColumnFromMatrix","applyProjection","getChildByName","renderDepth","getWorldRotation","applyMatrix","eulerOrder","useQuaternion","setDrawMode","drawMode","initBones","setLens","onlyShadow","shadowCameraFov","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraVisible","shadowDarkness","shadowMapWidth","shadowMapHeight","dynamic","setDynamic","copyIndicesArray","setArray","addIndex","addAttribute","addDrawCall","clearDrawCalls","computeOffsets","removeAttribute","getArrays","addShapeList","wrapAround","overdraw","wrapRGB","clearTarget","animate","getCurrentRenderTarget","getPrecision","resetGLState","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","supportsInstancedArrays","enableScissorTest","initMaterial","addPrePlugin","addPostPlugin","updateShadowMap","setFaceCulling","allocTextureUnit","getActiveMipMapLevel","shadowMapCullFace","vr","gammaInput","gammaOutput","toneMappingWhitePoint","renderReverseSided","renderSingleSided","audioLoader","AudioLoader","AudioAnalyser","getData","updateCubeMap","TextureLoader","loadTextureCube","CubeTextureLoader","loadCompressedTexture","loadCompressedTextureCube","SceneUtils","createMultiMaterialObject","detach","revision","__THREE__","AnimationLoader","ArrowHelper","AudioListener","AxisHelper","BinaryTextureLoader","BoundingBoxHelper","Box3Helper","CameraHelper","CanvasRenderer","CompressedTextureLoader","Cylindrical","DataUtils","DirectionalLightHelper","DynamicBufferAttribute","EdgesHelper","Float32Attribute","Float64Attribute","FontLoader","HemisphereLightHelper","Int16Attribute","Int32Attribute","Int8Attribute","JSONLoader","LensFlare","MeshFaceMaterial","MultiMaterial","ObjectLoader","PMREMGenerator","Particle","ParticleBasicMaterial","ParticleSystem","ParticleSystemMaterial","PlaneHelper","PointCloud","PointCloudMaterial","PointLightHelper","PolarGridHelper","PositionalAudio","Raycaster","Spherical","SpotLightHelper","StereoCamera","Uint16Attribute","Uint32Attribute","Uint8Attribute","Uint8ClampedAttribute","Vertex","WebGLRenderTargetCube","WireframeHelper","XHRLoader","OrbitControls","AddRenderer","AddCamera","AddControls","HandleResize","innerWidth","innerHeight","controls","autoRotate","enableDamping","dampingFactor","clientWidth","clientHeight","devicePixelRatio"],"version":3,"file":"index.72166a09.js.map","sourceRoot":"/__parcel_source_root/"}