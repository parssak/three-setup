{"mappings":"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eA;IACfC,eAAeA;IACfC,gBAAgBA;IAChBC,gBAAgBA;IAChBC,mBAAmBA;IACnBC,mBAAmBA;IACnBC,aAAaA;IACbC,aAAaA;IACbC,aAAaA;IACbC,aAAaA;IACbC,aAAaA;IACbC,aAAaA;IACbC,aAAaA;IACbC,aAAaA;;;;;QAORE;IACLjH;MACCkH;QACCt5C,WAAW08B,MAAM;;MAElBjJ;QACCzzB,OAAO;;MAERlU;QACCkU,OAAO;;MAERu5C;QACCv5C,WAAWoM;;MAEZotC;QACCx5C,WAAWoM;;MAEZ+qB;QACCn3B,OAAO;;;IAGTy5C;MACCthB;QACCn4B,OAAO;;;IAGT05C;MACCthB;QACCp4B,OAAO;;MAER25C;QACC35C,QAAQ;;MAETu4B;QACCv4B,OAAO;;MAERw4B;QACCx4B,OAAO;;MAER45C;QACC55C,OAAO;;;IAGT65C;MACCviB;QACCt3B,OAAO;;MAERu3B;QACCv3B,OAAO;;;IAGT85C;MACC1iB;QACCp3B,OAAO;;MAERq3B;QACCr3B,OAAO;;;IAGT+5C;MACC7hB;QACCl4B,OAAO;;;IAGTg6C;MACCxiB;QACCx3B,OAAO;;MAERy3B;QACCz3B,OAAO;;;IAGTi6C;MACCviB;QACC13B,OAAO;;MAER43B;QACC53B,WAAW2H,QAAQ,GAAG;;;IAGxBuyC;MACCriB;QACC73B,OAAO;;MAER83B;QACC93B,OAAO;;MAER+3B;QACC/3B,OAAO;;;IAGTm6C;MACCniB;QACCh4B,OAAO;;;IAGTo6C;MACCniB;QACCj4B,OAAO;;;IAGTq6C;MACC5hB;QACCz4B,OAAO;;;IAGT/O;MACCqpD;QACCt6C,OAAO;;MAERu6C;QACCv6C,OAAO;;MAERw6C;QACCx6C,OAAO;;MAERy6C;QACCz6C,WAAW08B,MAAM;;;IAGnBiM;MACC+R;QACC16C;;MAED26C;QACC36C;;MAED46C;QACC56C;QACA66C;UACC16B;UACAgW;;;MAGF2kB;QACC96C;QACA66C;UACCE;UACAC;UACAC;UACAC;;;MAGFC;QACCn7C;;MAEDo7C;QACCp7C;;MAEDq7C;QACCr7C;QACA66C;UACC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Q,KAAK5nB,SAAS8wF;IAE7D,KAAK05D,SAASC,aAAa;IAC3B,KAAKD,SAASE,gBAAgB;IAC9B,KAAKF,SAASG,gBAAgB;IAC9B,KAAK/iI,OAAOsO,SAAS9W,IAAI;IAEzB,KAAKorI,SAASlmI;;;;;EAMhB+lI;IACE,KAAKziI,OAAOoxB,SAAS,KAAKqmB,UAAUurF,cAAc,KAAKvrF,UAAUwrF;IACjE,KAAKjjI,OAAO0xB;IAEZ,KAAKt5C,SAASyhB,QAAQ,KAAK49C,UAAUurF,aAAa,KAAKvrF,UAAUwrF;IACjE,KAAK7qJ,SAASm1F,cAAc37F,OAAOsxJ;;;;;EAMrC1sJ;IACE,KAAKosJ,SAASlmI;IACd,KAAKtkB,SAASu7C,OAAO,KAAKn8C,OAAO,KAAKwoB;;;;;;ACpE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../../.config/yarn/global/node_modules/@parcel/runtime-browser-hmr/lib/HMRRuntime.js","./src/app.js","./src/setup/index.js","./src/setup/Scene.js","../node_modules/three/build/three.js","./src/setup/CameraController.js","../node_modules/three-orbit-controls/index.js","../../.config/yarn/global/node_modules/@parcel/transformer-js/lib/esmodule-helpers.js","../node_modules/uuid/dist/index.js","../node_modules/uuid/dist/v1.js","../node_modules/uuid/dist/rng-browser.js","../node_modules/uuid/dist/stringify.js","../node_modules/uuid/dist/validate.js","../node_modules/uuid/dist/regex.js","../node_modules/uuid/dist/v3.js","../node_modules/uuid/dist/v35.js","../node_modules/uuid/dist/parse.js","../node_modules/uuid/dist/md5-browser.js","../node_modules/uuid/dist/v4.js","../node_modules/uuid/dist/v5.js","../node_modules/uuid/dist/sha1-browser.js","../node_modules/uuid/dist/nil.js","../node_modules/uuid/dist/version.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _plugin() {\n  const data = require(\"@parcel/plugin\");\n\n  _plugin = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fs() {\n  const data = _interopRequireDefault(require(\"fs\"));\n\n  _fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _utils() {\n  const data = require(\"@parcel/utils\");\n\n  _utils = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst HMR_RUNTIME = _fs().default.readFileSync(_path().default.join(__dirname, './loaders/hmr-runtime.js'), 'utf8');\n\nvar _default = new (_plugin().Runtime)({\n  apply({\n    bundle,\n    options\n  }) {\n    if (bundle.type !== 'js' || !options.hmrOptions) {\n      return;\n    }\n\n    const {\n      host,\n      port\n    } = options.hmrOptions;\n    return {\n      filePath: __filename,\n      code: `var HMR_HOST = ${JSON.stringify(host != null ? host : null)};` + `var HMR_PORT = ${JSON.stringify(port != null ? port : null)};` + `var HMR_SECURE = ${JSON.stringify(!!(options.serveOptions && options.serveOptions.https))};` + `var HMR_ENV_HASH = \"${(0, _utils().md5FromObject)(bundle.env)}\";` + `module.bundle.HMR_BUNDLE_ID = ${JSON.stringify(bundle.id)};` + HMR_RUNTIME,\n      isEntry: true\n    };\n  }\n\n});\n\nexports.default = _default;",null,null,null,"/**\n * @license\n * Copyright 2010-2021 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.THREE = {}));\n}(this, (function (exports) { 'use strict';\n\n\tconst REVISION = '129';\n\tconst MOUSE = {\n\t\tLEFT: 0,\n\t\tMIDDLE: 1,\n\t\tRIGHT: 2,\n\t\tROTATE: 0,\n\t\tDOLLY: 1,\n\t\tPAN: 2\n\t};\n\tconst TOUCH = {\n\t\tROTATE: 0,\n\t\tPAN: 1,\n\t\tDOLLY_PAN: 2,\n\t\tDOLLY_ROTATE: 3\n\t};\n\tconst CullFaceNone = 0;\n\tconst CullFaceBack = 1;\n\tconst CullFaceFront = 2;\n\tconst CullFaceFrontBack = 3;\n\tconst BasicShadowMap = 0;\n\tconst PCFShadowMap = 1;\n\tconst PCFSoftShadowMap = 2;\n\tconst VSMShadowMap = 3;\n\tconst FrontSide = 0;\n\tconst BackSide = 1;\n\tconst DoubleSide = 2;\n\tconst FlatShading = 1;\n\tconst SmoothShading = 2;\n\tconst NoBlending = 0;\n\tconst NormalBlending = 1;\n\tconst AdditiveBlending = 2;\n\tconst SubtractiveBlending = 3;\n\tconst MultiplyBlending = 4;\n\tconst CustomBlending = 5;\n\tconst AddEquation = 100;\n\tconst SubtractEquation = 101;\n\tconst ReverseSubtractEquation = 102;\n\tconst MinEquation = 103;\n\tconst MaxEquation = 104;\n\tconst ZeroFactor = 200;\n\tconst OneFactor = 201;\n\tconst SrcColorFactor = 202;\n\tconst OneMinusSrcColorFactor = 203;\n\tconst SrcAlphaFactor = 204;\n\tconst OneMinusSrcAlphaFactor = 205;\n\tconst DstAlphaFactor = 206;\n\tconst OneMinusDstAlphaFactor = 207;\n\tconst DstColorFactor = 208;\n\tconst OneMinusDstColorFactor = 209;\n\tconst SrcAlphaSaturateFactor = 210;\n\tconst NeverDepth = 0;\n\tconst AlwaysDepth = 1;\n\tconst LessDepth = 2;\n\tconst LessEqualDepth = 3;\n\tconst EqualDepth = 4;\n\tconst GreaterEqualDepth = 5;\n\tconst GreaterDepth = 6;\n\tconst NotEqualDepth = 7;\n\tconst MultiplyOperation = 0;\n\tconst MixOperation = 1;\n\tconst AddOperation = 2;\n\tconst NoToneMapping = 0;\n\tconst LinearToneMapping = 1;\n\tconst ReinhardToneMapping = 2;\n\tconst CineonToneMapping = 3;\n\tconst ACESFilmicToneMapping = 4;\n\tconst CustomToneMapping = 5;\n\tconst UVMapping = 300;\n\tconst CubeReflectionMapping = 301;\n\tconst CubeRefractionMapping = 302;\n\tconst EquirectangularReflectionMapping = 303;\n\tconst EquirectangularRefractionMapping = 304;\n\tconst CubeUVReflectionMapping = 306;\n\tconst CubeUVRefractionMapping = 307;\n\tconst RepeatWrapping = 1000;\n\tconst ClampToEdgeWrapping = 1001;\n\tconst MirroredRepeatWrapping = 1002;\n\tconst NearestFilter = 1003;\n\tconst NearestMipmapNearestFilter = 1004;\n\tconst NearestMipMapNearestFilter = 1004;\n\tconst NearestMipmapLinearFilter = 1005;\n\tconst NearestMipMapLinearFilter = 1005;\n\tconst LinearFilter = 1006;\n\tconst LinearMipmapNearestFilter = 1007;\n\tconst LinearMipMapNearestFilter = 1007;\n\tconst LinearMipmapLinearFilter = 1008;\n\tconst LinearMipMapLinearFilter = 1008;\n\tconst UnsignedByteType = 1009;\n\tconst ByteType = 1010;\n\tconst ShortType = 1011;\n\tconst UnsignedShortType = 1012;\n\tconst IntType = 1013;\n\tconst UnsignedIntType = 1014;\n\tconst FloatType = 1015;\n\tconst HalfFloatType = 1016;\n\tconst UnsignedShort4444Type = 1017;\n\tconst UnsignedShort5551Type = 1018;\n\tconst UnsignedShort565Type = 1019;\n\tconst UnsignedInt248Type = 1020;\n\tconst AlphaFormat = 1021;\n\tconst RGBFormat = 1022;\n\tconst RGBAFormat = 1023;\n\tconst LuminanceFormat = 1024;\n\tconst LuminanceAlphaFormat = 1025;\n\tconst RGBEFormat = RGBAFormat;\n\tconst DepthFormat = 1026;\n\tconst DepthStencilFormat = 1027;\n\tconst RedFormat = 1028;\n\tconst RedIntegerFormat = 1029;\n\tconst RGFormat = 1030;\n\tconst RGIntegerFormat = 1031;\n\tconst RGBIntegerFormat = 1032;\n\tconst RGBAIntegerFormat = 1033;\n\tconst RGB_S3TC_DXT1_Format = 33776;\n\tconst RGBA_S3TC_DXT1_Format = 33777;\n\tconst RGBA_S3TC_DXT3_Format = 33778;\n\tconst RGBA_S3TC_DXT5_Format = 33779;\n\tconst RGB_PVRTC_4BPPV1_Format = 35840;\n\tconst RGB_PVRTC_2BPPV1_Format = 35841;\n\tconst RGBA_PVRTC_4BPPV1_Format = 35842;\n\tconst RGBA_PVRTC_2BPPV1_Format = 35843;\n\tconst RGB_ETC1_Format = 36196;\n\tconst RGB_ETC2_Format = 37492;\n\tconst RGBA_ETC2_EAC_Format = 37496;\n\tconst RGBA_ASTC_4x4_Format = 37808;\n\tconst RGBA_ASTC_5x4_Format = 37809;\n\tconst RGBA_ASTC_5x5_Format = 37810;\n\tconst RGBA_ASTC_6x5_Format = 37811;\n\tconst RGBA_ASTC_6x6_Format = 37812;\n\tconst RGBA_ASTC_8x5_Format = 37813;\n\tconst RGBA_ASTC_8x6_Format = 37814;\n\tconst RGBA_ASTC_8x8_Format = 37815;\n\tconst RGBA_ASTC_10x5_Format = 37816;\n\tconst RGBA_ASTC_10x6_Format = 37817;\n\tconst RGBA_ASTC_10x8_Format = 37818;\n\tconst RGBA_ASTC_10x10_Format = 37819;\n\tconst RGBA_ASTC_12x10_Format = 37820;\n\tconst RGBA_ASTC_12x12_Format = 37821;\n\tconst RGBA_BPTC_Format = 36492;\n\tconst SRGB8_ALPHA8_ASTC_4x4_Format = 37840;\n\tconst SRGB8_ALPHA8_ASTC_5x4_Format = 37841;\n\tconst SRGB8_ALPHA8_ASTC_5x5_Format = 37842;\n\tconst SRGB8_ALPHA8_ASTC_6x5_Format = 37843;\n\tconst SRGB8_ALPHA8_ASTC_6x6_Format = 37844;\n\tconst SRGB8_ALPHA8_ASTC_8x5_Format = 37845;\n\tconst SRGB8_ALPHA8_ASTC_8x6_Format = 37846;\n\tconst SRGB8_ALPHA8_ASTC_8x8_Format = 37847;\n\tconst SRGB8_ALPHA8_ASTC_10x5_Format = 37848;\n\tconst SRGB8_ALPHA8_ASTC_10x6_Format = 37849;\n\tconst SRGB8_ALPHA8_ASTC_10x8_Format = 37850;\n\tconst SRGB8_ALPHA8_ASTC_10x10_Format = 37851;\n\tconst SRGB8_ALPHA8_ASTC_12x10_Format = 37852;\n\tconst SRGB8_ALPHA8_ASTC_12x12_Format = 37853;\n\tconst LoopOnce = 2200;\n\tconst LoopRepeat = 2201;\n\tconst LoopPingPong = 2202;\n\tconst InterpolateDiscrete = 2300;\n\tconst InterpolateLinear = 2301;\n\tconst InterpolateSmooth = 2302;\n\tconst ZeroCurvatureEnding = 2400;\n\tconst ZeroSlopeEnding = 2401;\n\tconst WrapAroundEnding = 2402;\n\tconst NormalAnimationBlendMode = 2500;\n\tconst AdditiveAnimationBlendMode = 2501;\n\tconst TrianglesDrawMode = 0;\n\tconst TriangleStripDrawMode = 1;\n\tconst TriangleFanDrawMode = 2;\n\tconst LinearEncoding = 3000;\n\tconst sRGBEncoding = 3001;\n\tconst GammaEncoding = 3007;\n\tconst RGBEEncoding = 3002;\n\tconst LogLuvEncoding = 3003;\n\tconst RGBM7Encoding = 3004;\n\tconst RGBM16Encoding = 3005;\n\tconst RGBDEncoding = 3006;\n\tconst BasicDepthPacking = 3200;\n\tconst RGBADepthPacking = 3201;\n\tconst TangentSpaceNormalMap = 0;\n\tconst ObjectSpaceNormalMap = 1;\n\tconst ZeroStencilOp = 0;\n\tconst KeepStencilOp = 7680;\n\tconst ReplaceStencilOp = 7681;\n\tconst IncrementStencilOp = 7682;\n\tconst DecrementStencilOp = 7683;\n\tconst IncrementWrapStencilOp = 34055;\n\tconst DecrementWrapStencilOp = 34056;\n\tconst InvertStencilOp = 5386;\n\tconst NeverStencilFunc = 512;\n\tconst LessStencilFunc = 513;\n\tconst EqualStencilFunc = 514;\n\tconst LessEqualStencilFunc = 515;\n\tconst GreaterStencilFunc = 516;\n\tconst NotEqualStencilFunc = 517;\n\tconst GreaterEqualStencilFunc = 518;\n\tconst AlwaysStencilFunc = 519;\n\tconst StaticDrawUsage = 35044;\n\tconst DynamicDrawUsage = 35048;\n\tconst StreamDrawUsage = 35040;\n\tconst StaticReadUsage = 35045;\n\tconst DynamicReadUsage = 35049;\n\tconst StreamReadUsage = 35041;\n\tconst StaticCopyUsage = 35046;\n\tconst DynamicCopyUsage = 35050;\n\tconst StreamCopyUsage = 35042;\n\tconst GLSL1 = '100';\n\tconst GLSL3 = '300 es';\n\n\t/**\n\t * https://github.com/mrdoob/eventdispatcher.js/\n\t */\n\tclass EventDispatcher {\n\t\taddEventListener(type, listener) {\n\t\t\tif (this._listeners === undefined) this._listeners = {};\n\t\t\tconst listeners = this._listeners;\n\n\t\t\tif (listeners[type] === undefined) {\n\t\t\t\tlisteners[type] = [];\n\t\t\t}\n\n\t\t\tif (listeners[type].indexOf(listener) === -1) {\n\t\t\t\tlisteners[type].push(listener);\n\t\t\t}\n\t\t}\n\n\t\thasEventListener(type, listener) {\n\t\t\tif (this._listeners === undefined) return false;\n\t\t\tconst listeners = this._listeners;\n\t\t\treturn listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;\n\t\t}\n\n\t\tremoveEventListener(type, listener) {\n\t\t\tif (this._listeners === undefined) return;\n\t\t\tconst listeners = this._listeners;\n\t\t\tconst listenerArray = listeners[type];\n\n\t\t\tif (listenerArray !== undefined) {\n\t\t\t\tconst index = listenerArray.indexOf(listener);\n\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tlistenerArray.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdispatchEvent(event) {\n\t\t\tif (this._listeners === undefined) return;\n\t\t\tconst listeners = this._listeners;\n\t\t\tconst listenerArray = listeners[event.type];\n\n\t\t\tif (listenerArray !== undefined) {\n\t\t\t\tevent.target = this; // Make a copy, in case listeners are removed while iterating.\n\n\t\t\t\tconst array = listenerArray.slice(0);\n\n\t\t\t\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\t\t\t\tarray[i].call(this, event);\n\t\t\t\t}\n\n\t\t\t\tevent.target = null;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tconst _lut = [];\n\n\tfor (let i = 0; i < 256; i++) {\n\t\t_lut[i] = (i < 16 ? '0' : '') + i.toString(16);\n\t}\n\n\tlet _seed = 1234567;\n\tconst DEG2RAD = Math.PI / 180;\n\tconst RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n\tfunction generateUUID() {\n\t\tconst d0 = Math.random() * 0xffffffff | 0;\n\t\tconst d1 = Math.random() * 0xffffffff | 0;\n\t\tconst d2 = Math.random() * 0xffffffff | 0;\n\t\tconst d3 = Math.random() * 0xffffffff | 0;\n\t\tconst uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.\n\n\t\treturn uuid.toUpperCase();\n\t}\n\n\tfunction clamp(value, min, max) {\n\t\treturn Math.max(min, Math.min(max, value));\n\t} // compute euclidian modulo of m % n\n\t// https://en.wikipedia.org/wiki/Modulo_operation\n\n\n\tfunction euclideanModulo(n, m) {\n\t\treturn (n % m + m) % m;\n\t} // Linear mapping from range <a1, a2> to range <b1, b2>\n\n\n\tfunction mapLinear(x, a1, a2, b1, b2) {\n\t\treturn b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n\t} // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\n\n\n\tfunction inverseLerp(x, y, value) {\n\t\tif (x !== y) {\n\t\t\treturn (value - x) / (y - x);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t} // https://en.wikipedia.org/wiki/Linear_interpolation\n\n\n\tfunction lerp(x, y, t) {\n\t\treturn (1 - t) * x + t * y;\n\t} // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\n\n\n\tfunction damp(x, y, lambda, dt) {\n\t\treturn lerp(x, y, 1 - Math.exp(-lambda * dt));\n\t} // https://www.desmos.com/calculator/vcsjnyz7x4\n\n\n\tfunction pingpong(x, length = 1) {\n\t\treturn length - Math.abs(euclideanModulo(x, length * 2) - length);\n\t} // http://en.wikipedia.org/wiki/Smoothstep\n\n\n\tfunction smoothstep(x, min, max) {\n\t\tif (x <= min) return 0;\n\t\tif (x >= max) return 1;\n\t\tx = (x - min) / (max - min);\n\t\treturn x * x * (3 - 2 * x);\n\t}\n\n\tfunction smootherstep(x, min, max) {\n\t\tif (x <= min) return 0;\n\t\tif (x >= max) return 1;\n\t\tx = (x - min) / (max - min);\n\t\treturn x * x * x * (x * (x * 6 - 15) + 10);\n\t} // Random integer from <low, high> interval\n\n\n\tfunction randInt(low, high) {\n\t\treturn low + Math.floor(Math.random() * (high - low + 1));\n\t} // Random float from <low, high> interval\n\n\n\tfunction randFloat(low, high) {\n\t\treturn low + Math.random() * (high - low);\n\t} // Random float from <-range/2, range/2> interval\n\n\n\tfunction randFloatSpread(range) {\n\t\treturn range * (0.5 - Math.random());\n\t} // Deterministic pseudo-random float in the interval [ 0, 1 ]\n\n\n\tfunction seededRandom(s) {\n\t\tif (s !== undefined) _seed = s % 2147483647; // Park-Miller algorithm\n\n\t\t_seed = _seed * 16807 % 2147483647;\n\t\treturn (_seed - 1) / 2147483646;\n\t}\n\n\tfunction degToRad(degrees) {\n\t\treturn degrees * DEG2RAD;\n\t}\n\n\tfunction radToDeg(radians) {\n\t\treturn radians * RAD2DEG;\n\t}\n\n\tfunction isPowerOfTwo(value) {\n\t\treturn (value & value - 1) === 0 && value !== 0;\n\t}\n\n\tfunction ceilPowerOfTwo(value) {\n\t\treturn Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n\t}\n\n\tfunction floorPowerOfTwo(value) {\n\t\treturn Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\n\t}\n\n\tfunction setQuaternionFromProperEuler(q, a, b, c, order) {\n\t\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\t\t// rotations are applied to the axes in the order specified by 'order'\n\t\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t\t// angles are in radians\n\t\tconst cos = Math.cos;\n\t\tconst sin = Math.sin;\n\t\tconst c2 = cos(b / 2);\n\t\tconst s2 = sin(b / 2);\n\t\tconst c13 = cos((a + c) / 2);\n\t\tconst s13 = sin((a + c) / 2);\n\t\tconst c1_3 = cos((a - c) / 2);\n\t\tconst s1_3 = sin((a - c) / 2);\n\t\tconst c3_1 = cos((c - a) / 2);\n\t\tconst s3_1 = sin((c - a) / 2);\n\n\t\tswitch (order) {\n\t\t\tcase 'XYX':\n\t\t\t\tq.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZY':\n\t\t\t\tq.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXZ':\n\t\t\t\tq.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZX':\n\t\t\t\tq.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXY':\n\t\t\t\tq.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYZ':\n\t\t\t\tq.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);\n\t\t}\n\t}\n\n\tvar MathUtils = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tDEG2RAD: DEG2RAD,\n\t\tRAD2DEG: RAD2DEG,\n\t\tgenerateUUID: generateUUID,\n\t\tclamp: clamp,\n\t\teuclideanModulo: euclideanModulo,\n\t\tmapLinear: mapLinear,\n\t\tinverseLerp: inverseLerp,\n\t\tlerp: lerp,\n\t\tdamp: damp,\n\t\tpingpong: pingpong,\n\t\tsmoothstep: smoothstep,\n\t\tsmootherstep: smootherstep,\n\t\trandInt: randInt,\n\t\trandFloat: randFloat,\n\t\trandFloatSpread: randFloatSpread,\n\t\tseededRandom: seededRandom,\n\t\tdegToRad: degToRad,\n\t\tradToDeg: radToDeg,\n\t\tisPowerOfTwo: isPowerOfTwo,\n\t\tceilPowerOfTwo: ceilPowerOfTwo,\n\t\tfloorPowerOfTwo: floorPowerOfTwo,\n\t\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler\n\t});\n\n\tclass Vector2 {\n\t\tconstructor(x = 0, y = 0) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tget width() {\n\t\t\treturn this.x;\n\t\t}\n\n\t\tset width(value) {\n\t\t\tthis.x = value;\n\t\t}\n\n\t\tget height() {\n\t\t\treturn this.y;\n\t\t}\n\n\t\tset height(value) {\n\t\t\tthis.y = value;\n\t\t}\n\n\t\tset(x, y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetScalar(scalar) {\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetX(x) {\n\t\t\tthis.x = x;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetY(y) {\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetComponent(index, value) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.x = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tthis.y = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetComponent(index) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn this.x;\n\n\t\t\t\tcase 1:\n\t\t\t\t\treturn this.y;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.x, this.y);\n\t\t}\n\n\t\tcopy(v) {\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tadd(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n\t\t\t\treturn this.addVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScalar(s) {\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\treturn this;\n\t\t}\n\n\t\taddVectors(a, b) {\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScaledVector(v, s) {\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsub(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n\t\t\t\treturn this.subVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubScalar(s) {\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubVectors(a, b) {\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(v) {\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(scalar) {\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tdivide(v) {\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tdivideScalar(scalar) {\n\t\t\treturn this.multiplyScalar(1 / scalar);\n\t\t}\n\n\t\tapplyMatrix3(m) {\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y;\n\t\t\tconst e = m.elements;\n\t\t\tthis.x = e[0] * x + e[3] * y + e[6];\n\t\t\tthis.y = e[1] * x + e[4] * y + e[7];\n\t\t\treturn this;\n\t\t}\n\n\t\tmin(v) {\n\t\t\tthis.x = Math.min(this.x, v.x);\n\t\t\tthis.y = Math.min(this.y, v.y);\n\t\t\treturn this;\n\t\t}\n\n\t\tmax(v) {\n\t\t\tthis.x = Math.max(this.x, v.x);\n\t\t\tthis.y = Math.max(this.y, v.y);\n\t\t\treturn this;\n\t\t}\n\n\t\tclamp(min, max) {\n\t\t\t// assumes min < max, componentwise\n\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\n\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampScalar(minVal, maxVal) {\n\t\t\tthis.x = Math.max(minVal, Math.min(maxVal, this.x));\n\t\t\tthis.y = Math.max(minVal, Math.min(maxVal, this.y));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampLength(min, max) {\n\t\t\tconst length = this.length();\n\t\t\treturn this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n\t\t}\n\n\t\tfloor() {\n\t\t\tthis.x = Math.floor(this.x);\n\t\t\tthis.y = Math.floor(this.y);\n\t\t\treturn this;\n\t\t}\n\n\t\tceil() {\n\t\t\tthis.x = Math.ceil(this.x);\n\t\t\tthis.y = Math.ceil(this.y);\n\t\t\treturn this;\n\t\t}\n\n\t\tround() {\n\t\t\tthis.x = Math.round(this.x);\n\t\t\tthis.y = Math.round(this.y);\n\t\t\treturn this;\n\t\t}\n\n\t\troundToZero() {\n\t\t\tthis.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n\t\t\tthis.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n\t\t\treturn this;\n\t\t}\n\n\t\tnegate() {\n\t\t\tthis.x = -this.x;\n\t\t\tthis.y = -this.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tdot(v) {\n\t\t\treturn this.x * v.x + this.y * v.y;\n\t\t}\n\n\t\tcross(v) {\n\t\t\treturn this.x * v.y - this.y * v.x;\n\t\t}\n\n\t\tlengthSq() {\n\t\t\treturn this.x * this.x + this.y * this.y;\n\t\t}\n\n\t\tlength() {\n\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t\t}\n\n\t\tmanhattanLength() {\n\t\t\treturn Math.abs(this.x) + Math.abs(this.y);\n\t\t}\n\n\t\tnormalize() {\n\t\t\treturn this.divideScalar(this.length() || 1);\n\t\t}\n\n\t\tangle() {\n\t\t\t// computes the angle in radians with respect to the positive x-axis\n\t\t\tconst angle = Math.atan2(-this.y, -this.x) + Math.PI;\n\t\t\treturn angle;\n\t\t}\n\n\t\tdistanceTo(v) {\n\t\t\treturn Math.sqrt(this.distanceToSquared(v));\n\t\t}\n\n\t\tdistanceToSquared(v) {\n\t\t\tconst dx = this.x - v.x,\n\t\t\t\t\t\tdy = this.y - v.y;\n\t\t\treturn dx * dx + dy * dy;\n\t\t}\n\n\t\tmanhattanDistanceTo(v) {\n\t\t\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n\t\t}\n\n\t\tsetLength(length) {\n\t\t\treturn this.normalize().multiplyScalar(length);\n\t\t}\n\n\t\tlerp(v, alpha) {\n\t\t\tthis.x += (v.x - this.x) * alpha;\n\t\t\tthis.y += (v.y - this.y) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerpVectors(v1, v2, alpha) {\n\t\t\tthis.x = v1.x + (v2.x - v1.x) * alpha;\n\t\t\tthis.y = v1.y + (v2.y - v1.y) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(v) {\n\t\t\treturn v.x === this.x && v.y === this.y;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tthis.x = array[offset];\n\t\t\tthis.y = array[offset + 1];\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this.x;\n\t\t\tarray[offset + 1] = this.y;\n\t\t\treturn array;\n\t\t}\n\n\t\tfromBufferAttribute(attribute, index, offset) {\n\t\t\tif (offset !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');\n\t\t\t}\n\n\t\t\tthis.x = attribute.getX(index);\n\t\t\tthis.y = attribute.getY(index);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateAround(center, angle) {\n\t\t\tconst c = Math.cos(angle),\n\t\t\t\t\t\ts = Math.sin(angle);\n\t\t\tconst x = this.x - center.x;\n\t\t\tconst y = this.y - center.y;\n\t\t\tthis.x = x * c - y * s + center.x;\n\t\t\tthis.y = x * s + y * c + center.y;\n\t\t\treturn this;\n\t\t}\n\n\t\trandom() {\n\t\t\tthis.x = Math.random();\n\t\t\tthis.y = Math.random();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tVector2.prototype.isVector2 = true;\n\n\tclass Matrix3 {\n\t\tconstructor() {\n\t\t\tthis.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n\t\t\tif (arguments.length > 0) {\n\t\t\t\tconsole.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');\n\t\t\t}\n\t\t}\n\n\t\tset(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] = n11;\n\t\t\tte[1] = n21;\n\t\t\tte[2] = n31;\n\t\t\tte[3] = n12;\n\t\t\tte[4] = n22;\n\t\t\tte[5] = n32;\n\t\t\tte[6] = n13;\n\t\t\tte[7] = n23;\n\t\t\tte[8] = n33;\n\t\t\treturn this;\n\t\t}\n\n\t\tidentity() {\n\t\t\tthis.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(m) {\n\t\t\tconst te = this.elements;\n\t\t\tconst me = m.elements;\n\t\t\tte[0] = me[0];\n\t\t\tte[1] = me[1];\n\t\t\tte[2] = me[2];\n\t\t\tte[3] = me[3];\n\t\t\tte[4] = me[4];\n\t\t\tte[5] = me[5];\n\t\t\tte[6] = me[6];\n\t\t\tte[7] = me[7];\n\t\t\tte[8] = me[8];\n\t\t\treturn this;\n\t\t}\n\n\t\textractBasis(xAxis, yAxis, zAxis) {\n\t\t\txAxis.setFromMatrix3Column(this, 0);\n\t\t\tyAxis.setFromMatrix3Column(this, 1);\n\t\t\tzAxis.setFromMatrix3Column(this, 2);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromMatrix4(m) {\n\t\t\tconst me = m.elements;\n\t\t\tthis.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(m) {\n\t\t\treturn this.multiplyMatrices(this, m);\n\t\t}\n\n\t\tpremultiply(m) {\n\t\t\treturn this.multiplyMatrices(m, this);\n\t\t}\n\n\t\tmultiplyMatrices(a, b) {\n\t\t\tconst ae = a.elements;\n\t\t\tconst be = b.elements;\n\t\t\tconst te = this.elements;\n\t\t\tconst a11 = ae[0],\n\t\t\t\t\t\ta12 = ae[3],\n\t\t\t\t\t\ta13 = ae[6];\n\t\t\tconst a21 = ae[1],\n\t\t\t\t\t\ta22 = ae[4],\n\t\t\t\t\t\ta23 = ae[7];\n\t\t\tconst a31 = ae[2],\n\t\t\t\t\t\ta32 = ae[5],\n\t\t\t\t\t\ta33 = ae[8];\n\t\t\tconst b11 = be[0],\n\t\t\t\t\t\tb12 = be[3],\n\t\t\t\t\t\tb13 = be[6];\n\t\t\tconst b21 = be[1],\n\t\t\t\t\t\tb22 = be[4],\n\t\t\t\t\t\tb23 = be[7];\n\t\t\tconst b31 = be[2],\n\t\t\t\t\t\tb32 = be[5],\n\t\t\t\t\t\tb33 = be[8];\n\t\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\t\tte[3] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\t\tte[6] = a11 * b13 + a12 * b23 + a13 * b33;\n\t\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\t\tte[4] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\t\tte[7] = a21 * b13 + a22 * b23 + a23 * b33;\n\t\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\t\tte[5] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\t\tte[8] = a31 * b13 + a32 * b23 + a33 * b33;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(s) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] *= s;\n\t\t\tte[3] *= s;\n\t\t\tte[6] *= s;\n\t\t\tte[1] *= s;\n\t\t\tte[4] *= s;\n\t\t\tte[7] *= s;\n\t\t\tte[2] *= s;\n\t\t\tte[5] *= s;\n\t\t\tte[8] *= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tdeterminant() {\n\t\t\tconst te = this.elements;\n\t\t\tconst a = te[0],\n\t\t\t\t\t\tb = te[1],\n\t\t\t\t\t\tc = te[2],\n\t\t\t\t\t\td = te[3],\n\t\t\t\t\t\te = te[4],\n\t\t\t\t\t\tf = te[5],\n\t\t\t\t\t\tg = te[6],\n\t\t\t\t\t\th = te[7],\n\t\t\t\t\t\ti = te[8];\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\t\t}\n\n\t\tinvert() {\n\t\t\tconst te = this.elements,\n\t\t\t\t\t\tn11 = te[0],\n\t\t\t\t\t\tn21 = te[1],\n\t\t\t\t\t\tn31 = te[2],\n\t\t\t\t\t\tn12 = te[3],\n\t\t\t\t\t\tn22 = te[4],\n\t\t\t\t\t\tn32 = te[5],\n\t\t\t\t\t\tn13 = te[6],\n\t\t\t\t\t\tn23 = te[7],\n\t\t\t\t\t\tn33 = te[8],\n\t\t\t\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\t\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\t\t\t\tt13 = n23 * n12 - n22 * n13,\n\t\t\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\t\t\tif (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n\t\t\tconst detInv = 1 / det;\n\t\t\tte[0] = t11 * detInv;\n\t\t\tte[1] = (n31 * n23 - n33 * n21) * detInv;\n\t\t\tte[2] = (n32 * n21 - n31 * n22) * detInv;\n\t\t\tte[3] = t12 * detInv;\n\t\t\tte[4] = (n33 * n11 - n31 * n13) * detInv;\n\t\t\tte[5] = (n31 * n12 - n32 * n11) * detInv;\n\t\t\tte[6] = t13 * detInv;\n\t\t\tte[7] = (n21 * n13 - n23 * n11) * detInv;\n\t\t\tte[8] = (n22 * n11 - n21 * n12) * detInv;\n\t\t\treturn this;\n\t\t}\n\n\t\ttranspose() {\n\t\t\tlet tmp;\n\t\t\tconst m = this.elements;\n\t\t\ttmp = m[1];\n\t\t\tm[1] = m[3];\n\t\t\tm[3] = tmp;\n\t\t\ttmp = m[2];\n\t\t\tm[2] = m[6];\n\t\t\tm[6] = tmp;\n\t\t\ttmp = m[5];\n\t\t\tm[5] = m[7];\n\t\t\tm[7] = tmp;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetNormalMatrix(matrix4) {\n\t\t\treturn this.setFromMatrix4(matrix4).invert().transpose();\n\t\t}\n\n\t\ttransposeIntoArray(r) {\n\t\t\tconst m = this.elements;\n\t\t\tr[0] = m[0];\n\t\t\tr[1] = m[3];\n\t\t\tr[2] = m[6];\n\t\t\tr[3] = m[1];\n\t\t\tr[4] = m[4];\n\t\t\tr[5] = m[7];\n\t\t\tr[6] = m[2];\n\t\t\tr[7] = m[5];\n\t\t\tr[8] = m[8];\n\t\t\treturn this;\n\t\t}\n\n\t\tsetUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n\t\t\tconst c = Math.cos(rotation);\n\t\t\tconst s = Math.sin(rotation);\n\t\t\tthis.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tscale(sx, sy) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] *= sx;\n\t\t\tte[3] *= sx;\n\t\t\tte[6] *= sx;\n\t\t\tte[1] *= sy;\n\t\t\tte[4] *= sy;\n\t\t\tte[7] *= sy;\n\t\t\treturn this;\n\t\t}\n\n\t\trotate(theta) {\n\t\t\tconst c = Math.cos(theta);\n\t\t\tconst s = Math.sin(theta);\n\t\t\tconst te = this.elements;\n\t\t\tconst a11 = te[0],\n\t\t\t\t\t\ta12 = te[3],\n\t\t\t\t\t\ta13 = te[6];\n\t\t\tconst a21 = te[1],\n\t\t\t\t\t\ta22 = te[4],\n\t\t\t\t\t\ta23 = te[7];\n\t\t\tte[0] = c * a11 + s * a21;\n\t\t\tte[3] = c * a12 + s * a22;\n\t\t\tte[6] = c * a13 + s * a23;\n\t\t\tte[1] = -s * a11 + c * a21;\n\t\t\tte[4] = -s * a12 + c * a22;\n\t\t\tte[7] = -s * a13 + c * a23;\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(tx, ty) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] += tx * te[2];\n\t\t\tte[3] += tx * te[5];\n\t\t\tte[6] += tx * te[8];\n\t\t\tte[1] += ty * te[2];\n\t\t\tte[4] += ty * te[5];\n\t\t\tte[7] += ty * te[8];\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(matrix) {\n\t\t\tconst te = this.elements;\n\t\t\tconst me = matrix.elements;\n\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tif (te[i] !== me[i]) return false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.elements[i] = array[i + offset];\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tconst te = this.elements;\n\t\t\tarray[offset] = te[0];\n\t\t\tarray[offset + 1] = te[1];\n\t\t\tarray[offset + 2] = te[2];\n\t\t\tarray[offset + 3] = te[3];\n\t\t\tarray[offset + 4] = te[4];\n\t\t\tarray[offset + 5] = te[5];\n\t\t\tarray[offset + 6] = te[6];\n\t\t\tarray[offset + 7] = te[7];\n\t\t\tarray[offset + 8] = te[8];\n\t\t\treturn array;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().fromArray(this.elements);\n\t\t}\n\n\t}\n\n\tMatrix3.prototype.isMatrix3 = true;\n\n\tlet _canvas;\n\n\tclass ImageUtils {\n\t\tstatic getDataURL(image) {\n\t\t\tif (/^data:/i.test(image.src)) {\n\t\t\t\treturn image.src;\n\t\t\t}\n\n\t\t\tif (typeof HTMLCanvasElement == 'undefined') {\n\t\t\t\treturn image.src;\n\t\t\t}\n\n\t\t\tlet canvas;\n\n\t\t\tif (image instanceof HTMLCanvasElement) {\n\t\t\t\tcanvas = image;\n\t\t\t} else {\n\t\t\t\tif (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');\n\t\t\t\t_canvas.width = image.width;\n\t\t\t\t_canvas.height = image.height;\n\n\t\t\t\tconst context = _canvas.getContext('2d');\n\n\t\t\t\tif (image instanceof ImageData) {\n\t\t\t\t\tcontext.putImageData(image, 0, 0);\n\t\t\t\t} else {\n\t\t\t\t\tcontext.drawImage(image, 0, 0, image.width, image.height);\n\t\t\t\t}\n\n\t\t\t\tcanvas = _canvas;\n\t\t\t}\n\n\t\t\tif (canvas.width > 2048 || canvas.height > 2048) {\n\t\t\t\tconsole.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);\n\t\t\t\treturn canvas.toDataURL('image/jpeg', 0.6);\n\t\t\t} else {\n\t\t\t\treturn canvas.toDataURL('image/png');\n\t\t\t}\n\t\t}\n\n\t}\n\n\tlet textureId = 0;\n\n\tclass Texture extends EventDispatcher {\n\t\tconstructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {\n\t\t\tsuper();\n\t\t\tObject.defineProperty(this, 'id', {\n\t\t\t\tvalue: textureId++\n\t\t\t});\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.name = '';\n\t\t\tthis.image = image;\n\t\t\tthis.mipmaps = [];\n\t\t\tthis.mapping = mapping;\n\t\t\tthis.wrapS = wrapS;\n\t\t\tthis.wrapT = wrapT;\n\t\t\tthis.magFilter = magFilter;\n\t\t\tthis.minFilter = minFilter;\n\t\t\tthis.anisotropy = anisotropy;\n\t\t\tthis.format = format;\n\t\t\tthis.internalFormat = null;\n\t\t\tthis.type = type;\n\t\t\tthis.offset = new Vector2(0, 0);\n\t\t\tthis.repeat = new Vector2(1, 1);\n\t\t\tthis.center = new Vector2(0, 0);\n\t\t\tthis.rotation = 0;\n\t\t\tthis.matrixAutoUpdate = true;\n\t\t\tthis.matrix = new Matrix3();\n\t\t\tthis.generateMipmaps = true;\n\t\t\tthis.premultiplyAlpha = false;\n\t\t\tthis.flipY = true;\n\t\t\tthis.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\t\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t\t//\n\t\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t\t// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\n\t\t\tthis.encoding = encoding;\n\t\t\tthis.version = 0;\n\t\t\tthis.onUpdate = null;\n\t\t}\n\n\t\tupdateMatrix() {\n\t\t\tthis.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.name = source.name;\n\t\t\tthis.image = source.image;\n\t\t\tthis.mipmaps = source.mipmaps.slice(0);\n\t\t\tthis.mapping = source.mapping;\n\t\t\tthis.wrapS = source.wrapS;\n\t\t\tthis.wrapT = source.wrapT;\n\t\t\tthis.magFilter = source.magFilter;\n\t\t\tthis.minFilter = source.minFilter;\n\t\t\tthis.anisotropy = source.anisotropy;\n\t\t\tthis.format = source.format;\n\t\t\tthis.internalFormat = source.internalFormat;\n\t\t\tthis.type = source.type;\n\t\t\tthis.offset.copy(source.offset);\n\t\t\tthis.repeat.copy(source.repeat);\n\t\t\tthis.center.copy(source.center);\n\t\t\tthis.rotation = source.rotation;\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\tthis.matrix.copy(source.matrix);\n\t\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\t\tthis.flipY = source.flipY;\n\t\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\t\tthis.encoding = source.encoding;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst isRootObject = meta === undefined || typeof meta === 'string';\n\n\t\t\tif (!isRootObject && meta.textures[this.uuid] !== undefined) {\n\t\t\t\treturn meta.textures[this.uuid];\n\t\t\t}\n\n\t\t\tconst output = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Texture',\n\t\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t\t},\n\t\t\t\tuuid: this.uuid,\n\t\t\t\tname: this.name,\n\t\t\t\tmapping: this.mapping,\n\t\t\t\trepeat: [this.repeat.x, this.repeat.y],\n\t\t\t\toffset: [this.offset.x, this.offset.y],\n\t\t\t\tcenter: [this.center.x, this.center.y],\n\t\t\t\trotation: this.rotation,\n\t\t\t\twrap: [this.wrapS, this.wrapT],\n\t\t\t\tformat: this.format,\n\t\t\t\ttype: this.type,\n\t\t\t\tencoding: this.encoding,\n\t\t\t\tminFilter: this.minFilter,\n\t\t\t\tmagFilter: this.magFilter,\n\t\t\t\tanisotropy: this.anisotropy,\n\t\t\t\tflipY: this.flipY,\n\t\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\t\tunpackAlignment: this.unpackAlignment\n\t\t\t};\n\n\t\t\tif (this.image !== undefined) {\n\t\t\t\t// TODO: Move to THREE.Image\n\t\t\t\tconst image = this.image;\n\n\t\t\t\tif (image.uuid === undefined) {\n\t\t\t\t\timage.uuid = generateUUID(); // UGH\n\t\t\t\t}\n\n\t\t\t\tif (!isRootObject && meta.images[image.uuid] === undefined) {\n\t\t\t\t\tlet url;\n\n\t\t\t\t\tif (Array.isArray(image)) {\n\t\t\t\t\t\t// process array of images e.g. CubeTexture\n\t\t\t\t\t\turl = [];\n\n\t\t\t\t\t\tfor (let i = 0, l = image.length; i < l; i++) {\n\t\t\t\t\t\t\t// check cube texture with data textures\n\t\t\t\t\t\t\tif (image[i].isDataTexture) {\n\t\t\t\t\t\t\t\turl.push(serializeImage(image[i].image));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\turl.push(serializeImage(image[i]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// process single image\n\t\t\t\t\t\turl = serializeImage(image);\n\t\t\t\t\t}\n\n\t\t\t\t\tmeta.images[image.uuid] = {\n\t\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\t\turl: url\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\toutput.image = image.uuid;\n\t\t\t}\n\n\t\t\tif (!isRootObject) {\n\t\t\t\tmeta.textures[this.uuid] = output;\n\t\t\t}\n\n\t\t\treturn output;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'dispose'\n\t\t\t});\n\t\t}\n\n\t\ttransformUv(uv) {\n\t\t\tif (this.mapping !== UVMapping) return uv;\n\t\t\tuv.applyMatrix3(this.matrix);\n\n\t\t\tif (uv.x < 0 || uv.x > 1) {\n\t\t\t\tswitch (this.wrapS) {\n\t\t\t\t\tcase RepeatWrapping:\n\t\t\t\t\t\tuv.x = uv.x - Math.floor(uv.x);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\t\t\t\t\t\tif (Math.abs(Math.floor(uv.x) % 2) === 1) {\n\t\t\t\t\t\t\tuv.x = Math.ceil(uv.x) - uv.x;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor(uv.x);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (uv.y < 0 || uv.y > 1) {\n\t\t\t\tswitch (this.wrapT) {\n\t\t\t\t\tcase RepeatWrapping:\n\t\t\t\t\t\tuv.y = uv.y - Math.floor(uv.y);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase ClampToEdgeWrapping:\n\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MirroredRepeatWrapping:\n\t\t\t\t\t\tif (Math.abs(Math.floor(uv.y) % 2) === 1) {\n\t\t\t\t\t\t\tuv.y = Math.ceil(uv.y) - uv.y;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor(uv.y);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.flipY) {\n\t\t\t\tuv.y = 1 - uv.y;\n\t\t\t}\n\n\t\t\treturn uv;\n\t\t}\n\n\t\tset needsUpdate(value) {\n\t\t\tif (value === true) this.version++;\n\t\t}\n\n\t}\n\n\tTexture.DEFAULT_IMAGE = undefined;\n\tTexture.DEFAULT_MAPPING = UVMapping;\n\tTexture.prototype.isTexture = true;\n\n\tfunction serializeImage(image) {\n\t\tif (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n\t\t\t// default images\n\t\t\treturn ImageUtils.getDataURL(image);\n\t\t} else {\n\t\t\tif (image.data) {\n\t\t\t\t// images of DataTexture\n\t\t\t\treturn {\n\t\t\t\t\tdata: Array.prototype.slice.call(image.data),\n\t\t\t\t\twidth: image.width,\n\t\t\t\t\theight: image.height,\n\t\t\t\t\ttype: image.data.constructor.name\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tconsole.warn('THREE.Texture: Unable to serialize Texture.');\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Vector4 {\n\t\tconstructor(x = 0, y = 0, z = 0, w = 1) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\t\t}\n\n\t\tget width() {\n\t\t\treturn this.z;\n\t\t}\n\n\t\tset width(value) {\n\t\t\tthis.z = value;\n\t\t}\n\n\t\tget height() {\n\t\t\treturn this.w;\n\t\t}\n\n\t\tset height(value) {\n\t\t\tthis.w = value;\n\t\t}\n\n\t\tset(x, y, z, w) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetScalar(scalar) {\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\t\t\tthis.w = scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetX(x) {\n\t\t\tthis.x = x;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetY(y) {\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetZ(z) {\n\t\t\tthis.z = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetW(w) {\n\t\t\tthis.w = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetComponent(index, value) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.x = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tthis.y = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.z = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\t\tthis.w = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetComponent(index) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn this.x;\n\n\t\t\t\tcase 1:\n\t\t\t\t\treturn this.y;\n\n\t\t\t\tcase 2:\n\t\t\t\t\treturn this.z;\n\n\t\t\t\tcase 3:\n\t\t\t\t\treturn this.w;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.x, this.y, this.z, this.w);\n\t\t}\n\n\t\tcopy(v) {\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\t\t\tthis.w = v.w !== undefined ? v.w : 1;\n\t\t\treturn this;\n\t\t}\n\n\t\tadd(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n\t\t\t\treturn this.addVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\t\t\tthis.w += v.w;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScalar(s) {\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\t\t\tthis.w += s;\n\t\t\treturn this;\n\t\t}\n\n\t\taddVectors(a, b) {\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\t\t\tthis.w = a.w + b.w;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScaledVector(v, s) {\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\t\t\tthis.w += v.w * s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsub(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n\t\t\t\treturn this.subVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\t\t\tthis.w -= v.w;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubScalar(s) {\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\t\t\tthis.w -= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubVectors(a, b) {\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\t\t\tthis.w = a.w - b.w;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(v) {\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\tthis.z *= v.z;\n\t\t\tthis.w *= v.w;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(scalar) {\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\t\t\tthis.w *= scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyMatrix4(m) {\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y,\n\t\t\t\t\t\tz = this.z,\n\t\t\t\t\t\tw = this.w;\n\t\t\tconst e = m.elements;\n\t\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n\t\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n\t\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n\t\t\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n\t\t\treturn this;\n\t\t}\n\n\t\tdivideScalar(scalar) {\n\t\t\treturn this.multiplyScalar(1 / scalar);\n\t\t}\n\n\t\tsetAxisAngleFromQuaternion(q) {\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\t\t\t// q is assumed to be normalized\n\t\t\tthis.w = 2 * Math.acos(q.w);\n\t\t\tconst s = Math.sqrt(1 - q.w * q.w);\n\n\t\t\tif (s < 0.0001) {\n\t\t\t\tthis.x = 1;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = 0;\n\t\t\t} else {\n\t\t\t\tthis.x = q.x / s;\n\t\t\t\tthis.y = q.y / s;\n\t\t\t\tthis.z = q.z / s;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetAxisAngleFromRotationMatrix(m) {\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\t\tlet angle, x, y, z; // variables for result\n\n\t\t\tconst epsilon = 0.01,\n\t\t\t\t\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\n\t\t\t\t\t\t// margin to distinguish between 0 and 180 degrees\n\t\t\tte = m.elements,\n\t\t\t\t\t\tm11 = te[0],\n\t\t\t\t\t\tm12 = te[4],\n\t\t\t\t\t\tm13 = te[8],\n\t\t\t\t\t\tm21 = te[1],\n\t\t\t\t\t\tm22 = te[5],\n\t\t\t\t\t\tm23 = te[9],\n\t\t\t\t\t\tm31 = te[2],\n\t\t\t\t\t\tm32 = te[6],\n\t\t\t\t\t\tm33 = te[10];\n\n\t\t\tif (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n\t\t\t\t// singularity found\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t\t// in leading diagonal and zero in other terms\n\t\t\t\tif (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\n\t\t\t\t\tthis.set(1, 0, 0, 0);\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\n\t\t\t\t} // otherwise this singularity is angle = 180\n\n\n\t\t\t\tangle = Math.PI;\n\t\t\t\tconst xx = (m11 + 1) / 2;\n\t\t\t\tconst yy = (m22 + 1) / 2;\n\t\t\t\tconst zz = (m33 + 1) / 2;\n\t\t\t\tconst xy = (m12 + m21) / 4;\n\t\t\t\tconst xz = (m13 + m31) / 4;\n\t\t\t\tconst yz = (m23 + m32) / 4;\n\n\t\t\t\tif (xx > yy && xx > zz) {\n\t\t\t\t\t// m11 is the largest diagonal term\n\t\t\t\t\tif (xx < epsilon) {\n\t\t\t\t\t\tx = 0;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0.707106781;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tx = Math.sqrt(xx);\n\t\t\t\t\t\ty = xy / x;\n\t\t\t\t\t\tz = xz / x;\n\t\t\t\t\t}\n\t\t\t\t} else if (yy > zz) {\n\t\t\t\t\t// m22 is the largest diagonal term\n\t\t\t\t\tif (yy < epsilon) {\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\tz = 0.707106781;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ty = Math.sqrt(yy);\n\t\t\t\t\t\tx = xy / y;\n\t\t\t\t\t\tz = yz / y;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// m33 is the largest diagonal term so base result on this\n\t\t\t\t\tif (zz < epsilon) {\n\t\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\t\tz = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tz = Math.sqrt(zz);\n\t\t\t\t\t\tx = xz / z;\n\t\t\t\t\t\ty = yz / z;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.set(x, y, z, angle);\n\t\t\t\treturn this; // return 180 deg rotation\n\t\t\t} // as we have reached here there are no singularities so we can handle normally\n\n\n\t\t\tlet s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize\n\n\t\t\tif (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\t\tthis.x = (m32 - m23) / s;\n\t\t\tthis.y = (m13 - m31) / s;\n\t\t\tthis.z = (m21 - m12) / s;\n\t\t\tthis.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n\t\t\treturn this;\n\t\t}\n\n\t\tmin(v) {\n\t\t\tthis.x = Math.min(this.x, v.x);\n\t\t\tthis.y = Math.min(this.y, v.y);\n\t\t\tthis.z = Math.min(this.z, v.z);\n\t\t\tthis.w = Math.min(this.w, v.w);\n\t\t\treturn this;\n\t\t}\n\n\t\tmax(v) {\n\t\t\tthis.x = Math.max(this.x, v.x);\n\t\t\tthis.y = Math.max(this.y, v.y);\n\t\t\tthis.z = Math.max(this.z, v.z);\n\t\t\tthis.w = Math.max(this.w, v.w);\n\t\t\treturn this;\n\t\t}\n\n\t\tclamp(min, max) {\n\t\t\t// assumes min < max, componentwise\n\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\n\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\n\t\t\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\n\t\t\tthis.w = Math.max(min.w, Math.min(max.w, this.w));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampScalar(minVal, maxVal) {\n\t\t\tthis.x = Math.max(minVal, Math.min(maxVal, this.x));\n\t\t\tthis.y = Math.max(minVal, Math.min(maxVal, this.y));\n\t\t\tthis.z = Math.max(minVal, Math.min(maxVal, this.z));\n\t\t\tthis.w = Math.max(minVal, Math.min(maxVal, this.w));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampLength(min, max) {\n\t\t\tconst length = this.length();\n\t\t\treturn this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n\t\t}\n\n\t\tfloor() {\n\t\t\tthis.x = Math.floor(this.x);\n\t\t\tthis.y = Math.floor(this.y);\n\t\t\tthis.z = Math.floor(this.z);\n\t\t\tthis.w = Math.floor(this.w);\n\t\t\treturn this;\n\t\t}\n\n\t\tceil() {\n\t\t\tthis.x = Math.ceil(this.x);\n\t\t\tthis.y = Math.ceil(this.y);\n\t\t\tthis.z = Math.ceil(this.z);\n\t\t\tthis.w = Math.ceil(this.w);\n\t\t\treturn this;\n\t\t}\n\n\t\tround() {\n\t\t\tthis.x = Math.round(this.x);\n\t\t\tthis.y = Math.round(this.y);\n\t\t\tthis.z = Math.round(this.z);\n\t\t\tthis.w = Math.round(this.w);\n\t\t\treturn this;\n\t\t}\n\n\t\troundToZero() {\n\t\t\tthis.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n\t\t\tthis.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n\t\t\tthis.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n\t\t\tthis.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);\n\t\t\treturn this;\n\t\t}\n\n\t\tnegate() {\n\t\t\tthis.x = -this.x;\n\t\t\tthis.y = -this.y;\n\t\t\tthis.z = -this.z;\n\t\t\tthis.w = -this.w;\n\t\t\treturn this;\n\t\t}\n\n\t\tdot(v) {\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\t\t}\n\n\t\tlengthSq() {\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\t\t}\n\n\t\tlength() {\n\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n\t\t}\n\n\t\tmanhattanLength() {\n\t\t\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n\t\t}\n\n\t\tnormalize() {\n\t\t\treturn this.divideScalar(this.length() || 1);\n\t\t}\n\n\t\tsetLength(length) {\n\t\t\treturn this.normalize().multiplyScalar(length);\n\t\t}\n\n\t\tlerp(v, alpha) {\n\t\t\tthis.x += (v.x - this.x) * alpha;\n\t\t\tthis.y += (v.y - this.y) * alpha;\n\t\t\tthis.z += (v.z - this.z) * alpha;\n\t\t\tthis.w += (v.w - this.w) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerpVectors(v1, v2, alpha) {\n\t\t\tthis.x = v1.x + (v2.x - v1.x) * alpha;\n\t\t\tthis.y = v1.y + (v2.y - v1.y) * alpha;\n\t\t\tthis.z = v1.z + (v2.z - v1.z) * alpha;\n\t\t\tthis.w = v1.w + (v2.w - v1.w) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(v) {\n\t\t\treturn v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tthis.x = array[offset];\n\t\t\tthis.y = array[offset + 1];\n\t\t\tthis.z = array[offset + 2];\n\t\t\tthis.w = array[offset + 3];\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this.x;\n\t\t\tarray[offset + 1] = this.y;\n\t\t\tarray[offset + 2] = this.z;\n\t\t\tarray[offset + 3] = this.w;\n\t\t\treturn array;\n\t\t}\n\n\t\tfromBufferAttribute(attribute, index, offset) {\n\t\t\tif (offset !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');\n\t\t\t}\n\n\t\t\tthis.x = attribute.getX(index);\n\t\t\tthis.y = attribute.getY(index);\n\t\t\tthis.z = attribute.getZ(index);\n\t\t\tthis.w = attribute.getW(index);\n\t\t\treturn this;\n\t\t}\n\n\t\trandom() {\n\t\t\tthis.x = Math.random();\n\t\t\tthis.y = Math.random();\n\t\t\tthis.z = Math.random();\n\t\t\tthis.w = Math.random();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tVector4.prototype.isVector4 = true;\n\n\t/*\n\t In options, we can specify:\n\t * Texture parameters for an auto-generated target texture\n\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n\t*/\n\n\tclass WebGLRenderTarget extends EventDispatcher {\n\t\tconstructor(width, height, options) {\n\t\t\tsuper();\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.depth = 1;\n\t\t\tthis.scissor = new Vector4(0, 0, width, height);\n\t\t\tthis.scissorTest = false;\n\t\t\tthis.viewport = new Vector4(0, 0, width, height);\n\t\t\toptions = options || {};\n\t\t\tthis.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);\n\t\t\tthis.texture.image = {};\n\t\t\tthis.texture.image.width = width;\n\t\t\tthis.texture.image.height = height;\n\t\t\tthis.texture.image.depth = 1;\n\t\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\t\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;\n\t\t\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\t\t}\n\n\t\tsetTexture(texture) {\n\t\t\ttexture.image = {\n\t\t\t\twidth: this.width,\n\t\t\t\theight: this.height,\n\t\t\t\tdepth: this.depth\n\t\t\t};\n\t\t\tthis.texture = texture;\n\t\t}\n\n\t\tsetSize(width, height, depth = 1) {\n\t\t\tif (this.width !== width || this.height !== height || this.depth !== depth) {\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\t\t\t\tthis.depth = depth;\n\t\t\t\tthis.texture.image.width = width;\n\t\t\t\tthis.texture.image.height = height;\n\t\t\t\tthis.texture.image.depth = depth;\n\t\t\t\tthis.dispose();\n\t\t\t}\n\n\t\t\tthis.viewport.set(0, 0, width, height);\n\t\t\tthis.scissor.set(0, 0, width, height);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\t\t\tthis.depth = source.depth;\n\t\t\tthis.viewport.copy(source.viewport);\n\t\t\tthis.texture = source.texture.clone();\n\t\t\tthis.texture.image = { ...this.texture.image\n\t\t\t}; // See #20328.\n\n\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\tthis.depthTexture = source.depthTexture;\n\t\t\treturn this;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'dispose'\n\t\t\t});\n\t\t}\n\n\t}\n\n\tWebGLRenderTarget.prototype.isWebGLRenderTarget = true;\n\n\tclass WebGLMultipleRenderTargets extends WebGLRenderTarget {\n\t\tconstructor(width, height, count) {\n\t\t\tsuper(width, height);\n\t\t\tconst texture = this.texture;\n\t\t\tthis.texture = [];\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tthis.texture[i] = texture.clone();\n\t\t\t}\n\t\t}\n\n\t\tsetSize(width, height, depth = 1) {\n\t\t\tif (this.width !== width || this.height !== height || this.depth !== depth) {\n\t\t\t\tthis.width = width;\n\t\t\t\tthis.height = height;\n\t\t\t\tthis.depth = depth;\n\n\t\t\t\tfor (let i = 0, il = this.texture.length; i < il; i++) {\n\t\t\t\t\tthis.texture[i].image.width = width;\n\t\t\t\t\tthis.texture[i].image.height = height;\n\t\t\t\t\tthis.texture[i].image.depth = depth;\n\t\t\t\t}\n\n\t\t\t\tthis.dispose();\n\t\t\t}\n\n\t\t\tthis.viewport.set(0, 0, width, height);\n\t\t\tthis.scissor.set(0, 0, width, height);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.dispose();\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\t\t\tthis.depth = source.depth;\n\t\t\tthis.viewport.set(0, 0, this.width, this.height);\n\t\t\tthis.scissor.set(0, 0, this.width, this.height);\n\t\t\tthis.depthBuffer = source.depthBuffer;\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\n\t\t\tthis.depthTexture = source.depthTexture;\n\t\t\tthis.texture.length = 0;\n\n\t\t\tfor (let i = 0, il = source.texture.length; i < il; i++) {\n\t\t\t\tthis.texture[i] = source.texture[i].clone();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tWebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;\n\n\tclass WebGLMultisampleRenderTarget extends WebGLRenderTarget {\n\t\tconstructor(width, height, options) {\n\t\t\tsuper(width, height, options);\n\t\t\tthis.samples = 4;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy.call(this, source);\n\t\t\tthis.samples = source.samples;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tWebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;\n\n\tclass Quaternion {\n\t\tconstructor(x = 0, y = 0, z = 0, w = 1) {\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._w = w;\n\t\t}\n\n\t\tstatic slerp(qa, qb, qm, t) {\n\t\t\tconsole.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');\n\t\t\treturn qm.slerpQuaternions(qa, qb, t);\n\t\t}\n\n\t\tstatic slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n\t\t\t// fuzz-free, array-based Quaternion SLERP operation\n\t\t\tlet x0 = src0[srcOffset0 + 0],\n\t\t\t\t\ty0 = src0[srcOffset0 + 1],\n\t\t\t\t\tz0 = src0[srcOffset0 + 2],\n\t\t\t\t\tw0 = src0[srcOffset0 + 3];\n\t\t\tconst x1 = src1[srcOffset1 + 0],\n\t\t\t\t\t\ty1 = src1[srcOffset1 + 1],\n\t\t\t\t\t\tz1 = src1[srcOffset1 + 2],\n\t\t\t\t\t\tw1 = src1[srcOffset1 + 3];\n\n\t\t\tif (t === 0) {\n\t\t\t\tdst[dstOffset + 0] = x0;\n\t\t\t\tdst[dstOffset + 1] = y0;\n\t\t\t\tdst[dstOffset + 2] = z0;\n\t\t\t\tdst[dstOffset + 3] = w0;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (t === 1) {\n\t\t\t\tdst[dstOffset + 0] = x1;\n\t\t\t\tdst[dstOffset + 1] = y1;\n\t\t\t\tdst[dstOffset + 2] = z1;\n\t\t\t\tdst[dstOffset + 3] = w1;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n\t\t\t\tlet s = 1 - t;\n\t\t\t\tconst cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\t\t\t\t\t\tdir = cos >= 0 ? 1 : -1,\n\t\t\t\t\t\t\tsqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:\n\n\t\t\t\tif (sqrSin > Number.EPSILON) {\n\t\t\t\t\tconst sin = Math.sqrt(sqrSin),\n\t\t\t\t\t\t\t\tlen = Math.atan2(sin, cos * dir);\n\t\t\t\t\ts = Math.sin(s * len) / sin;\n\t\t\t\t\tt = Math.sin(t * len) / sin;\n\t\t\t\t}\n\n\t\t\t\tconst tDir = t * dir;\n\t\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\t\tw0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:\n\n\t\t\t\tif (s === 1 - t) {\n\t\t\t\t\tconst f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n\t\t\t\t\tx0 *= f;\n\t\t\t\t\ty0 *= f;\n\t\t\t\t\tz0 *= f;\n\t\t\t\t\tw0 *= f;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdst[dstOffset] = x0;\n\t\t\tdst[dstOffset + 1] = y0;\n\t\t\tdst[dstOffset + 2] = z0;\n\t\t\tdst[dstOffset + 3] = w0;\n\t\t}\n\n\t\tstatic multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n\t\t\tconst x0 = src0[srcOffset0];\n\t\t\tconst y0 = src0[srcOffset0 + 1];\n\t\t\tconst z0 = src0[srcOffset0 + 2];\n\t\t\tconst w0 = src0[srcOffset0 + 3];\n\t\t\tconst x1 = src1[srcOffset1];\n\t\t\tconst y1 = src1[srcOffset1 + 1];\n\t\t\tconst z1 = src1[srcOffset1 + 2];\n\t\t\tconst w1 = src1[srcOffset1 + 3];\n\t\t\tdst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n\t\t\tdst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n\t\t\tdst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n\t\t\tdst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\t\t\treturn dst;\n\t\t}\n\n\t\tget x() {\n\t\t\treturn this._x;\n\t\t}\n\n\t\tset x(value) {\n\t\t\tthis._x = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget y() {\n\t\t\treturn this._y;\n\t\t}\n\n\t\tset y(value) {\n\t\t\tthis._y = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget z() {\n\t\t\treturn this._z;\n\t\t}\n\n\t\tset z(value) {\n\t\t\tthis._z = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget w() {\n\t\t\treturn this._w;\n\t\t}\n\n\t\tset w(value) {\n\t\t\tthis._w = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tset(x, y, z, w) {\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._w = w;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this._x, this._y, this._z, this._w);\n\t\t}\n\n\t\tcopy(quaternion) {\n\t\t\tthis._x = quaternion.x;\n\t\t\tthis._y = quaternion.y;\n\t\t\tthis._z = quaternion.z;\n\t\t\tthis._w = quaternion.w;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromEuler(euler, update) {\n\t\t\tif (!(euler && euler.isEuler)) {\n\t\t\t\tthrow new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');\n\t\t\t}\n\n\t\t\tconst x = euler._x,\n\t\t\t\t\t\ty = euler._y,\n\t\t\t\t\t\tz = euler._z,\n\t\t\t\t\t\torder = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t\t//\tcontent/SpinCalc.m\n\n\t\t\tconst cos = Math.cos;\n\t\t\tconst sin = Math.sin;\n\t\t\tconst c1 = cos(x / 2);\n\t\t\tconst c2 = cos(y / 2);\n\t\t\tconst c3 = cos(z / 2);\n\t\t\tconst s1 = sin(x / 2);\n\t\t\tconst s2 = sin(y / 2);\n\t\t\tconst s3 = sin(z / 2);\n\n\t\t\tswitch (order) {\n\t\t\t\tcase 'XYZ':\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'YXZ':\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZXY':\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZYX':\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'YZX':\n\t\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'XZY':\n\t\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);\n\t\t\t}\n\n\t\t\tif (update !== false) this._onChangeCallback();\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromAxisAngle(axis, angle) {\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\t\t\t// assumes axis is normalized\n\t\t\tconst halfAngle = angle / 2,\n\t\t\t\t\t\ts = Math.sin(halfAngle);\n\t\t\tthis._x = axis.x * s;\n\t\t\tthis._y = axis.y * s;\n\t\t\tthis._z = axis.z * s;\n\t\t\tthis._w = Math.cos(halfAngle);\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromRotationMatrix(m) {\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\t\tconst te = m.elements,\n\t\t\t\t\t\tm11 = te[0],\n\t\t\t\t\t\tm12 = te[4],\n\t\t\t\t\t\tm13 = te[8],\n\t\t\t\t\t\tm21 = te[1],\n\t\t\t\t\t\tm22 = te[5],\n\t\t\t\t\t\tm23 = te[9],\n\t\t\t\t\t\tm31 = te[2],\n\t\t\t\t\t\tm32 = te[6],\n\t\t\t\t\t\tm33 = te[10],\n\t\t\t\t\t\ttrace = m11 + m22 + m33;\n\n\t\t\tif (trace > 0) {\n\t\t\t\tconst s = 0.5 / Math.sqrt(trace + 1.0);\n\t\t\t\tthis._w = 0.25 / s;\n\t\t\t\tthis._x = (m32 - m23) * s;\n\t\t\t\tthis._y = (m13 - m31) * s;\n\t\t\t\tthis._z = (m21 - m12) * s;\n\t\t\t} else if (m11 > m22 && m11 > m33) {\n\t\t\t\tconst s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\t\t\t\tthis._w = (m32 - m23) / s;\n\t\t\t\tthis._x = 0.25 * s;\n\t\t\t\tthis._y = (m12 + m21) / s;\n\t\t\t\tthis._z = (m13 + m31) / s;\n\t\t\t} else if (m22 > m33) {\n\t\t\t\tconst s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\t\t\t\tthis._w = (m13 - m31) / s;\n\t\t\t\tthis._x = (m12 + m21) / s;\n\t\t\t\tthis._y = 0.25 * s;\n\t\t\t\tthis._z = (m23 + m32) / s;\n\t\t\t} else {\n\t\t\t\tconst s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\t\t\t\tthis._w = (m21 - m12) / s;\n\t\t\t\tthis._x = (m13 + m31) / s;\n\t\t\t\tthis._y = (m23 + m32) / s;\n\t\t\t\tthis._z = 0.25 * s;\n\t\t\t}\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromUnitVectors(vFrom, vTo) {\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\n\t\t\tlet r = vFrom.dot(vTo) + 1;\n\n\t\t\tif (r < Number.EPSILON) {\n\t\t\t\t// vFrom and vTo point in opposite directions\n\t\t\t\tr = 0;\n\n\t\t\t\tif (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n\t\t\t\t\tthis._x = -vFrom.y;\n\t\t\t\t\tthis._y = vFrom.x;\n\t\t\t\t\tthis._z = 0;\n\t\t\t\t\tthis._w = r;\n\t\t\t\t} else {\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = -vFrom.z;\n\t\t\t\t\tthis._z = vFrom.y;\n\t\t\t\t\tthis._w = r;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\t\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\t\t\tthis._w = r;\n\t\t\t}\n\n\t\t\treturn this.normalize();\n\t\t}\n\n\t\tangleTo(q) {\n\t\t\treturn 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\n\t\t}\n\n\t\trotateTowards(q, step) {\n\t\t\tconst angle = this.angleTo(q);\n\t\t\tif (angle === 0) return this;\n\t\t\tconst t = Math.min(1, step / angle);\n\t\t\tthis.slerp(q, t);\n\t\t\treturn this;\n\t\t}\n\n\t\tidentity() {\n\t\t\treturn this.set(0, 0, 0, 1);\n\t\t}\n\n\t\tinvert() {\n\t\t\t// quaternion is assumed to have unit length\n\t\t\treturn this.conjugate();\n\t\t}\n\n\t\tconjugate() {\n\t\t\tthis._x *= -1;\n\t\t\tthis._y *= -1;\n\t\t\tthis._z *= -1;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tdot(v) {\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\t\t}\n\n\t\tlengthSq() {\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\t\t}\n\n\t\tlength() {\n\t\t\treturn Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n\t\t}\n\n\t\tnormalize() {\n\t\t\tlet l = this.length();\n\n\t\t\tif (l === 0) {\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = 1;\n\t\t\t} else {\n\t\t\t\tl = 1 / l;\n\t\t\t\tthis._x = this._x * l;\n\t\t\t\tthis._y = this._y * l;\n\t\t\t\tthis._z = this._z * l;\n\t\t\t\tthis._w = this._w * l;\n\t\t\t}\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(q, p) {\n\t\t\tif (p !== undefined) {\n\t\t\t\tconsole.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');\n\t\t\t\treturn this.multiplyQuaternions(q, p);\n\t\t\t}\n\n\t\t\treturn this.multiplyQuaternions(this, q);\n\t\t}\n\n\t\tpremultiply(q) {\n\t\t\treturn this.multiplyQuaternions(q, this);\n\t\t}\n\n\t\tmultiplyQuaternions(a, b) {\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\t\t\tconst qax = a._x,\n\t\t\t\t\t\tqay = a._y,\n\t\t\t\t\t\tqaz = a._z,\n\t\t\t\t\t\tqaw = a._w;\n\t\t\tconst qbx = b._x,\n\t\t\t\t\t\tqby = b._y,\n\t\t\t\t\t\tqbz = b._z,\n\t\t\t\t\t\tqbw = b._w;\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tslerp(qb, t) {\n\t\t\tif (t === 0) return this;\n\t\t\tif (t === 1) return this.copy(qb);\n\t\t\tconst x = this._x,\n\t\t\t\t\t\ty = this._y,\n\t\t\t\t\t\tz = this._z,\n\t\t\t\t\t\tw = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\t\tlet cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\t\tif (cosHalfTheta < 0) {\n\t\t\t\tthis._w = -qb._w;\n\t\t\t\tthis._x = -qb._x;\n\t\t\t\tthis._y = -qb._y;\n\t\t\t\tthis._z = -qb._z;\n\t\t\t\tcosHalfTheta = -cosHalfTheta;\n\t\t\t} else {\n\t\t\t\tthis.copy(qb);\n\t\t\t}\n\n\t\t\tif (cosHalfTheta >= 1.0) {\n\t\t\t\tthis._w = w;\n\t\t\t\tthis._x = x;\n\t\t\t\tthis._y = y;\n\t\t\t\tthis._z = z;\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tconst sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\t\tif (sqrSinHalfTheta <= Number.EPSILON) {\n\t\t\t\tconst s = 1 - t;\n\t\t\t\tthis._w = s * w + t * this._w;\n\t\t\t\tthis._x = s * x + t * this._x;\n\t\t\t\tthis._y = s * y + t * this._y;\n\t\t\t\tthis._z = s * z + t * this._z;\n\t\t\t\tthis.normalize();\n\n\t\t\t\tthis._onChangeCallback();\n\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tconst sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n\t\t\tconst halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n\t\t\tconst ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,\n\t\t\t\t\t\tratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n\t\t\tthis._w = w * ratioA + this._w * ratioB;\n\t\t\tthis._x = x * ratioA + this._x * ratioB;\n\t\t\tthis._y = y * ratioA + this._y * ratioB;\n\t\t\tthis._z = z * ratioA + this._z * ratioB;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tslerpQuaternions(qa, qb, t) {\n\t\t\tthis.copy(qa).slerp(qb, t);\n\t\t}\n\n\t\tequals(quaternion) {\n\t\t\treturn quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tthis._x = array[offset];\n\t\t\tthis._y = array[offset + 1];\n\t\t\tthis._z = array[offset + 2];\n\t\t\tthis._w = array[offset + 3];\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this._x;\n\t\t\tarray[offset + 1] = this._y;\n\t\t\tarray[offset + 2] = this._z;\n\t\t\tarray[offset + 3] = this._w;\n\t\t\treturn array;\n\t\t}\n\n\t\tfromBufferAttribute(attribute, index) {\n\t\t\tthis._x = attribute.getX(index);\n\t\t\tthis._y = attribute.getY(index);\n\t\t\tthis._z = attribute.getZ(index);\n\t\t\tthis._w = attribute.getW(index);\n\t\t\treturn this;\n\t\t}\n\n\t\t_onChange(callback) {\n\t\t\tthis._onChangeCallback = callback;\n\t\t\treturn this;\n\t\t}\n\n\t\t_onChangeCallback() {}\n\n\t}\n\n\tQuaternion.prototype.isQuaternion = true;\n\n\tclass Vector3 {\n\t\tconstructor(x = 0, y = 0, z = 0) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tset(x, y, z) {\n\t\t\tif (z === undefined) z = this.z; // sprite.scale.set(x,y)\n\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetScalar(scalar) {\n\t\t\tthis.x = scalar;\n\t\t\tthis.y = scalar;\n\t\t\tthis.z = scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetX(x) {\n\t\t\tthis.x = x;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetY(y) {\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetZ(z) {\n\t\t\tthis.z = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetComponent(index, value) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.x = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\tthis.y = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.z = value;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetComponent(index) {\n\t\t\tswitch (index) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn this.x;\n\n\t\t\t\tcase 1:\n\t\t\t\t\treturn this.y;\n\n\t\t\t\tcase 2:\n\t\t\t\t\treturn this.z;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('index is out of range: ' + index);\n\t\t\t}\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.x, this.y, this.z);\n\t\t}\n\n\t\tcopy(v) {\n\t\t\tthis.x = v.x;\n\t\t\tthis.y = v.y;\n\t\t\tthis.z = v.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tadd(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');\n\t\t\t\treturn this.addVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x += v.x;\n\t\t\tthis.y += v.y;\n\t\t\tthis.z += v.z;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScalar(s) {\n\t\t\tthis.x += s;\n\t\t\tthis.y += s;\n\t\t\tthis.z += s;\n\t\t\treturn this;\n\t\t}\n\n\t\taddVectors(a, b) {\n\t\t\tthis.x = a.x + b.x;\n\t\t\tthis.y = a.y + b.y;\n\t\t\tthis.z = a.z + b.z;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScaledVector(v, s) {\n\t\t\tthis.x += v.x * s;\n\t\t\tthis.y += v.y * s;\n\t\t\tthis.z += v.z * s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsub(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');\n\t\t\t\treturn this.subVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x -= v.x;\n\t\t\tthis.y -= v.y;\n\t\t\tthis.z -= v.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubScalar(s) {\n\t\t\tthis.x -= s;\n\t\t\tthis.y -= s;\n\t\t\tthis.z -= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsubVectors(a, b) {\n\t\t\tthis.x = a.x - b.x;\n\t\t\tthis.y = a.y - b.y;\n\t\t\tthis.z = a.z - b.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');\n\t\t\t\treturn this.multiplyVectors(v, w);\n\t\t\t}\n\n\t\t\tthis.x *= v.x;\n\t\t\tthis.y *= v.y;\n\t\t\tthis.z *= v.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(scalar) {\n\t\t\tthis.x *= scalar;\n\t\t\tthis.y *= scalar;\n\t\t\tthis.z *= scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyVectors(a, b) {\n\t\t\tthis.x = a.x * b.x;\n\t\t\tthis.y = a.y * b.y;\n\t\t\tthis.z = a.z * b.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyEuler(euler) {\n\t\t\tif (!(euler && euler.isEuler)) {\n\t\t\t\tconsole.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');\n\t\t\t}\n\n\t\t\treturn this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n\t\t}\n\n\t\tapplyAxisAngle(axis, angle) {\n\t\t\treturn this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n\t\t}\n\n\t\tapplyMatrix3(m) {\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y,\n\t\t\t\t\t\tz = this.z;\n\t\t\tconst e = m.elements;\n\t\t\tthis.x = e[0] * x + e[3] * y + e[6] * z;\n\t\t\tthis.y = e[1] * x + e[4] * y + e[7] * z;\n\t\t\tthis.z = e[2] * x + e[5] * y + e[8] * z;\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyNormalMatrix(m) {\n\t\t\treturn this.applyMatrix3(m).normalize();\n\t\t}\n\n\t\tapplyMatrix4(m) {\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y,\n\t\t\t\t\t\tz = this.z;\n\t\t\tconst e = m.elements;\n\t\t\tconst w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\n\t\t\tthis.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\n\t\t\tthis.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\n\t\t\tthis.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyQuaternion(q) {\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y,\n\t\t\t\t\t\tz = this.z;\n\t\t\tconst qx = q.x,\n\t\t\t\t\t\tqy = q.y,\n\t\t\t\t\t\tqz = q.z,\n\t\t\t\t\t\tqw = q.w; // calculate quat * vector\n\n\t\t\tconst ix = qw * x + qy * z - qz * y;\n\t\t\tconst iy = qw * y + qz * x - qx * z;\n\t\t\tconst iz = qw * z + qx * y - qy * x;\n\t\t\tconst iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n\t\t\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n\t\t\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n\t\t\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\t\t\treturn this;\n\t\t}\n\n\t\tproject(camera) {\n\t\t\treturn this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n\t\t}\n\n\t\tunproject(camera) {\n\t\t\treturn this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n\t\t}\n\n\t\ttransformDirection(m) {\n\t\t\t// input: THREE.Matrix4 affine matrix\n\t\t\t// vector interpreted as a direction\n\t\t\tconst x = this.x,\n\t\t\t\t\t\ty = this.y,\n\t\t\t\t\t\tz = this.z;\n\t\t\tconst e = m.elements;\n\t\t\tthis.x = e[0] * x + e[4] * y + e[8] * z;\n\t\t\tthis.y = e[1] * x + e[5] * y + e[9] * z;\n\t\t\tthis.z = e[2] * x + e[6] * y + e[10] * z;\n\t\t\treturn this.normalize();\n\t\t}\n\n\t\tdivide(v) {\n\t\t\tthis.x /= v.x;\n\t\t\tthis.y /= v.y;\n\t\t\tthis.z /= v.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tdivideScalar(scalar) {\n\t\t\treturn this.multiplyScalar(1 / scalar);\n\t\t}\n\n\t\tmin(v) {\n\t\t\tthis.x = Math.min(this.x, v.x);\n\t\t\tthis.y = Math.min(this.y, v.y);\n\t\t\tthis.z = Math.min(this.z, v.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tmax(v) {\n\t\t\tthis.x = Math.max(this.x, v.x);\n\t\t\tthis.y = Math.max(this.y, v.y);\n\t\t\tthis.z = Math.max(this.z, v.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tclamp(min, max) {\n\t\t\t// assumes min < max, componentwise\n\t\t\tthis.x = Math.max(min.x, Math.min(max.x, this.x));\n\t\t\tthis.y = Math.max(min.y, Math.min(max.y, this.y));\n\t\t\tthis.z = Math.max(min.z, Math.min(max.z, this.z));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampScalar(minVal, maxVal) {\n\t\t\tthis.x = Math.max(minVal, Math.min(maxVal, this.x));\n\t\t\tthis.y = Math.max(minVal, Math.min(maxVal, this.y));\n\t\t\tthis.z = Math.max(minVal, Math.min(maxVal, this.z));\n\t\t\treturn this;\n\t\t}\n\n\t\tclampLength(min, max) {\n\t\t\tconst length = this.length();\n\t\t\treturn this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n\t\t}\n\n\t\tfloor() {\n\t\t\tthis.x = Math.floor(this.x);\n\t\t\tthis.y = Math.floor(this.y);\n\t\t\tthis.z = Math.floor(this.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tceil() {\n\t\t\tthis.x = Math.ceil(this.x);\n\t\t\tthis.y = Math.ceil(this.y);\n\t\t\tthis.z = Math.ceil(this.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tround() {\n\t\t\tthis.x = Math.round(this.x);\n\t\t\tthis.y = Math.round(this.y);\n\t\t\tthis.z = Math.round(this.z);\n\t\t\treturn this;\n\t\t}\n\n\t\troundToZero() {\n\t\t\tthis.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n\t\t\tthis.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n\t\t\tthis.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tnegate() {\n\t\t\tthis.x = -this.x;\n\t\t\tthis.y = -this.y;\n\t\t\tthis.z = -this.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tdot(v) {\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\t\t} // TODO lengthSquared?\n\n\n\t\tlengthSq() {\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\t\t}\n\n\t\tlength() {\n\t\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n\t\t}\n\n\t\tmanhattanLength() {\n\t\t\treturn Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n\t\t}\n\n\t\tnormalize() {\n\t\t\treturn this.divideScalar(this.length() || 1);\n\t\t}\n\n\t\tsetLength(length) {\n\t\t\treturn this.normalize().multiplyScalar(length);\n\t\t}\n\n\t\tlerp(v, alpha) {\n\t\t\tthis.x += (v.x - this.x) * alpha;\n\t\t\tthis.y += (v.y - this.y) * alpha;\n\t\t\tthis.z += (v.z - this.z) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerpVectors(v1, v2, alpha) {\n\t\t\tthis.x = v1.x + (v2.x - v1.x) * alpha;\n\t\t\tthis.y = v1.y + (v2.y - v1.y) * alpha;\n\t\t\tthis.z = v1.z + (v2.z - v1.z) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tcross(v, w) {\n\t\t\tif (w !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');\n\t\t\t\treturn this.crossVectors(v, w);\n\t\t\t}\n\n\t\t\treturn this.crossVectors(this, v);\n\t\t}\n\n\t\tcrossVectors(a, b) {\n\t\t\tconst ax = a.x,\n\t\t\t\t\t\tay = a.y,\n\t\t\t\t\t\taz = a.z;\n\t\t\tconst bx = b.x,\n\t\t\t\t\t\tby = b.y,\n\t\t\t\t\t\tbz = b.z;\n\t\t\tthis.x = ay * bz - az * by;\n\t\t\tthis.y = az * bx - ax * bz;\n\t\t\tthis.z = ax * by - ay * bx;\n\t\t\treturn this;\n\t\t}\n\n\t\tprojectOnVector(v) {\n\t\t\tconst denominator = v.lengthSq();\n\t\t\tif (denominator === 0) return this.set(0, 0, 0);\n\t\t\tconst scalar = v.dot(this) / denominator;\n\t\t\treturn this.copy(v).multiplyScalar(scalar);\n\t\t}\n\n\t\tprojectOnPlane(planeNormal) {\n\t\t\t_vector$c.copy(this).projectOnVector(planeNormal);\n\n\t\t\treturn this.sub(_vector$c);\n\t\t}\n\n\t\treflect(normal) {\n\t\t\t// reflect incident vector off plane orthogonal to normal\n\t\t\t// normal is assumed to have unit length\n\t\t\treturn this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\n\t\t}\n\n\t\tangleTo(v) {\n\t\t\tconst denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n\t\t\tif (denominator === 0) return Math.PI / 2;\n\t\t\tconst theta = this.dot(v) / denominator; // clamp, to handle numerical problems\n\n\t\t\treturn Math.acos(clamp(theta, -1, 1));\n\t\t}\n\n\t\tdistanceTo(v) {\n\t\t\treturn Math.sqrt(this.distanceToSquared(v));\n\t\t}\n\n\t\tdistanceToSquared(v) {\n\t\t\tconst dx = this.x - v.x,\n\t\t\t\t\t\tdy = this.y - v.y,\n\t\t\t\t\t\tdz = this.z - v.z;\n\t\t\treturn dx * dx + dy * dy + dz * dz;\n\t\t}\n\n\t\tmanhattanDistanceTo(v) {\n\t\t\treturn Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n\t\t}\n\n\t\tsetFromSpherical(s) {\n\t\t\treturn this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n\t\t}\n\n\t\tsetFromSphericalCoords(radius, phi, theta) {\n\t\t\tconst sinPhiRadius = Math.sin(phi) * radius;\n\t\t\tthis.x = sinPhiRadius * Math.sin(theta);\n\t\t\tthis.y = Math.cos(phi) * radius;\n\t\t\tthis.z = sinPhiRadius * Math.cos(theta);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromCylindrical(c) {\n\t\t\treturn this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n\t\t}\n\n\t\tsetFromCylindricalCoords(radius, theta, y) {\n\t\t\tthis.x = radius * Math.sin(theta);\n\t\t\tthis.y = y;\n\t\t\tthis.z = radius * Math.cos(theta);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromMatrixPosition(m) {\n\t\t\tconst e = m.elements;\n\t\t\tthis.x = e[12];\n\t\t\tthis.y = e[13];\n\t\t\tthis.z = e[14];\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromMatrixScale(m) {\n\t\t\tconst sx = this.setFromMatrixColumn(m, 0).length();\n\t\t\tconst sy = this.setFromMatrixColumn(m, 1).length();\n\t\t\tconst sz = this.setFromMatrixColumn(m, 2).length();\n\t\t\tthis.x = sx;\n\t\t\tthis.y = sy;\n\t\t\tthis.z = sz;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromMatrixColumn(m, index) {\n\t\t\treturn this.fromArray(m.elements, index * 4);\n\t\t}\n\n\t\tsetFromMatrix3Column(m, index) {\n\t\t\treturn this.fromArray(m.elements, index * 3);\n\t\t}\n\n\t\tequals(v) {\n\t\t\treturn v.x === this.x && v.y === this.y && v.z === this.z;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tthis.x = array[offset];\n\t\t\tthis.y = array[offset + 1];\n\t\t\tthis.z = array[offset + 2];\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this.x;\n\t\t\tarray[offset + 1] = this.y;\n\t\t\tarray[offset + 2] = this.z;\n\t\t\treturn array;\n\t\t}\n\n\t\tfromBufferAttribute(attribute, index, offset) {\n\t\t\tif (offset !== undefined) {\n\t\t\t\tconsole.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');\n\t\t\t}\n\n\t\t\tthis.x = attribute.getX(index);\n\t\t\tthis.y = attribute.getY(index);\n\t\t\tthis.z = attribute.getZ(index);\n\t\t\treturn this;\n\t\t}\n\n\t\trandom() {\n\t\t\tthis.x = Math.random();\n\t\t\tthis.y = Math.random();\n\t\t\tthis.z = Math.random();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tVector3.prototype.isVector3 = true;\n\n\tconst _vector$c = /*@__PURE__*/new Vector3();\n\n\tconst _quaternion$4 = /*@__PURE__*/new Quaternion();\n\n\tclass Box3 {\n\t\tconstructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\t\t}\n\n\t\tset(min, max) {\n\t\t\tthis.min.copy(min);\n\t\t\tthis.max.copy(max);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromArray(array) {\n\t\t\tlet minX = +Infinity;\n\t\t\tlet minY = +Infinity;\n\t\t\tlet minZ = +Infinity;\n\t\t\tlet maxX = -Infinity;\n\t\t\tlet maxY = -Infinity;\n\t\t\tlet maxZ = -Infinity;\n\n\t\t\tfor (let i = 0, l = array.length; i < l; i += 3) {\n\t\t\t\tconst x = array[i];\n\t\t\t\tconst y = array[i + 1];\n\t\t\t\tconst z = array[i + 2];\n\t\t\t\tif (x < minX) minX = x;\n\t\t\t\tif (y < minY) minY = y;\n\t\t\t\tif (z < minZ) minZ = z;\n\t\t\t\tif (x > maxX) maxX = x;\n\t\t\t\tif (y > maxY) maxY = y;\n\t\t\t\tif (z > maxZ) maxZ = z;\n\t\t\t}\n\n\t\t\tthis.min.set(minX, minY, minZ);\n\t\t\tthis.max.set(maxX, maxY, maxZ);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromBufferAttribute(attribute) {\n\t\t\tlet minX = +Infinity;\n\t\t\tlet minY = +Infinity;\n\t\t\tlet minZ = +Infinity;\n\t\t\tlet maxX = -Infinity;\n\t\t\tlet maxY = -Infinity;\n\t\t\tlet maxZ = -Infinity;\n\n\t\t\tfor (let i = 0, l = attribute.count; i < l; i++) {\n\t\t\t\tconst x = attribute.getX(i);\n\t\t\t\tconst y = attribute.getY(i);\n\t\t\t\tconst z = attribute.getZ(i);\n\t\t\t\tif (x < minX) minX = x;\n\t\t\t\tif (y < minY) minY = y;\n\t\t\t\tif (z < minZ) minZ = z;\n\t\t\t\tif (x > maxX) maxX = x;\n\t\t\t\tif (y > maxY) maxY = y;\n\t\t\t\tif (z > maxZ) maxZ = z;\n\t\t\t}\n\n\t\t\tthis.min.set(minX, minY, minZ);\n\t\t\tthis.max.set(maxX, maxY, maxZ);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromPoints(points) {\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor (let i = 0, il = points.length; i < il; i++) {\n\t\t\t\tthis.expandByPoint(points[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromCenterAndSize(center, size) {\n\t\t\tconst halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n\n\t\t\tthis.min.copy(center).sub(halfSize);\n\t\t\tthis.max.copy(center).add(halfSize);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromObject(object) {\n\t\t\tthis.makeEmpty();\n\t\t\treturn this.expandByObject(object);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(box) {\n\t\t\tthis.min.copy(box.min);\n\t\t\tthis.max.copy(box.max);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeEmpty() {\n\t\t\tthis.min.x = this.min.y = this.min.z = +Infinity;\n\t\t\tthis.max.x = this.max.y = this.max.z = -Infinity;\n\t\t\treturn this;\n\t\t}\n\n\t\tisEmpty() {\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\t\treturn this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n\t\t}\n\n\t\tgetCenter(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box3: .getCenter() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n\t\t}\n\n\t\tgetSize(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box3: .getSize() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n\t\t}\n\n\t\texpandByPoint(point) {\n\t\t\tthis.min.min(point);\n\t\t\tthis.max.max(point);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByVector(vector) {\n\t\t\tthis.min.sub(vector);\n\t\t\tthis.max.add(vector);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByScalar(scalar) {\n\t\t\tthis.min.addScalar(-scalar);\n\t\t\tthis.max.addScalar(scalar);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByObject(object) {\n\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t\t// accounting for both the object's, and children's, world transforms\n\t\t\tobject.updateWorldMatrix(false, false);\n\t\t\tconst geometry = object.geometry;\n\n\t\t\tif (geometry !== undefined) {\n\t\t\t\tif (geometry.boundingBox === null) {\n\t\t\t\t\tgeometry.computeBoundingBox();\n\t\t\t\t}\n\n\t\t\t\t_box$3.copy(geometry.boundingBox);\n\n\t\t\t\t_box$3.applyMatrix4(object.matrixWorld);\n\n\t\t\t\tthis.union(_box$3);\n\t\t\t}\n\n\t\t\tconst children = object.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tthis.expandByObject(children[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcontainsPoint(point) {\n\t\t\treturn point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;\n\t\t}\n\n\t\tcontainsBox(box) {\n\t\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n\t\t}\n\n\t\tgetParameter(point, target) {\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box3: .getParameter() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\t// using 6 splitting planes to rule out intersections.\n\t\t\treturn box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n\t\t}\n\n\t\tintersectsSphere(sphere) {\n\t\t\t// Find the point on the AABB closest to the sphere center.\n\t\t\tthis.clampPoint(sphere.center, _vector$b); // If that point is inside the sphere, the AABB and sphere intersect.\n\n\t\t\treturn _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n\t\t}\n\n\t\tintersectsPlane(plane) {\n\t\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\t\t\tlet min, max;\n\n\t\t\tif (plane.normal.x > 0) {\n\t\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\t\tmax = plane.normal.x * this.max.x;\n\t\t\t} else {\n\t\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\t\tmax = plane.normal.x * this.min.x;\n\t\t\t}\n\n\t\t\tif (plane.normal.y > 0) {\n\t\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\t\tmax += plane.normal.y * this.max.y;\n\t\t\t} else {\n\t\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\t\tmax += plane.normal.y * this.min.y;\n\t\t\t}\n\n\t\t\tif (plane.normal.z > 0) {\n\t\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\t\tmax += plane.normal.z * this.max.z;\n\t\t\t} else {\n\t\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\t\tmax += plane.normal.z * this.min.z;\n\t\t\t}\n\n\t\t\treturn min <= -plane.constant && max >= -plane.constant;\n\t\t}\n\n\t\tintersectsTriangle(triangle) {\n\t\t\tif (this.isEmpty()) {\n\t\t\t\treturn false;\n\t\t\t} // compute box center and extents\n\n\n\t\t\tthis.getCenter(_center);\n\n\t\t\t_extents.subVectors(this.max, _center); // translate triangle to aabb origin\n\n\n\t\t\t_v0$2.subVectors(triangle.a, _center);\n\n\t\t\t_v1$7.subVectors(triangle.b, _center);\n\n\t\t\t_v2$3.subVectors(triangle.c, _center); // compute edge vectors for triangle\n\n\n\t\t\t_f0.subVectors(_v1$7, _v0$2);\n\n\t\t\t_f1.subVectors(_v2$3, _v1$7);\n\n\t\t\t_f2.subVectors(_v0$2, _v2$3); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\n\n\t\t\tlet axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];\n\n\t\t\tif (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {\n\t\t\t\treturn false;\n\t\t\t} // test 3 face normals from the aabb\n\n\n\t\t\taxes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n\t\t\tif (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {\n\t\t\t\treturn false;\n\t\t\t} // finally testing the face normal of the triangle\n\t\t\t// use already existing triangle edge vectors here\n\n\n\t\t\t_triangleNormal.crossVectors(_f0, _f1);\n\n\t\t\taxes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n\t\t\treturn satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);\n\t\t}\n\n\t\tclampPoint(point, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box3: .clampPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.copy(point).clamp(this.min, this.max);\n\t\t}\n\n\t\tdistanceToPoint(point) {\n\t\t\tconst clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);\n\n\t\t\treturn clampedPoint.sub(point).length();\n\t\t}\n\n\t\tgetBoundingSphere(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.error('THREE.Box3: .getBoundingSphere() target is now required'); //target = new Sphere(); // removed to avoid cyclic dependency\n\t\t\t}\n\n\t\t\tthis.getCenter(target.center);\n\t\t\ttarget.radius = this.getSize(_vector$b).length() * 0.5;\n\t\t\treturn target;\n\t\t}\n\n\t\tintersect(box) {\n\t\t\tthis.min.max(box.min);\n\t\t\tthis.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\n\t\t\tif (this.isEmpty()) this.makeEmpty();\n\t\t\treturn this;\n\t\t}\n\n\t\tunion(box) {\n\t\t\tthis.min.min(box.min);\n\t\t\tthis.max.max(box.max);\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyMatrix4(matrix) {\n\t\t\t// transform of empty box is an empty box.\n\t\t\tif (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\n\t\t\t_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000\n\n\n\t\t\t_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001\n\n\n\t\t\t_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010\n\n\n\t\t\t_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011\n\n\n\t\t\t_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100\n\n\n\t\t\t_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101\n\n\n\t\t\t_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110\n\n\n\t\t\t_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111\n\n\n\t\t\tthis.setFromPoints(_points);\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(offset) {\n\t\t\tthis.min.add(offset);\n\t\t\tthis.max.add(offset);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(box) {\n\t\t\treturn box.min.equals(this.min) && box.max.equals(this.max);\n\t\t}\n\n\t}\n\n\tBox3.prototype.isBox3 = true;\n\tconst _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];\n\n\tconst _vector$b = /*@__PURE__*/new Vector3();\n\n\tconst _box$3 = /*@__PURE__*/new Box3(); // triangle centered vertices\n\n\n\tconst _v0$2 = /*@__PURE__*/new Vector3();\n\n\tconst _v1$7 = /*@__PURE__*/new Vector3();\n\n\tconst _v2$3 = /*@__PURE__*/new Vector3(); // triangle edge vectors\n\n\n\tconst _f0 = /*@__PURE__*/new Vector3();\n\n\tconst _f1 = /*@__PURE__*/new Vector3();\n\n\tconst _f2 = /*@__PURE__*/new Vector3();\n\n\tconst _center = /*@__PURE__*/new Vector3();\n\n\tconst _extents = /*@__PURE__*/new Vector3();\n\n\tconst _triangleNormal = /*@__PURE__*/new Vector3();\n\n\tconst _testAxis = /*@__PURE__*/new Vector3();\n\n\tfunction satForAxes(axes, v0, v1, v2, extents) {\n\t\tfor (let i = 0, j = axes.length - 3; i <= j; i += 3) {\n\t\t\t_testAxis.fromArray(axes, i); // project the aabb onto the seperating axis\n\n\n\t\t\tconst r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis\n\n\t\t\tconst p0 = v0.dot(_testAxis);\n\t\t\tconst p1 = v1.dot(_testAxis);\n\t\t\tconst p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r\n\n\t\t\tif (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n\t\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t\t// the axis is seperating and we can exit\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tconst _box$2 = /*@__PURE__*/new Box3();\n\n\tconst _v1$6 = /*@__PURE__*/new Vector3();\n\n\tconst _toFarthestPoint = /*@__PURE__*/new Vector3();\n\n\tconst _toPoint = /*@__PURE__*/new Vector3();\n\n\tclass Sphere {\n\t\tconstructor(center = new Vector3(), radius = -1) {\n\t\t\tthis.center = center;\n\t\t\tthis.radius = radius;\n\t\t}\n\n\t\tset(center, radius) {\n\t\t\tthis.center.copy(center);\n\t\t\tthis.radius = radius;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromPoints(points, optionalCenter) {\n\t\t\tconst center = this.center;\n\n\t\t\tif (optionalCenter !== undefined) {\n\t\t\t\tcenter.copy(optionalCenter);\n\t\t\t} else {\n\t\t\t\t_box$2.setFromPoints(points).getCenter(center);\n\t\t\t}\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor (let i = 0, il = points.length; i < il; i++) {\n\t\t\t\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n\t\t\t}\n\n\t\t\tthis.radius = Math.sqrt(maxRadiusSq);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(sphere) {\n\t\t\tthis.center.copy(sphere.center);\n\t\t\tthis.radius = sphere.radius;\n\t\t\treturn this;\n\t\t}\n\n\t\tisEmpty() {\n\t\t\treturn this.radius < 0;\n\t\t}\n\n\t\tmakeEmpty() {\n\t\t\tthis.center.set(0, 0, 0);\n\t\t\tthis.radius = -1;\n\t\t\treturn this;\n\t\t}\n\n\t\tcontainsPoint(point) {\n\t\t\treturn point.distanceToSquared(this.center) <= this.radius * this.radius;\n\t\t}\n\n\t\tdistanceToPoint(point) {\n\t\t\treturn point.distanceTo(this.center) - this.radius;\n\t\t}\n\n\t\tintersectsSphere(sphere) {\n\t\t\tconst radiusSum = this.radius + sphere.radius;\n\t\t\treturn sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\treturn box.intersectsSphere(this);\n\t\t}\n\n\t\tintersectsPlane(plane) {\n\t\t\treturn Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n\t\t}\n\n\t\tclampPoint(point, target) {\n\t\t\tconst deltaLengthSq = this.center.distanceToSquared(point);\n\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Sphere: .clampPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\ttarget.copy(point);\n\n\t\t\tif (deltaLengthSq > this.radius * this.radius) {\n\t\t\t\ttarget.sub(this.center).normalize();\n\t\t\t\ttarget.multiplyScalar(this.radius).add(this.center);\n\t\t\t}\n\n\t\t\treturn target;\n\t\t}\n\n\t\tgetBoundingBox(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Sphere: .getBoundingBox() target is now required');\n\t\t\t\ttarget = new Box3();\n\t\t\t}\n\n\t\t\tif (this.isEmpty()) {\n\t\t\t\t// Empty sphere produces empty bounding box\n\t\t\t\ttarget.makeEmpty();\n\t\t\t\treturn target;\n\t\t\t}\n\n\t\t\ttarget.set(this.center, this.center);\n\t\t\ttarget.expandByScalar(this.radius);\n\t\t\treturn target;\n\t\t}\n\n\t\tapplyMatrix4(matrix) {\n\t\t\tthis.center.applyMatrix4(matrix);\n\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(offset) {\n\t\t\tthis.center.add(offset);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByPoint(point) {\n\t\t\t// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671\n\t\t\t_toPoint.subVectors(point, this.center);\n\n\t\t\tconst lengthSq = _toPoint.lengthSq();\n\n\t\t\tif (lengthSq > this.radius * this.radius) {\n\t\t\t\tconst length = Math.sqrt(lengthSq);\n\t\t\t\tconst missingRadiusHalf = (length - this.radius) * 0.5; // Nudge this sphere towards the target point. Add half the missing distance to radius,\n\t\t\t\t// and the other half to position. This gives a tighter enclosure, instead of if\n\t\t\t\t// the whole missing distance were just added to radius.\n\n\t\t\t\tthis.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));\n\t\t\t\tthis.radius += missingRadiusHalf;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tunion(sphere) {\n\t\t\t// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769\n\t\t\t// To enclose another sphere into this sphere, we only need to enclose two points:\n\t\t\t// 1) Enclose the farthest point on the other sphere into this sphere.\n\t\t\t// 2) Enclose the opposite point of the farthest point into this sphere.\n\t\t\t_toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);\n\n\t\t\tthis.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));\n\t\t\tthis.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(sphere) {\n\t\t\treturn sphere.center.equals(this.center) && sphere.radius === this.radius;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tconst _vector$a = /*@__PURE__*/new Vector3();\n\n\tconst _segCenter = /*@__PURE__*/new Vector3();\n\n\tconst _segDir = /*@__PURE__*/new Vector3();\n\n\tconst _diff = /*@__PURE__*/new Vector3();\n\n\tconst _edge1 = /*@__PURE__*/new Vector3();\n\n\tconst _edge2 = /*@__PURE__*/new Vector3();\n\n\tconst _normal$1 = /*@__PURE__*/new Vector3();\n\n\tclass Ray {\n\t\tconstructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {\n\t\t\tthis.origin = origin;\n\t\t\tthis.direction = direction;\n\t\t}\n\n\t\tset(origin, direction) {\n\t\t\tthis.origin.copy(origin);\n\t\t\tthis.direction.copy(direction);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(ray) {\n\t\t\tthis.origin.copy(ray.origin);\n\t\t\tthis.direction.copy(ray.direction);\n\t\t\treturn this;\n\t\t}\n\n\t\tat(t, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Ray: .at() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.copy(this.direction).multiplyScalar(t).add(this.origin);\n\t\t}\n\n\t\tlookAt(v) {\n\t\t\tthis.direction.copy(v).sub(this.origin).normalize();\n\t\t\treturn this;\n\t\t}\n\n\t\trecast(t) {\n\t\t\tthis.origin.copy(this.at(t, _vector$a));\n\t\t\treturn this;\n\t\t}\n\n\t\tclosestPointToPoint(point, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Ray: .closestPointToPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\ttarget.subVectors(point, this.origin);\n\t\t\tconst directionDistance = target.dot(this.direction);\n\n\t\t\tif (directionDistance < 0) {\n\t\t\t\treturn target.copy(this.origin);\n\t\t\t}\n\n\t\t\treturn target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n\t\t}\n\n\t\tdistanceToPoint(point) {\n\t\t\treturn Math.sqrt(this.distanceSqToPoint(point));\n\t\t}\n\n\t\tdistanceSqToPoint(point) {\n\t\t\tconst directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction); // point behind the ray\n\n\n\t\t\tif (directionDistance < 0) {\n\t\t\t\treturn this.origin.distanceToSquared(point);\n\t\t\t}\n\n\t\t\t_vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n\n\t\t\treturn _vector$a.distanceToSquared(point);\n\t\t}\n\n\t\tdistanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t\t// It returns the min distance between the ray and the segment\n\t\t\t// defined by v0 and v1\n\t\t\t// It can also set two optional targets :\n\t\t\t// - The closest point on the ray\n\t\t\t// - The closest point on the segment\n\t\t\t_segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n\n\t\t\t_segDir.copy(v1).sub(v0).normalize();\n\n\t\t\t_diff.copy(this.origin).sub(_segCenter);\n\n\t\t\tconst segExtent = v0.distanceTo(v1) * 0.5;\n\t\t\tconst a01 = -this.direction.dot(_segDir);\n\n\t\t\tconst b0 = _diff.dot(this.direction);\n\n\t\t\tconst b1 = -_diff.dot(_segDir);\n\n\t\t\tconst c = _diff.lengthSq();\n\n\t\t\tconst det = Math.abs(1 - a01 * a01);\n\t\t\tlet s0, s1, sqrDist, extDet;\n\n\t\t\tif (det > 0) {\n\t\t\t\t// The ray and segment are not parallel.\n\t\t\t\ts0 = a01 * b1 - b0;\n\t\t\t\ts1 = a01 * b0 - b1;\n\t\t\t\textDet = segExtent * det;\n\n\t\t\t\tif (s0 >= 0) {\n\t\t\t\t\tif (s1 >= -extDet) {\n\t\t\t\t\t\tif (s1 <= extDet) {\n\t\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\t\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\t\tsqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// region 1\n\t\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\t\ts0 = Math.max(0, -(a01 * s1 + b0));\n\t\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// region 5\n\t\t\t\t\t\ts1 = -segExtent;\n\t\t\t\t\t\ts0 = Math.max(0, -(a01 * s1 + b0));\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (s1 <= -extDet) {\n\t\t\t\t\t\t// region 4\n\t\t\t\t\t\ts0 = Math.max(0, -(-a01 * segExtent + b0));\n\t\t\t\t\t\ts1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n\t\t\t\t\t} else if (s1 <= extDet) {\n\t\t\t\t\t\t// region 3\n\t\t\t\t\t\ts0 = 0;\n\t\t\t\t\t\ts1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n\t\t\t\t\t\tsqrDist = s1 * (s1 + 2 * b1) + c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// region 2\n\t\t\t\t\t\ts0 = Math.max(0, -(a01 * segExtent + b0));\n\t\t\t\t\t\ts1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Ray and segment are parallel.\n\t\t\t\ts1 = a01 > 0 ? -segExtent : segExtent;\n\t\t\t\ts0 = Math.max(0, -(a01 * s1 + b0));\n\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n\t\t\t}\n\n\t\t\tif (optionalPointOnRay) {\n\t\t\t\toptionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\n\t\t\t}\n\n\t\t\tif (optionalPointOnSegment) {\n\t\t\t\toptionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);\n\t\t\t}\n\n\t\t\treturn sqrDist;\n\t\t}\n\n\t\tintersectSphere(sphere, target) {\n\t\t\t_vector$a.subVectors(sphere.center, this.origin);\n\n\t\t\tconst tca = _vector$a.dot(this.direction);\n\n\t\t\tconst d2 = _vector$a.dot(_vector$a) - tca * tca;\n\t\t\tconst radius2 = sphere.radius * sphere.radius;\n\t\t\tif (d2 > radius2) return null;\n\t\t\tconst thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere\n\n\t\t\tconst t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere\n\n\t\t\tconst t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null\n\n\t\t\tif (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t\t// in order to always return an intersect point that is in front of the ray.\n\n\t\t\tif (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0\n\n\t\t\treturn this.at(t0, target);\n\t\t}\n\n\t\tintersectsSphere(sphere) {\n\t\t\treturn this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n\t\t}\n\n\t\tdistanceToPlane(plane) {\n\t\t\tconst denominator = plane.normal.dot(this.direction);\n\n\t\t\tif (denominator === 0) {\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif (plane.distanceToPoint(this.origin) === 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t} // Null is preferable to undefined since undefined means.... it is undefined\n\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane\n\n\t\t\treturn t >= 0 ? t : null;\n\t\t}\n\n\t\tintersectPlane(plane, target) {\n\t\t\tconst t = this.distanceToPlane(plane);\n\n\t\t\tif (t === null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn this.at(t, target);\n\t\t}\n\n\t\tintersectsPlane(plane) {\n\t\t\t// check if the ray lies on the plane first\n\t\t\tconst distToPoint = plane.distanceToPoint(this.origin);\n\n\t\t\tif (distToPoint === 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst denominator = plane.normal.dot(this.direction);\n\n\t\t\tif (denominator * distToPoint < 0) {\n\t\t\t\treturn true;\n\t\t\t} // ray origin is behind the plane (and is pointing behind it)\n\n\n\t\t\treturn false;\n\t\t}\n\n\t\tintersectBox(box, target) {\n\t\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\t\t\tconst invdirx = 1 / this.direction.x,\n\t\t\t\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\t\t\t\tinvdirz = 1 / this.direction.z;\n\t\t\tconst origin = this.origin;\n\n\t\t\tif (invdirx >= 0) {\n\t\t\t\ttmin = (box.min.x - origin.x) * invdirx;\n\t\t\t\ttmax = (box.max.x - origin.x) * invdirx;\n\t\t\t} else {\n\t\t\t\ttmin = (box.max.x - origin.x) * invdirx;\n\t\t\t\ttmax = (box.min.x - origin.x) * invdirx;\n\t\t\t}\n\n\t\t\tif (invdiry >= 0) {\n\t\t\t\ttymin = (box.min.y - origin.y) * invdiry;\n\t\t\t\ttymax = (box.max.y - origin.y) * invdiry;\n\t\t\t} else {\n\t\t\t\ttymin = (box.max.y - origin.y) * invdiry;\n\t\t\t\ttymax = (box.min.y - origin.y) * invdiry;\n\t\t\t}\n\n\t\t\tif (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN\n\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\t\tif (tymin > tmin || tmin !== tmin) tmin = tymin;\n\t\t\tif (tymax < tmax || tmax !== tmax) tmax = tymax;\n\n\t\t\tif (invdirz >= 0) {\n\t\t\t\ttzmin = (box.min.z - origin.z) * invdirz;\n\t\t\t\ttzmax = (box.max.z - origin.z) * invdirz;\n\t\t\t} else {\n\t\t\t\ttzmin = (box.max.z - origin.z) * invdirz;\n\t\t\t\ttzmax = (box.min.z - origin.z) * invdirz;\n\t\t\t}\n\n\t\t\tif (tmin > tzmax || tzmin > tmax) return null;\n\t\t\tif (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n\t\t\tif (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)\n\n\t\t\tif (tmax < 0) return null;\n\t\t\treturn this.at(tmin >= 0 ? tmin : tmax, target);\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\treturn this.intersectBox(box, _vector$a) !== null;\n\t\t}\n\n\t\tintersectTriangle(a, b, c, backfaceCulling, target) {\n\t\t\t// Compute the offset origin, edges, and normal.\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\t\t\t_edge1.subVectors(b, a);\n\n\t\t\t_edge2.subVectors(c, a);\n\n\t\t\t_normal$1.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t//\t |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t//\t |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t//\t |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\n\n\t\t\tlet DdN = this.direction.dot(_normal$1);\n\t\t\tlet sign;\n\n\t\t\tif (DdN > 0) {\n\t\t\t\tif (backfaceCulling) return null;\n\t\t\t\tsign = 1;\n\t\t\t} else if (DdN < 0) {\n\t\t\t\tsign = -1;\n\t\t\t\tDdN = -DdN;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t_diff.subVectors(this.origin, a);\n\n\t\t\tconst DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection\n\n\t\t\tif (DdQxE2 < 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection\n\n\t\t\tif (DdE1xQ < 0) {\n\t\t\t\treturn null;\n\t\t\t} // b1+b2 > 1, no intersection\n\n\n\t\t\tif (DdQxE2 + DdE1xQ > DdN) {\n\t\t\t\treturn null;\n\t\t\t} // Line intersects triangle, check if ray does.\n\n\n\t\t\tconst QdN = -sign * _diff.dot(_normal$1); // t < 0, no intersection\n\n\n\t\t\tif (QdN < 0) {\n\t\t\t\treturn null;\n\t\t\t} // Ray intersects triangle.\n\n\n\t\t\treturn this.at(QdN / DdN, target);\n\t\t}\n\n\t\tapplyMatrix4(matrix4) {\n\t\t\tthis.origin.applyMatrix4(matrix4);\n\t\t\tthis.direction.transformDirection(matrix4);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(ray) {\n\t\t\treturn ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tclass Matrix4 {\n\t\tconstructor() {\n\t\t\tthis.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\n\t\t\tif (arguments.length > 0) {\n\t\t\t\tconsole.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');\n\t\t\t}\n\t\t}\n\n\t\tset(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] = n11;\n\t\t\tte[4] = n12;\n\t\t\tte[8] = n13;\n\t\t\tte[12] = n14;\n\t\t\tte[1] = n21;\n\t\t\tte[5] = n22;\n\t\t\tte[9] = n23;\n\t\t\tte[13] = n24;\n\t\t\tte[2] = n31;\n\t\t\tte[6] = n32;\n\t\t\tte[10] = n33;\n\t\t\tte[14] = n34;\n\t\t\tte[3] = n41;\n\t\t\tte[7] = n42;\n\t\t\tte[11] = n43;\n\t\t\tte[15] = n44;\n\t\t\treturn this;\n\t\t}\n\n\t\tidentity() {\n\t\t\tthis.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new Matrix4().fromArray(this.elements);\n\t\t}\n\n\t\tcopy(m) {\n\t\t\tconst te = this.elements;\n\t\t\tconst me = m.elements;\n\t\t\tte[0] = me[0];\n\t\t\tte[1] = me[1];\n\t\t\tte[2] = me[2];\n\t\t\tte[3] = me[3];\n\t\t\tte[4] = me[4];\n\t\t\tte[5] = me[5];\n\t\t\tte[6] = me[6];\n\t\t\tte[7] = me[7];\n\t\t\tte[8] = me[8];\n\t\t\tte[9] = me[9];\n\t\t\tte[10] = me[10];\n\t\t\tte[11] = me[11];\n\t\t\tte[12] = me[12];\n\t\t\tte[13] = me[13];\n\t\t\tte[14] = me[14];\n\t\t\tte[15] = me[15];\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyPosition(m) {\n\t\t\tconst te = this.elements,\n\t\t\t\t\t\tme = m.elements;\n\t\t\tte[12] = me[12];\n\t\t\tte[13] = me[13];\n\t\t\tte[14] = me[14];\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromMatrix3(m) {\n\t\t\tconst me = m.elements;\n\t\t\tthis.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\textractBasis(xAxis, yAxis, zAxis) {\n\t\t\txAxis.setFromMatrixColumn(this, 0);\n\t\t\tyAxis.setFromMatrixColumn(this, 1);\n\t\t\tzAxis.setFromMatrixColumn(this, 2);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeBasis(xAxis, yAxis, zAxis) {\n\t\t\tthis.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\textractRotation(m) {\n\t\t\t// this method does not support reflection matrices\n\t\t\tconst te = this.elements;\n\t\t\tconst me = m.elements;\n\n\t\t\tconst scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();\n\n\t\t\tconst scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();\n\n\t\t\tconst scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();\n\n\t\t\tte[0] = me[0] * scaleX;\n\t\t\tte[1] = me[1] * scaleX;\n\t\t\tte[2] = me[2] * scaleX;\n\t\t\tte[3] = 0;\n\t\t\tte[4] = me[4] * scaleY;\n\t\t\tte[5] = me[5] * scaleY;\n\t\t\tte[6] = me[6] * scaleY;\n\t\t\tte[7] = 0;\n\t\t\tte[8] = me[8] * scaleZ;\n\t\t\tte[9] = me[9] * scaleZ;\n\t\t\tte[10] = me[10] * scaleZ;\n\t\t\tte[11] = 0;\n\t\t\tte[12] = 0;\n\t\t\tte[13] = 0;\n\t\t\tte[14] = 0;\n\t\t\tte[15] = 1;\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationFromEuler(euler) {\n\t\t\tif (!(euler && euler.isEuler)) {\n\t\t\t\tconsole.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');\n\t\t\t}\n\n\t\t\tconst te = this.elements;\n\t\t\tconst x = euler.x,\n\t\t\t\t\t\ty = euler.y,\n\t\t\t\t\t\tz = euler.z;\n\t\t\tconst a = Math.cos(x),\n\t\t\t\t\t\tb = Math.sin(x);\n\t\t\tconst c = Math.cos(y),\n\t\t\t\t\t\td = Math.sin(y);\n\t\t\tconst e = Math.cos(z),\n\t\t\t\t\t\tf = Math.sin(z);\n\n\t\t\tif (euler.order === 'XYZ') {\n\t\t\t\tconst ae = a * e,\n\t\t\t\t\t\t\taf = a * f,\n\t\t\t\t\t\t\tbe = b * e,\n\t\t\t\t\t\t\tbf = b * f;\n\t\t\t\tte[0] = c * e;\n\t\t\t\tte[4] = -c * f;\n\t\t\t\tte[8] = d;\n\t\t\t\tte[1] = af + be * d;\n\t\t\t\tte[5] = ae - bf * d;\n\t\t\t\tte[9] = -b * c;\n\t\t\t\tte[2] = bf - ae * d;\n\t\t\t\tte[6] = be + af * d;\n\t\t\t\tte[10] = a * c;\n\t\t\t} else if (euler.order === 'YXZ') {\n\t\t\t\tconst ce = c * e,\n\t\t\t\t\t\t\tcf = c * f,\n\t\t\t\t\t\t\tde = d * e,\n\t\t\t\t\t\t\tdf = d * f;\n\t\t\t\tte[0] = ce + df * b;\n\t\t\t\tte[4] = de * b - cf;\n\t\t\t\tte[8] = a * d;\n\t\t\t\tte[1] = a * f;\n\t\t\t\tte[5] = a * e;\n\t\t\t\tte[9] = -b;\n\t\t\t\tte[2] = cf * b - de;\n\t\t\t\tte[6] = df + ce * b;\n\t\t\t\tte[10] = a * c;\n\t\t\t} else if (euler.order === 'ZXY') {\n\t\t\t\tconst ce = c * e,\n\t\t\t\t\t\t\tcf = c * f,\n\t\t\t\t\t\t\tde = d * e,\n\t\t\t\t\t\t\tdf = d * f;\n\t\t\t\tte[0] = ce - df * b;\n\t\t\t\tte[4] = -a * f;\n\t\t\t\tte[8] = de + cf * b;\n\t\t\t\tte[1] = cf + de * b;\n\t\t\t\tte[5] = a * e;\n\t\t\t\tte[9] = df - ce * b;\n\t\t\t\tte[2] = -a * d;\n\t\t\t\tte[6] = b;\n\t\t\t\tte[10] = a * c;\n\t\t\t} else if (euler.order === 'ZYX') {\n\t\t\t\tconst ae = a * e,\n\t\t\t\t\t\t\taf = a * f,\n\t\t\t\t\t\t\tbe = b * e,\n\t\t\t\t\t\t\tbf = b * f;\n\t\t\t\tte[0] = c * e;\n\t\t\t\tte[4] = be * d - af;\n\t\t\t\tte[8] = ae * d + bf;\n\t\t\t\tte[1] = c * f;\n\t\t\t\tte[5] = bf * d + ae;\n\t\t\t\tte[9] = af * d - be;\n\t\t\t\tte[2] = -d;\n\t\t\t\tte[6] = b * c;\n\t\t\t\tte[10] = a * c;\n\t\t\t} else if (euler.order === 'YZX') {\n\t\t\t\tconst ac = a * c,\n\t\t\t\t\t\t\tad = a * d,\n\t\t\t\t\t\t\tbc = b * c,\n\t\t\t\t\t\t\tbd = b * d;\n\t\t\t\tte[0] = c * e;\n\t\t\t\tte[4] = bd - ac * f;\n\t\t\t\tte[8] = bc * f + ad;\n\t\t\t\tte[1] = f;\n\t\t\t\tte[5] = a * e;\n\t\t\t\tte[9] = -b * e;\n\t\t\t\tte[2] = -d * e;\n\t\t\t\tte[6] = ad * f + bc;\n\t\t\t\tte[10] = ac - bd * f;\n\t\t\t} else if (euler.order === 'XZY') {\n\t\t\t\tconst ac = a * c,\n\t\t\t\t\t\t\tad = a * d,\n\t\t\t\t\t\t\tbc = b * c,\n\t\t\t\t\t\t\tbd = b * d;\n\t\t\t\tte[0] = c * e;\n\t\t\t\tte[4] = -f;\n\t\t\t\tte[8] = d * e;\n\t\t\t\tte[1] = ac * f + bd;\n\t\t\t\tte[5] = a * e;\n\t\t\t\tte[9] = ad * f - bc;\n\t\t\t\tte[2] = bc * f - ad;\n\t\t\t\tte[6] = b * e;\n\t\t\t\tte[10] = bd * f + ac;\n\t\t\t} // bottom row\n\n\n\t\t\tte[3] = 0;\n\t\t\tte[7] = 0;\n\t\t\tte[11] = 0; // last column\n\n\t\t\tte[12] = 0;\n\t\t\tte[13] = 0;\n\t\t\tte[14] = 0;\n\t\t\tte[15] = 1;\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationFromQuaternion(q) {\n\t\t\treturn this.compose(_zero, q, _one);\n\t\t}\n\n\t\tlookAt(eye, target, up) {\n\t\t\tconst te = this.elements;\n\n\t\t\t_z.subVectors(eye, target);\n\n\t\t\tif (_z.lengthSq() === 0) {\n\t\t\t\t// eye and target are in the same position\n\t\t\t\t_z.z = 1;\n\t\t\t}\n\n\t\t\t_z.normalize();\n\n\t\t\t_x.crossVectors(up, _z);\n\n\t\t\tif (_x.lengthSq() === 0) {\n\t\t\t\t// up and z are parallel\n\t\t\t\tif (Math.abs(up.z) === 1) {\n\t\t\t\t\t_z.x += 0.0001;\n\t\t\t\t} else {\n\t\t\t\t\t_z.z += 0.0001;\n\t\t\t\t}\n\n\t\t\t\t_z.normalize();\n\n\t\t\t\t_x.crossVectors(up, _z);\n\t\t\t}\n\n\t\t\t_x.normalize();\n\n\t\t\t_y.crossVectors(_z, _x);\n\n\t\t\tte[0] = _x.x;\n\t\t\tte[4] = _y.x;\n\t\t\tte[8] = _z.x;\n\t\t\tte[1] = _x.y;\n\t\t\tte[5] = _y.y;\n\t\t\tte[9] = _z.y;\n\t\t\tte[2] = _x.z;\n\t\t\tte[6] = _y.z;\n\t\t\tte[10] = _z.z;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(m, n) {\n\t\t\tif (n !== undefined) {\n\t\t\t\tconsole.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');\n\t\t\t\treturn this.multiplyMatrices(m, n);\n\t\t\t}\n\n\t\t\treturn this.multiplyMatrices(this, m);\n\t\t}\n\n\t\tpremultiply(m) {\n\t\t\treturn this.multiplyMatrices(m, this);\n\t\t}\n\n\t\tmultiplyMatrices(a, b) {\n\t\t\tconst ae = a.elements;\n\t\t\tconst be = b.elements;\n\t\t\tconst te = this.elements;\n\t\t\tconst a11 = ae[0],\n\t\t\t\t\t\ta12 = ae[4],\n\t\t\t\t\t\ta13 = ae[8],\n\t\t\t\t\t\ta14 = ae[12];\n\t\t\tconst a21 = ae[1],\n\t\t\t\t\t\ta22 = ae[5],\n\t\t\t\t\t\ta23 = ae[9],\n\t\t\t\t\t\ta24 = ae[13];\n\t\t\tconst a31 = ae[2],\n\t\t\t\t\t\ta32 = ae[6],\n\t\t\t\t\t\ta33 = ae[10],\n\t\t\t\t\t\ta34 = ae[14];\n\t\t\tconst a41 = ae[3],\n\t\t\t\t\t\ta42 = ae[7],\n\t\t\t\t\t\ta43 = ae[11],\n\t\t\t\t\t\ta44 = ae[15];\n\t\t\tconst b11 = be[0],\n\t\t\t\t\t\tb12 = be[4],\n\t\t\t\t\t\tb13 = be[8],\n\t\t\t\t\t\tb14 = be[12];\n\t\t\tconst b21 = be[1],\n\t\t\t\t\t\tb22 = be[5],\n\t\t\t\t\t\tb23 = be[9],\n\t\t\t\t\t\tb24 = be[13];\n\t\t\tconst b31 = be[2],\n\t\t\t\t\t\tb32 = be[6],\n\t\t\t\t\t\tb33 = be[10],\n\t\t\t\t\t\tb34 = be[14];\n\t\t\tconst b41 = be[3],\n\t\t\t\t\t\tb42 = be[7],\n\t\t\t\t\t\tb43 = be[11],\n\t\t\t\t\t\tb44 = be[15];\n\t\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\t\tte[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\t\tte[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\t\tte[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\t\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\t\tte[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\t\tte[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\t\tte[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\t\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\t\tte[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\t\tte[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\t\tte[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\t\t\tte[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\t\tte[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\t\tte[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\t\tte[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(s) {\n\t\t\tconst te = this.elements;\n\t\t\tte[0] *= s;\n\t\t\tte[4] *= s;\n\t\t\tte[8] *= s;\n\t\t\tte[12] *= s;\n\t\t\tte[1] *= s;\n\t\t\tte[5] *= s;\n\t\t\tte[9] *= s;\n\t\t\tte[13] *= s;\n\t\t\tte[2] *= s;\n\t\t\tte[6] *= s;\n\t\t\tte[10] *= s;\n\t\t\tte[14] *= s;\n\t\t\tte[3] *= s;\n\t\t\tte[7] *= s;\n\t\t\tte[11] *= s;\n\t\t\tte[15] *= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tdeterminant() {\n\t\t\tconst te = this.elements;\n\t\t\tconst n11 = te[0],\n\t\t\t\t\t\tn12 = te[4],\n\t\t\t\t\t\tn13 = te[8],\n\t\t\t\t\t\tn14 = te[12];\n\t\t\tconst n21 = te[1],\n\t\t\t\t\t\tn22 = te[5],\n\t\t\t\t\t\tn23 = te[9],\n\t\t\t\t\t\tn24 = te[13];\n\t\t\tconst n31 = te[2],\n\t\t\t\t\t\tn32 = te[6],\n\t\t\t\t\t\tn33 = te[10],\n\t\t\t\t\t\tn34 = te[14];\n\t\t\tconst n41 = te[3],\n\t\t\t\t\t\tn42 = te[7],\n\t\t\t\t\t\tn43 = te[11],\n\t\t\t\t\t\tn44 = te[15]; //TODO: make this more efficient\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\t\treturn n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n\t\t}\n\n\t\ttranspose() {\n\t\t\tconst te = this.elements;\n\t\t\tlet tmp;\n\t\t\ttmp = te[1];\n\t\t\tte[1] = te[4];\n\t\t\tte[4] = tmp;\n\t\t\ttmp = te[2];\n\t\t\tte[2] = te[8];\n\t\t\tte[8] = tmp;\n\t\t\ttmp = te[6];\n\t\t\tte[6] = te[9];\n\t\t\tte[9] = tmp;\n\t\t\ttmp = te[3];\n\t\t\tte[3] = te[12];\n\t\t\tte[12] = tmp;\n\t\t\ttmp = te[7];\n\t\t\tte[7] = te[13];\n\t\t\tte[13] = tmp;\n\t\t\ttmp = te[11];\n\t\t\tte[11] = te[14];\n\t\t\tte[14] = tmp;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetPosition(x, y, z) {\n\t\t\tconst te = this.elements;\n\n\t\t\tif (x.isVector3) {\n\t\t\t\tte[12] = x.x;\n\t\t\t\tte[13] = x.y;\n\t\t\t\tte[14] = x.z;\n\t\t\t} else {\n\t\t\t\tte[12] = x;\n\t\t\t\tte[13] = y;\n\t\t\t\tte[14] = z;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tinvert() {\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t\tconst te = this.elements,\n\t\t\t\t\t\tn11 = te[0],\n\t\t\t\t\t\tn21 = te[1],\n\t\t\t\t\t\tn31 = te[2],\n\t\t\t\t\t\tn41 = te[3],\n\t\t\t\t\t\tn12 = te[4],\n\t\t\t\t\t\tn22 = te[5],\n\t\t\t\t\t\tn32 = te[6],\n\t\t\t\t\t\tn42 = te[7],\n\t\t\t\t\t\tn13 = te[8],\n\t\t\t\t\t\tn23 = te[9],\n\t\t\t\t\t\tn33 = te[10],\n\t\t\t\t\t\tn43 = te[11],\n\t\t\t\t\t\tn14 = te[12],\n\t\t\t\t\t\tn24 = te[13],\n\t\t\t\t\t\tn34 = te[14],\n\t\t\t\t\t\tn44 = te[15],\n\t\t\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\t\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\t\t\tif (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n\t\t\tconst detInv = 1 / det;\n\t\t\tte[0] = t11 * detInv;\n\t\t\tte[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n\t\t\tte[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n\t\t\tte[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n\t\t\tte[4] = t12 * detInv;\n\t\t\tte[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n\t\t\tte[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n\t\t\tte[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n\t\t\tte[8] = t13 * detInv;\n\t\t\tte[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n\t\t\tte[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n\t\t\tte[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n\t\t\tte[12] = t14 * detInv;\n\t\t\tte[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n\t\t\tte[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n\t\t\tte[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n\t\t\treturn this;\n\t\t}\n\n\t\tscale(v) {\n\t\t\tconst te = this.elements;\n\t\t\tconst x = v.x,\n\t\t\t\t\t\ty = v.y,\n\t\t\t\t\t\tz = v.z;\n\t\t\tte[0] *= x;\n\t\t\tte[4] *= y;\n\t\t\tte[8] *= z;\n\t\t\tte[1] *= x;\n\t\t\tte[5] *= y;\n\t\t\tte[9] *= z;\n\t\t\tte[2] *= x;\n\t\t\tte[6] *= y;\n\t\t\tte[10] *= z;\n\t\t\tte[3] *= x;\n\t\t\tte[7] *= y;\n\t\t\tte[11] *= z;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetMaxScaleOnAxis() {\n\t\t\tconst te = this.elements;\n\t\t\tconst scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n\t\t\tconst scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n\t\t\tconst scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n\t\t\treturn Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n\t\t}\n\n\t\tmakeTranslation(x, y, z) {\n\t\t\tthis.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationX(theta) {\n\t\t\tconst c = Math.cos(theta),\n\t\t\t\t\t\ts = Math.sin(theta);\n\t\t\tthis.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationY(theta) {\n\t\t\tconst c = Math.cos(theta),\n\t\t\t\t\t\ts = Math.sin(theta);\n\t\t\tthis.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationZ(theta) {\n\t\t\tconst c = Math.cos(theta),\n\t\t\t\t\t\ts = Math.sin(theta);\n\t\t\tthis.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeRotationAxis(axis, angle) {\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\t\t\tconst c = Math.cos(angle);\n\t\t\tconst s = Math.sin(angle);\n\t\t\tconst t = 1 - c;\n\t\t\tconst x = axis.x,\n\t\t\t\t\t\ty = axis.y,\n\t\t\t\t\t\tz = axis.z;\n\t\t\tconst tx = t * x,\n\t\t\t\t\t\tty = t * y;\n\t\t\tthis.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeScale(x, y, z) {\n\t\t\tthis.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeShear(xy, xz, yx, yz, zx, zy) {\n\t\t\tthis.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);\n\t\t\treturn this;\n\t\t}\n\n\t\tcompose(position, quaternion, scale) {\n\t\t\tconst te = this.elements;\n\t\t\tconst x = quaternion._x,\n\t\t\t\t\t\ty = quaternion._y,\n\t\t\t\t\t\tz = quaternion._z,\n\t\t\t\t\t\tw = quaternion._w;\n\t\t\tconst x2 = x + x,\n\t\t\t\t\t\ty2 = y + y,\n\t\t\t\t\t\tz2 = z + z;\n\t\t\tconst xx = x * x2,\n\t\t\t\t\t\txy = x * y2,\n\t\t\t\t\t\txz = x * z2;\n\t\t\tconst yy = y * y2,\n\t\t\t\t\t\tyz = y * z2,\n\t\t\t\t\t\tzz = z * z2;\n\t\t\tconst wx = w * x2,\n\t\t\t\t\t\twy = w * y2,\n\t\t\t\t\t\twz = w * z2;\n\t\t\tconst sx = scale.x,\n\t\t\t\t\t\tsy = scale.y,\n\t\t\t\t\t\tsz = scale.z;\n\t\t\tte[0] = (1 - (yy + zz)) * sx;\n\t\t\tte[1] = (xy + wz) * sx;\n\t\t\tte[2] = (xz - wy) * sx;\n\t\t\tte[3] = 0;\n\t\t\tte[4] = (xy - wz) * sy;\n\t\t\tte[5] = (1 - (xx + zz)) * sy;\n\t\t\tte[6] = (yz + wx) * sy;\n\t\t\tte[7] = 0;\n\t\t\tte[8] = (xz + wy) * sz;\n\t\t\tte[9] = (yz - wx) * sz;\n\t\t\tte[10] = (1 - (xx + yy)) * sz;\n\t\t\tte[11] = 0;\n\t\t\tte[12] = position.x;\n\t\t\tte[13] = position.y;\n\t\t\tte[14] = position.z;\n\t\t\tte[15] = 1;\n\t\t\treturn this;\n\t\t}\n\n\t\tdecompose(position, quaternion, scale) {\n\t\t\tconst te = this.elements;\n\n\t\t\tlet sx = _v1$5.set(te[0], te[1], te[2]).length();\n\n\t\t\tconst sy = _v1$5.set(te[4], te[5], te[6]).length();\n\n\t\t\tconst sz = _v1$5.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale\n\n\n\t\t\tconst det = this.determinant();\n\t\t\tif (det < 0) sx = -sx;\n\t\t\tposition.x = te[12];\n\t\t\tposition.y = te[13];\n\t\t\tposition.z = te[14]; // scale the rotation part\n\n\t\t\t_m1$2.copy(this);\n\n\t\t\tconst invSX = 1 / sx;\n\t\t\tconst invSY = 1 / sy;\n\t\t\tconst invSZ = 1 / sz;\n\t\t\t_m1$2.elements[0] *= invSX;\n\t\t\t_m1$2.elements[1] *= invSX;\n\t\t\t_m1$2.elements[2] *= invSX;\n\t\t\t_m1$2.elements[4] *= invSY;\n\t\t\t_m1$2.elements[5] *= invSY;\n\t\t\t_m1$2.elements[6] *= invSY;\n\t\t\t_m1$2.elements[8] *= invSZ;\n\t\t\t_m1$2.elements[9] *= invSZ;\n\t\t\t_m1$2.elements[10] *= invSZ;\n\t\t\tquaternion.setFromRotationMatrix(_m1$2);\n\t\t\tscale.x = sx;\n\t\t\tscale.y = sy;\n\t\t\tscale.z = sz;\n\t\t\treturn this;\n\t\t}\n\n\t\tmakePerspective(left, right, top, bottom, near, far) {\n\t\t\tif (far === undefined) {\n\t\t\t\tconsole.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');\n\t\t\t}\n\n\t\t\tconst te = this.elements;\n\t\t\tconst x = 2 * near / (right - left);\n\t\t\tconst y = 2 * near / (top - bottom);\n\t\t\tconst a = (right + left) / (right - left);\n\t\t\tconst b = (top + bottom) / (top - bottom);\n\t\t\tconst c = -(far + near) / (far - near);\n\t\t\tconst d = -2 * far * near / (far - near);\n\t\t\tte[0] = x;\n\t\t\tte[4] = 0;\n\t\t\tte[8] = a;\n\t\t\tte[12] = 0;\n\t\t\tte[1] = 0;\n\t\t\tte[5] = y;\n\t\t\tte[9] = b;\n\t\t\tte[13] = 0;\n\t\t\tte[2] = 0;\n\t\t\tte[6] = 0;\n\t\t\tte[10] = c;\n\t\t\tte[14] = d;\n\t\t\tte[3] = 0;\n\t\t\tte[7] = 0;\n\t\t\tte[11] = -1;\n\t\t\tte[15] = 0;\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeOrthographic(left, right, top, bottom, near, far) {\n\t\t\tconst te = this.elements;\n\t\t\tconst w = 1.0 / (right - left);\n\t\t\tconst h = 1.0 / (top - bottom);\n\t\t\tconst p = 1.0 / (far - near);\n\t\t\tconst x = (right + left) * w;\n\t\t\tconst y = (top + bottom) * h;\n\t\t\tconst z = (far + near) * p;\n\t\t\tte[0] = 2 * w;\n\t\t\tte[4] = 0;\n\t\t\tte[8] = 0;\n\t\t\tte[12] = -x;\n\t\t\tte[1] = 0;\n\t\t\tte[5] = 2 * h;\n\t\t\tte[9] = 0;\n\t\t\tte[13] = -y;\n\t\t\tte[2] = 0;\n\t\t\tte[6] = 0;\n\t\t\tte[10] = -2 * p;\n\t\t\tte[14] = -z;\n\t\t\tte[3] = 0;\n\t\t\tte[7] = 0;\n\t\t\tte[11] = 0;\n\t\t\tte[15] = 1;\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(matrix) {\n\t\t\tconst te = this.elements;\n\t\t\tconst me = matrix.elements;\n\n\t\t\tfor (let i = 0; i < 16; i++) {\n\t\t\t\tif (te[i] !== me[i]) return false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tfor (let i = 0; i < 16; i++) {\n\t\t\t\tthis.elements[i] = array[i + offset];\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tconst te = this.elements;\n\t\t\tarray[offset] = te[0];\n\t\t\tarray[offset + 1] = te[1];\n\t\t\tarray[offset + 2] = te[2];\n\t\t\tarray[offset + 3] = te[3];\n\t\t\tarray[offset + 4] = te[4];\n\t\t\tarray[offset + 5] = te[5];\n\t\t\tarray[offset + 6] = te[6];\n\t\t\tarray[offset + 7] = te[7];\n\t\t\tarray[offset + 8] = te[8];\n\t\t\tarray[offset + 9] = te[9];\n\t\t\tarray[offset + 10] = te[10];\n\t\t\tarray[offset + 11] = te[11];\n\t\t\tarray[offset + 12] = te[12];\n\t\t\tarray[offset + 13] = te[13];\n\t\t\tarray[offset + 14] = te[14];\n\t\t\tarray[offset + 15] = te[15];\n\t\t\treturn array;\n\t\t}\n\n\t}\n\n\tMatrix4.prototype.isMatrix4 = true;\n\n\tconst _v1$5 = /*@__PURE__*/new Vector3();\n\n\tconst _m1$2 = /*@__PURE__*/new Matrix4();\n\n\tconst _zero = /*@__PURE__*/new Vector3(0, 0, 0);\n\n\tconst _one = /*@__PURE__*/new Vector3(1, 1, 1);\n\n\tconst _x = /*@__PURE__*/new Vector3();\n\n\tconst _y = /*@__PURE__*/new Vector3();\n\n\tconst _z = /*@__PURE__*/new Vector3();\n\n\tconst _matrix$1 = /*@__PURE__*/new Matrix4();\n\n\tconst _quaternion$3 = /*@__PURE__*/new Quaternion();\n\n\tclass Euler {\n\t\tconstructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._order = order;\n\t\t}\n\n\t\tget x() {\n\t\t\treturn this._x;\n\t\t}\n\n\t\tset x(value) {\n\t\t\tthis._x = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget y() {\n\t\t\treturn this._y;\n\t\t}\n\n\t\tset y(value) {\n\t\t\tthis._y = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget z() {\n\t\t\treturn this._z;\n\t\t}\n\n\t\tset z(value) {\n\t\t\tthis._z = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tget order() {\n\t\t\treturn this._order;\n\t\t}\n\n\t\tset order(value) {\n\t\t\tthis._order = value;\n\n\t\t\tthis._onChangeCallback();\n\t\t}\n\n\t\tset(x, y, z, order) {\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\t\t\tthis._order = order || this._order;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this._x, this._y, this._z, this._order);\n\t\t}\n\n\t\tcopy(euler) {\n\t\t\tthis._x = euler._x;\n\t\t\tthis._y = euler._y;\n\t\t\tthis._z = euler._z;\n\t\t\tthis._order = euler._order;\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromRotationMatrix(m, order, update) {\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\t\tconst te = m.elements;\n\t\t\tconst m11 = te[0],\n\t\t\t\t\t\tm12 = te[4],\n\t\t\t\t\t\tm13 = te[8];\n\t\t\tconst m21 = te[1],\n\t\t\t\t\t\tm22 = te[5],\n\t\t\t\t\t\tm23 = te[9];\n\t\t\tconst m31 = te[2],\n\t\t\t\t\t\tm32 = te[6],\n\t\t\t\t\t\tm33 = te[10];\n\t\t\torder = order || this._order;\n\n\t\t\tswitch (order) {\n\t\t\t\tcase 'XYZ':\n\t\t\t\t\tthis._y = Math.asin(clamp(m13, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m13) < 0.9999999) {\n\t\t\t\t\t\tthis._x = Math.atan2(-m23, m33);\n\t\t\t\t\t\tthis._z = Math.atan2(-m12, m11);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._x = Math.atan2(m32, m22);\n\t\t\t\t\t\tthis._z = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'YXZ':\n\t\t\t\t\tthis._x = Math.asin(-clamp(m23, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m23) < 0.9999999) {\n\t\t\t\t\t\tthis._y = Math.atan2(m13, m33);\n\t\t\t\t\t\tthis._z = Math.atan2(m21, m22);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._y = Math.atan2(-m31, m11);\n\t\t\t\t\t\tthis._z = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZXY':\n\t\t\t\t\tthis._x = Math.asin(clamp(m32, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m32) < 0.9999999) {\n\t\t\t\t\t\tthis._y = Math.atan2(-m31, m33);\n\t\t\t\t\t\tthis._z = Math.atan2(-m12, m22);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._y = 0;\n\t\t\t\t\t\tthis._z = Math.atan2(m21, m11);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ZYX':\n\t\t\t\t\tthis._y = Math.asin(-clamp(m31, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m31) < 0.9999999) {\n\t\t\t\t\t\tthis._x = Math.atan2(m32, m33);\n\t\t\t\t\t\tthis._z = Math.atan2(m21, m11);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\tthis._z = Math.atan2(-m12, m22);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'YZX':\n\t\t\t\t\tthis._z = Math.asin(clamp(m21, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m21) < 0.9999999) {\n\t\t\t\t\t\tthis._x = Math.atan2(-m23, m22);\n\t\t\t\t\t\tthis._y = Math.atan2(-m31, m11);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._x = 0;\n\t\t\t\t\t\tthis._y = Math.atan2(m13, m33);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'XZY':\n\t\t\t\t\tthis._z = Math.asin(-clamp(m12, -1, 1));\n\n\t\t\t\t\tif (Math.abs(m12) < 0.9999999) {\n\t\t\t\t\t\tthis._x = Math.atan2(m32, m22);\n\t\t\t\t\t\tthis._y = Math.atan2(m13, m11);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._x = Math.atan2(-m23, m33);\n\t\t\t\t\t\tthis._y = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);\n\t\t\t}\n\n\t\t\tthis._order = order;\n\t\t\tif (update !== false) this._onChangeCallback();\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromQuaternion(q, order, update) {\n\t\t\t_matrix$1.makeRotationFromQuaternion(q);\n\n\t\t\treturn this.setFromRotationMatrix(_matrix$1, order, update);\n\t\t}\n\n\t\tsetFromVector3(v, order) {\n\t\t\treturn this.set(v.x, v.y, v.z, order || this._order);\n\t\t}\n\n\t\treorder(newOrder) {\n\t\t\t// WARNING: this discards revolution information -bhouston\n\t\t\t_quaternion$3.setFromEuler(this);\n\n\t\t\treturn this.setFromQuaternion(_quaternion$3, newOrder);\n\t\t}\n\n\t\tequals(euler) {\n\t\t\treturn euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n\t\t}\n\n\t\tfromArray(array) {\n\t\t\tthis._x = array[0];\n\t\t\tthis._y = array[1];\n\t\t\tthis._z = array[2];\n\t\t\tif (array[3] !== undefined) this._order = array[3];\n\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this._x;\n\t\t\tarray[offset + 1] = this._y;\n\t\t\tarray[offset + 2] = this._z;\n\t\t\tarray[offset + 3] = this._order;\n\t\t\treturn array;\n\t\t}\n\n\t\ttoVector3(optionalResult) {\n\t\t\tif (optionalResult) {\n\t\t\t\treturn optionalResult.set(this._x, this._y, this._z);\n\t\t\t} else {\n\t\t\t\treturn new Vector3(this._x, this._y, this._z);\n\t\t\t}\n\t\t}\n\n\t\t_onChange(callback) {\n\t\t\tthis._onChangeCallback = callback;\n\t\t\treturn this;\n\t\t}\n\n\t\t_onChangeCallback() {}\n\n\t}\n\n\tEuler.prototype.isEuler = true;\n\tEuler.DefaultOrder = 'XYZ';\n\tEuler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];\n\n\tclass Layers {\n\t\tconstructor() {\n\t\t\tthis.mask = 1 | 0;\n\t\t}\n\n\t\tset(channel) {\n\t\t\tthis.mask = 1 << channel | 0;\n\t\t}\n\n\t\tenable(channel) {\n\t\t\tthis.mask |= 1 << channel | 0;\n\t\t}\n\n\t\tenableAll() {\n\t\t\tthis.mask = 0xffffffff | 0;\n\t\t}\n\n\t\ttoggle(channel) {\n\t\t\tthis.mask ^= 1 << channel | 0;\n\t\t}\n\n\t\tdisable(channel) {\n\t\t\tthis.mask &= ~(1 << channel | 0);\n\t\t}\n\n\t\tdisableAll() {\n\t\t\tthis.mask = 0;\n\t\t}\n\n\t\ttest(layers) {\n\t\t\treturn (this.mask & layers.mask) !== 0;\n\t\t}\n\n\t}\n\n\tlet _object3DId = 0;\n\n\tconst _v1$4 = /*@__PURE__*/new Vector3();\n\n\tconst _q1 = /*@__PURE__*/new Quaternion();\n\n\tconst _m1$1 = /*@__PURE__*/new Matrix4();\n\n\tconst _target = /*@__PURE__*/new Vector3();\n\n\tconst _position$3 = /*@__PURE__*/new Vector3();\n\n\tconst _scale$2 = /*@__PURE__*/new Vector3();\n\n\tconst _quaternion$2 = /*@__PURE__*/new Quaternion();\n\n\tconst _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);\n\n\tconst _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);\n\n\tconst _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);\n\n\tconst _addedEvent = {\n\t\ttype: 'added'\n\t};\n\tconst _removedEvent = {\n\t\ttype: 'removed'\n\t};\n\n\tclass Object3D extends EventDispatcher {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tObject.defineProperty(this, 'id', {\n\t\t\t\tvalue: _object3DId++\n\t\t\t});\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Object3D';\n\t\t\tthis.parent = null;\n\t\t\tthis.children = [];\n\t\t\tthis.up = Object3D.DefaultUp.clone();\n\t\t\tconst position = new Vector3();\n\t\t\tconst rotation = new Euler();\n\t\t\tconst quaternion = new Quaternion();\n\t\t\tconst scale = new Vector3(1, 1, 1);\n\n\t\t\tfunction onRotationChange() {\n\t\t\t\tquaternion.setFromEuler(rotation, false);\n\t\t\t}\n\n\t\t\tfunction onQuaternionChange() {\n\t\t\t\trotation.setFromQuaternion(quaternion, undefined, false);\n\t\t\t}\n\n\t\t\trotation._onChange(onRotationChange);\n\n\t\t\tquaternion._onChange(onQuaternionChange);\n\n\t\t\tObject.defineProperties(this, {\n\t\t\t\tposition: {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: position\n\t\t\t\t},\n\t\t\t\trotation: {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: rotation\n\t\t\t\t},\n\t\t\t\tquaternion: {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: quaternion\n\t\t\t\t},\n\t\t\t\tscale: {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: scale\n\t\t\t\t},\n\t\t\t\tmodelViewMatrix: {\n\t\t\t\t\tvalue: new Matrix4()\n\t\t\t\t},\n\t\t\t\tnormalMatrix: {\n\t\t\t\t\tvalue: new Matrix3()\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.matrix = new Matrix4();\n\t\t\tthis.matrixWorld = new Matrix4();\n\t\t\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\t\t\tthis.layers = new Layers();\n\t\t\tthis.visible = true;\n\t\t\tthis.castShadow = false;\n\t\t\tthis.receiveShadow = false;\n\t\t\tthis.frustumCulled = true;\n\t\t\tthis.renderOrder = 0;\n\t\t\tthis.animations = [];\n\t\t\tthis.userData = {};\n\t\t}\n\n\t\tonBeforeRender() {}\n\n\t\tonAfterRender() {}\n\n\t\tapplyMatrix4(matrix) {\n\t\t\tif (this.matrixAutoUpdate) this.updateMatrix();\n\t\t\tthis.matrix.premultiply(matrix);\n\t\t\tthis.matrix.decompose(this.position, this.quaternion, this.scale);\n\t\t}\n\n\t\tapplyQuaternion(q) {\n\t\t\tthis.quaternion.premultiply(q);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetRotationFromAxisAngle(axis, angle) {\n\t\t\t// assumes axis is normalized\n\t\t\tthis.quaternion.setFromAxisAngle(axis, angle);\n\t\t}\n\n\t\tsetRotationFromEuler(euler) {\n\t\t\tthis.quaternion.setFromEuler(euler, true);\n\t\t}\n\n\t\tsetRotationFromMatrix(m) {\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t\t\tthis.quaternion.setFromRotationMatrix(m);\n\t\t}\n\n\t\tsetRotationFromQuaternion(q) {\n\t\t\t// assumes q is normalized\n\t\t\tthis.quaternion.copy(q);\n\t\t}\n\n\t\trotateOnAxis(axis, angle) {\n\t\t\t// rotate object on axis in object space\n\t\t\t// axis is assumed to be normalized\n\t\t\t_q1.setFromAxisAngle(axis, angle);\n\n\t\t\tthis.quaternion.multiply(_q1);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateOnWorldAxis(axis, angle) {\n\t\t\t// rotate object on axis in world space\n\t\t\t// axis is assumed to be normalized\n\t\t\t// method assumes no rotated parent\n\t\t\t_q1.setFromAxisAngle(axis, angle);\n\n\t\t\tthis.quaternion.premultiply(_q1);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateX(angle) {\n\t\t\treturn this.rotateOnAxis(_xAxis, angle);\n\t\t}\n\n\t\trotateY(angle) {\n\t\t\treturn this.rotateOnAxis(_yAxis, angle);\n\t\t}\n\n\t\trotateZ(angle) {\n\t\t\treturn this.rotateOnAxis(_zAxis, angle);\n\t\t}\n\n\t\ttranslateOnAxis(axis, distance) {\n\t\t\t// translate object by distance along axis in object space\n\t\t\t// axis is assumed to be normalized\n\t\t\t_v1$4.copy(axis).applyQuaternion(this.quaternion);\n\n\t\t\tthis.position.add(_v1$4.multiplyScalar(distance));\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslateX(distance) {\n\t\t\treturn this.translateOnAxis(_xAxis, distance);\n\t\t}\n\n\t\ttranslateY(distance) {\n\t\t\treturn this.translateOnAxis(_yAxis, distance);\n\t\t}\n\n\t\ttranslateZ(distance) {\n\t\t\treturn this.translateOnAxis(_zAxis, distance);\n\t\t}\n\n\t\tlocalToWorld(vector) {\n\t\t\treturn vector.applyMatrix4(this.matrixWorld);\n\t\t}\n\n\t\tworldToLocal(vector) {\n\t\t\treturn vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());\n\t\t}\n\n\t\tlookAt(x, y, z) {\n\t\t\t// This method does not support objects having non-uniformly-scaled parent(s)\n\t\t\tif (x.isVector3) {\n\t\t\t\t_target.copy(x);\n\t\t\t} else {\n\t\t\t\t_target.set(x, y, z);\n\t\t\t}\n\n\t\t\tconst parent = this.parent;\n\t\t\tthis.updateWorldMatrix(true, false);\n\n\t\t\t_position$3.setFromMatrixPosition(this.matrixWorld);\n\n\t\t\tif (this.isCamera || this.isLight) {\n\t\t\t\t_m1$1.lookAt(_position$3, _target, this.up);\n\t\t\t} else {\n\t\t\t\t_m1$1.lookAt(_target, _position$3, this.up);\n\t\t\t}\n\n\t\t\tthis.quaternion.setFromRotationMatrix(_m1$1);\n\n\t\t\tif (parent) {\n\t\t\t\t_m1$1.extractRotation(parent.matrixWorld);\n\n\t\t\t\t_q1.setFromRotationMatrix(_m1$1);\n\n\t\t\t\tthis.quaternion.premultiply(_q1.invert());\n\t\t\t}\n\t\t}\n\n\t\tadd(object) {\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\t\t\tthis.add(arguments[i]);\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (object === this) {\n\t\t\t\tconsole.error('THREE.Object3D.add: object can\\'t be added as a child of itself.', object);\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (object && object.isObject3D) {\n\t\t\t\tif (object.parent !== null) {\n\t\t\t\t\tobject.parent.remove(object);\n\t\t\t\t}\n\n\t\t\t\tobject.parent = this;\n\t\t\t\tthis.children.push(object);\n\t\t\t\tobject.dispatchEvent(_addedEvent);\n\t\t\t} else {\n\t\t\t\tconsole.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tremove(object) {\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\t\t\tthis.remove(arguments[i]);\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tconst index = this.children.indexOf(object);\n\n\t\t\tif (index !== -1) {\n\t\t\t\tobject.parent = null;\n\t\t\t\tthis.children.splice(index, 1);\n\t\t\t\tobject.dispatchEvent(_removedEvent);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tremoveFromParent() {\n\t\t\tconst parent = this.parent;\n\n\t\t\tif (parent !== null) {\n\t\t\t\tparent.remove(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclear() {\n\t\t\tfor (let i = 0; i < this.children.length; i++) {\n\t\t\t\tconst object = this.children[i];\n\t\t\t\tobject.parent = null;\n\t\t\t\tobject.dispatchEvent(_removedEvent);\n\t\t\t}\n\n\t\t\tthis.children.length = 0;\n\t\t\treturn this;\n\t\t}\n\n\t\tattach(object) {\n\t\t\t// adds object as a child of this, while maintaining the object's world transform\n\t\t\tthis.updateWorldMatrix(true, false);\n\n\t\t\t_m1$1.copy(this.matrixWorld).invert();\n\n\t\t\tif (object.parent !== null) {\n\t\t\t\tobject.parent.updateWorldMatrix(true, false);\n\n\t\t\t\t_m1$1.multiply(object.parent.matrixWorld);\n\t\t\t}\n\n\t\t\tobject.applyMatrix4(_m1$1);\n\t\t\tthis.add(object);\n\t\t\tobject.updateWorldMatrix(false, true);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetObjectById(id) {\n\t\t\treturn this.getObjectByProperty('id', id);\n\t\t}\n\n\t\tgetObjectByName(name) {\n\t\t\treturn this.getObjectByProperty('name', name);\n\t\t}\n\n\t\tgetObjectByProperty(name, value) {\n\t\t\tif (this[name] === value) return this;\n\n\t\t\tfor (let i = 0, l = this.children.length; i < l; i++) {\n\t\t\t\tconst child = this.children[i];\n\t\t\t\tconst object = child.getObjectByProperty(name, value);\n\n\t\t\t\tif (object !== undefined) {\n\t\t\t\t\treturn object;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\tgetWorldPosition(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Object3D: .getWorldPosition() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tthis.updateWorldMatrix(true, false);\n\t\t\treturn target.setFromMatrixPosition(this.matrixWorld);\n\t\t}\n\n\t\tgetWorldQuaternion(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Object3D: .getWorldQuaternion() target is now required');\n\t\t\t\ttarget = new Quaternion();\n\t\t\t}\n\n\t\t\tthis.updateWorldMatrix(true, false);\n\t\t\tthis.matrixWorld.decompose(_position$3, target, _scale$2);\n\t\t\treturn target;\n\t\t}\n\n\t\tgetWorldScale(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Object3D: .getWorldScale() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tthis.updateWorldMatrix(true, false);\n\t\t\tthis.matrixWorld.decompose(_position$3, _quaternion$2, target);\n\t\t\treturn target;\n\t\t}\n\n\t\tgetWorldDirection(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Object3D: .getWorldDirection() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tthis.updateWorldMatrix(true, false);\n\t\t\tconst e = this.matrixWorld.elements;\n\t\t\treturn target.set(e[8], e[9], e[10]).normalize();\n\t\t}\n\n\t\traycast() {}\n\n\t\ttraverse(callback) {\n\t\t\tcallback(this);\n\t\t\tconst children = this.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tchildren[i].traverse(callback);\n\t\t\t}\n\t\t}\n\n\t\ttraverseVisible(callback) {\n\t\t\tif (this.visible === false) return;\n\t\t\tcallback(this);\n\t\t\tconst children = this.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tchildren[i].traverseVisible(callback);\n\t\t\t}\n\t\t}\n\n\t\ttraverseAncestors(callback) {\n\t\t\tconst parent = this.parent;\n\n\t\t\tif (parent !== null) {\n\t\t\t\tcallback(parent);\n\t\t\t\tparent.traverseAncestors(callback);\n\t\t\t}\n\t\t}\n\n\t\tupdateMatrix() {\n\t\t\tthis.matrix.compose(this.position, this.quaternion, this.scale);\n\t\t\tthis.matrixWorldNeedsUpdate = true;\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tif (this.matrixAutoUpdate) this.updateMatrix();\n\n\t\t\tif (this.matrixWorldNeedsUpdate || force) {\n\t\t\t\tif (this.parent === null) {\n\t\t\t\t\tthis.matrixWorld.copy(this.matrix);\n\t\t\t\t} else {\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n\t\t\t\t}\n\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\n\t\t\t\tforce = true;\n\t\t\t} // update children\n\n\n\t\t\tconst children = this.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tchildren[i].updateMatrixWorld(force);\n\t\t\t}\n\t\t}\n\n\t\tupdateWorldMatrix(updateParents, updateChildren) {\n\t\t\tconst parent = this.parent;\n\n\t\t\tif (updateParents === true && parent !== null) {\n\t\t\t\tparent.updateWorldMatrix(true, false);\n\t\t\t}\n\n\t\t\tif (this.matrixAutoUpdate) this.updateMatrix();\n\n\t\t\tif (this.parent === null) {\n\t\t\t\tthis.matrixWorld.copy(this.matrix);\n\t\t\t} else {\n\t\t\t\tthis.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n\t\t\t} // update children\n\n\n\t\t\tif (updateChildren === true) {\n\t\t\t\tconst children = this.children;\n\n\t\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tchildren[i].updateWorldMatrix(false, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\t// meta is a string when called from JSON.stringify\n\t\t\tconst isRootObject = meta === undefined || typeof meta === 'string';\n\t\t\tconst output = {}; // meta is a hash used to collect geometries, materials.\n\t\t\t// not providing it implies that this is the root object\n\t\t\t// being serialized.\n\n\t\t\tif (isRootObject) {\n\t\t\t\t// initialize meta obj\n\t\t\t\tmeta = {\n\t\t\t\t\tgeometries: {},\n\t\t\t\t\tmaterials: {},\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {},\n\t\t\t\t\tshapes: {},\n\t\t\t\t\tskeletons: {},\n\t\t\t\t\tanimations: {}\n\t\t\t\t};\n\t\t\t\toutput.metadata = {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Object',\n\t\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t\t};\n\t\t\t} // standard Object3D serialization\n\n\n\t\t\tconst object = {};\n\t\t\tobject.uuid = this.uuid;\n\t\t\tobject.type = this.type;\n\t\t\tif (this.name !== '') object.name = this.name;\n\t\t\tif (this.castShadow === true) object.castShadow = true;\n\t\t\tif (this.receiveShadow === true) object.receiveShadow = true;\n\t\t\tif (this.visible === false) object.visible = false;\n\t\t\tif (this.frustumCulled === false) object.frustumCulled = false;\n\t\t\tif (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n\t\t\tif (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;\n\t\t\tobject.layers = this.layers.mask;\n\t\t\tobject.matrix = this.matrix.toArray();\n\t\t\tif (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties\n\n\t\t\tif (this.isInstancedMesh) {\n\t\t\t\tobject.type = 'InstancedMesh';\n\t\t\t\tobject.count = this.count;\n\t\t\t\tobject.instanceMatrix = this.instanceMatrix.toJSON();\n\t\t\t\tif (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();\n\t\t\t} //\n\n\n\t\t\tfunction serialize(library, element) {\n\t\t\t\tif (library[element.uuid] === undefined) {\n\t\t\t\t\tlibrary[element.uuid] = element.toJSON(meta);\n\t\t\t\t}\n\n\t\t\t\treturn element.uuid;\n\t\t\t}\n\n\t\t\tif (this.isMesh || this.isLine || this.isPoints) {\n\t\t\t\tobject.geometry = serialize(meta.geometries, this.geometry);\n\t\t\t\tconst parameters = this.geometry.parameters;\n\n\t\t\t\tif (parameters !== undefined && parameters.shapes !== undefined) {\n\t\t\t\t\tconst shapes = parameters.shapes;\n\n\t\t\t\t\tif (Array.isArray(shapes)) {\n\t\t\t\t\t\tfor (let i = 0, l = shapes.length; i < l; i++) {\n\t\t\t\t\t\t\tconst shape = shapes[i];\n\t\t\t\t\t\t\tserialize(meta.shapes, shape);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tserialize(meta.shapes, shapes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isSkinnedMesh) {\n\t\t\t\tobject.bindMode = this.bindMode;\n\t\t\t\tobject.bindMatrix = this.bindMatrix.toArray();\n\n\t\t\t\tif (this.skeleton !== undefined) {\n\t\t\t\t\tserialize(meta.skeletons, this.skeleton);\n\t\t\t\t\tobject.skeleton = this.skeleton.uuid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.material !== undefined) {\n\t\t\t\tif (Array.isArray(this.material)) {\n\t\t\t\t\tconst uuids = [];\n\n\t\t\t\t\tfor (let i = 0, l = this.material.length; i < l; i++) {\n\t\t\t\t\t\tuuids.push(serialize(meta.materials, this.material[i]));\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.material = uuids;\n\t\t\t\t} else {\n\t\t\t\t\tobject.material = serialize(meta.materials, this.material);\n\t\t\t\t}\n\t\t\t} //\n\n\n\t\t\tif (this.children.length > 0) {\n\t\t\t\tobject.children = [];\n\n\t\t\t\tfor (let i = 0; i < this.children.length; i++) {\n\t\t\t\t\tobject.children.push(this.children[i].toJSON(meta).object);\n\t\t\t\t}\n\t\t\t} //\n\n\n\t\t\tif (this.animations.length > 0) {\n\t\t\t\tobject.animations = [];\n\n\t\t\t\tfor (let i = 0; i < this.animations.length; i++) {\n\t\t\t\t\tconst animation = this.animations[i];\n\t\t\t\t\tobject.animations.push(serialize(meta.animations, animation));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isRootObject) {\n\t\t\t\tconst geometries = extractFromCache(meta.geometries);\n\t\t\t\tconst materials = extractFromCache(meta.materials);\n\t\t\t\tconst textures = extractFromCache(meta.textures);\n\t\t\t\tconst images = extractFromCache(meta.images);\n\t\t\t\tconst shapes = extractFromCache(meta.shapes);\n\t\t\t\tconst skeletons = extractFromCache(meta.skeletons);\n\t\t\t\tconst animations = extractFromCache(meta.animations);\n\t\t\t\tif (geometries.length > 0) output.geometries = geometries;\n\t\t\t\tif (materials.length > 0) output.materials = materials;\n\t\t\t\tif (textures.length > 0) output.textures = textures;\n\t\t\t\tif (images.length > 0) output.images = images;\n\t\t\t\tif (shapes.length > 0) output.shapes = shapes;\n\t\t\t\tif (skeletons.length > 0) output.skeletons = skeletons;\n\t\t\t\tif (animations.length > 0) output.animations = animations;\n\t\t\t}\n\n\t\t\toutput.object = object;\n\t\t\treturn output; // extract data from the cache hash\n\t\t\t// remove metadata on each item\n\t\t\t// and return as array\n\n\t\t\tfunction extractFromCache(cache) {\n\t\t\t\tconst values = [];\n\n\t\t\t\tfor (const key in cache) {\n\t\t\t\t\tconst data = cache[key];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push(data);\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\n\t\tclone(recursive) {\n\t\t\treturn new this.constructor().copy(this, recursive);\n\t\t}\n\n\t\tcopy(source, recursive = true) {\n\t\t\tthis.name = source.name;\n\t\t\tthis.up.copy(source.up);\n\t\t\tthis.position.copy(source.position);\n\t\t\tthis.rotation.order = source.rotation.order;\n\t\t\tthis.quaternion.copy(source.quaternion);\n\t\t\tthis.scale.copy(source.scale);\n\t\t\tthis.matrix.copy(source.matrix);\n\t\t\tthis.matrixWorld.copy(source.matrixWorld);\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\t\t\tthis.layers.mask = source.layers.mask;\n\t\t\tthis.visible = source.visible;\n\t\t\tthis.castShadow = source.castShadow;\n\t\t\tthis.receiveShadow = source.receiveShadow;\n\t\t\tthis.frustumCulled = source.frustumCulled;\n\t\t\tthis.renderOrder = source.renderOrder;\n\t\t\tthis.userData = JSON.parse(JSON.stringify(source.userData));\n\n\t\t\tif (recursive === true) {\n\t\t\t\tfor (let i = 0; i < source.children.length; i++) {\n\t\t\t\t\tconst child = source.children[i];\n\t\t\t\t\tthis.add(child.clone());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tObject3D.DefaultUp = new Vector3(0, 1, 0);\n\tObject3D.DefaultMatrixAutoUpdate = true;\n\tObject3D.prototype.isObject3D = true;\n\n\tconst _vector1 = /*@__PURE__*/new Vector3();\n\n\tconst _vector2$1 = /*@__PURE__*/new Vector3();\n\n\tconst _normalMatrix = /*@__PURE__*/new Matrix3();\n\n\tclass Plane {\n\t\tconstructor(normal = new Vector3(1, 0, 0), constant = 0) {\n\t\t\t// normal is assumed to be normalized\n\t\t\tthis.normal = normal;\n\t\t\tthis.constant = constant;\n\t\t}\n\n\t\tset(normal, constant) {\n\t\t\tthis.normal.copy(normal);\n\t\t\tthis.constant = constant;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetComponents(x, y, z, w) {\n\t\t\tthis.normal.set(x, y, z);\n\t\t\tthis.constant = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromNormalAndCoplanarPoint(normal, point) {\n\t\t\tthis.normal.copy(normal);\n\t\t\tthis.constant = -point.dot(this.normal);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromCoplanarPoints(a, b, c) {\n\t\t\tconst normal = _vector1.subVectors(c, b).cross(_vector2$1.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\n\t\t\tthis.setFromNormalAndCoplanarPoint(normal, a);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(plane) {\n\t\t\tthis.normal.copy(plane.normal);\n\t\t\tthis.constant = plane.constant;\n\t\t\treturn this;\n\t\t}\n\n\t\tnormalize() {\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\t\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\t\tthis.normal.multiplyScalar(inverseNormalLength);\n\t\t\tthis.constant *= inverseNormalLength;\n\t\t\treturn this;\n\t\t}\n\n\t\tnegate() {\n\t\t\tthis.constant *= -1;\n\t\t\tthis.normal.negate();\n\t\t\treturn this;\n\t\t}\n\n\t\tdistanceToPoint(point) {\n\t\t\treturn this.normal.dot(point) + this.constant;\n\t\t}\n\n\t\tdistanceToSphere(sphere) {\n\t\t\treturn this.distanceToPoint(sphere.center) - sphere.radius;\n\t\t}\n\n\t\tprojectPoint(point, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Plane: .projectPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);\n\t\t}\n\n\t\tintersectLine(line, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Plane: .intersectLine() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tconst direction = line.delta(_vector1);\n\t\t\tconst denominator = this.normal.dot(direction);\n\n\t\t\tif (denominator === 0) {\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif (this.distanceToPoint(line.start) === 0) {\n\t\t\t\t\treturn target.copy(line.start);\n\t\t\t\t} // Unsure if this is the correct method to handle this case.\n\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst t = -(line.start.dot(this.normal) + this.constant) / denominator;\n\n\t\t\tif (t < 0 || t > 1) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn target.copy(direction).multiplyScalar(t).add(line.start);\n\t\t}\n\n\t\tintersectsLine(line) {\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\t\t\tconst startSign = this.distanceToPoint(line.start);\n\t\t\tconst endSign = this.distanceToPoint(line.end);\n\t\t\treturn startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\treturn box.intersectsPlane(this);\n\t\t}\n\n\t\tintersectsSphere(sphere) {\n\t\t\treturn sphere.intersectsPlane(this);\n\t\t}\n\n\t\tcoplanarPoint(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Plane: .coplanarPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.copy(this.normal).multiplyScalar(-this.constant);\n\t\t}\n\n\t\tapplyMatrix4(matrix, optionalNormalMatrix) {\n\t\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n\n\t\t\tconst referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n\t\t\tconst normal = this.normal.applyMatrix3(normalMatrix).normalize();\n\t\t\tthis.constant = -referencePoint.dot(normal);\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(offset) {\n\t\t\tthis.constant -= offset.dot(this.normal);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(plane) {\n\t\t\treturn plane.normal.equals(this.normal) && plane.constant === this.constant;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tPlane.prototype.isPlane = true;\n\n\tconst _v0$1 = /*@__PURE__*/new Vector3();\n\n\tconst _v1$3 = /*@__PURE__*/new Vector3();\n\n\tconst _v2$2 = /*@__PURE__*/new Vector3();\n\n\tconst _v3$1 = /*@__PURE__*/new Vector3();\n\n\tconst _vab = /*@__PURE__*/new Vector3();\n\n\tconst _vac = /*@__PURE__*/new Vector3();\n\n\tconst _vbc = /*@__PURE__*/new Vector3();\n\n\tconst _vap = /*@__PURE__*/new Vector3();\n\n\tconst _vbp = /*@__PURE__*/new Vector3();\n\n\tconst _vcp = /*@__PURE__*/new Vector3();\n\n\tclass Triangle {\n\t\tconstructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tstatic getNormal(a, b, c, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Triangle: .getNormal() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\ttarget.subVectors(c, b);\n\n\t\t\t_v0$1.subVectors(a, b);\n\n\t\t\ttarget.cross(_v0$1);\n\t\t\tconst targetLengthSq = target.lengthSq();\n\n\t\t\tif (targetLengthSq > 0) {\n\t\t\t\treturn target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n\t\t\t}\n\n\t\t\treturn target.set(0, 0, 0);\n\t\t} // static/instance method to calculate barycentric coordinates\n\t\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\n\n\t\tstatic getBarycoord(point, a, b, c, target) {\n\t\t\t_v0$1.subVectors(c, a);\n\n\t\t\t_v1$3.subVectors(b, a);\n\n\t\t\t_v2$2.subVectors(point, a);\n\n\t\t\tconst dot00 = _v0$1.dot(_v0$1);\n\n\t\t\tconst dot01 = _v0$1.dot(_v1$3);\n\n\t\t\tconst dot02 = _v0$1.dot(_v2$2);\n\n\t\t\tconst dot11 = _v1$3.dot(_v1$3);\n\n\t\t\tconst dot12 = _v1$3.dot(_v2$2);\n\n\t\t\tconst denom = dot00 * dot11 - dot01 * dot01;\n\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Triangle: .getBarycoord() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t} // collinear or singular triangle\n\n\n\t\t\tif (denom === 0) {\n\t\t\t\t// arbitrary location outside of triangle?\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\t\treturn target.set(-2, -1, -1);\n\t\t\t}\n\n\t\t\tconst invDenom = 1 / denom;\n\t\t\tconst u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n\t\t\tconst v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1\n\n\t\t\treturn target.set(1 - u - v, v, u);\n\t\t}\n\n\t\tstatic containsPoint(point, a, b, c) {\n\t\t\tthis.getBarycoord(point, a, b, c, _v3$1);\n\t\t\treturn _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;\n\t\t}\n\n\t\tstatic getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {\n\t\t\tthis.getBarycoord(point, p1, p2, p3, _v3$1);\n\t\t\ttarget.set(0, 0);\n\t\t\ttarget.addScaledVector(uv1, _v3$1.x);\n\t\t\ttarget.addScaledVector(uv2, _v3$1.y);\n\t\t\ttarget.addScaledVector(uv3, _v3$1.z);\n\t\t\treturn target;\n\t\t}\n\n\t\tstatic isFrontFacing(a, b, c, direction) {\n\t\t\t_v0$1.subVectors(c, b);\n\n\t\t\t_v1$3.subVectors(a, b); // strictly front facing\n\n\n\t\t\treturn _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;\n\t\t}\n\n\t\tset(a, b, c) {\n\t\t\tthis.a.copy(a);\n\t\t\tthis.b.copy(b);\n\t\t\tthis.c.copy(c);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromPointsAndIndices(points, i0, i1, i2) {\n\t\t\tthis.a.copy(points[i0]);\n\t\t\tthis.b.copy(points[i1]);\n\t\t\tthis.c.copy(points[i2]);\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(triangle) {\n\t\t\tthis.a.copy(triangle.a);\n\t\t\tthis.b.copy(triangle.b);\n\t\t\tthis.c.copy(triangle.c);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetArea() {\n\t\t\t_v0$1.subVectors(this.c, this.b);\n\n\t\t\t_v1$3.subVectors(this.a, this.b);\n\n\t\t\treturn _v0$1.cross(_v1$3).length() * 0.5;\n\t\t}\n\n\t\tgetMidpoint(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Triangle: .getMidpoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n\t\t}\n\n\t\tgetNormal(target) {\n\t\t\treturn Triangle.getNormal(this.a, this.b, this.c, target);\n\t\t}\n\n\t\tgetPlane(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Triangle: .getPlane() target is now required');\n\t\t\t\ttarget = new Plane();\n\t\t\t}\n\n\t\t\treturn target.setFromCoplanarPoints(this.a, this.b, this.c);\n\t\t}\n\n\t\tgetBarycoord(point, target) {\n\t\t\treturn Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n\t\t}\n\n\t\tgetUV(point, uv1, uv2, uv3, target) {\n\t\t\treturn Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);\n\t\t}\n\n\t\tcontainsPoint(point) {\n\t\t\treturn Triangle.containsPoint(point, this.a, this.b, this.c);\n\t\t}\n\n\t\tisFrontFacing(direction) {\n\t\t\treturn Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\treturn box.intersectsTriangle(this);\n\t\t}\n\n\t\tclosestPointToPoint(p, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Triangle: .closestPointToPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tconst a = this.a,\n\t\t\t\t\t\tb = this.b,\n\t\t\t\t\t\tc = this.c;\n\t\t\tlet v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t\t_vab.subVectors(b, a);\n\n\t\t\t_vac.subVectors(c, a);\n\n\t\t\t_vap.subVectors(p, a);\n\n\t\t\tconst d1 = _vab.dot(_vap);\n\n\t\t\tconst d2 = _vac.dot(_vap);\n\n\t\t\tif (d1 <= 0 && d2 <= 0) {\n\t\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\t\treturn target.copy(a);\n\t\t\t}\n\n\t\t\t_vbp.subVectors(p, b);\n\n\t\t\tconst d3 = _vab.dot(_vbp);\n\n\t\t\tconst d4 = _vac.dot(_vbp);\n\n\t\t\tif (d3 >= 0 && d4 <= d3) {\n\t\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\t\treturn target.copy(b);\n\t\t\t}\n\n\t\t\tconst vc = d1 * d4 - d3 * d2;\n\n\t\t\tif (vc <= 0 && d1 >= 0 && d3 <= 0) {\n\t\t\t\tv = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)\n\n\t\t\t\treturn target.copy(a).addScaledVector(_vab, v);\n\t\t\t}\n\n\t\t\t_vcp.subVectors(p, c);\n\n\t\t\tconst d5 = _vab.dot(_vcp);\n\n\t\t\tconst d6 = _vac.dot(_vcp);\n\n\t\t\tif (d6 >= 0 && d5 <= d6) {\n\t\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\t\treturn target.copy(c);\n\t\t\t}\n\n\t\t\tconst vb = d5 * d2 - d1 * d6;\n\n\t\t\tif (vb <= 0 && d2 >= 0 && d6 <= 0) {\n\t\t\t\tw = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)\n\n\t\t\t\treturn target.copy(a).addScaledVector(_vac, w);\n\t\t\t}\n\n\t\t\tconst va = d3 * d6 - d5 * d4;\n\n\t\t\tif (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n\t\t\t\t_vbc.subVectors(c, b);\n\n\t\t\t\tw = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)\n\n\t\t\t\treturn target.copy(b).addScaledVector(_vbc, w); // edge region of BC\n\t\t\t} // face region\n\n\n\t\t\tconst denom = 1 / (va + vb + vc); // u = va * denom\n\n\t\t\tv = vb * denom;\n\t\t\tw = vc * denom;\n\t\t\treturn target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n\t\t}\n\n\t\tequals(triangle) {\n\t\t\treturn triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n\t\t}\n\n\t}\n\n\tlet materialId = 0;\n\n\tclass Material extends EventDispatcher {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tObject.defineProperty(this, 'id', {\n\t\t\t\tvalue: materialId++\n\t\t\t});\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'Material';\n\t\t\tthis.fog = true;\n\t\t\tthis.blending = NormalBlending;\n\t\t\tthis.side = FrontSide;\n\t\t\tthis.vertexColors = false;\n\t\t\tthis.opacity = 1;\n\t\t\tthis.transparent = false;\n\t\t\tthis.blendSrc = SrcAlphaFactor;\n\t\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\t\tthis.blendEquation = AddEquation;\n\t\t\tthis.blendSrcAlpha = null;\n\t\t\tthis.blendDstAlpha = null;\n\t\t\tthis.blendEquationAlpha = null;\n\t\t\tthis.depthFunc = LessEqualDepth;\n\t\t\tthis.depthTest = true;\n\t\t\tthis.depthWrite = true;\n\t\t\tthis.stencilWriteMask = 0xff;\n\t\t\tthis.stencilFunc = AlwaysStencilFunc;\n\t\t\tthis.stencilRef = 0;\n\t\t\tthis.stencilFuncMask = 0xff;\n\t\t\tthis.stencilFail = KeepStencilOp;\n\t\t\tthis.stencilZFail = KeepStencilOp;\n\t\t\tthis.stencilZPass = KeepStencilOp;\n\t\t\tthis.stencilWrite = false;\n\t\t\tthis.clippingPlanes = null;\n\t\t\tthis.clipIntersection = false;\n\t\t\tthis.clipShadows = false;\n\t\t\tthis.shadowSide = null;\n\t\t\tthis.colorWrite = true;\n\t\t\tthis.precision = null; // override the renderer's default precision for this material\n\n\t\t\tthis.polygonOffset = false;\n\t\t\tthis.polygonOffsetFactor = 0;\n\t\t\tthis.polygonOffsetUnits = 0;\n\t\t\tthis.dithering = false;\n\t\t\tthis.alphaTest = 0;\n\t\t\tthis.alphaToCoverage = false;\n\t\t\tthis.premultipliedAlpha = false;\n\t\t\tthis.visible = true;\n\t\t\tthis.toneMapped = true;\n\t\t\tthis.userData = {};\n\t\t\tthis.version = 0;\n\t\t}\n\n\t\tonBuild()\n\t\t/* shaderobject, renderer */\n\t\t{}\n\n\t\tonBeforeCompile()\n\t\t/* shaderobject, renderer */\n\t\t{}\n\n\t\tcustomProgramCacheKey() {\n\t\t\treturn this.onBeforeCompile.toString();\n\t\t}\n\n\t\tsetValues(values) {\n\t\t\tif (values === undefined) return;\n\n\t\t\tfor (const key in values) {\n\t\t\t\tconst newValue = values[key];\n\n\t\t\t\tif (newValue === undefined) {\n\t\t\t\t\tconsole.warn('THREE.Material: \\'' + key + '\\' parameter is undefined.');\n\t\t\t\t\tcontinue;\n\t\t\t\t} // for backward compatability if shading is set in the constructor\n\n\n\t\t\t\tif (key === 'shading') {\n\t\t\t\t\tconsole.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');\n\t\t\t\t\tthis.flatShading = newValue === FlatShading ? true : false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst currentValue = this[key];\n\n\t\t\t\tif (currentValue === undefined) {\n\t\t\t\t\tconsole.warn('THREE.' + this.type + ': \\'' + key + '\\' is not a property of this material.');\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (currentValue && currentValue.isColor) {\n\t\t\t\t\tcurrentValue.set(newValue);\n\t\t\t\t} else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {\n\t\t\t\t\tcurrentValue.copy(newValue);\n\t\t\t\t} else {\n\t\t\t\t\tthis[key] = newValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst isRoot = meta === undefined || typeof meta === 'string';\n\n\t\t\tif (isRoot) {\n\t\t\t\tmeta = {\n\t\t\t\t\ttextures: {},\n\t\t\t\t\timages: {}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Material',\n\t\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t\t}\n\t\t\t}; // standard Material serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif (this.name !== '') data.name = this.name;\n\t\t\tif (this.color && this.color.isColor) data.color = this.color.getHex();\n\t\t\tif (this.roughness !== undefined) data.roughness = this.roughness;\n\t\t\tif (this.metalness !== undefined) data.metalness = this.metalness;\n\t\t\tif (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();\n\t\t\tif (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();\n\t\t\tif (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;\n\t\t\tif (this.specular && this.specular.isColor) data.specular = this.specular.getHex();\n\t\t\tif (this.shininess !== undefined) data.shininess = this.shininess;\n\t\t\tif (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;\n\t\t\tif (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;\n\n\t\t\tif (this.clearcoatMap && this.clearcoatMap.isTexture) {\n\t\t\t\tdata.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;\n\t\t\t}\n\n\t\t\tif (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n\t\t\t\tdata.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n\t\t\t}\n\n\t\t\tif (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {\n\t\t\t\tdata.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;\n\t\t\t\tdata.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n\t\t\t}\n\n\t\t\tif (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n\t\t\tif (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;\n\t\t\tif (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n\n\t\t\tif (this.lightMap && this.lightMap.isTexture) {\n\t\t\t\tdata.lightMap = this.lightMap.toJSON(meta).uuid;\n\t\t\t\tdata.lightMapIntensity = this.lightMapIntensity;\n\t\t\t}\n\n\t\t\tif (this.aoMap && this.aoMap.isTexture) {\n\t\t\t\tdata.aoMap = this.aoMap.toJSON(meta).uuid;\n\t\t\t\tdata.aoMapIntensity = this.aoMapIntensity;\n\t\t\t}\n\n\t\t\tif (this.bumpMap && this.bumpMap.isTexture) {\n\t\t\t\tdata.bumpMap = this.bumpMap.toJSON(meta).uuid;\n\t\t\t\tdata.bumpScale = this.bumpScale;\n\t\t\t}\n\n\t\t\tif (this.normalMap && this.normalMap.isTexture) {\n\t\t\t\tdata.normalMap = this.normalMap.toJSON(meta).uuid;\n\t\t\t\tdata.normalMapType = this.normalMapType;\n\t\t\t\tdata.normalScale = this.normalScale.toArray();\n\t\t\t}\n\n\t\t\tif (this.displacementMap && this.displacementMap.isTexture) {\n\t\t\t\tdata.displacementMap = this.displacementMap.toJSON(meta).uuid;\n\t\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\t\tdata.displacementBias = this.displacementBias;\n\t\t\t}\n\n\t\t\tif (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\n\t\t\tif (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\n\t\t\tif (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\n\t\t\tif (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;\n\n\t\t\tif (this.envMap && this.envMap.isTexture) {\n\t\t\t\tdata.envMap = this.envMap.toJSON(meta).uuid;\n\t\t\t\tif (this.combine !== undefined) data.combine = this.combine;\n\t\t\t}\n\n\t\t\tif (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;\n\t\t\tif (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;\n\t\t\tif (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;\n\n\t\t\tif (this.gradientMap && this.gradientMap.isTexture) {\n\t\t\t\tdata.gradientMap = this.gradientMap.toJSON(meta).uuid;\n\t\t\t}\n\n\t\t\tif (this.transmission !== undefined) data.transmission = this.transmission;\n\t\t\tif (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;\n\t\t\tif (this.thickness !== undefined) data.thickness = this.thickness;\n\t\t\tif (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;\n\t\t\tif (this.attenuationDistance !== undefined) data.attenuationDistance = this.attenuationDistance;\n\t\t\tif (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();\n\t\t\tif (this.size !== undefined) data.size = this.size;\n\t\t\tif (this.shadowSide !== null) data.shadowSide = this.shadowSide;\n\t\t\tif (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;\n\t\t\tif (this.blending !== NormalBlending) data.blending = this.blending;\n\t\t\tif (this.side !== FrontSide) data.side = this.side;\n\t\t\tif (this.vertexColors) data.vertexColors = true;\n\t\t\tif (this.opacity < 1) data.opacity = this.opacity;\n\t\t\tif (this.transparent === true) data.transparent = this.transparent;\n\t\t\tdata.depthFunc = this.depthFunc;\n\t\t\tdata.depthTest = this.depthTest;\n\t\t\tdata.depthWrite = this.depthWrite;\n\t\t\tdata.colorWrite = this.colorWrite;\n\t\t\tdata.stencilWrite = this.stencilWrite;\n\t\t\tdata.stencilWriteMask = this.stencilWriteMask;\n\t\t\tdata.stencilFunc = this.stencilFunc;\n\t\t\tdata.stencilRef = this.stencilRef;\n\t\t\tdata.stencilFuncMask = this.stencilFuncMask;\n\t\t\tdata.stencilFail = this.stencilFail;\n\t\t\tdata.stencilZFail = this.stencilZFail;\n\t\t\tdata.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)\n\n\t\t\tif (this.rotation && this.rotation !== 0) data.rotation = this.rotation;\n\t\t\tif (this.polygonOffset === true) data.polygonOffset = true;\n\t\t\tif (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;\n\t\t\tif (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;\n\t\t\tif (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;\n\t\t\tif (this.dashSize !== undefined) data.dashSize = this.dashSize;\n\t\t\tif (this.gapSize !== undefined) data.gapSize = this.gapSize;\n\t\t\tif (this.scale !== undefined) data.scale = this.scale;\n\t\t\tif (this.dithering === true) data.dithering = true;\n\t\t\tif (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n\t\t\tif (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;\n\t\t\tif (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\t\tif (this.wireframe === true) data.wireframe = this.wireframe;\n\t\t\tif (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\t\tif (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;\n\t\t\tif (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;\n\t\t\tif (this.morphTargets === true) data.morphTargets = true;\n\t\t\tif (this.morphNormals === true) data.morphNormals = true;\n\t\t\tif (this.flatShading === true) data.flatShading = this.flatShading;\n\t\t\tif (this.visible === false) data.visible = false;\n\t\t\tif (this.toneMapped === false) data.toneMapped = false;\n\t\t\tif (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON\n\n\t\t\tfunction extractFromCache(cache) {\n\t\t\t\tconst values = [];\n\n\t\t\t\tfor (const key in cache) {\n\t\t\t\t\tconst data = cache[key];\n\t\t\t\t\tdelete data.metadata;\n\t\t\t\t\tvalues.push(data);\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t}\n\n\t\t\tif (isRoot) {\n\t\t\t\tconst textures = extractFromCache(meta.textures);\n\t\t\t\tconst images = extractFromCache(meta.images);\n\t\t\t\tif (textures.length > 0) data.textures = textures;\n\t\t\t\tif (images.length > 0) data.images = images;\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.name = source.name;\n\t\t\tthis.fog = source.fog;\n\t\t\tthis.blending = source.blending;\n\t\t\tthis.side = source.side;\n\t\t\tthis.vertexColors = source.vertexColors;\n\t\t\tthis.opacity = source.opacity;\n\t\t\tthis.transparent = source.transparent;\n\t\t\tthis.blendSrc = source.blendSrc;\n\t\t\tthis.blendDst = source.blendDst;\n\t\t\tthis.blendEquation = source.blendEquation;\n\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\t\t\tthis.depthFunc = source.depthFunc;\n\t\t\tthis.depthTest = source.depthTest;\n\t\t\tthis.depthWrite = source.depthWrite;\n\t\t\tthis.stencilWriteMask = source.stencilWriteMask;\n\t\t\tthis.stencilFunc = source.stencilFunc;\n\t\t\tthis.stencilRef = source.stencilRef;\n\t\t\tthis.stencilFuncMask = source.stencilFuncMask;\n\t\t\tthis.stencilFail = source.stencilFail;\n\t\t\tthis.stencilZFail = source.stencilZFail;\n\t\t\tthis.stencilZPass = source.stencilZPass;\n\t\t\tthis.stencilWrite = source.stencilWrite;\n\t\t\tconst srcPlanes = source.clippingPlanes;\n\t\t\tlet dstPlanes = null;\n\n\t\t\tif (srcPlanes !== null) {\n\t\t\t\tconst n = srcPlanes.length;\n\t\t\t\tdstPlanes = new Array(n);\n\n\t\t\t\tfor (let i = 0; i !== n; ++i) {\n\t\t\t\t\tdstPlanes[i] = srcPlanes[i].clone();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.clippingPlanes = dstPlanes;\n\t\t\tthis.clipIntersection = source.clipIntersection;\n\t\t\tthis.clipShadows = source.clipShadows;\n\t\t\tthis.shadowSide = source.shadowSide;\n\t\t\tthis.colorWrite = source.colorWrite;\n\t\t\tthis.precision = source.precision;\n\t\t\tthis.polygonOffset = source.polygonOffset;\n\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\t\t\tthis.dithering = source.dithering;\n\t\t\tthis.alphaTest = source.alphaTest;\n\t\t\tthis.alphaToCoverage = source.alphaToCoverage;\n\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\t\t\tthis.visible = source.visible;\n\t\t\tthis.toneMapped = source.toneMapped;\n\t\t\tthis.userData = JSON.parse(JSON.stringify(source.userData));\n\t\t\treturn this;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'dispose'\n\t\t\t});\n\t\t}\n\n\t\tset needsUpdate(value) {\n\t\t\tif (value === true) this.version++;\n\t\t}\n\n\t}\n\n\tMaterial.prototype.isMaterial = true;\n\n\tconst _colorKeywords = {\n\t\t'aliceblue': 0xF0F8FF,\n\t\t'antiquewhite': 0xFAEBD7,\n\t\t'aqua': 0x00FFFF,\n\t\t'aquamarine': 0x7FFFD4,\n\t\t'azure': 0xF0FFFF,\n\t\t'beige': 0xF5F5DC,\n\t\t'bisque': 0xFFE4C4,\n\t\t'black': 0x000000,\n\t\t'blanchedalmond': 0xFFEBCD,\n\t\t'blue': 0x0000FF,\n\t\t'blueviolet': 0x8A2BE2,\n\t\t'brown': 0xA52A2A,\n\t\t'burlywood': 0xDEB887,\n\t\t'cadetblue': 0x5F9EA0,\n\t\t'chartreuse': 0x7FFF00,\n\t\t'chocolate': 0xD2691E,\n\t\t'coral': 0xFF7F50,\n\t\t'cornflowerblue': 0x6495ED,\n\t\t'cornsilk': 0xFFF8DC,\n\t\t'crimson': 0xDC143C,\n\t\t'cyan': 0x00FFFF,\n\t\t'darkblue': 0x00008B,\n\t\t'darkcyan': 0x008B8B,\n\t\t'darkgoldenrod': 0xB8860B,\n\t\t'darkgray': 0xA9A9A9,\n\t\t'darkgreen': 0x006400,\n\t\t'darkgrey': 0xA9A9A9,\n\t\t'darkkhaki': 0xBDB76B,\n\t\t'darkmagenta': 0x8B008B,\n\t\t'darkolivegreen': 0x556B2F,\n\t\t'darkorange': 0xFF8C00,\n\t\t'darkorchid': 0x9932CC,\n\t\t'darkred': 0x8B0000,\n\t\t'darksalmon': 0xE9967A,\n\t\t'darkseagreen': 0x8FBC8F,\n\t\t'darkslateblue': 0x483D8B,\n\t\t'darkslategray': 0x2F4F4F,\n\t\t'darkslategrey': 0x2F4F4F,\n\t\t'darkturquoise': 0x00CED1,\n\t\t'darkviolet': 0x9400D3,\n\t\t'deeppink': 0xFF1493,\n\t\t'deepskyblue': 0x00BFFF,\n\t\t'dimgray': 0x696969,\n\t\t'dimgrey': 0x696969,\n\t\t'dodgerblue': 0x1E90FF,\n\t\t'firebrick': 0xB22222,\n\t\t'floralwhite': 0xFFFAF0,\n\t\t'forestgreen': 0x228B22,\n\t\t'fuchsia': 0xFF00FF,\n\t\t'gainsboro': 0xDCDCDC,\n\t\t'ghostwhite': 0xF8F8FF,\n\t\t'gold': 0xFFD700,\n\t\t'goldenrod': 0xDAA520,\n\t\t'gray': 0x808080,\n\t\t'green': 0x008000,\n\t\t'greenyellow': 0xADFF2F,\n\t\t'grey': 0x808080,\n\t\t'honeydew': 0xF0FFF0,\n\t\t'hotpink': 0xFF69B4,\n\t\t'indianred': 0xCD5C5C,\n\t\t'indigo': 0x4B0082,\n\t\t'ivory': 0xFFFFF0,\n\t\t'khaki': 0xF0E68C,\n\t\t'lavender': 0xE6E6FA,\n\t\t'lavenderblush': 0xFFF0F5,\n\t\t'lawngreen': 0x7CFC00,\n\t\t'lemonchiffon': 0xFFFACD,\n\t\t'lightblue': 0xADD8E6,\n\t\t'lightcoral': 0xF08080,\n\t\t'lightcyan': 0xE0FFFF,\n\t\t'lightgoldenrodyellow': 0xFAFAD2,\n\t\t'lightgray': 0xD3D3D3,\n\t\t'lightgreen': 0x90EE90,\n\t\t'lightgrey': 0xD3D3D3,\n\t\t'lightpink': 0xFFB6C1,\n\t\t'lightsalmon': 0xFFA07A,\n\t\t'lightseagreen': 0x20B2AA,\n\t\t'lightskyblue': 0x87CEFA,\n\t\t'lightslategray': 0x778899,\n\t\t'lightslategrey': 0x778899,\n\t\t'lightsteelblue': 0xB0C4DE,\n\t\t'lightyellow': 0xFFFFE0,\n\t\t'lime': 0x00FF00,\n\t\t'limegreen': 0x32CD32,\n\t\t'linen': 0xFAF0E6,\n\t\t'magenta': 0xFF00FF,\n\t\t'maroon': 0x800000,\n\t\t'mediumaquamarine': 0x66CDAA,\n\t\t'mediumblue': 0x0000CD,\n\t\t'mediumorchid': 0xBA55D3,\n\t\t'mediumpurple': 0x9370DB,\n\t\t'mediumseagreen': 0x3CB371,\n\t\t'mediumslateblue': 0x7B68EE,\n\t\t'mediumspringgreen': 0x00FA9A,\n\t\t'mediumturquoise': 0x48D1CC,\n\t\t'mediumvioletred': 0xC71585,\n\t\t'midnightblue': 0x191970,\n\t\t'mintcream': 0xF5FFFA,\n\t\t'mistyrose': 0xFFE4E1,\n\t\t'moccasin': 0xFFE4B5,\n\t\t'navajowhite': 0xFFDEAD,\n\t\t'navy': 0x000080,\n\t\t'oldlace': 0xFDF5E6,\n\t\t'olive': 0x808000,\n\t\t'olivedrab': 0x6B8E23,\n\t\t'orange': 0xFFA500,\n\t\t'orangered': 0xFF4500,\n\t\t'orchid': 0xDA70D6,\n\t\t'palegoldenrod': 0xEEE8AA,\n\t\t'palegreen': 0x98FB98,\n\t\t'paleturquoise': 0xAFEEEE,\n\t\t'palevioletred': 0xDB7093,\n\t\t'papayawhip': 0xFFEFD5,\n\t\t'peachpuff': 0xFFDAB9,\n\t\t'peru': 0xCD853F,\n\t\t'pink': 0xFFC0CB,\n\t\t'plum': 0xDDA0DD,\n\t\t'powderblue': 0xB0E0E6,\n\t\t'purple': 0x800080,\n\t\t'rebeccapurple': 0x663399,\n\t\t'red': 0xFF0000,\n\t\t'rosybrown': 0xBC8F8F,\n\t\t'royalblue': 0x4169E1,\n\t\t'saddlebrown': 0x8B4513,\n\t\t'salmon': 0xFA8072,\n\t\t'sandybrown': 0xF4A460,\n\t\t'seagreen': 0x2E8B57,\n\t\t'seashell': 0xFFF5EE,\n\t\t'sienna': 0xA0522D,\n\t\t'silver': 0xC0C0C0,\n\t\t'skyblue': 0x87CEEB,\n\t\t'slateblue': 0x6A5ACD,\n\t\t'slategray': 0x708090,\n\t\t'slategrey': 0x708090,\n\t\t'snow': 0xFFFAFA,\n\t\t'springgreen': 0x00FF7F,\n\t\t'steelblue': 0x4682B4,\n\t\t'tan': 0xD2B48C,\n\t\t'teal': 0x008080,\n\t\t'thistle': 0xD8BFD8,\n\t\t'tomato': 0xFF6347,\n\t\t'turquoise': 0x40E0D0,\n\t\t'violet': 0xEE82EE,\n\t\t'wheat': 0xF5DEB3,\n\t\t'white': 0xFFFFFF,\n\t\t'whitesmoke': 0xF5F5F5,\n\t\t'yellow': 0xFFFF00,\n\t\t'yellowgreen': 0x9ACD32\n\t};\n\tconst _hslA = {\n\t\th: 0,\n\t\ts: 0,\n\t\tl: 0\n\t};\n\tconst _hslB = {\n\t\th: 0,\n\t\ts: 0,\n\t\tl: 0\n\t};\n\n\tfunction hue2rgb(p, q, t) {\n\t\tif (t < 0) t += 1;\n\t\tif (t > 1) t -= 1;\n\t\tif (t < 1 / 6) return p + (q - p) * 6 * t;\n\t\tif (t < 1 / 2) return q;\n\t\tif (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n\t\treturn p;\n\t}\n\n\tfunction SRGBToLinear(c) {\n\t\treturn c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n\t}\n\n\tfunction LinearToSRGB(c) {\n\t\treturn c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n\t}\n\n\tclass Color {\n\t\tconstructor(r, g, b) {\n\t\t\tif (g === undefined && b === undefined) {\n\t\t\t\t// r is THREE.Color, hex or string\n\t\t\t\treturn this.set(r);\n\t\t\t}\n\n\t\t\treturn this.setRGB(r, g, b);\n\t\t}\n\n\t\tset(value) {\n\t\t\tif (value && value.isColor) {\n\t\t\t\tthis.copy(value);\n\t\t\t} else if (typeof value === 'number') {\n\t\t\t\tthis.setHex(value);\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\tthis.setStyle(value);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetScalar(scalar) {\n\t\t\tthis.r = scalar;\n\t\t\tthis.g = scalar;\n\t\t\tthis.b = scalar;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetHex(hex) {\n\t\t\thex = Math.floor(hex);\n\t\t\tthis.r = (hex >> 16 & 255) / 255;\n\t\t\tthis.g = (hex >> 8 & 255) / 255;\n\t\t\tthis.b = (hex & 255) / 255;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetRGB(r, g, b) {\n\t\t\tthis.r = r;\n\t\t\tthis.g = g;\n\t\t\tthis.b = b;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetHSL(h, s, l) {\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\th = euclideanModulo(h, 1);\n\t\t\ts = clamp(s, 0, 1);\n\t\t\tl = clamp(l, 0, 1);\n\n\t\t\tif (s === 0) {\n\t\t\t\tthis.r = this.g = this.b = l;\n\t\t\t} else {\n\t\t\t\tconst p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n\t\t\t\tconst q = 2 * l - p;\n\t\t\t\tthis.r = hue2rgb(q, p, h + 1 / 3);\n\t\t\t\tthis.g = hue2rgb(q, p, h);\n\t\t\t\tthis.b = hue2rgb(q, p, h - 1 / 3);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetStyle(style) {\n\t\t\tfunction handleAlpha(string) {\n\t\t\t\tif (string === undefined) return;\n\n\t\t\t\tif (parseFloat(string) < 1) {\n\t\t\t\t\tconsole.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet m;\n\n\t\t\tif (m = /^((?:rgb|hsl)a?)\\(([^\\)]*)\\)/.exec(style)) {\n\t\t\t\t// rgb / hsl\n\t\t\t\tlet color;\n\t\t\t\tconst name = m[1];\n\t\t\t\tconst components = m[2];\n\n\t\t\t\tswitch (name) {\n\t\t\t\t\tcase 'rgb':\n\t\t\t\t\tcase 'rgba':\n\t\t\t\t\t\tif (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min(255, parseInt(color[1], 10)) / 255;\n\t\t\t\t\t\t\tthis.g = Math.min(255, parseInt(color[2], 10)) / 255;\n\t\t\t\t\t\t\tthis.b = Math.min(255, parseInt(color[3], 10)) / 255;\n\t\t\t\t\t\t\thandleAlpha(color[4]);\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t\t\t\t\t\t\tthis.r = Math.min(100, parseInt(color[1], 10)) / 100;\n\t\t\t\t\t\t\tthis.g = Math.min(100, parseInt(color[2], 10)) / 100;\n\t\t\t\t\t\t\tthis.b = Math.min(100, parseInt(color[3], 10)) / 100;\n\t\t\t\t\t\t\thandleAlpha(color[4]);\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'hsl':\n\t\t\t\t\tcase 'hsla':\n\t\t\t\t\t\tif (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t\t\t\t\t\t\tconst h = parseFloat(color[1]) / 360;\n\t\t\t\t\t\t\tconst s = parseInt(color[2], 10) / 100;\n\t\t\t\t\t\t\tconst l = parseInt(color[3], 10) / 100;\n\t\t\t\t\t\t\thandleAlpha(color[4]);\n\t\t\t\t\t\t\treturn this.setHSL(h, s, l);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {\n\t\t\t\t// hex color\n\t\t\t\tconst hex = m[1];\n\t\t\t\tconst size = hex.length;\n\n\t\t\t\tif (size === 3) {\n\t\t\t\t\t// #ff0\n\t\t\t\t\tthis.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\n\t\t\t\t\tthis.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\n\t\t\t\t\tthis.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\n\t\t\t\t\treturn this;\n\t\t\t\t} else if (size === 6) {\n\t\t\t\t\t// #ff0000\n\t\t\t\t\tthis.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\n\t\t\t\t\tthis.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\n\t\t\t\t\tthis.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (style && style.length > 0) {\n\t\t\t\treturn this.setColorName(style);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetColorName(style) {\n\t\t\t// color keywords\n\t\t\tconst hex = _colorKeywords[style.toLowerCase()];\n\n\t\t\tif (hex !== undefined) {\n\t\t\t\t// red\n\t\t\t\tthis.setHex(hex);\n\t\t\t} else {\n\t\t\t\t// unknown color\n\t\t\t\tconsole.warn('THREE.Color: Unknown color ' + style);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.r, this.g, this.b);\n\t\t}\n\n\t\tcopy(color) {\n\t\t\tthis.r = color.r;\n\t\t\tthis.g = color.g;\n\t\t\tthis.b = color.b;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyGammaToLinear(color, gammaFactor = 2.0) {\n\t\t\tthis.r = Math.pow(color.r, gammaFactor);\n\t\t\tthis.g = Math.pow(color.g, gammaFactor);\n\t\t\tthis.b = Math.pow(color.b, gammaFactor);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyLinearToGamma(color, gammaFactor = 2.0) {\n\t\t\tconst safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;\n\t\t\tthis.r = Math.pow(color.r, safeInverse);\n\t\t\tthis.g = Math.pow(color.g, safeInverse);\n\t\t\tthis.b = Math.pow(color.b, safeInverse);\n\t\t\treturn this;\n\t\t}\n\n\t\tconvertGammaToLinear(gammaFactor) {\n\t\t\tthis.copyGammaToLinear(this, gammaFactor);\n\t\t\treturn this;\n\t\t}\n\n\t\tconvertLinearToGamma(gammaFactor) {\n\t\t\tthis.copyLinearToGamma(this, gammaFactor);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopySRGBToLinear(color) {\n\t\t\tthis.r = SRGBToLinear(color.r);\n\t\t\tthis.g = SRGBToLinear(color.g);\n\t\t\tthis.b = SRGBToLinear(color.b);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyLinearToSRGB(color) {\n\t\t\tthis.r = LinearToSRGB(color.r);\n\t\t\tthis.g = LinearToSRGB(color.g);\n\t\t\tthis.b = LinearToSRGB(color.b);\n\t\t\treturn this;\n\t\t}\n\n\t\tconvertSRGBToLinear() {\n\t\t\tthis.copySRGBToLinear(this);\n\t\t\treturn this;\n\t\t}\n\n\t\tconvertLinearToSRGB() {\n\t\t\tthis.copyLinearToSRGB(this);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetHex() {\n\t\t\treturn this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;\n\t\t}\n\n\t\tgetHexString() {\n\t\t\treturn ('000000' + this.getHex().toString(16)).slice(-6);\n\t\t}\n\n\t\tgetHSL(target) {\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Color: .getHSL() target is now required');\n\t\t\t\ttarget = {\n\t\t\t\t\th: 0,\n\t\t\t\t\ts: 0,\n\t\t\t\t\tl: 0\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst r = this.r,\n\t\t\t\t\t\tg = this.g,\n\t\t\t\t\t\tb = this.b;\n\t\t\tconst max = Math.max(r, g, b);\n\t\t\tconst min = Math.min(r, g, b);\n\t\t\tlet hue, saturation;\n\t\t\tconst lightness = (min + max) / 2.0;\n\n\t\t\tif (min === max) {\n\t\t\t\thue = 0;\n\t\t\t\tsaturation = 0;\n\t\t\t} else {\n\t\t\t\tconst delta = max - min;\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\n\n\t\t\t\tswitch (max) {\n\t\t\t\t\tcase r:\n\t\t\t\t\t\thue = (g - b) / delta + (g < b ? 6 : 0);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase g:\n\t\t\t\t\t\thue = (b - r) / delta + 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase b:\n\t\t\t\t\t\thue = (r - g) / delta + 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\thue /= 6;\n\t\t\t}\n\n\t\t\ttarget.h = hue;\n\t\t\ttarget.s = saturation;\n\t\t\ttarget.l = lightness;\n\t\t\treturn target;\n\t\t}\n\n\t\tgetStyle() {\n\t\t\treturn 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';\n\t\t}\n\n\t\toffsetHSL(h, s, l) {\n\t\t\tthis.getHSL(_hslA);\n\t\t\t_hslA.h += h;\n\t\t\t_hslA.s += s;\n\t\t\t_hslA.l += l;\n\t\t\tthis.setHSL(_hslA.h, _hslA.s, _hslA.l);\n\t\t\treturn this;\n\t\t}\n\n\t\tadd(color) {\n\t\t\tthis.r += color.r;\n\t\t\tthis.g += color.g;\n\t\t\tthis.b += color.b;\n\t\t\treturn this;\n\t\t}\n\n\t\taddColors(color1, color2) {\n\t\t\tthis.r = color1.r + color2.r;\n\t\t\tthis.g = color1.g + color2.g;\n\t\t\tthis.b = color1.b + color2.b;\n\t\t\treturn this;\n\t\t}\n\n\t\taddScalar(s) {\n\t\t\tthis.r += s;\n\t\t\tthis.g += s;\n\t\t\tthis.b += s;\n\t\t\treturn this;\n\t\t}\n\n\t\tsub(color) {\n\t\t\tthis.r = Math.max(0, this.r - color.r);\n\t\t\tthis.g = Math.max(0, this.g - color.g);\n\t\t\tthis.b = Math.max(0, this.b - color.b);\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiply(color) {\n\t\t\tthis.r *= color.r;\n\t\t\tthis.g *= color.g;\n\t\t\tthis.b *= color.b;\n\t\t\treturn this;\n\t\t}\n\n\t\tmultiplyScalar(s) {\n\t\t\tthis.r *= s;\n\t\t\tthis.g *= s;\n\t\t\tthis.b *= s;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerp(color, alpha) {\n\t\t\tthis.r += (color.r - this.r) * alpha;\n\t\t\tthis.g += (color.g - this.g) * alpha;\n\t\t\tthis.b += (color.b - this.b) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerpColors(color1, color2, alpha) {\n\t\t\tthis.r = color1.r + (color2.r - color1.r) * alpha;\n\t\t\tthis.g = color1.g + (color2.g - color1.g) * alpha;\n\t\t\tthis.b = color1.b + (color2.b - color1.b) * alpha;\n\t\t\treturn this;\n\t\t}\n\n\t\tlerpHSL(color, alpha) {\n\t\t\tthis.getHSL(_hslA);\n\t\t\tcolor.getHSL(_hslB);\n\t\t\tconst h = lerp(_hslA.h, _hslB.h, alpha);\n\t\t\tconst s = lerp(_hslA.s, _hslB.s, alpha);\n\t\t\tconst l = lerp(_hslA.l, _hslB.l, alpha);\n\t\t\tthis.setHSL(h, s, l);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(c) {\n\t\t\treturn c.r === this.r && c.g === this.g && c.b === this.b;\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tthis.r = array[offset];\n\t\t\tthis.g = array[offset + 1];\n\t\t\tthis.b = array[offset + 2];\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tarray[offset] = this.r;\n\t\t\tarray[offset + 1] = this.g;\n\t\t\tarray[offset + 2] = this.b;\n\t\t\treturn array;\n\t\t}\n\n\t\tfromBufferAttribute(attribute, index) {\n\t\t\tthis.r = attribute.getX(index);\n\t\t\tthis.g = attribute.getY(index);\n\t\t\tthis.b = attribute.getZ(index);\n\n\t\t\tif (attribute.normalized === true) {\n\t\t\t\t// assuming Uint8Array\n\t\t\t\tthis.r /= 255;\n\t\t\t\tthis.g /= 255;\n\t\t\t\tthis.b /= 255;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\treturn this.getHex();\n\t\t}\n\n\t}\n\n\tColor.NAMES = _colorKeywords;\n\tColor.prototype.isColor = true;\n\tColor.prototype.r = 1;\n\tColor.prototype.g = 1;\n\tColor.prototype.b = 1;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\tlightMap: new THREE.Texture( <Image> ),\n\t *\tlightMapIntensity: <float>\n\t *\n\t *\taoMap: new THREE.Texture( <Image> ),\n\t *\taoMapIntensity: <float>\n\t *\n\t *\tspecularMap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tenvMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *\tcombine: THREE.Multiply,\n\t *\treflectivity: <float>,\n\t *\trefractionRatio: <float>,\n\t *\n\t *\tdepthTest: <bool>,\n\t *\tdepthWrite: <bool>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tmorphTargets: <bool>\n\t * }\n\t */\n\n\tclass MeshBasicMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshBasicMaterial';\n\t\t\tthis.color = new Color(0xffffff); // emissive\n\n\t\t\tthis.map = null;\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\t\tthis.specularMap = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.map = source.map;\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\t\tthis.specularMap = source.specularMap;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\n\n\tconst _vector$9 = /*@__PURE__*/new Vector3();\n\n\tconst _vector2 = /*@__PURE__*/new Vector2();\n\n\tclass BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tif (Array.isArray(array)) {\n\t\t\t\tthrow new TypeError('THREE.BufferAttribute: array should be a Typed Array.');\n\t\t\t}\n\n\t\t\tthis.name = '';\n\t\t\tthis.array = array;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\t\tthis.normalized = normalized === true;\n\t\t\tthis.usage = StaticDrawUsage;\n\t\t\tthis.updateRange = {\n\t\t\t\toffset: 0,\n\t\t\t\tcount: -1\n\t\t\t};\n\t\t\tthis.version = 0;\n\t\t}\n\n\t\tonUploadCallback() {}\n\n\t\tset needsUpdate(value) {\n\t\t\tif (value === true) this.version++;\n\t\t}\n\n\t\tsetUsage(value) {\n\t\t\tthis.usage = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.name = source.name;\n\t\t\tthis.array = new source.array.constructor(source.array);\n\t\t\tthis.itemSize = source.itemSize;\n\t\t\tthis.count = source.count;\n\t\t\tthis.normalized = source.normalized;\n\t\t\tthis.usage = source.usage;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyAt(index1, attribute, index2) {\n\t\t\tindex1 *= this.itemSize;\n\t\t\tindex2 *= attribute.itemSize;\n\n\t\t\tfor (let i = 0, l = this.itemSize; i < l; i++) {\n\t\t\t\tthis.array[index1 + i] = attribute.array[index2 + i];\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyArray(array) {\n\t\t\tthis.array.set(array);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyColorsArray(colors) {\n\t\t\tconst array = this.array;\n\t\t\tlet offset = 0;\n\n\t\t\tfor (let i = 0, l = colors.length; i < l; i++) {\n\t\t\t\tlet color = colors[i];\n\n\t\t\t\tif (color === undefined) {\n\t\t\t\t\tconsole.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);\n\t\t\t\t\tcolor = new Color();\n\t\t\t\t}\n\n\t\t\t\tarray[offset++] = color.r;\n\t\t\t\tarray[offset++] = color.g;\n\t\t\t\tarray[offset++] = color.b;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyVector2sArray(vectors) {\n\t\t\tconst array = this.array;\n\t\t\tlet offset = 0;\n\n\t\t\tfor (let i = 0, l = vectors.length; i < l; i++) {\n\t\t\t\tlet vector = vectors[i];\n\n\t\t\t\tif (vector === undefined) {\n\t\t\t\t\tconsole.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);\n\t\t\t\t\tvector = new Vector2();\n\t\t\t\t}\n\n\t\t\t\tarray[offset++] = vector.x;\n\t\t\t\tarray[offset++] = vector.y;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyVector3sArray(vectors) {\n\t\t\tconst array = this.array;\n\t\t\tlet offset = 0;\n\n\t\t\tfor (let i = 0, l = vectors.length; i < l; i++) {\n\t\t\t\tlet vector = vectors[i];\n\n\t\t\t\tif (vector === undefined) {\n\t\t\t\t\tconsole.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);\n\t\t\t\t\tvector = new Vector3();\n\t\t\t\t}\n\n\t\t\t\tarray[offset++] = vector.x;\n\t\t\t\tarray[offset++] = vector.y;\n\t\t\t\tarray[offset++] = vector.z;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyVector4sArray(vectors) {\n\t\t\tconst array = this.array;\n\t\t\tlet offset = 0;\n\n\t\t\tfor (let i = 0, l = vectors.length; i < l; i++) {\n\t\t\t\tlet vector = vectors[i];\n\n\t\t\t\tif (vector === undefined) {\n\t\t\t\t\tconsole.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);\n\t\t\t\t\tvector = new Vector4();\n\t\t\t\t}\n\n\t\t\t\tarray[offset++] = vector.x;\n\t\t\t\tarray[offset++] = vector.y;\n\t\t\t\tarray[offset++] = vector.z;\n\t\t\t\tarray[offset++] = vector.w;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyMatrix3(m) {\n\t\t\tif (this.itemSize === 2) {\n\t\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t\t_vector2.fromBufferAttribute(this, i);\n\n\t\t\t\t\t_vector2.applyMatrix3(m);\n\n\t\t\t\t\tthis.setXY(i, _vector2.x, _vector2.y);\n\t\t\t\t}\n\t\t\t} else if (this.itemSize === 3) {\n\t\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t\t_vector$9.fromBufferAttribute(this, i);\n\n\t\t\t\t\t_vector$9.applyMatrix3(m);\n\n\t\t\t\t\tthis.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyMatrix4(m) {\n\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t_vector$9.x = this.getX(i);\n\t\t\t\t_vector$9.y = this.getY(i);\n\t\t\t\t_vector$9.z = this.getZ(i);\n\n\t\t\t\t_vector$9.applyMatrix4(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyNormalMatrix(m) {\n\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t_vector$9.x = this.getX(i);\n\t\t\t\t_vector$9.y = this.getY(i);\n\t\t\t\t_vector$9.z = this.getZ(i);\n\n\t\t\t\t_vector$9.applyNormalMatrix(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttransformDirection(m) {\n\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t_vector$9.x = this.getX(i);\n\t\t\t\t_vector$9.y = this.getY(i);\n\t\t\t\t_vector$9.z = this.getZ(i);\n\n\t\t\t\t_vector$9.transformDirection(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tset(value, offset = 0) {\n\t\t\tthis.array.set(value, offset);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetX(index) {\n\t\t\treturn this.array[index * this.itemSize];\n\t\t}\n\n\t\tsetX(index, x) {\n\t\t\tthis.array[index * this.itemSize] = x;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetY(index) {\n\t\t\treturn this.array[index * this.itemSize + 1];\n\t\t}\n\n\t\tsetY(index, y) {\n\t\t\tthis.array[index * this.itemSize + 1] = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetZ(index) {\n\t\t\treturn this.array[index * this.itemSize + 2];\n\t\t}\n\n\t\tsetZ(index, z) {\n\t\t\tthis.array[index * this.itemSize + 2] = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetW(index) {\n\t\t\treturn this.array[index * this.itemSize + 3];\n\t\t}\n\n\t\tsetW(index, w) {\n\t\t\tthis.array[index * this.itemSize + 3] = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetXY(index, x, y) {\n\t\t\tindex *= this.itemSize;\n\t\t\tthis.array[index + 0] = x;\n\t\t\tthis.array[index + 1] = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetXYZ(index, x, y, z) {\n\t\t\tindex *= this.itemSize;\n\t\t\tthis.array[index + 0] = x;\n\t\t\tthis.array[index + 1] = y;\n\t\t\tthis.array[index + 2] = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetXYZW(index, x, y, z, w) {\n\t\t\tindex *= this.itemSize;\n\t\t\tthis.array[index + 0] = x;\n\t\t\tthis.array[index + 1] = y;\n\t\t\tthis.array[index + 2] = z;\n\t\t\tthis.array[index + 3] = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tonUpload(callback) {\n\t\t\tthis.onUploadCallback = callback;\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.array, this.itemSize).copy(this);\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = {\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call(this.array),\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\t\t\tif (this.name !== '') data.name = this.name;\n\t\t\tif (this.usage !== StaticDrawUsage) data.usage = this.usage;\n\t\t\tif (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tBufferAttribute.prototype.isBufferAttribute = true; //\n\n\tclass Int8BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Int8Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Uint8BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Uint8Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Uint8ClampedBufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Uint8ClampedArray(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Int16BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Int16Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Uint16BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Uint16Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Int32BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Int32Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Uint32BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Uint32Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Float16BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Uint16Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tFloat16BufferAttribute.prototype.isFloat16BufferAttribute = true;\n\n\tclass Float32BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Float32Array(array), itemSize, normalized);\n\t\t}\n\n\t}\n\n\tclass Float64BufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized) {\n\t\t\tsuper(new Float64Array(array), itemSize, normalized);\n\t\t}\n\n\t} //\n\n\tfunction arrayMax(array) {\n\t\tif (array.length === 0) return -Infinity;\n\t\tlet max = array[0];\n\n\t\tfor (let i = 1, l = array.length; i < l; ++i) {\n\t\t\tif (array[i] > max) max = array[i];\n\t\t}\n\n\t\treturn max;\n\t}\n\n\tconst TYPED_ARRAYS = {\n\t\tInt8Array: Int8Array,\n\t\tUint8Array: Uint8Array,\n\t\tUint8ClampedArray: Uint8ClampedArray,\n\t\tInt16Array: Int16Array,\n\t\tUint16Array: Uint16Array,\n\t\tInt32Array: Int32Array,\n\t\tUint32Array: Uint32Array,\n\t\tFloat32Array: Float32Array,\n\t\tFloat64Array: Float64Array\n\t};\n\n\tfunction getTypedArray(type, buffer) {\n\t\treturn new TYPED_ARRAYS[type](buffer);\n\t}\n\n\tlet _id = 0;\n\n\tconst _m1 = /*@__PURE__*/new Matrix4();\n\n\tconst _obj = /*@__PURE__*/new Object3D();\n\n\tconst _offset = /*@__PURE__*/new Vector3();\n\n\tconst _box$1 = /*@__PURE__*/new Box3();\n\n\tconst _boxMorphTargets = /*@__PURE__*/new Box3();\n\n\tconst _vector$8 = /*@__PURE__*/new Vector3();\n\n\tclass BufferGeometry extends EventDispatcher {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tObject.defineProperty(this, 'id', {\n\t\t\t\tvalue: _id++\n\t\t\t});\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.name = '';\n\t\t\tthis.type = 'BufferGeometry';\n\t\t\tthis.index = null;\n\t\t\tthis.attributes = {};\n\t\t\tthis.morphAttributes = {};\n\t\t\tthis.morphTargetsRelative = false;\n\t\t\tthis.groups = [];\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null;\n\t\t\tthis.drawRange = {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: Infinity\n\t\t\t};\n\t\t\tthis.userData = {};\n\t\t}\n\n\t\tgetIndex() {\n\t\t\treturn this.index;\n\t\t}\n\n\t\tsetIndex(index) {\n\t\t\tif (Array.isArray(index)) {\n\t\t\t\tthis.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n\t\t\t} else {\n\t\t\t\tthis.index = index;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetAttribute(name) {\n\t\t\treturn this.attributes[name];\n\t\t}\n\n\t\tsetAttribute(name, attribute) {\n\t\t\tthis.attributes[name] = attribute;\n\t\t\treturn this;\n\t\t}\n\n\t\tdeleteAttribute(name) {\n\t\t\tdelete this.attributes[name];\n\t\t\treturn this;\n\t\t}\n\n\t\thasAttribute(name) {\n\t\t\treturn this.attributes[name] !== undefined;\n\t\t}\n\n\t\taddGroup(start, count, materialIndex = 0) {\n\t\t\tthis.groups.push({\n\t\t\t\tstart: start,\n\t\t\t\tcount: count,\n\t\t\t\tmaterialIndex: materialIndex\n\t\t\t});\n\t\t}\n\n\t\tclearGroups() {\n\t\t\tthis.groups = [];\n\t\t}\n\n\t\tsetDrawRange(start, count) {\n\t\t\tthis.drawRange.start = start;\n\t\t\tthis.drawRange.count = count;\n\t\t}\n\n\t\tapplyMatrix4(matrix) {\n\t\t\tconst position = this.attributes.position;\n\n\t\t\tif (position !== undefined) {\n\t\t\t\tposition.applyMatrix4(matrix);\n\t\t\t\tposition.needsUpdate = true;\n\t\t\t}\n\n\t\t\tconst normal = this.attributes.normal;\n\n\t\t\tif (normal !== undefined) {\n\t\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\t\t\t\tnormal.applyNormalMatrix(normalMatrix);\n\t\t\t\tnormal.needsUpdate = true;\n\t\t\t}\n\n\t\t\tconst tangent = this.attributes.tangent;\n\n\t\t\tif (tangent !== undefined) {\n\t\t\t\ttangent.transformDirection(matrix);\n\t\t\t\ttangent.needsUpdate = true;\n\t\t\t}\n\n\t\t\tif (this.boundingBox !== null) {\n\t\t\t\tthis.computeBoundingBox();\n\t\t\t}\n\n\t\t\tif (this.boundingSphere !== null) {\n\t\t\t\tthis.computeBoundingSphere();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyQuaternion(q) {\n\t\t\t_m1.makeRotationFromQuaternion(q);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateX(angle) {\n\t\t\t// rotate geometry around world x-axis\n\t\t\t_m1.makeRotationX(angle);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateY(angle) {\n\t\t\t// rotate geometry around world y-axis\n\t\t\t_m1.makeRotationY(angle);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\trotateZ(angle) {\n\t\t\t// rotate geometry around world z-axis\n\t\t\t_m1.makeRotationZ(angle);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(x, y, z) {\n\t\t\t// translate geometry\n\t\t\t_m1.makeTranslation(x, y, z);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\tscale(x, y, z) {\n\t\t\t// scale geometry\n\t\t\t_m1.makeScale(x, y, z);\n\n\t\t\tthis.applyMatrix4(_m1);\n\t\t\treturn this;\n\t\t}\n\n\t\tlookAt(vector) {\n\t\t\t_obj.lookAt(vector);\n\n\t\t\t_obj.updateMatrix();\n\n\t\t\tthis.applyMatrix4(_obj.matrix);\n\t\t\treturn this;\n\t\t}\n\n\t\tcenter() {\n\t\t\tthis.computeBoundingBox();\n\t\t\tthis.boundingBox.getCenter(_offset).negate();\n\t\t\tthis.translate(_offset.x, _offset.y, _offset.z);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromPoints(points) {\n\t\t\tconst position = [];\n\n\t\t\tfor (let i = 0, l = points.length; i < l; i++) {\n\t\t\t\tconst point = points[i];\n\t\t\t\tposition.push(point.x, point.y, point.z || 0);\n\t\t\t}\n\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(position, 3));\n\t\t\treturn this;\n\t\t}\n\n\t\tcomputeBoundingBox() {\n\t\t\tif (this.boundingBox === null) {\n\t\t\t\tthis.boundingBox = new Box3();\n\t\t\t}\n\n\t\t\tconst position = this.attributes.position;\n\t\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\t\tif (position && position.isGLBufferAttribute) {\n\t\t\t\tconsole.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n\t\t\t\tthis.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (position !== undefined) {\n\t\t\t\tthis.boundingBox.setFromBufferAttribute(position); // process morph attributes if present\n\n\t\t\t\tif (morphAttributesPosition) {\n\t\t\t\t\tfor (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n\t\t\t\t\t\tconst morphAttribute = morphAttributesPosition[i];\n\n\t\t\t\t\t\t_box$1.setFromBufferAttribute(morphAttribute);\n\n\t\t\t\t\t\tif (this.morphTargetsRelative) {\n\t\t\t\t\t\t\t_vector$8.addVectors(this.boundingBox.min, _box$1.min);\n\n\t\t\t\t\t\t\tthis.boundingBox.expandByPoint(_vector$8);\n\n\t\t\t\t\t\t\t_vector$8.addVectors(this.boundingBox.max, _box$1.max);\n\n\t\t\t\t\t\t\tthis.boundingBox.expandByPoint(_vector$8);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.boundingBox.expandByPoint(_box$1.min);\n\t\t\t\t\t\t\tthis.boundingBox.expandByPoint(_box$1.max);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.boundingBox.makeEmpty();\n\t\t\t}\n\n\t\t\tif (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n\t\t\t\tconsole.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n\t\t\t}\n\t\t}\n\n\t\tcomputeBoundingSphere() {\n\t\t\tif (this.boundingSphere === null) {\n\t\t\t\tthis.boundingSphere = new Sphere();\n\t\t\t}\n\n\t\t\tconst position = this.attributes.position;\n\t\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\t\tif (position && position.isGLBufferAttribute) {\n\t\t\t\tconsole.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n\t\t\t\tthis.boundingSphere.set(new Vector3(), Infinity);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (position) {\n\t\t\t\t// first, find the center of the bounding sphere\n\t\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t\t_box$1.setFromBufferAttribute(position); // process morph attributes if present\n\n\n\t\t\t\tif (morphAttributesPosition) {\n\t\t\t\t\tfor (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n\t\t\t\t\t\tconst morphAttribute = morphAttributesPosition[i];\n\n\t\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute(morphAttribute);\n\n\t\t\t\t\t\tif (this.morphTargetsRelative) {\n\t\t\t\t\t\t\t_vector$8.addVectors(_box$1.min, _boxMorphTargets.min);\n\n\t\t\t\t\t\t\t_box$1.expandByPoint(_vector$8);\n\n\t\t\t\t\t\t\t_vector$8.addVectors(_box$1.max, _boxMorphTargets.max);\n\n\t\t\t\t\t\t\t_box$1.expandByPoint(_vector$8);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_box$1.expandByPoint(_boxMorphTargets.min);\n\n\t\t\t\t\t\t\t_box$1.expandByPoint(_boxMorphTargets.max);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t_box$1.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\n\t\t\t\tlet maxRadiusSq = 0;\n\n\t\t\t\tfor (let i = 0, il = position.count; i < il; i++) {\n\t\t\t\t\t_vector$8.fromBufferAttribute(position, i);\n\n\t\t\t\t\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n\t\t\t\t} // process morph attributes if present\n\n\n\t\t\t\tif (morphAttributesPosition) {\n\t\t\t\t\tfor (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n\t\t\t\t\t\tconst morphAttribute = morphAttributesPosition[i];\n\t\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\t\tfor (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n\t\t\t\t\t\t\t_vector$8.fromBufferAttribute(morphAttribute, j);\n\n\t\t\t\t\t\t\tif (morphTargetsRelative) {\n\t\t\t\t\t\t\t\t_offset.fromBufferAttribute(position, j);\n\n\t\t\t\t\t\t\t\t_vector$8.add(_offset);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmaxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n\n\t\t\t\tif (isNaN(this.boundingSphere.radius)) {\n\t\t\t\t\tconsole.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcomputeFaceNormals() {// backwards compatibility\n\t\t}\n\n\t\tcomputeTangents() {\n\t\t\tconst index = this.index;\n\t\t\tconst attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html\n\t\t\t// (per vertex tangents)\n\n\t\t\tif (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {\n\t\t\t\tconsole.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst indices = index.array;\n\t\t\tconst positions = attributes.position.array;\n\t\t\tconst normals = attributes.normal.array;\n\t\t\tconst uvs = attributes.uv.array;\n\t\t\tconst nVertices = positions.length / 3;\n\n\t\t\tif (attributes.tangent === undefined) {\n\t\t\t\tthis.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));\n\t\t\t}\n\n\t\t\tconst tangents = attributes.tangent.array;\n\t\t\tconst tan1 = [],\n\t\t\t\t\t\ttan2 = [];\n\n\t\t\tfor (let i = 0; i < nVertices; i++) {\n\t\t\t\ttan1[i] = new Vector3();\n\t\t\t\ttan2[i] = new Vector3();\n\t\t\t}\n\n\t\t\tconst vA = new Vector3(),\n\t\t\t\t\t\tvB = new Vector3(),\n\t\t\t\t\t\tvC = new Vector3(),\n\t\t\t\t\t\tuvA = new Vector2(),\n\t\t\t\t\t\tuvB = new Vector2(),\n\t\t\t\t\t\tuvC = new Vector2(),\n\t\t\t\t\t\tsdir = new Vector3(),\n\t\t\t\t\t\ttdir = new Vector3();\n\n\t\t\tfunction handleTriangle(a, b, c) {\n\t\t\t\tvA.fromArray(positions, a * 3);\n\t\t\t\tvB.fromArray(positions, b * 3);\n\t\t\t\tvC.fromArray(positions, c * 3);\n\t\t\t\tuvA.fromArray(uvs, a * 2);\n\t\t\t\tuvB.fromArray(uvs, b * 2);\n\t\t\t\tuvC.fromArray(uvs, c * 2);\n\t\t\t\tvB.sub(vA);\n\t\t\t\tvC.sub(vA);\n\t\t\t\tuvB.sub(uvA);\n\t\t\t\tuvC.sub(uvA);\n\t\t\t\tconst r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\t\tif (!isFinite(r)) return;\n\t\t\t\tsdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n\t\t\t\ttdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n\t\t\t\ttan1[a].add(sdir);\n\t\t\t\ttan1[b].add(sdir);\n\t\t\t\ttan1[c].add(sdir);\n\t\t\t\ttan2[a].add(tdir);\n\t\t\t\ttan2[b].add(tdir);\n\t\t\t\ttan2[c].add(tdir);\n\t\t\t}\n\n\t\t\tlet groups = this.groups;\n\n\t\t\tif (groups.length === 0) {\n\t\t\t\tgroups = [{\n\t\t\t\t\tstart: 0,\n\t\t\t\t\tcount: indices.length\n\t\t\t\t}];\n\t\t\t}\n\n\t\t\tfor (let i = 0, il = groups.length; i < il; ++i) {\n\t\t\t\tconst group = groups[i];\n\t\t\t\tconst start = group.start;\n\t\t\t\tconst count = group.count;\n\n\t\t\t\tfor (let j = start, jl = start + count; j < jl; j += 3) {\n\t\t\t\t\thandleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst tmp = new Vector3(),\n\t\t\t\t\t\ttmp2 = new Vector3();\n\t\t\tconst n = new Vector3(),\n\t\t\t\t\t\tn2 = new Vector3();\n\n\t\t\tfunction handleVertex(v) {\n\t\t\t\tn.fromArray(normals, v * 3);\n\t\t\t\tn2.copy(n);\n\t\t\t\tconst t = tan1[v]; // Gram-Schmidt orthogonalize\n\n\t\t\t\ttmp.copy(t);\n\t\t\t\ttmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness\n\n\t\t\t\ttmp2.crossVectors(n2, t);\n\t\t\t\tconst test = tmp2.dot(tan2[v]);\n\t\t\t\tconst w = test < 0.0 ? -1.0 : 1.0;\n\t\t\t\ttangents[v * 4] = tmp.x;\n\t\t\t\ttangents[v * 4 + 1] = tmp.y;\n\t\t\t\ttangents[v * 4 + 2] = tmp.z;\n\t\t\t\ttangents[v * 4 + 3] = w;\n\t\t\t}\n\n\t\t\tfor (let i = 0, il = groups.length; i < il; ++i) {\n\t\t\t\tconst group = groups[i];\n\t\t\t\tconst start = group.start;\n\t\t\t\tconst count = group.count;\n\n\t\t\t\tfor (let j = start, jl = start + count; j < jl; j += 3) {\n\t\t\t\t\thandleVertex(indices[j + 0]);\n\t\t\t\t\thandleVertex(indices[j + 1]);\n\t\t\t\t\thandleVertex(indices[j + 2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcomputeVertexNormals() {\n\t\t\tconst index = this.index;\n\t\t\tconst positionAttribute = this.getAttribute('position');\n\n\t\t\tif (positionAttribute !== undefined) {\n\t\t\t\tlet normalAttribute = this.getAttribute('normal');\n\n\t\t\t\tif (normalAttribute === undefined) {\n\t\t\t\t\tnormalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n\t\t\t\t\tthis.setAttribute('normal', normalAttribute);\n\t\t\t\t} else {\n\t\t\t\t\t// reset existing normals to zero\n\t\t\t\t\tfor (let i = 0, il = normalAttribute.count; i < il; i++) {\n\t\t\t\t\t\tnormalAttribute.setXYZ(i, 0, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst pA = new Vector3(),\n\t\t\t\t\t\t\tpB = new Vector3(),\n\t\t\t\t\t\t\tpC = new Vector3();\n\t\t\t\tconst nA = new Vector3(),\n\t\t\t\t\t\t\tnB = new Vector3(),\n\t\t\t\t\t\t\tnC = new Vector3();\n\t\t\t\tconst cb = new Vector3(),\n\t\t\t\t\t\t\tab = new Vector3(); // indexed elements\n\n\t\t\t\tif (index) {\n\t\t\t\t\tfor (let i = 0, il = index.count; i < il; i += 3) {\n\t\t\t\t\t\tconst vA = index.getX(i + 0);\n\t\t\t\t\t\tconst vB = index.getX(i + 1);\n\t\t\t\t\t\tconst vC = index.getX(i + 2);\n\t\t\t\t\t\tpA.fromBufferAttribute(positionAttribute, vA);\n\t\t\t\t\t\tpB.fromBufferAttribute(positionAttribute, vB);\n\t\t\t\t\t\tpC.fromBufferAttribute(positionAttribute, vC);\n\t\t\t\t\t\tcb.subVectors(pC, pB);\n\t\t\t\t\t\tab.subVectors(pA, pB);\n\t\t\t\t\t\tcb.cross(ab);\n\t\t\t\t\t\tnA.fromBufferAttribute(normalAttribute, vA);\n\t\t\t\t\t\tnB.fromBufferAttribute(normalAttribute, vB);\n\t\t\t\t\t\tnC.fromBufferAttribute(normalAttribute, vC);\n\t\t\t\t\t\tnA.add(cb);\n\t\t\t\t\t\tnB.add(cb);\n\t\t\t\t\t\tnC.add(cb);\n\t\t\t\t\t\tnormalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n\t\t\t\t\t\tnormalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n\t\t\t\t\t\tnormalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\t\t\t\t\tfor (let i = 0, il = positionAttribute.count; i < il; i += 3) {\n\t\t\t\t\t\tpA.fromBufferAttribute(positionAttribute, i + 0);\n\t\t\t\t\t\tpB.fromBufferAttribute(positionAttribute, i + 1);\n\t\t\t\t\t\tpC.fromBufferAttribute(positionAttribute, i + 2);\n\t\t\t\t\t\tcb.subVectors(pC, pB);\n\t\t\t\t\t\tab.subVectors(pA, pB);\n\t\t\t\t\t\tcb.cross(ab);\n\t\t\t\t\t\tnormalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);\n\t\t\t\t\t\tnormalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);\n\t\t\t\t\t\tnormalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.normalizeNormals();\n\t\t\t\tnormalAttribute.needsUpdate = true;\n\t\t\t}\n\t\t}\n\n\t\tmerge(geometry, offset) {\n\t\t\tif (!(geometry && geometry.isBufferGeometry)) {\n\t\t\t\tconsole.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (offset === undefined) {\n\t\t\t\toffset = 0;\n\t\t\t\tconsole.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');\n\t\t\t}\n\n\t\t\tconst attributes = this.attributes;\n\n\t\t\tfor (const key in attributes) {\n\t\t\t\tif (geometry.attributes[key] === undefined) continue;\n\t\t\t\tconst attribute1 = attributes[key];\n\t\t\t\tconst attributeArray1 = attribute1.array;\n\t\t\t\tconst attribute2 = geometry.attributes[key];\n\t\t\t\tconst attributeArray2 = attribute2.array;\n\t\t\t\tconst attributeOffset = attribute2.itemSize * offset;\n\t\t\t\tconst length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);\n\n\t\t\t\tfor (let i = 0, j = attributeOffset; i < length; i++, j++) {\n\t\t\t\t\tattributeArray1[j] = attributeArray2[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tnormalizeNormals() {\n\t\t\tconst normals = this.attributes.normal;\n\n\t\t\tfor (let i = 0, il = normals.count; i < il; i++) {\n\t\t\t\t_vector$8.fromBufferAttribute(normals, i);\n\n\t\t\t\t_vector$8.normalize();\n\n\t\t\t\tnormals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);\n\t\t\t}\n\t\t}\n\n\t\ttoNonIndexed() {\n\t\t\tfunction convertBufferAttribute(attribute, indices) {\n\t\t\t\tconst array = attribute.array;\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst normalized = attribute.normalized;\n\t\t\t\tconst array2 = new array.constructor(indices.length * itemSize);\n\t\t\t\tlet index = 0,\n\t\t\t\t\t\tindex2 = 0;\n\n\t\t\t\tfor (let i = 0, l = indices.length; i < l; i++) {\n\t\t\t\t\tindex = indices[i] * itemSize;\n\n\t\t\t\t\tfor (let j = 0; j < itemSize; j++) {\n\t\t\t\t\t\tarray2[index2++] = array[index++];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new BufferAttribute(array2, itemSize, normalized);\n\t\t\t} //\n\n\n\t\t\tif (this.index === null) {\n\t\t\t\tconsole.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tconst geometry2 = new BufferGeometry();\n\t\t\tconst indices = this.index.array;\n\t\t\tconst attributes = this.attributes; // attributes\n\n\t\t\tfor (const name in attributes) {\n\t\t\t\tconst attribute = attributes[name];\n\t\t\t\tconst newAttribute = convertBufferAttribute(attribute, indices);\n\t\t\t\tgeometry2.setAttribute(name, newAttribute);\n\t\t\t} // morph attributes\n\n\n\t\t\tconst morphAttributes = this.morphAttributes;\n\n\t\t\tfor (const name in morphAttributes) {\n\t\t\t\tconst morphArray = [];\n\t\t\t\tconst morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\t\tfor (let i = 0, il = morphAttribute.length; i < il; i++) {\n\t\t\t\t\tconst attribute = morphAttribute[i];\n\t\t\t\t\tconst newAttribute = convertBufferAttribute(attribute, indices);\n\t\t\t\t\tmorphArray.push(newAttribute);\n\t\t\t\t}\n\n\t\t\t\tgeometry2.morphAttributes[name] = morphArray;\n\t\t\t}\n\n\t\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative; // groups\n\n\t\t\tconst groups = this.groups;\n\n\t\t\tfor (let i = 0, l = groups.length; i < l; i++) {\n\t\t\t\tconst group = groups[i];\n\t\t\t\tgeometry2.addGroup(group.start, group.count, group.materialIndex);\n\t\t\t}\n\n\t\t\treturn geometry2;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t\t}\n\t\t\t}; // standard BufferGeometry serialization\n\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.type = this.type;\n\t\t\tif (this.name !== '') data.name = this.name;\n\t\t\tif (Object.keys(this.userData).length > 0) data.userData = this.userData;\n\n\t\t\tif (this.parameters !== undefined) {\n\t\t\t\tconst parameters = this.parameters;\n\n\t\t\t\tfor (const key in parameters) {\n\t\t\t\t\tif (parameters[key] !== undefined) data[key] = parameters[key];\n\t\t\t\t}\n\n\t\t\t\treturn data;\n\t\t\t} // for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\n\t\t\tdata.data = {\n\t\t\t\tattributes: {}\n\t\t\t};\n\t\t\tconst index = this.index;\n\n\t\t\tif (index !== null) {\n\t\t\t\tdata.data.index = {\n\t\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\t\tarray: Array.prototype.slice.call(index.array)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tconst attributes = this.attributes;\n\n\t\t\tfor (const key in attributes) {\n\t\t\t\tconst attribute = attributes[key];\n\t\t\t\tdata.data.attributes[key] = attribute.toJSON(data.data);\n\t\t\t}\n\n\t\t\tconst morphAttributes = {};\n\t\t\tlet hasMorphAttributes = false;\n\n\t\t\tfor (const key in this.morphAttributes) {\n\t\t\t\tconst attributeArray = this.morphAttributes[key];\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor (let i = 0, il = attributeArray.length; i < il; i++) {\n\t\t\t\t\tconst attribute = attributeArray[i];\n\t\t\t\t\tarray.push(attribute.toJSON(data.data));\n\t\t\t\t}\n\n\t\t\t\tif (array.length > 0) {\n\t\t\t\t\tmorphAttributes[key] = array;\n\t\t\t\t\thasMorphAttributes = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (hasMorphAttributes) {\n\t\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\t\t\t}\n\n\t\t\tconst groups = this.groups;\n\n\t\t\tif (groups.length > 0) {\n\t\t\t\tdata.data.groups = JSON.parse(JSON.stringify(groups));\n\t\t\t}\n\n\t\t\tconst boundingSphere = this.boundingSphere;\n\n\t\t\tif (boundingSphere !== null) {\n\t\t\t\tdata.data.boundingSphere = {\n\t\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\t\tradius: boundingSphere.radius\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tclone() {\n\t\t\t/*\n\t\t\t // Handle primitives\n\t\t\t\t const parameters = this.parameters;\n\t\t\t\t if ( parameters !== undefined ) {\n\t\t\t\t const values = [];\n\t\t\t\t for ( const key in parameters ) {\n\t\t\t\t values.push( parameters[ key ] );\n\t\t\t\t }\n\t\t\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t\t this.constructor.apply( geometry, values );\n\t\t\t return geometry;\n\t\t\t\t }\n\t\t\t\t return new this.constructor().copy( this );\n\t\t\t */\n\t\t\treturn new BufferGeometry().copy(this);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\t// reset\n\t\t\tthis.index = null;\n\t\t\tthis.attributes = {};\n\t\t\tthis.morphAttributes = {};\n\t\t\tthis.groups = [];\n\t\t\tthis.boundingBox = null;\n\t\t\tthis.boundingSphere = null; // used for storing cloned, shared data\n\n\t\t\tconst data = {}; // name\n\n\t\t\tthis.name = source.name; // index\n\n\t\t\tconst index = source.index;\n\n\t\t\tif (index !== null) {\n\t\t\t\tthis.setIndex(index.clone(data));\n\t\t\t} // attributes\n\n\n\t\t\tconst attributes = source.attributes;\n\n\t\t\tfor (const name in attributes) {\n\t\t\t\tconst attribute = attributes[name];\n\t\t\t\tthis.setAttribute(name, attribute.clone(data));\n\t\t\t} // morph attributes\n\n\n\t\t\tconst morphAttributes = source.morphAttributes;\n\n\t\t\tfor (const name in morphAttributes) {\n\t\t\t\tconst array = [];\n\t\t\t\tconst morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\t\tfor (let i = 0, l = morphAttribute.length; i < l; i++) {\n\t\t\t\t\tarray.push(morphAttribute[i].clone(data));\n\t\t\t\t}\n\n\t\t\t\tthis.morphAttributes[name] = array;\n\t\t\t}\n\n\t\t\tthis.morphTargetsRelative = source.morphTargetsRelative; // groups\n\n\t\t\tconst groups = source.groups;\n\n\t\t\tfor (let i = 0, l = groups.length; i < l; i++) {\n\t\t\t\tconst group = groups[i];\n\t\t\t\tthis.addGroup(group.start, group.count, group.materialIndex);\n\t\t\t} // bounding box\n\n\n\t\t\tconst boundingBox = source.boundingBox;\n\n\t\t\tif (boundingBox !== null) {\n\t\t\t\tthis.boundingBox = boundingBox.clone();\n\t\t\t} // bounding sphere\n\n\n\t\t\tconst boundingSphere = source.boundingSphere;\n\n\t\t\tif (boundingSphere !== null) {\n\t\t\t\tthis.boundingSphere = boundingSphere.clone();\n\t\t\t} // draw range\n\n\n\t\t\tthis.drawRange.start = source.drawRange.start;\n\t\t\tthis.drawRange.count = source.drawRange.count; // user data\n\n\t\t\tthis.userData = source.userData;\n\t\t\treturn this;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'dispose'\n\t\t\t});\n\t\t}\n\n\t}\n\n\tBufferGeometry.prototype.isBufferGeometry = true;\n\n\tconst _inverseMatrix$2 = /*@__PURE__*/new Matrix4();\n\n\tconst _ray$2 = /*@__PURE__*/new Ray();\n\n\tconst _sphere$3 = /*@__PURE__*/new Sphere();\n\n\tconst _vA$1 = /*@__PURE__*/new Vector3();\n\n\tconst _vB$1 = /*@__PURE__*/new Vector3();\n\n\tconst _vC$1 = /*@__PURE__*/new Vector3();\n\n\tconst _tempA = /*@__PURE__*/new Vector3();\n\n\tconst _tempB = /*@__PURE__*/new Vector3();\n\n\tconst _tempC = /*@__PURE__*/new Vector3();\n\n\tconst _morphA = /*@__PURE__*/new Vector3();\n\n\tconst _morphB = /*@__PURE__*/new Vector3();\n\n\tconst _morphC = /*@__PURE__*/new Vector3();\n\n\tconst _uvA$1 = /*@__PURE__*/new Vector2();\n\n\tconst _uvB$1 = /*@__PURE__*/new Vector2();\n\n\tconst _uvC$1 = /*@__PURE__*/new Vector2();\n\n\tconst _intersectionPoint = /*@__PURE__*/new Vector3();\n\n\tconst _intersectionPointWorld = /*@__PURE__*/new Vector3();\n\n\tclass Mesh extends Object3D {\n\t\tconstructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Mesh';\n\t\t\tthis.geometry = geometry;\n\t\t\tthis.material = material;\n\t\t\tthis.updateMorphTargets();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\n\t\t\tif (source.morphTargetInfluences !== undefined) {\n\t\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\t\t\t}\n\n\t\t\tif (source.morphTargetDictionary !== undefined) {\n\t\t\t\tthis.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n\t\t\t}\n\n\t\t\tthis.material = source.material;\n\t\t\tthis.geometry = source.geometry;\n\t\t\treturn this;\n\t\t}\n\n\t\tupdateMorphTargets() {\n\t\t\tconst geometry = this.geometry;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\t\tconst keys = Object.keys(morphAttributes);\n\n\t\t\t\tif (keys.length > 0) {\n\t\t\t\t\tconst morphAttribute = morphAttributes[keys[0]];\n\n\t\t\t\t\tif (morphAttribute !== undefined) {\n\t\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\t\tfor (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n\t\t\t\t\t\t\tconst name = morphAttribute[m].name || String(m);\n\t\t\t\t\t\t\tthis.morphTargetInfluences.push(0);\n\t\t\t\t\t\t\tthis.morphTargetDictionary[name] = m;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\t\tif (morphTargets !== undefined && morphTargets.length > 0) {\n\t\t\t\t\tconsole.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst material = this.material;\n\t\t\tconst matrixWorld = this.matrixWorld;\n\t\t\tif (material === undefined) return; // Checking boundingSphere distance to ray\n\n\t\t\tif (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n\t\t\t_sphere$3.copy(geometry.boundingSphere);\n\n\t\t\t_sphere$3.applyMatrix4(matrixWorld);\n\n\t\t\tif (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //\n\n\t\t\t_inverseMatrix$2.copy(matrixWorld).invert();\n\n\t\t\t_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2); // Check boundingBox before continuing\n\n\n\t\t\tif (geometry.boundingBox !== null) {\n\t\t\t\tif (_ray$2.intersectsBox(geometry.boundingBox) === false) return;\n\t\t\t}\n\n\t\t\tlet intersection;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\t\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\t\t\tconst uv = geometry.attributes.uv;\n\t\t\t\tconst uv2 = geometry.attributes.uv2;\n\t\t\t\tconst groups = geometry.groups;\n\t\t\t\tconst drawRange = geometry.drawRange;\n\n\t\t\t\tif (index !== null) {\n\t\t\t\t\t// indexed buffer geometry\n\t\t\t\t\tif (Array.isArray(material)) {\n\t\t\t\t\t\tfor (let i = 0, il = groups.length; i < il; i++) {\n\t\t\t\t\t\t\tconst group = groups[i];\n\t\t\t\t\t\t\tconst groupMaterial = material[group.materialIndex];\n\t\t\t\t\t\t\tconst start = Math.max(group.start, drawRange.start);\n\t\t\t\t\t\t\tconst end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\t\t\tfor (let j = start, jl = end; j < jl; j += 3) {\n\t\t\t\t\t\t\t\tconst a = index.getX(j);\n\t\t\t\t\t\t\t\tconst b = index.getX(j + 1);\n\t\t\t\t\t\t\t\tconst c = index.getX(j + 2);\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n\t\t\t\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics\n\n\t\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\t\tintersects.push(intersection);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\t\tconst end = Math.min(index.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\t\tfor (let i = start, il = end; i < il; i += 3) {\n\t\t\t\t\t\t\tconst a = index.getX(i);\n\t\t\t\t\t\t\tconst b = index.getX(i + 1);\n\t\t\t\t\t\t\tconst c = index.getX(i + 2);\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n\t\t\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics\n\n\t\t\t\t\t\t\t\tintersects.push(intersection);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (position !== undefined) {\n\t\t\t\t\t// non-indexed buffer geometry\n\t\t\t\t\tif (Array.isArray(material)) {\n\t\t\t\t\t\tfor (let i = 0, il = groups.length; i < il; i++) {\n\t\t\t\t\t\t\tconst group = groups[i];\n\t\t\t\t\t\t\tconst groupMaterial = material[group.materialIndex];\n\t\t\t\t\t\t\tconst start = Math.max(group.start, drawRange.start);\n\t\t\t\t\t\t\tconst end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\t\t\tfor (let j = start, jl = end; j < jl; j += 3) {\n\t\t\t\t\t\t\t\tconst a = j;\n\t\t\t\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\t\t\t\tconst c = j + 2;\n\t\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n\t\t\t\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics\n\n\t\t\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\t\t\tintersects.push(intersection);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\t\tconst end = Math.min(position.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\t\tfor (let i = start, il = end; i < il; i += 3) {\n\t\t\t\t\t\t\tconst a = i;\n\t\t\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\t\t\tconst c = i + 2;\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n\n\t\t\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics\n\n\t\t\t\t\t\t\t\tintersects.push(intersection);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (geometry.isGeometry) {\n\t\t\t\tconsole.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t}\n\t\t}\n\n\t}\n\n\tMesh.prototype.isMesh = true;\n\n\tfunction checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {\n\t\tlet intersect;\n\n\t\tif (material.side === BackSide) {\n\t\t\tintersect = ray.intersectTriangle(pC, pB, pA, true, point);\n\t\t} else {\n\t\t\tintersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);\n\t\t}\n\n\t\tif (intersect === null) return null;\n\n\t\t_intersectionPointWorld.copy(point);\n\n\t\t_intersectionPointWorld.applyMatrix4(object.matrixWorld);\n\n\t\tconst distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n\t\tif (distance < raycaster.near || distance > raycaster.far) return null;\n\t\treturn {\n\t\t\tdistance: distance,\n\t\t\tpoint: _intersectionPointWorld.clone(),\n\t\t\tobject: object\n\t\t};\n\t}\n\n\tfunction checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {\n\t\t_vA$1.fromBufferAttribute(position, a);\n\n\t\t_vB$1.fromBufferAttribute(position, b);\n\n\t\t_vC$1.fromBufferAttribute(position, c);\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif (material.morphTargets && morphPosition && morphInfluences) {\n\t\t\t_morphA.set(0, 0, 0);\n\n\t\t\t_morphB.set(0, 0, 0);\n\n\t\t\t_morphC.set(0, 0, 0);\n\n\t\t\tfor (let i = 0, il = morphPosition.length; i < il; i++) {\n\t\t\t\tconst influence = morphInfluences[i];\n\t\t\t\tconst morphAttribute = morphPosition[i];\n\t\t\t\tif (influence === 0) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute(morphAttribute, a);\n\n\t\t\t\t_tempB.fromBufferAttribute(morphAttribute, b);\n\n\t\t\t\t_tempC.fromBufferAttribute(morphAttribute, c);\n\n\t\t\t\tif (morphTargetsRelative) {\n\t\t\t\t\t_morphA.addScaledVector(_tempA, influence);\n\n\t\t\t\t\t_morphB.addScaledVector(_tempB, influence);\n\n\t\t\t\t\t_morphC.addScaledVector(_tempC, influence);\n\t\t\t\t} else {\n\t\t\t\t\t_morphA.addScaledVector(_tempA.sub(_vA$1), influence);\n\n\t\t\t\t\t_morphB.addScaledVector(_tempB.sub(_vB$1), influence);\n\n\t\t\t\t\t_morphC.addScaledVector(_tempC.sub(_vC$1), influence);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_vA$1.add(_morphA);\n\n\t\t\t_vB$1.add(_morphB);\n\n\t\t\t_vC$1.add(_morphC);\n\t\t}\n\n\t\tif (object.isSkinnedMesh) {\n\t\t\tobject.boneTransform(a, _vA$1);\n\t\t\tobject.boneTransform(b, _vB$1);\n\t\t\tobject.boneTransform(c, _vC$1);\n\t\t}\n\n\t\tconst intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);\n\n\t\tif (intersection) {\n\t\t\tif (uv) {\n\t\t\t\t_uvA$1.fromBufferAttribute(uv, a);\n\n\t\t\t\t_uvB$1.fromBufferAttribute(uv, b);\n\n\t\t\t\t_uvC$1.fromBufferAttribute(uv, c);\n\n\t\t\t\tintersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());\n\t\t\t}\n\n\t\t\tif (uv2) {\n\t\t\t\t_uvA$1.fromBufferAttribute(uv2, a);\n\n\t\t\t\t_uvB$1.fromBufferAttribute(uv2, b);\n\n\t\t\t\t_uvC$1.fromBufferAttribute(uv2, c);\n\n\t\t\t\tintersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());\n\t\t\t}\n\n\t\t\tconst face = {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tnormal: new Vector3(),\n\t\t\t\tmaterialIndex: 0\n\t\t\t};\n\t\t\tTriangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);\n\t\t\tintersection.face = face;\n\t\t}\n\n\t\treturn intersection;\n\t}\n\n\tclass BoxGeometry extends BufferGeometry {\n\t\tconstructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {\n\t\t\tsuper();\n\t\t\tthis.type = 'BoxGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tdepth: depth,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tdepthSegments: depthSegments\n\t\t\t};\n\t\t\tconst scope = this; // segments\n\n\t\t\twidthSegments = Math.floor(widthSegments);\n\t\t\theightSegments = Math.floor(heightSegments);\n\t\t\tdepthSegments = Math.floor(depthSegments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tlet numberOfVertices = 0;\n\t\t\tlet groupStart = 0; // build each side of the box geometry\n\n\t\t\tbuildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px\n\n\t\t\tbuildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx\n\n\t\t\tbuildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py\n\n\t\t\tbuildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny\n\n\t\t\tbuildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz\n\n\t\t\tbuildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz\n\t\t\t// build geometry\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n\t\t\tfunction buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {\n\t\t\t\tconst segmentWidth = width / gridX;\n\t\t\t\tconst segmentHeight = height / gridY;\n\t\t\t\tconst widthHalf = width / 2;\n\t\t\t\tconst heightHalf = height / 2;\n\t\t\t\tconst depthHalf = depth / 2;\n\t\t\t\tconst gridX1 = gridX + 1;\n\t\t\t\tconst gridY1 = gridY + 1;\n\t\t\t\tlet vertexCounter = 0;\n\t\t\t\tlet groupCount = 0;\n\t\t\t\tconst vector = new Vector3(); // generate vertices, normals and uvs\n\n\t\t\t\tfor (let iy = 0; iy < gridY1; iy++) {\n\t\t\t\t\tconst y = iy * segmentHeight - heightHalf;\n\n\t\t\t\t\tfor (let ix = 0; ix < gridX1; ix++) {\n\t\t\t\t\t\tconst x = ix * segmentWidth - widthHalf; // set values to correct vector component\n\n\t\t\t\t\t\tvector[u] = x * udir;\n\t\t\t\t\t\tvector[v] = y * vdir;\n\t\t\t\t\t\tvector[w] = depthHalf; // now apply vector to vertex buffer\n\n\t\t\t\t\t\tvertices.push(vector.x, vector.y, vector.z); // set values to correct vector component\n\n\t\t\t\t\t\tvector[u] = 0;\n\t\t\t\t\t\tvector[v] = 0;\n\t\t\t\t\t\tvector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer\n\n\t\t\t\t\t\tnormals.push(vector.x, vector.y, vector.z); // uvs\n\n\t\t\t\t\t\tuvs.push(ix / gridX);\n\t\t\t\t\t\tuvs.push(1 - iy / gridY); // counters\n\n\t\t\t\t\t\tvertexCounter += 1;\n\t\t\t\t\t}\n\t\t\t\t} // indices\n\t\t\t\t// 1. you need three indices to draw a single face\n\t\t\t\t// 2. a single segment consists of two faces\n\t\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\n\t\t\t\tfor (let iy = 0; iy < gridY; iy++) {\n\t\t\t\t\tfor (let ix = 0; ix < gridX; ix++) {\n\t\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * (iy + 1);\n\t\t\t\t\t\tconst c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);\n\t\t\t\t\t\tconst d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces\n\n\t\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\t\tindices.push(b, c, d); // increase counter\n\n\t\t\t\t\t\tgroupCount += 6;\n\t\t\t\t\t}\n\t\t\t\t} // add a group to the geometry. this will ensure multi material support\n\n\n\t\t\t\tscope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups\n\n\t\t\t\tgroupStart += groupCount; // update total number of vertices\n\n\t\t\t\tnumberOfVertices += vertexCounter;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Uniform Utilities\n\t */\n\tfunction cloneUniforms(src) {\n\t\tconst dst = {};\n\n\t\tfor (const u in src) {\n\t\t\tdst[u] = {};\n\n\t\t\tfor (const p in src[u]) {\n\t\t\t\tconst property = src[u][p];\n\n\t\t\t\tif (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {\n\t\t\t\t\tdst[u][p] = property.clone();\n\t\t\t\t} else if (Array.isArray(property)) {\n\t\t\t\t\tdst[u][p] = property.slice();\n\t\t\t\t} else {\n\t\t\t\t\tdst[u][p] = property;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn dst;\n\t}\n\tfunction mergeUniforms(uniforms) {\n\t\tconst merged = {};\n\n\t\tfor (let u = 0; u < uniforms.length; u++) {\n\t\t\tconst tmp = cloneUniforms(uniforms[u]);\n\n\t\t\tfor (const p in tmp) {\n\t\t\t\tmerged[p] = tmp[p];\n\t\t\t}\n\t\t}\n\n\t\treturn merged;\n\t} // Legacy\n\n\tconst UniformsUtils = {\n\t\tclone: cloneUniforms,\n\t\tmerge: mergeUniforms\n\t};\n\n\tvar default_vertex = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\n\n\tvar default_fragment = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\n\n\t/**\n\t * parameters = {\n\t *\tdefines: { \"label\" : \"value\" },\n\t *\tuniforms: { \"parameter1\": { value: 1.0 }, \"parameter2\": { value2: 2 } },\n\t *\n\t *\tfragmentShader: <string>,\n\t *\tvertexShader: <string>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tlights: <bool>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>\n\t * }\n\t */\n\n\tclass ShaderMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ShaderMaterial';\n\t\t\tthis.defines = {};\n\t\t\tthis.uniforms = {};\n\t\t\tthis.vertexShader = default_vertex;\n\t\t\tthis.fragmentShader = default_fragment;\n\t\t\tthis.linewidth = 1;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.fog = false; // set to use scene fog\n\n\t\t\tthis.lights = false; // set to use scene lights\n\n\t\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\t\tthis.morphTargets = false; // set to use morph targets\n\n\t\t\tthis.morphNormals = false; // set to use morph normals\n\n\t\t\tthis.extensions = {\n\t\t\t\tderivatives: false,\n\t\t\t\t// set to use derivatives\n\t\t\t\tfragDepth: false,\n\t\t\t\t// set to use fragment depth values\n\t\t\t\tdrawBuffers: false,\n\t\t\t\t// set to use draw buffers\n\t\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\n\t\t\t}; // When rendered geometry doesn't include these attributes but the material does,\n\t\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\n\t\t\tthis.defaultAttributeValues = {\n\t\t\t\t'color': [1, 1, 1],\n\t\t\t\t'uv': [0, 0],\n\t\t\t\t'uv2': [0, 0]\n\t\t\t};\n\t\t\tthis.index0AttributeName = undefined;\n\t\t\tthis.uniformsNeedUpdate = false;\n\t\t\tthis.glslVersion = null;\n\n\t\t\tif (parameters !== undefined) {\n\t\t\t\tif (parameters.attributes !== undefined) {\n\t\t\t\t\tconsole.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');\n\t\t\t\t}\n\n\t\t\t\tthis.setValues(parameters);\n\t\t\t}\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.fragmentShader = source.fragmentShader;\n\t\t\tthis.vertexShader = source.vertexShader;\n\t\t\tthis.uniforms = cloneUniforms(source.uniforms);\n\t\t\tthis.defines = Object.assign({}, source.defines);\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.lights = source.lights;\n\t\t\tthis.clipping = source.clipping;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\tthis.extensions = Object.assign({}, source.extensions);\n\t\t\tthis.glslVersion = source.glslVersion;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.glslVersion = this.glslVersion;\n\t\t\tdata.uniforms = {};\n\n\t\t\tfor (const name in this.uniforms) {\n\t\t\t\tconst uniform = this.uniforms[name];\n\t\t\t\tconst value = uniform.value;\n\n\t\t\t\tif (value && value.isTexture) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 't',\n\t\t\t\t\t\tvalue: value.toJSON(meta).uuid\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isColor) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'c',\n\t\t\t\t\t\tvalue: value.getHex()\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isVector2) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'v2',\n\t\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isVector3) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'v3',\n\t\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isVector4) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'v4',\n\t\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isMatrix3) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'm3',\n\t\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t\t};\n\t\t\t\t} else if (value && value.isMatrix4) {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\ttype: 'm4',\n\t\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tdata.uniforms[name] = {\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t}; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Object.keys(this.defines).length > 0) data.defines = this.defines;\n\t\t\tdata.vertexShader = this.vertexShader;\n\t\t\tdata.fragmentShader = this.fragmentShader;\n\t\t\tconst extensions = {};\n\n\t\t\tfor (const key in this.extensions) {\n\t\t\t\tif (this.extensions[key] === true) extensions[key] = true;\n\t\t\t}\n\n\t\t\tif (Object.keys(extensions).length > 0) data.extensions = extensions;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tShaderMaterial.prototype.isShaderMaterial = true;\n\n\tclass Camera extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'Camera';\n\t\t\tthis.matrixWorldInverse = new Matrix4();\n\t\t\tthis.projectionMatrix = new Matrix4();\n\t\t\tthis.projectionMatrixInverse = new Matrix4();\n\t\t}\n\n\t\tcopy(source, recursive) {\n\t\t\tsuper.copy(source, recursive);\n\t\t\tthis.matrixWorldInverse.copy(source.matrixWorldInverse);\n\t\t\tthis.projectionMatrix.copy(source.projectionMatrix);\n\t\t\tthis.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetWorldDirection(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Camera: .getWorldDirection() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\tthis.updateWorldMatrix(true, false);\n\t\t\tconst e = this.matrixWorld.elements;\n\t\t\treturn target.set(-e[8], -e[9], -e[10]).normalize();\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t\tthis.matrixWorldInverse.copy(this.matrixWorld).invert();\n\t\t}\n\n\t\tupdateWorldMatrix(updateParents, updateChildren) {\n\t\t\tsuper.updateWorldMatrix(updateParents, updateChildren);\n\t\t\tthis.matrixWorldInverse.copy(this.matrixWorld).invert();\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tCamera.prototype.isCamera = true;\n\n\tclass PerspectiveCamera extends Camera {\n\t\tconstructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {\n\t\t\tsuper();\n\t\t\tthis.type = 'PerspectiveCamera';\n\t\t\tthis.fov = fov;\n\t\t\tthis.zoom = 1;\n\t\t\tthis.near = near;\n\t\t\tthis.far = far;\n\t\t\tthis.focus = 10;\n\t\t\tthis.aspect = aspect;\n\t\t\tthis.view = null;\n\t\t\tthis.filmGauge = 35; // width of the film (default in millimeters)\n\n\t\t\tthis.filmOffset = 0; // horizontal film offset (same unit as gauge)\n\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tcopy(source, recursive) {\n\t\t\tsuper.copy(source, recursive);\n\t\t\tthis.fov = source.fov;\n\t\t\tthis.zoom = source.zoom;\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\t\t\tthis.focus = source.focus;\n\t\t\tthis.aspect = source.aspect;\n\t\t\tthis.view = source.view === null ? null : Object.assign({}, source.view);\n\t\t\tthis.filmGauge = source.filmGauge;\n\t\t\tthis.filmOffset = source.filmOffset;\n\t\t\treturn this;\n\t\t}\n\t\t/**\n\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t\t *\n\t\t * The default film gauge is 35, so that the focal length can be specified for\n\t\t * a 35mm (full frame) camera.\n\t\t *\n\t\t * Values for focal length and film gauge must have the same unit.\n\t\t */\n\n\n\t\tsetFocalLength(focalLength) {\n\t\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n\t\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\t\t\tthis.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\t\t/**\n\t\t * Calculates the focal length from the current .fov and .filmGauge.\n\t\t */\n\n\n\t\tgetFocalLength() {\n\t\t\tconst vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);\n\t\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\t\t}\n\n\t\tgetEffectiveFOV() {\n\t\t\treturn RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);\n\t\t}\n\n\t\tgetFilmWidth() {\n\t\t\t// film not completely covered in portrait format (aspect < 1)\n\t\t\treturn this.filmGauge * Math.min(this.aspect, 1);\n\t\t}\n\n\t\tgetFilmHeight() {\n\t\t\t// film not completely covered in landscape format (aspect > 1)\n\t\t\treturn this.filmGauge / Math.max(this.aspect, 1);\n\t\t}\n\t\t/**\n\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t\t * multi-monitor/multi-machine setups.\n\t\t *\n\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t\t * the monitors are in grid like this\n\t\t *\n\t\t *\t +---+---+---+\n\t\t *\t | A | B | C |\n\t\t *\t +---+---+---+\n\t\t *\t | D | E | F |\n\t\t *\t +---+---+---+\n\t\t *\n\t\t * then for each monitor you would call it like this\n\t\t *\n\t\t *\t const w = 1920;\n\t\t *\t const h = 1080;\n\t\t *\t const fullWidth = w * 3;\n\t\t *\t const fullHeight = h * 2;\n\t\t *\n\t\t *\t --A--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t\t *\t --B--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t\t *\t --C--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t\t *\t --D--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t\t *\t --E--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t\t *\t --F--\n\t\t *\t camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t\t *\n\t\t *\t Note there is no reason monitors have to be the same size or in a grid.\n\t\t */\n\n\n\t\tsetViewOffset(fullWidth, fullHeight, x, y, width, height) {\n\t\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\t\tif (this.view === null) {\n\t\t\t\tthis.view = {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tfullWidth: 1,\n\t\t\t\t\tfullHeight: 1,\n\t\t\t\t\toffsetX: 0,\n\t\t\t\t\toffsetY: 0,\n\t\t\t\t\twidth: 1,\n\t\t\t\t\theight: 1\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis.view.enabled = true;\n\t\t\tthis.view.fullWidth = fullWidth;\n\t\t\tthis.view.fullHeight = fullHeight;\n\t\t\tthis.view.offsetX = x;\n\t\t\tthis.view.offsetY = y;\n\t\t\tthis.view.width = width;\n\t\t\tthis.view.height = height;\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tclearViewOffset() {\n\t\t\tif (this.view !== null) {\n\t\t\t\tthis.view.enabled = false;\n\t\t\t}\n\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tupdateProjectionMatrix() {\n\t\t\tconst near = this.near;\n\t\t\tlet top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;\n\t\t\tlet height = 2 * top;\n\t\t\tlet width = this.aspect * height;\n\t\t\tlet left = -0.5 * width;\n\t\t\tconst view = this.view;\n\n\t\t\tif (this.view !== null && this.view.enabled) {\n\t\t\t\tconst fullWidth = view.fullWidth,\n\t\t\t\t\t\t\tfullHeight = view.fullHeight;\n\t\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\t\twidth *= view.width / fullWidth;\n\t\t\t\theight *= view.height / fullHeight;\n\t\t\t}\n\n\t\t\tconst skew = this.filmOffset;\n\t\t\tif (skew !== 0) left += near * skew / this.getFilmWidth();\n\t\t\tthis.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);\n\t\t\tthis.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.object.fov = this.fov;\n\t\t\tdata.object.zoom = this.zoom;\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\t\t\tdata.object.focus = this.focus;\n\t\t\tdata.object.aspect = this.aspect;\n\t\t\tif (this.view !== null) data.object.view = Object.assign({}, this.view);\n\t\t\tdata.object.filmGauge = this.filmGauge;\n\t\t\tdata.object.filmOffset = this.filmOffset;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tPerspectiveCamera.prototype.isPerspectiveCamera = true;\n\n\tconst fov = 90,\n\t\t\t\taspect = 1;\n\n\tclass CubeCamera extends Object3D {\n\t\tconstructor(near, far, renderTarget) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CubeCamera';\n\n\t\t\tif (renderTarget.isWebGLCubeRenderTarget !== true) {\n\t\t\t\tconsole.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.renderTarget = renderTarget;\n\t\t\tconst cameraPX = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraPX.layers = this.layers;\n\t\t\tcameraPX.up.set(0, -1, 0);\n\t\t\tcameraPX.lookAt(new Vector3(1, 0, 0));\n\t\t\tthis.add(cameraPX);\n\t\t\tconst cameraNX = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraNX.layers = this.layers;\n\t\t\tcameraNX.up.set(0, -1, 0);\n\t\t\tcameraNX.lookAt(new Vector3(-1, 0, 0));\n\t\t\tthis.add(cameraNX);\n\t\t\tconst cameraPY = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraPY.layers = this.layers;\n\t\t\tcameraPY.up.set(0, 0, 1);\n\t\t\tcameraPY.lookAt(new Vector3(0, 1, 0));\n\t\t\tthis.add(cameraPY);\n\t\t\tconst cameraNY = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraNY.layers = this.layers;\n\t\t\tcameraNY.up.set(0, 0, -1);\n\t\t\tcameraNY.lookAt(new Vector3(0, -1, 0));\n\t\t\tthis.add(cameraNY);\n\t\t\tconst cameraPZ = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraPZ.layers = this.layers;\n\t\t\tcameraPZ.up.set(0, -1, 0);\n\t\t\tcameraPZ.lookAt(new Vector3(0, 0, 1));\n\t\t\tthis.add(cameraPZ);\n\t\t\tconst cameraNZ = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tcameraNZ.layers = this.layers;\n\t\t\tcameraNZ.up.set(0, -1, 0);\n\t\t\tcameraNZ.lookAt(new Vector3(0, 0, -1));\n\t\t\tthis.add(cameraNZ);\n\t\t}\n\n\t\tupdate(renderer, scene) {\n\t\t\tif (this.parent === null) this.updateMatrixWorld();\n\t\t\tconst renderTarget = this.renderTarget;\n\t\t\tconst [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\t\trenderer.xr.enabled = false;\n\t\t\tconst generateMipmaps = renderTarget.texture.generateMipmaps;\n\t\t\trenderTarget.texture.generateMipmaps = false;\n\t\t\trenderer.setRenderTarget(renderTarget, 0);\n\t\t\trenderer.render(scene, cameraPX);\n\t\t\trenderer.setRenderTarget(renderTarget, 1);\n\t\t\trenderer.render(scene, cameraNX);\n\t\t\trenderer.setRenderTarget(renderTarget, 2);\n\t\t\trenderer.render(scene, cameraPY);\n\t\t\trenderer.setRenderTarget(renderTarget, 3);\n\t\t\trenderer.render(scene, cameraNY);\n\t\t\trenderer.setRenderTarget(renderTarget, 4);\n\t\t\trenderer.render(scene, cameraPZ);\n\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\t\t\trenderer.setRenderTarget(renderTarget, 5);\n\t\t\trenderer.render(scene, cameraNZ);\n\t\t\trenderer.setRenderTarget(currentRenderTarget);\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t}\n\n\t}\n\n\tclass CubeTexture extends Texture {\n\t\tconstructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {\n\t\t\timages = images !== undefined ? images : [];\n\t\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\t\t\tformat = format !== undefined ? format : RGBFormat;\n\t\t\tsuper(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding); // Why CubeTexture._needsFlipEnvMap is necessary:\n\t\t\t//\n\t\t\t// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n\t\t\t// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n\t\t\t// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n\t\t\t// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n\t\t\t// and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)\n\t\t\t// when using WebGLCubeRenderTarget.texture as a cube texture.\n\n\t\t\tthis._needsFlipEnvMap = true;\n\t\t\tthis.flipY = false;\n\t\t}\n\n\t\tget images() {\n\t\t\treturn this.image;\n\t\t}\n\n\t\tset images(value) {\n\t\t\tthis.image = value;\n\t\t}\n\n\t}\n\n\tCubeTexture.prototype.isCubeTexture = true;\n\n\tclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n\t\tconstructor(size, options, dummy) {\n\t\t\tif (Number.isInteger(options)) {\n\t\t\t\tconsole.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');\n\t\t\t\toptions = dummy;\n\t\t\t}\n\n\t\t\tsuper(size, size, options);\n\t\t\toptions = options || {};\n\t\t\tthis.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);\n\t\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\t\t\tthis.texture._needsFlipEnvMap = false;\n\t\t}\n\n\t\tfromEquirectangularTexture(renderer, texture) {\n\t\t\tthis.texture.type = texture.type;\n\t\t\tthis.texture.format = RGBAFormat; // see #18859\n\n\t\t\tthis.texture.encoding = texture.encoding;\n\t\t\tthis.texture.generateMipmaps = texture.generateMipmaps;\n\t\t\tthis.texture.minFilter = texture.minFilter;\n\t\t\tthis.texture.magFilter = texture.magFilter;\n\t\t\tconst shader = {\n\t\t\t\tuniforms: {\n\t\t\t\t\ttEquirect: {\n\t\t\t\t\t\tvalue: null\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tvertexShader:\n\t\t\t\t/* glsl */\n\t\t\t\t`\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n\t\t\t\tfragmentShader:\n\t\t\t\t/* glsl */\n\t\t\t\t`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n\t\t\t};\n\t\t\tconst geometry = new BoxGeometry(5, 5, 5);\n\t\t\tconst material = new ShaderMaterial({\n\t\t\t\tname: 'CubemapFromEquirect',\n\t\t\t\tuniforms: cloneUniforms(shader.uniforms),\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\t\tside: BackSide,\n\t\t\t\tblending: NoBlending\n\t\t\t});\n\t\t\tmaterial.uniforms.tEquirect.value = texture;\n\t\t\tconst mesh = new Mesh(geometry, material);\n\t\t\tconst currentMinFilter = texture.minFilter; // Avoid blurred poles\n\n\t\t\tif (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;\n\t\t\tconst camera = new CubeCamera(1, 10, this);\n\t\t\tcamera.update(renderer, mesh);\n\t\t\ttexture.minFilter = currentMinFilter;\n\t\t\tmesh.geometry.dispose();\n\t\t\tmesh.material.dispose();\n\t\t\treturn this;\n\t\t}\n\n\t\tclear(renderer, color, depth, stencil) {\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\trenderer.setRenderTarget(this, i);\n\t\t\t\trenderer.clear(color, depth, stencil);\n\t\t\t}\n\n\t\t\trenderer.setRenderTarget(currentRenderTarget);\n\t\t}\n\n\t}\n\n\tWebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;\n\n\tconst _sphere$2 = /*@__PURE__*/new Sphere();\n\n\tconst _vector$7 = /*@__PURE__*/new Vector3();\n\n\tclass Frustum {\n\t\tconstructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {\n\t\t\tthis.planes = [p0, p1, p2, p3, p4, p5];\n\t\t}\n\n\t\tset(p0, p1, p2, p3, p4, p5) {\n\t\t\tconst planes = this.planes;\n\t\t\tplanes[0].copy(p0);\n\t\t\tplanes[1].copy(p1);\n\t\t\tplanes[2].copy(p2);\n\t\t\tplanes[3].copy(p3);\n\t\t\tplanes[4].copy(p4);\n\t\t\tplanes[5].copy(p5);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(frustum) {\n\t\t\tconst planes = this.planes;\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tplanes[i].copy(frustum.planes[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromProjectionMatrix(m) {\n\t\t\tconst planes = this.planes;\n\t\t\tconst me = m.elements;\n\t\t\tconst me0 = me[0],\n\t\t\t\t\t\tme1 = me[1],\n\t\t\t\t\t\tme2 = me[2],\n\t\t\t\t\t\tme3 = me[3];\n\t\t\tconst me4 = me[4],\n\t\t\t\t\t\tme5 = me[5],\n\t\t\t\t\t\tme6 = me[6],\n\t\t\t\t\t\tme7 = me[7];\n\t\t\tconst me8 = me[8],\n\t\t\t\t\t\tme9 = me[9],\n\t\t\t\t\t\tme10 = me[10],\n\t\t\t\t\t\tme11 = me[11];\n\t\t\tconst me12 = me[12],\n\t\t\t\t\t\tme13 = me[13],\n\t\t\t\t\t\tme14 = me[14],\n\t\t\t\t\t\tme15 = me[15];\n\t\t\tplanes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\n\t\t\tplanes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\n\t\t\tplanes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\n\t\t\tplanes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\n\t\t\tplanes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\n\t\t\tplanes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\n\t\t\treturn this;\n\t\t}\n\n\t\tintersectsObject(object) {\n\t\t\tconst geometry = object.geometry;\n\t\t\tif (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n\t\t\t_sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);\n\n\t\t\treturn this.intersectsSphere(_sphere$2);\n\t\t}\n\n\t\tintersectsSprite(sprite) {\n\t\t\t_sphere$2.center.set(0, 0, 0);\n\n\t\t\t_sphere$2.radius = 0.7071067811865476;\n\n\t\t\t_sphere$2.applyMatrix4(sprite.matrixWorld);\n\n\t\t\treturn this.intersectsSphere(_sphere$2);\n\t\t}\n\n\t\tintersectsSphere(sphere) {\n\t\t\tconst planes = this.planes;\n\t\t\tconst center = sphere.center;\n\t\t\tconst negRadius = -sphere.radius;\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tconst distance = planes[i].distanceToPoint(center);\n\n\t\t\t\tif (distance < negRadius) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\tconst planes = this.planes;\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tconst plane = planes[i]; // corner at max distance\n\n\t\t\t\t_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\t_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\t_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\tif (plane.distanceToPoint(_vector$7) < 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tcontainsPoint(point) {\n\t\t\tconst planes = this.planes;\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tif (planes[i].distanceToPoint(point) < 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tfunction WebGLAnimation() {\n\t\tlet context = null;\n\t\tlet isAnimating = false;\n\t\tlet animationLoop = null;\n\t\tlet requestId = null;\n\n\t\tfunction onAnimationFrame(time, frame) {\n\t\t\tanimationLoop(time, frame);\n\t\t\trequestId = context.requestAnimationFrame(onAnimationFrame);\n\t\t}\n\n\t\treturn {\n\t\t\tstart: function () {\n\t\t\t\tif (isAnimating === true) return;\n\t\t\t\tif (animationLoop === null) return;\n\t\t\t\trequestId = context.requestAnimationFrame(onAnimationFrame);\n\t\t\t\tisAnimating = true;\n\t\t\t},\n\t\t\tstop: function () {\n\t\t\t\tcontext.cancelAnimationFrame(requestId);\n\t\t\t\tisAnimating = false;\n\t\t\t},\n\t\t\tsetAnimationLoop: function (callback) {\n\t\t\t\tanimationLoop = callback;\n\t\t\t},\n\t\t\tsetContext: function (value) {\n\t\t\t\tcontext = value;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction WebGLAttributes(gl, capabilities) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\t\tconst buffers = new WeakMap();\n\n\t\tfunction createBuffer(attribute, bufferType) {\n\t\t\tconst array = attribute.array;\n\t\t\tconst usage = attribute.usage;\n\t\t\tconst buffer = gl.createBuffer();\n\t\t\tgl.bindBuffer(bufferType, buffer);\n\t\t\tgl.bufferData(bufferType, array, usage);\n\t\t\tattribute.onUploadCallback();\n\t\t\tlet type = gl.FLOAT;\n\n\t\t\tif (array instanceof Float32Array) {\n\t\t\t\ttype = gl.FLOAT;\n\t\t\t} else if (array instanceof Float64Array) {\n\t\t\t\tconsole.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');\n\t\t\t} else if (array instanceof Uint16Array) {\n\t\t\t\tif (attribute.isFloat16BufferAttribute) {\n\t\t\t\t\tif (isWebGL2) {\n\t\t\t\t\t\ttype = gl.HALF_FLOAT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\t\t\t\t}\n\t\t\t} else if (array instanceof Int16Array) {\n\t\t\t\ttype = gl.SHORT;\n\t\t\t} else if (array instanceof Uint32Array) {\n\t\t\t\ttype = gl.UNSIGNED_INT;\n\t\t\t} else if (array instanceof Int32Array) {\n\t\t\t\ttype = gl.INT;\n\t\t\t} else if (array instanceof Int8Array) {\n\t\t\t\ttype = gl.BYTE;\n\t\t\t} else if (array instanceof Uint8Array) {\n\t\t\t\ttype = gl.UNSIGNED_BYTE;\n\t\t\t} else if (array instanceof Uint8ClampedArray) {\n\t\t\t\ttype = gl.UNSIGNED_BYTE;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tbuffer: buffer,\n\t\t\t\ttype: type,\n\t\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\t\tversion: attribute.version\n\t\t\t};\n\t\t}\n\n\t\tfunction updateBuffer(buffer, attribute, bufferType) {\n\t\t\tconst array = attribute.array;\n\t\t\tconst updateRange = attribute.updateRange;\n\t\t\tgl.bindBuffer(bufferType, buffer);\n\n\t\t\tif (updateRange.count === -1) {\n\t\t\t\t// Not using update ranges\n\t\t\t\tgl.bufferSubData(bufferType, 0, array);\n\t\t\t} else {\n\t\t\t\tif (isWebGL2) {\n\t\t\t\t\tgl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);\n\t\t\t\t} else {\n\t\t\t\t\tgl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));\n\t\t\t\t}\n\n\t\t\t\tupdateRange.count = -1; // reset range\n\t\t\t}\n\t\t} //\n\n\n\t\tfunction get(attribute) {\n\t\t\tif (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n\t\t\treturn buffers.get(attribute);\n\t\t}\n\n\t\tfunction remove(attribute) {\n\t\t\tif (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n\t\t\tconst data = buffers.get(attribute);\n\n\t\t\tif (data) {\n\t\t\t\tgl.deleteBuffer(data.buffer);\n\t\t\t\tbuffers.delete(attribute);\n\t\t\t}\n\t\t}\n\n\t\tfunction update(attribute, bufferType) {\n\t\t\tif (attribute.isGLBufferAttribute) {\n\t\t\t\tconst cached = buffers.get(attribute);\n\n\t\t\t\tif (!cached || cached.version < attribute.version) {\n\t\t\t\t\tbuffers.set(attribute, {\n\t\t\t\t\t\tbuffer: attribute.buffer,\n\t\t\t\t\t\ttype: attribute.type,\n\t\t\t\t\t\tbytesPerElement: attribute.elementSize,\n\t\t\t\t\t\tversion: attribute.version\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n\t\t\tconst data = buffers.get(attribute);\n\n\t\t\tif (data === undefined) {\n\t\t\t\tbuffers.set(attribute, createBuffer(attribute, bufferType));\n\t\t\t} else if (data.version < attribute.version) {\n\t\t\t\tupdateBuffer(data.buffer, attribute, bufferType);\n\t\t\t\tdata.version = attribute.version;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tremove: remove,\n\t\t\tupdate: update\n\t\t};\n\t}\n\n\tclass PlaneGeometry extends BufferGeometry {\n\t\tconstructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {\n\t\t\tsuper();\n\t\t\tthis.type = 'PlaneGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments\n\t\t\t};\n\t\t\tconst width_half = width / 2;\n\t\t\tconst height_half = height / 2;\n\t\t\tconst gridX = Math.floor(widthSegments);\n\t\t\tconst gridY = Math.floor(heightSegments);\n\t\t\tconst gridX1 = gridX + 1;\n\t\t\tconst gridY1 = gridY + 1;\n\t\t\tconst segment_width = width / gridX;\n\t\t\tconst segment_height = height / gridY; //\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = [];\n\n\t\t\tfor (let iy = 0; iy < gridY1; iy++) {\n\t\t\t\tconst y = iy * segment_height - height_half;\n\n\t\t\t\tfor (let ix = 0; ix < gridX1; ix++) {\n\t\t\t\t\tconst x = ix * segment_width - width_half;\n\t\t\t\t\tvertices.push(x, -y, 0);\n\t\t\t\t\tnormals.push(0, 0, 1);\n\t\t\t\t\tuvs.push(ix / gridX);\n\t\t\t\t\tuvs.push(1 - iy / gridY);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let iy = 0; iy < gridY; iy++) {\n\t\t\t\tfor (let ix = 0; ix < gridX; ix++) {\n\t\t\t\t\tconst a = ix + gridX1 * iy;\n\t\t\t\t\tconst b = ix + gridX1 * (iy + 1);\n\t\t\t\t\tconst c = ix + 1 + gridX1 * (iy + 1);\n\t\t\t\t\tconst d = ix + 1 + gridX1 * iy;\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\";\n\n\tvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\n\tvar alphatest_fragment = \"#ifdef ALPHATEST\\n\\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\";\n\n\tvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\\t#endif\\n#endif\";\n\n\tvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\n\tvar begin_vertex = \"vec3 transformed = vec3( position );\";\n\n\tvar beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif\";\n\n\tvar bsdfs = \"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\tif( cutoffDistance > 0.0 ) {\\n\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t}\\n\\treturn distanceFalloff;\\n#else\\n\\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t}\\n\\treturn 1.0;\\n#endif\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\\n\\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\\n\\treturn Fr * fresnel + F0;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\treturn specularColor * brdf.x + brdf.y;\\n}\\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\\n\\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\\tvec3 FssEss = F * brdf.x + brdf.y;\\n\\tfloat Ess = brdf.x + brdf.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n#if defined( USE_SHEEN )\\nfloat D_Charlie(float roughness, float NoH) {\\n\\tfloat invAlpha = 1.0 / roughness;\\n\\tfloat cos2h = NoH * NoH;\\n\\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\\n}\\nfloat V_Neubelt(float NoV, float NoL) {\\n\\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\\n}\\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\\n\\tvec3 N = geometry.normal;\\n\\tvec3 V = geometry.viewDir;\\n\\tvec3 H = normalize( V + L );\\n\\tfloat dotNH = saturate( dot( N, H ) );\\n\\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\\n}\\n#endif\";\n\n\tvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\";\n\n\tvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\";\n\n\tvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\";\n\n\tvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n#endif\";\n\n\tvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvClipPosition = - mvPosition.xyz;\\n#endif\";\n\n\tvar color_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tdiffuseColor *= vColor;\\n#elif defined( USE_COLOR )\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\n\tvar color_pars_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\n\tvar color_pars_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\n\tvar color_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvColor = vec4( 1.0 );\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvColor = vec3( 1.0 );\\n#endif\\n#ifdef USE_COLOR\\n\\tvColor *= color;\\n#endif\\n#ifdef USE_INSTANCING_COLOR\\n\\tvColor.xyz *= instanceColor.xyz;\\n#endif\";\n\n\tvar common = \"#define PI 3.141592653589793\\n#define PI2 6.283185307179586\\n#define PI_HALF 1.5707963267948966\\n#define RECIPROCAL_PI 0.3183098861837907\\n#define RECIPROCAL_PI2 0.15915494309189535\\n#define EPSILON 1e-6\\n#ifndef saturate\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\n#ifdef HIGH_PRECISION\\n\\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\\n#else\\n\\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\\n\\tfloat precisionSafeLength( vec3 v ) {\\n\\t\\tfloat maxComponent = max3( abs( v ) );\\n\\t\\treturn length( v / maxComponent ) * maxComponent;\\n\\t}\\n#endif\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n#ifdef CLEARCOAT\\n\\tvec3 clearcoatNormal;\\n#endif\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\\treturn dot( weights, color.rgb );\\n}\\nbool isPerspectiveMatrix( mat4 m ) {\\n\\treturn m[ 2 ][ 3 ] == - 1.0;\\n}\\nvec2 equirectUv( in vec3 dir ) {\\n\\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\treturn vec2( u, v );\\n}\";\n\n\tvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t#define cubeUV_maxMipLevel 8.0\\n\\t#define cubeUV_minMipLevel 4.0\\n\\t#define cubeUV_maxTileSize 256.0\\n\\t#define cubeUV_minTileSize 16.0\\n\\tfloat getFace( vec3 direction ) {\\n\\t\\tvec3 absDirection = abs( direction );\\n\\t\\tfloat face = - 1.0;\\n\\t\\tif ( absDirection.x > absDirection.z ) {\\n\\t\\t\\tif ( absDirection.x > absDirection.y )\\n\\t\\t\\t\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t} else {\\n\\t\\t\\tif ( absDirection.z > absDirection.y )\\n\\t\\t\\t\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t}\\n\\t\\treturn face;\\n\\t}\\n\\tvec2 getUV( vec3 direction, float face ) {\\n\\t\\tvec2 uv;\\n\\t\\tif ( face == 0.0 ) {\\n\\t\\t\\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 1.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\\n\\t\\t} else if ( face == 2.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\\n\\t\\t} else if ( face == 3.0 ) {\\n\\t\\t\\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 4.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\\n\\t\\t} else {\\n\\t\\t\\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\\n\\t\\t}\\n\\t\\treturn 0.5 * ( uv + 1.0 );\\n\\t}\\n\\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\\n\\t\\tfloat face = getFace( direction );\\n\\t\\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\\n\\t\\tmipInt = max( mipInt, cubeUV_minMipLevel );\\n\\t\\tfloat faceSize = exp2( mipInt );\\n\\t\\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\\n\\t\\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\\n\\t\\tvec2 f = fract( uv );\\n\\t\\tuv += 0.5 - f;\\n\\t\\tif ( face > 2.0 ) {\\n\\t\\t\\tuv.y += faceSize;\\n\\t\\t\\tface -= 3.0;\\n\\t\\t}\\n\\t\\tuv.x += face * faceSize;\\n\\t\\tif ( mipInt < cubeUV_maxMipLevel ) {\\n\\t\\t\\tuv.y += 2.0 * cubeUV_maxTileSize;\\n\\t\\t}\\n\\t\\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\\n\\t\\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\\n\\t\\tuv *= texelSize;\\n\\t\\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.x += texelSize;\\n\\t\\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.y += texelSize;\\n\\t\\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tuv.x -= texelSize;\\n\\t\\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\\t\\tvec3 tm = mix( tl, tr, f.x );\\n\\t\\tvec3 bm = mix( bl, br, f.x );\\n\\t\\treturn mix( tm, bm, f.y );\\n\\t}\\n\\t#define r0 1.0\\n\\t#define v0 0.339\\n\\t#define m0 - 2.0\\n\\t#define r1 0.8\\n\\t#define v1 0.276\\n\\t#define m1 - 1.0\\n\\t#define r4 0.4\\n\\t#define v4 0.046\\n\\t#define m4 2.0\\n\\t#define r5 0.305\\n\\t#define v5 0.016\\n\\t#define m5 3.0\\n\\t#define r6 0.21\\n\\t#define v6 0.0038\\n\\t#define m6 4.0\\n\\tfloat roughnessToMip( float roughness ) {\\n\\t\\tfloat mip = 0.0;\\n\\t\\tif ( roughness >= r1 ) {\\n\\t\\t\\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\\n\\t\\t} else if ( roughness >= r4 ) {\\n\\t\\t\\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\\n\\t\\t} else if ( roughness >= r5 ) {\\n\\t\\t\\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\\n\\t\\t} else if ( roughness >= r6 ) {\\n\\t\\t\\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\\n\\t\\t} else {\\n\\t\\t\\tmip = - 2.0 * log2( 1.16 * roughness );\\t\\t}\\n\\t\\treturn mip;\\n\\t}\\n\\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\\n\\t\\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\\n\\t\\tfloat mipF = fract( mip );\\n\\t\\tfloat mipInt = floor( mip );\\n\\t\\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\\n\\t\\tif ( mipF == 0.0 ) {\\n\\t\\t\\treturn vec4( color0, 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\\n\\t\\t\\treturn vec4( mix( color0, color1, mipF ), 1.0 );\\n\\t\\t}\\n\\t}\\n#endif\";\n\n\tvar defaultnormal_vertex = \"vec3 transformedNormal = objectNormal;\\n#ifdef USE_INSTANCING\\n\\tmat3 m = mat3( instanceMatrix );\\n\\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\\n\\ttransformedNormal = m * transformedNormal;\\n#endif\\ntransformedNormal = normalMatrix * transformedNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#ifdef FLIP_SIDED\\n\\t\\ttransformedTangent = - transformedTangent;\\n\\t#endif\\n#endif\";\n\n\tvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\";\n\n\tvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\\n#endif\";\n\n\tvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\";\n\n\tvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\";\n\n\tvar encodings_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\";\n\n\tvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value ) {\\n\\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\n\\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract( Le );\\n\\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}\";\n\n\tvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvec3 cameraToFrag;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\t#ifndef ENVMAP_TYPE_CUBE_UV\\n\\t\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#endif\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\";\n\n\tvar envmap_common_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float envMapIntensity;\\n\\tuniform float flipEnvMap;\\n\\tuniform int maxMipLevel;\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\t\\n#endif\";\n\n\tvar envmap_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float reflectivity;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\";\n\n\tvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\t\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\";\n\n\tvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\n\tvar fog_vertex = \"#ifdef USE_FOG\\n\\tfogDepth = - mvPosition.z;\\n#endif\";\n\n\tvar fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float fogDepth;\\n#endif\";\n\n\tvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\";\n\n\tvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float fogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\n\tvar gradientmap_pars_fragment = \"#ifdef USE_GRADIENTMAP\\n\\tuniform sampler2D gradientMap;\\n#endif\\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\tfloat dotNL = dot( normal, lightDirection );\\n\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t#ifdef USE_GRADIENTMAP\\n\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t#else\\n\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t#endif\\n}\";\n\n\tvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n#endif\";\n\n\tvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\n\tvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\nvIndirectFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\\tvLightBack = vec3( 0.0 );\\n\\tvIndirectBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\\n#ifdef DOUBLE_SIDED\\n\\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\\n\\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\\t\\tdotNL = dot( geometry.normal, directLight.direction );\\n\\t\\tdirectLightColor_Diffuse = PI * directLight.color;\\n\\t\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\\t\\t#endif\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\";\n\n\tvar lights_pars_begin = \"uniform bool receiveShadow;\\nuniform vec3 ambientLightColor;\\nuniform vec3 lightProbe[ 9 ];\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\\n\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tdirectLight.color = directionalLight.color;\\n\\t\\tdirectLight.direction = directionalLight.direction;\\n\\t\\tdirectLight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tdirectLight.color = pointLight.color;\\n\\t\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tdirectLight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\\t\\tif ( angleCos > spotLight.coneCos ) {\\n\\t\\t\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\t\\tdirectLight.color = spotLight.color;\\n\\t\\t\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tdirectLight.visible = true;\\n\\t\\t} else {\\n\\t\\t\\tdirectLight.color = vec3( 0.0 );\\n\\t\\t\\tdirectLight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\\t\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tirradiance *= PI;\\n\\t\\t#endif\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\";\n\n\tvar envmap_physical_pars_fragment = \"#if defined( USE_ENVMAP )\\n\\t#ifdef ENVMAP_MODE_REFRACTION\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\\t\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\\n\\t\\t#else\\n\\t\\t\\tvec4 envMapColor = vec4( 0.0 );\\n\\t\\t#endif\\n\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t}\\n\\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\\n\\t\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\\t\\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\\n\\t\\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\\n\\t\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\\t}\\n\\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( -viewDir, normal );\\n\\t\\t\\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\\n\\t\\t#endif\\n\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\t\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\\t\\t\\t#ifdef TEXTURE_LOD_EXT\\n\\t\\t\\t\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#else\\n\\t\\t\\t\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\\t\\t\\t#endif\\n\\t\\t\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\\t\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\\n\\t\\t#endif\\n\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t}\\n#endif\";\n\n\tvar lights_toon_fragment = \"ToonMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\";\n\n\tvar lights_toon_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct ToonMaterial {\\n\\tvec3 diffuseColor;\\n};\\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Toon\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Toon\\n#define Material_LightProbeLOD( material )\\t(0)\";\n\n\tvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\";\n\n\tvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3 diffuseColor;\\n\\tvec3 specularColor;\\n\\tfloat specularShininess;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\";\n\n\tvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\\n#ifdef REFLECTIVITY\\n\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), rawDiffuseColor, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), rawDiffuseColor, metalnessFactor );\\n#endif\\n#ifdef CLEARCOAT\\n\\tmaterial.clearcoat = clearcoat;\\n\\tmaterial.clearcoatRoughness = clearcoatRoughness;\\n\\t#ifdef USE_CLEARCOATMAP\\n\\t\\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\t\\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\\n\\t#endif\\n\\tmaterial.clearcoat = saturate( material.clearcoat );\\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\\n\\tmaterial.clearcoatRoughness += geometryRoughness;\\n\\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\\n#endif\\n#ifdef USE_SHEEN\\n\\tmaterial.sheenColor = sheen;\\n#endif\";\n\n\tvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat specularRoughness;\\n\\tvec3 specularColor;\\n#ifdef CLEARCOAT\\n\\tfloat clearcoat;\\n\\tfloat clearcoatRoughness;\\n#endif\\n#ifdef USE_SHEEN\\n\\tvec3 sheenColor;\\n#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(\t\t0, 1,\t\t0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifdef CLEARCOAT\\n\\t\\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\\n\\t\\tvec3 ccIrradiance = ccDotNL * directLight.color;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tccIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\\n\\t\\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\\n\\t#else\\n\\t\\tfloat clearcoatDHR = 0.0;\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\\n\\t\\t\\tmaterial.specularRoughness,\\n\\t\\t\\tdirectLight.direction,\\n\\t\\t\\tgeometry,\\n\\t\\t\\tmaterial.sheenColor\\n\\t\\t);\\n\\t#else\\n\\t\\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\\n\\t#endif\\n\\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifdef CLEARCOAT\\n\\t\\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\\n\\t\\tfloat ccDotNL = ccDotNV;\\n\\t\\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\\n\\t#else\\n\\t\\tfloat clearcoatDHR = 0.0;\\n\\t#endif\\n\\tfloat clearcoatInv = 1.0 - clearcoatDHR;\\n\\tvec3 singleScattering = vec3( 0.0 );\\n\\tvec3 multiScattering = vec3( 0.0 );\\n\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\\n\\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\\n\\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\\n\\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\\n\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\";\n\n\tvar lights_fragment_begin = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n#ifdef CLEARCOAT\\n\\tgeometry.clearcoatNormal = clearcoatNormal;\\n#endif\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow = pointLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow = spotLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 iblIrradiance = vec3( 0.0 );\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearcoatRadiance = vec3( 0.0 );\\n#endif\";\n\n\tvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\t\\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\t\\tlightMapIrradiance *= PI;\\n\\t\\t#endif\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\\n\\t#ifdef CLEARCOAT\\n\\t\\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\\n\\t#endif\\n#endif\";\n\n\tvar lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\\n#endif\";\n\n\tvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\n\n\tvar logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n\\tvarying float vIsPerspective;\\n#endif\";\n\n\tvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t\\tvarying float vIsPerspective;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif\";\n\n\tvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t\\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\\n\\t#else\\n\\t\\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\\n\\t\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\t\\tgl_Position.z *= gl_Position.w;\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\n\tvar map_fragment = \"#ifdef USE_MAP\\n\\tvec4 texelColor = texture2D( map, vUv );\\n\\ttexelColor = mapTexelToLinear( texelColor );\\n\\tdiffuseColor *= texelColor;\\n#endif\";\n\n\tvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\";\n\n\tvar map_particle_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n#endif\\n#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, uv );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\\n#endif\";\n\n\tvar map_particle_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\tuniform mat3 uvTransform;\\n#endif\\n#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\n\tvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\";\n\n\tvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\n\tvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal *= morphTargetBaseInfluence;\\n\\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\\n#endif\";\n\n\tvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\tuniform float morphTargetBaseInfluence;\\n\\t#ifndef USE_MORPHNORMALS\\n\\t\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\t\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif\";\n\n\tvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed *= morphTargetBaseInfluence;\\n\\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\\n\\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\\n\\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\\n\\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\t\\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\\n\\t\\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\\n\\t\\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\\n\\t\\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\";\n\n\tvar normal_fragment_begin = \"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\\n#ifdef FLAT_SHADED\\n\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\t#ifdef USE_TANGENT\\n\\t\\tvec3 tangent = normalize( vTangent );\\n\\t\\tvec3 bitangent = normalize( vBitangent );\\n\\t\\t#ifdef DOUBLE_SIDED\\n\\t\\t\\ttangent = tangent * faceDirection;\\n\\t\\t\\tbitangent = bitangent * faceDirection;\\n\\t\\t#endif\\n\\t\\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\\n\\t\\t\\tmat3 vTBN = mat3( tangent, bitangent, normal );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\nvec3 geometryNormal = normal;\";\n\n\tvar normal_fragment_maps = \"#ifdef OBJECTSPACE_NORMALMAP\\n\\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\t#ifdef FLIP_SIDED\\n\\t\\tnormal = - normal;\\n\\t#endif\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\tnormal = normalize( normalMatrix * normal );\\n#elif defined( TANGENTSPACE_NORMALMAP )\\n\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tmapN.xy *= normalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tnormal = normalize( vTBN * mapN );\\n\\t#else\\n\\t\\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\\n\\t#endif\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\\n#endif\";\n\n\tvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\n\\tuniform mat3 normalMatrix;\\n#endif\\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\\n\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\\n\\t\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\\t\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\\t\\tvec2 st0 = dFdx( vUv.st );\\n\\t\\tvec2 st1 = dFdy( vUv.st );\\n\\t\\tvec3 N = surf_norm;\\n\\t\\tvec3 q1perp = cross( q1, N );\\n\\t\\tvec3 q0perp = cross( N, q0 );\\n\\t\\tvec3 T = q1perp * st0.x + q0perp * st1.x;\\n\\t\\tvec3 B = q1perp * st0.y + q0perp * st1.y;\\n\\t\\tfloat det = max( dot( T, T ), dot( B, B ) );\\n\\t\\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\\n\\t\\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\\n\\t}\\n#endif\";\n\n\tvar clearcoat_normal_fragment_begin = \"#ifdef CLEARCOAT\\n\\tvec3 clearcoatNormal = geometryNormal;\\n#endif\";\n\n\tvar clearcoat_normal_fragment_maps = \"#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\\n\\tclearcoatMapN.xy *= clearcoatNormalScale;\\n\\t#ifdef USE_TANGENT\\n\\t\\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\\n\\t#else\\n\\t\\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\\n\\t#endif\\n#endif\";\n\n\tvar clearcoat_pars_fragment = \"#ifdef USE_CLEARCOATMAP\\n\\tuniform sampler2D clearcoatMap;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform sampler2D clearcoatRoughnessMap;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform sampler2D clearcoatNormalMap;\\n\\tuniform vec2 clearcoatNormalScale;\\n#endif\";\n\n\tvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nvec4 pack2HalfToRGBA( vec2 v ) {\\n\\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\\n\\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\\n}\\nvec2 unpackRGBATo2Half( vec4 v ) {\\n\\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\";\n\n\tvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\";\n\n\tvar project_vertex = \"vec4 mvPosition = vec4( transformed, 1.0 );\\n#ifdef USE_INSTANCING\\n\\tmvPosition = instanceMatrix * mvPosition;\\n#endif\\nmvPosition = modelViewMatrix * mvPosition;\\ngl_Position = projectionMatrix * mvPosition;\";\n\n\tvar dithering_fragment = \"#ifdef DITHERING\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\";\n\n\tvar dithering_pars_fragment = \"#ifdef DITHERING\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\";\n\n\tvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\";\n\n\tvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\n\tvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\\n\\t\\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\\n\\t}\\n\\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\\n\\t\\tfloat occlusion = 1.0;\\n\\t\\tvec2 distribution = texture2DDistribution( shadow, uv );\\n\\t\\tfloat hard_shadow = step( compare , distribution.x );\\n\\t\\tif (hard_shadow != 1.0 ) {\\n\\t\\t\\tfloat distance = compare - distribution.x ;\\n\\t\\t\\tfloat variance = max( 0.00000, distribution.y * distribution.y );\\n\\t\\t\\tfloat softness_probability = variance / (variance + distance * distance );\\t\\t\\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\\t\\t\\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\\n\\t\\t}\\n\\t\\treturn occlusion;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx2 = dx0 / 2.0;\\n\\t\\t\\tfloat dy2 = dy0 / 2.0;\\n\\t\\t\\tfloat dx3 = dx1 / 2.0;\\n\\t\\t\\tfloat dy3 = dy1 / 2.0;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 17.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx = texelSize.x;\\n\\t\\t\\tfloat dy = texelSize.y;\\n\\t\\t\\tvec2 uv = shadowCoord.xy;\\n\\t\\t\\tvec2 f = fract( uv * shadowMapSize + 0.5 );\\n\\t\\t\\tuv -= f * texelSize;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t\tf.x ),\\n\\t\\t\\t\\t\\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \\n\\t\\t\\t\\t\\t\\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t\tf.x ),\\n\\t\\t\\t\\t\\t f.y )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\";\n\n\tvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n#endif\";\n\n\tvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\tvec4 shadowWorldPosition;\\n\\t#endif\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\";\n\n\tvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tspotLight = spotLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tpointLight = pointLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\";\n\n\tvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\n\tvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\t#ifdef BONE_TEXTURE\\n\\t\\tuniform highp sampler2D boneTexture;\\n\\t\\tuniform int boneTextureSize;\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tfloat j = i * 4.0;\\n\\t\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\t\\ty = dy * ( y + 0.5 );\\n\\t\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#else\\n\\t\\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\\t\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\t\\tmat4 bone = boneMatrices[ int(i) ];\\n\\t\\t\\treturn bone;\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\n\tvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\";\n\n\tvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif\";\n\n\tvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\n\tvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\n\tvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\";\n\n\tvar tonemapping_pars_fragment = \"#ifndef saturate\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 RRTAndODTFit( vec3 v ) {\\n\\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\\n\\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\\n\\treturn a / b;\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tconst mat3 ACESInputMat = mat3(\\n\\t\\tvec3( 0.59719, 0.07600, 0.02840 ),\\t\\tvec3( 0.35458, 0.90834, 0.13383 ),\\n\\t\\tvec3( 0.04823, 0.01566, 0.83777 )\\n\\t);\\n\\tconst mat3 ACESOutputMat = mat3(\\n\\t\\tvec3(\t1.60475, -0.10208, -0.00327 ),\\t\\tvec3( -0.53108,\t1.10813, -0.07276 ),\\n\\t\\tvec3( -0.07367, -0.00605,\t1.07602 )\\n\\t);\\n\\tcolor *= toneMappingExposure / 0.6;\\n\\tcolor = ACESInputMat * color;\\n\\tcolor = RRTAndODTFit( color );\\n\\tcolor = ACESOutputMat * color;\\n\\treturn saturate( color );\\n}\\nvec3 CustomToneMapping( vec3 color ) { return color; }\";\n\n\tvar transmission_fragment = \"#ifdef USE_TRANSMISSION\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSNMAP\\n\\t\\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\\n\\t#endif\\n\\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\\n\\tvec3 v = normalize( cameraPosition - pos );\\n\\tvec3 viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n\\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\\n\\tvec3 f0 = vec3( pow( ior - 1.0, 2.0 ) / pow( ior + 1.0, 2.0 ) );\\n\\tvec3 f90 = vec3( 1.0 );\\n\\tvec3 f_transmission = totalTransmission * getIBLVolumeRefraction(\\n\\t\\tnormal, v, viewDir, roughnessFactor, diffuseColor.rgb, f0, f90,\\n\\t\\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\\n\\t\\tattenuationColor, attenuationDistance);\\n\\tdiffuseColor.rgb = mix( diffuseColor.rgb, f_transmission, totalTransmission );\\n#endif\";\n\n\tvar transmission_pars_fragment = \"#ifdef USE_TRANSMISSION\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\tuniform sampler2D transmissionMap;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tuniform sampler2D thicknessMap;\\n\\t#endif\\n\\tuniform vec2 transmissionSamplerSize;\\n\\tuniform sampler2D transmissionSamplerMap;\\n\\tuniform mat4 modelMatrix;\\n\\tuniform mat4 projectionMatrix;\\n\\tvarying vec4 vWorldPosition;\\n\\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\\n\\t\\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\\n\\t\\tvec3 modelScale;\\n\\t\\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\\n\\t\\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\\n\\t\\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\\n\\t\\treturn normalize(refractionVector) * thickness * modelScale;\\n\\t}\\n\\tfloat applyIorToRoughness(float roughness, float ior) {\\n\\t\\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\\n\\t}\\n\\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\\n\\t\\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\\n\\t\\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\\n\\t}\\n\\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\\n\\t\\tif (attenuationDistance == 0.0) {\\n\\t\\t\\treturn radiance;\\n\\t\\t} else {\\n\\t\\t\\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\\n\\t\\t\\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\\t\\t\\treturn transmittance * radiance;\\n\\t\\t}\\n\\t}\\n\\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, vec3 viewDir, float perceptualRoughness, vec3 baseColor, vec3 f0, vec3 f90,\\n\\t\\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec3 attenuationColor, float attenuationDistance) {\\n\\t\\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\\n\\t\\tvec3 refractedRayExit = position + transmissionRay;\\n\\t\\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\\n\\t\\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\\t\\trefractionCoords += 1.0;\\n\\t\\trefractionCoords /= 2.0;\\n\\t\\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\\n\\t\\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\\n\\t\\tfloat NdotV = saturate(dot(n, viewDir));\\n\\t\\tvec2 brdf = integrateSpecularBRDF(NdotV, perceptualRoughness);\\n\\t\\tvec3 specularColor = f0 * brdf.x + f90 * brdf.y;\\n\\t\\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\\n\\t}\\n#endif\";\n\n\tvar uv_pars_fragment = \"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\\n\\tvarying vec2 vUv;\\n#endif\";\n\n\tvar uv_pars_vertex = \"#ifdef USE_UV\\n\\t#ifdef UVS_VERTEX_ONLY\\n\\t\\tvec2 vUv;\\n\\t#else\\n\\t\\tvarying vec2 vUv;\\n\\t#endif\\n\\tuniform mat3 uvTransform;\\n#endif\";\n\n\tvar uv_vertex = \"#ifdef USE_UV\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\";\n\n\tvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif\";\n\n\tvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n\\tuniform mat3 uv2Transform;\\n#endif\";\n\n\tvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\\n#endif\";\n\n\tvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\\n\\tvec4 worldPosition = vec4( transformed, 1.0 );\\n\\t#ifdef USE_INSTANCING\\n\\t\\tworldPosition = instanceMatrix * worldPosition;\\n\\t#endif\\n\\tworldPosition = modelMatrix * worldPosition;\\n#endif\";\n\n\tvar background_frag = \"uniform sampler2D t2D;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\n\tvar background_vert = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\";\n\n\tvar cube_frag = \"#include <envmap_common_pars_fragment>\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\n#include <cube_uv_reflection_fragment>\\nvoid main() {\\n\\tvec3 vReflect = vWorldDirection;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = envColor;\\n\\tgl_FragColor.a *= opacity;\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\n\tvar cube_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\n\n\tvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( fragCoordZ );\\n\\t#endif\\n}\";\n\n\tvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvHighPrecisionZW = gl_Position.zw;\\n}\";\n\n\tvar distanceRGBA_frag = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\";\n\n\tvar distanceRGBA_vert = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\";\n\n\tvar equirect_frag = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV = equirectUv( direction );\\n\\tvec4 texColor = texture2D( tEquirect, sampleUV );\\n\\tgl_FragColor = mapTexelToLinear( texColor );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n}\";\n\n\tvar equirect_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\";\n\n\tvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\n\tvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvLineDistance = scale * lineDistance;\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\n\\t\\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\\t\\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vIndirectFront;\\n\\t#endif\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n\\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar meshmatcap_frag = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t\\tmatcapColor = matcapTexelToLinear( matcapColor );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshmatcap_vert = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#ifndef FLAT_SHADED\\n\\t\\tvNormal = normalize( transformedNormal );\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n}\";\n\n\tvar meshtoon_frag = \"#define TOON\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_toon_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_toon_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshtoon_vert = \"#define TOON\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar meshphysical_frag = \"#define STANDARD\\n#ifdef PHYSICAL\\n\\t#define REFLECTIVITY\\n\\t#define CLEARCOAT\\n#endif\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifdef USE_TRANSMISSION\\n\\tuniform float transmission;\\n\\tuniform float thickness;\\n\\tuniform vec3 attenuationColor;\\n\\tuniform float attenuationDistance;\\n#endif\\n#ifdef REFLECTIVITY\\n\\tuniform float reflectivity;\\n#endif\\n#ifdef CLEARCOAT\\n\\tuniform float clearcoat;\\n\\tuniform float clearcoatRoughness;\\n#endif\\n#ifdef USE_SHEEN\\n\\tuniform vec3 sheen;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <bsdfs>\\n#include <transmission_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <clearcoat_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#ifdef USE_TRANSMISSION\\n\\t\\tfloat totalTransmission = transmission;\\n\\t\\tfloat thicknessFactor = thickness;\\n\\t#endif\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <clearcoat_normal_fragment_begin>\\n\\t#include <clearcoat_normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\tvec3 rawDiffuseColor = diffuseColor.rgb;\\n\\t#include <transmission_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\n\tvar meshphysical_vert = \"#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#ifdef USE_TRANSMISSION\\n\\tvarying vec4 vWorldPosition;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n#ifdef USE_TRANSMISSION\\n\\tvWorldPosition = worldPosition;\\n#endif\\n}\";\n\n\tvar normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\";\n\n\tvar normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\";\n\n\tvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\n\tvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <color_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar shadow_frag = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\n\tvar shadow_vert = \"#include <common>\\n#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tvar sprite_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\n\tvar sprite_vert = \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\n\tconst ShaderChunk = {\n\t\talphamap_fragment: alphamap_fragment,\n\t\talphamap_pars_fragment: alphamap_pars_fragment,\n\t\talphatest_fragment: alphatest_fragment,\n\t\taomap_fragment: aomap_fragment,\n\t\taomap_pars_fragment: aomap_pars_fragment,\n\t\tbegin_vertex: begin_vertex,\n\t\tbeginnormal_vertex: beginnormal_vertex,\n\t\tbsdfs: bsdfs,\n\t\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\t\tclipping_planes_fragment: clipping_planes_fragment,\n\t\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\t\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\t\tclipping_planes_vertex: clipping_planes_vertex,\n\t\tcolor_fragment: color_fragment,\n\t\tcolor_pars_fragment: color_pars_fragment,\n\t\tcolor_pars_vertex: color_pars_vertex,\n\t\tcolor_vertex: color_vertex,\n\t\tcommon: common,\n\t\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\t\tdefaultnormal_vertex: defaultnormal_vertex,\n\t\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\t\tdisplacementmap_vertex: displacementmap_vertex,\n\t\temissivemap_fragment: emissivemap_fragment,\n\t\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\t\tencodings_fragment: encodings_fragment,\n\t\tencodings_pars_fragment: encodings_pars_fragment,\n\t\tenvmap_fragment: envmap_fragment,\n\t\tenvmap_common_pars_fragment: envmap_common_pars_fragment,\n\t\tenvmap_pars_fragment: envmap_pars_fragment,\n\t\tenvmap_pars_vertex: envmap_pars_vertex,\n\t\tenvmap_physical_pars_fragment: envmap_physical_pars_fragment,\n\t\tenvmap_vertex: envmap_vertex,\n\t\tfog_vertex: fog_vertex,\n\t\tfog_pars_vertex: fog_pars_vertex,\n\t\tfog_fragment: fog_fragment,\n\t\tfog_pars_fragment: fog_pars_fragment,\n\t\tgradientmap_pars_fragment: gradientmap_pars_fragment,\n\t\tlightmap_fragment: lightmap_fragment,\n\t\tlightmap_pars_fragment: lightmap_pars_fragment,\n\t\tlights_lambert_vertex: lights_lambert_vertex,\n\t\tlights_pars_begin: lights_pars_begin,\n\t\tlights_toon_fragment: lights_toon_fragment,\n\t\tlights_toon_pars_fragment: lights_toon_pars_fragment,\n\t\tlights_phong_fragment: lights_phong_fragment,\n\t\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\t\tlights_physical_fragment: lights_physical_fragment,\n\t\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\t\tlights_fragment_begin: lights_fragment_begin,\n\t\tlights_fragment_maps: lights_fragment_maps,\n\t\tlights_fragment_end: lights_fragment_end,\n\t\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\t\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\t\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\t\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\t\tmap_fragment: map_fragment,\n\t\tmap_pars_fragment: map_pars_fragment,\n\t\tmap_particle_fragment: map_particle_fragment,\n\t\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\t\tmetalnessmap_fragment: metalnessmap_fragment,\n\t\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\t\tmorphnormal_vertex: morphnormal_vertex,\n\t\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\t\tmorphtarget_vertex: morphtarget_vertex,\n\t\tnormal_fragment_begin: normal_fragment_begin,\n\t\tnormal_fragment_maps: normal_fragment_maps,\n\t\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\t\tclearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,\n\t\tclearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,\n\t\tclearcoat_pars_fragment: clearcoat_pars_fragment,\n\t\tpacking: packing,\n\t\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\t\tproject_vertex: project_vertex,\n\t\tdithering_fragment: dithering_fragment,\n\t\tdithering_pars_fragment: dithering_pars_fragment,\n\t\troughnessmap_fragment: roughnessmap_fragment,\n\t\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\t\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\t\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\t\tshadowmap_vertex: shadowmap_vertex,\n\t\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\t\tskinbase_vertex: skinbase_vertex,\n\t\tskinning_pars_vertex: skinning_pars_vertex,\n\t\tskinning_vertex: skinning_vertex,\n\t\tskinnormal_vertex: skinnormal_vertex,\n\t\tspecularmap_fragment: specularmap_fragment,\n\t\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\t\ttonemapping_fragment: tonemapping_fragment,\n\t\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\t\ttransmission_fragment: transmission_fragment,\n\t\ttransmission_pars_fragment: transmission_pars_fragment,\n\t\tuv_pars_fragment: uv_pars_fragment,\n\t\tuv_pars_vertex: uv_pars_vertex,\n\t\tuv_vertex: uv_vertex,\n\t\tuv2_pars_fragment: uv2_pars_fragment,\n\t\tuv2_pars_vertex: uv2_pars_vertex,\n\t\tuv2_vertex: uv2_vertex,\n\t\tworldpos_vertex: worldpos_vertex,\n\t\tbackground_frag: background_frag,\n\t\tbackground_vert: background_vert,\n\t\tcube_frag: cube_frag,\n\t\tcube_vert: cube_vert,\n\t\tdepth_frag: depth_frag,\n\t\tdepth_vert: depth_vert,\n\t\tdistanceRGBA_frag: distanceRGBA_frag,\n\t\tdistanceRGBA_vert: distanceRGBA_vert,\n\t\tequirect_frag: equirect_frag,\n\t\tequirect_vert: equirect_vert,\n\t\tlinedashed_frag: linedashed_frag,\n\t\tlinedashed_vert: linedashed_vert,\n\t\tmeshbasic_frag: meshbasic_frag,\n\t\tmeshbasic_vert: meshbasic_vert,\n\t\tmeshlambert_frag: meshlambert_frag,\n\t\tmeshlambert_vert: meshlambert_vert,\n\t\tmeshmatcap_frag: meshmatcap_frag,\n\t\tmeshmatcap_vert: meshmatcap_vert,\n\t\tmeshtoon_frag: meshtoon_frag,\n\t\tmeshtoon_vert: meshtoon_vert,\n\t\tmeshphong_frag: meshphong_frag,\n\t\tmeshphong_vert: meshphong_vert,\n\t\tmeshphysical_frag: meshphysical_frag,\n\t\tmeshphysical_vert: meshphysical_vert,\n\t\tnormal_frag: normal_frag,\n\t\tnormal_vert: normal_vert,\n\t\tpoints_frag: points_frag,\n\t\tpoints_vert: points_vert,\n\t\tshadow_frag: shadow_frag,\n\t\tshadow_vert: shadow_vert,\n\t\tsprite_frag: sprite_frag,\n\t\tsprite_vert: sprite_vert\n\t};\n\n\t/**\n\t * Uniforms library for shared webgl shaders\n\t */\n\n\tconst UniformsLib = {\n\t\tcommon: {\n\t\t\tdiffuse: {\n\t\t\t\tvalue: new Color(0xffffff)\n\t\t\t},\n\t\t\topacity: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\tmap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tuvTransform: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t},\n\t\t\tuv2Transform: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t},\n\t\t\talphaMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tspecularmap: {\n\t\t\tspecularMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tenvmap: {\n\t\t\tenvMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tflipEnvMap: {\n\t\t\t\tvalue: -1\n\t\t\t},\n\t\t\treflectivity: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\trefractionRatio: {\n\t\t\t\tvalue: 0.98\n\t\t\t},\n\t\t\tmaxMipLevel: {\n\t\t\t\tvalue: 0\n\t\t\t}\n\t\t},\n\t\taomap: {\n\t\t\taoMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\taoMapIntensity: {\n\t\t\t\tvalue: 1\n\t\t\t}\n\t\t},\n\t\tlightmap: {\n\t\t\tlightMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tlightMapIntensity: {\n\t\t\t\tvalue: 1\n\t\t\t}\n\t\t},\n\t\temissivemap: {\n\t\t\temissiveMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tbumpmap: {\n\t\t\tbumpMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tbumpScale: {\n\t\t\t\tvalue: 1\n\t\t\t}\n\t\t},\n\t\tnormalmap: {\n\t\t\tnormalMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tnormalScale: {\n\t\t\t\tvalue: new Vector2(1, 1)\n\t\t\t}\n\t\t},\n\t\tdisplacementmap: {\n\t\t\tdisplacementMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tdisplacementScale: {\n\t\t\t\tvalue: 1\n\t\t\t},\n\t\t\tdisplacementBias: {\n\t\t\t\tvalue: 0\n\t\t\t}\n\t\t},\n\t\troughnessmap: {\n\t\t\troughnessMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tmetalnessmap: {\n\t\t\tmetalnessMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tgradientmap: {\n\t\t\tgradientMap: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tfog: {\n\t\t\tfogDensity: {\n\t\t\t\tvalue: 0.00025\n\t\t\t},\n\t\t\tfogNear: {\n\t\t\t\tvalue: 1\n\t\t\t},\n\t\t\tfogFar: {\n\t\t\t\tvalue: 2000\n\t\t\t},\n\t\t\tfogColor: {\n\t\t\t\tvalue: new Color(0xffffff)\n\t\t\t}\n\t\t},\n\t\tlights: {\n\t\t\tambientLightColor: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tlightProbe: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tdirectionalLights: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tcolor: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdirectionalLightShadows: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowNormalBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdirectionalShadowMap: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tdirectionalShadowMatrix: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tspotLights: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tdistance: {},\n\t\t\t\t\tconeCos: {},\n\t\t\t\t\tpenumbraCos: {},\n\t\t\t\t\tdecay: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tspotLightShadows: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowNormalBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tspotShadowMap: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tspotShadowMatrix: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tpointLights: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\tdecay: {},\n\t\t\t\t\tdistance: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tpointLightShadows: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tshadowBias: {},\n\t\t\t\t\tshadowNormalBias: {},\n\t\t\t\t\tshadowRadius: {},\n\t\t\t\t\tshadowMapSize: {},\n\t\t\t\t\tshadowCameraNear: {},\n\t\t\t\t\tshadowCameraFar: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tpointShadowMap: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tpointShadowMatrix: {\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\themisphereLights: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tdirection: {},\n\t\t\t\t\tskyColor: {},\n\t\t\t\t\tgroundColor: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n\t\t\trectAreaLights: {\n\t\t\t\tvalue: [],\n\t\t\t\tproperties: {\n\t\t\t\t\tcolor: {},\n\t\t\t\t\tposition: {},\n\t\t\t\t\twidth: {},\n\t\t\t\t\theight: {}\n\t\t\t\t}\n\t\t\t},\n\t\t\tltc_1: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tltc_2: {\n\t\t\t\tvalue: null\n\t\t\t}\n\t\t},\n\t\tpoints: {\n\t\t\tdiffuse: {\n\t\t\t\tvalue: new Color(0xffffff)\n\t\t\t},\n\t\t\topacity: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\tsize: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\tmap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\talphaMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tuvTransform: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t},\n\t\tsprite: {\n\t\t\tdiffuse: {\n\t\t\t\tvalue: new Color(0xffffff)\n\t\t\t},\n\t\t\topacity: {\n\t\t\t\tvalue: 1.0\n\t\t\t},\n\t\t\tcenter: {\n\t\t\t\tvalue: new Vector2(0.5, 0.5)\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tvalue: 0.0\n\t\t\t},\n\t\t\tmap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\talphaMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tuvTransform: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t}\n\t};\n\n\tconst ShaderLib = {\n\t\tbasic: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),\n\t\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\t\t},\n\t\tlambert: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {\n\t\t\t\temissive: {\n\t\t\t\t\tvalue: new Color(0x000000)\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\t\t},\n\t\tphong: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {\n\t\t\t\temissive: {\n\t\t\t\t\tvalue: new Color(0x000000)\n\t\t\t\t},\n\t\t\t\tspecular: {\n\t\t\t\t\tvalue: new Color(0x111111)\n\t\t\t\t},\n\t\t\t\tshininess: {\n\t\t\t\t\tvalue: 30\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphong_frag\n\t\t},\n\t\tstandard: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {\n\t\t\t\temissive: {\n\t\t\t\t\tvalue: new Color(0x000000)\n\t\t\t\t},\n\t\t\t\troughness: {\n\t\t\t\t\tvalue: 1.0\n\t\t\t\t},\n\t\t\t\tmetalness: {\n\t\t\t\t\tvalue: 0.0\n\t\t\t\t},\n\t\t\t\tenvMapIntensity: {\n\t\t\t\t\tvalue: 1\n\t\t\t\t} // temporary\n\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\t\t},\n\t\ttoon: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {\n\t\t\t\temissive: {\n\t\t\t\t\tvalue: new Color(0x000000)\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.meshtoon_vert,\n\t\t\tfragmentShader: ShaderChunk.meshtoon_frag\n\t\t},\n\t\tmatcap: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {\n\t\t\t\tmatcap: {\n\t\t\t\t\tvalue: null\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.meshmatcap_vert,\n\t\t\tfragmentShader: ShaderChunk.meshmatcap_frag\n\t\t},\n\t\tpoints: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),\n\t\t\tvertexShader: ShaderChunk.points_vert,\n\t\t\tfragmentShader: ShaderChunk.points_frag\n\t\t},\n\t\tdashed: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {\n\t\t\t\tscale: {\n\t\t\t\t\tvalue: 1\n\t\t\t\t},\n\t\t\t\tdashSize: {\n\t\t\t\t\tvalue: 1\n\t\t\t\t},\n\t\t\t\ttotalSize: {\n\t\t\t\t\tvalue: 2\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\t\tfragmentShader: ShaderChunk.linedashed_frag\n\t\t},\n\t\tdepth: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),\n\t\t\tvertexShader: ShaderChunk.depth_vert,\n\t\t\tfragmentShader: ShaderChunk.depth_frag\n\t\t},\n\t\tnormal: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {\n\t\t\t\topacity: {\n\t\t\t\t\tvalue: 1.0\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.normal_vert,\n\t\t\tfragmentShader: ShaderChunk.normal_frag\n\t\t},\n\t\tsprite: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),\n\t\t\tvertexShader: ShaderChunk.sprite_vert,\n\t\t\tfragmentShader: ShaderChunk.sprite_frag\n\t\t},\n\t\tbackground: {\n\t\t\tuniforms: {\n\t\t\t\tuvTransform: {\n\t\t\t\t\tvalue: new Matrix3()\n\t\t\t\t},\n\t\t\t\tt2D: {\n\t\t\t\t\tvalue: null\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: ShaderChunk.background_vert,\n\t\t\tfragmentShader: ShaderChunk.background_frag\n\t\t},\n\n\t\t/* -------------------------------------------------------------------------\n\t\t//\tCube map shader\n\t\t ------------------------------------------------------------------------- */\n\t\tcube: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.envmap, {\n\t\t\t\topacity: {\n\t\t\t\t\tvalue: 1.0\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.cube_vert,\n\t\t\tfragmentShader: ShaderChunk.cube_frag\n\t\t},\n\t\tequirect: {\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: {\n\t\t\t\t\tvalue: null\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\t\tfragmentShader: ShaderChunk.equirect_frag\n\t\t},\n\t\tdistanceRGBA: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {\n\t\t\t\treferencePosition: {\n\t\t\t\t\tvalue: new Vector3()\n\t\t\t\t},\n\t\t\t\tnearDistance: {\n\t\t\t\t\tvalue: 1\n\t\t\t\t},\n\t\t\t\tfarDistance: {\n\t\t\t\t\tvalue: 1000\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\t\t},\n\t\tshadow: {\n\t\t\tuniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {\n\t\t\t\tcolor: {\n\t\t\t\t\tvalue: new Color(0x00000)\n\t\t\t\t},\n\t\t\t\topacity: {\n\t\t\t\t\tvalue: 1.0\n\t\t\t\t}\n\t\t\t}]),\n\t\t\tvertexShader: ShaderChunk.shadow_vert,\n\t\t\tfragmentShader: ShaderChunk.shadow_frag\n\t\t}\n\t};\n\tShaderLib.physical = {\n\t\tuniforms: mergeUniforms([ShaderLib.standard.uniforms, {\n\t\t\tclearcoat: {\n\t\t\t\tvalue: 0\n\t\t\t},\n\t\t\tclearcoatMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tclearcoatRoughness: {\n\t\t\t\tvalue: 0\n\t\t\t},\n\t\t\tclearcoatRoughnessMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tclearcoatNormalScale: {\n\t\t\t\tvalue: new Vector2(1, 1)\n\t\t\t},\n\t\t\tclearcoatNormalMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tsheen: {\n\t\t\t\tvalue: new Color(0x000000)\n\t\t\t},\n\t\t\ttransmission: {\n\t\t\t\tvalue: 0\n\t\t\t},\n\t\t\ttransmissionMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\ttransmissionSamplerSize: {\n\t\t\t\tvalue: new Vector2()\n\t\t\t},\n\t\t\ttransmissionSamplerMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tthickness: {\n\t\t\t\tvalue: 0\n\t\t\t},\n\t\t\tthicknessMap: {\n\t\t\t\tvalue: null\n\t\t\t},\n\t\t\tattenuationDistance: {\n\t\t\t\tvalue: 0\n\t\t\t},\n\t\t\tattenuationColor: {\n\t\t\t\tvalue: new Color(0x000000)\n\t\t\t}\n\t\t}]),\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\t};\n\n\tfunction WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {\n\t\tconst clearColor = new Color(0x000000);\n\t\tlet clearAlpha = 0;\n\t\tlet planeMesh;\n\t\tlet boxMesh;\n\t\tlet currentBackground = null;\n\t\tlet currentBackgroundVersion = 0;\n\t\tlet currentTonemapping = null;\n\n\t\tfunction render(renderList, scene) {\n\t\t\tlet forceClear = false;\n\t\t\tlet background = scene.isScene === true ? scene.background : null;\n\n\t\t\tif (background && background.isTexture) {\n\t\t\t\tbackground = cubemaps.get(background);\n\t\t\t} // Ignore background in AR\n\t\t\t// TODO: Reconsider this.\n\n\n\t\t\tconst xr = renderer.xr;\n\t\t\tconst session = xr.getSession && xr.getSession();\n\n\t\t\tif (session && session.environmentBlendMode === 'additive') {\n\t\t\t\tbackground = null;\n\t\t\t}\n\n\t\t\tif (background === null) {\n\t\t\t\tsetClear(clearColor, clearAlpha);\n\t\t\t} else if (background && background.isColor) {\n\t\t\t\tsetClear(background, 1);\n\t\t\t\tforceClear = true;\n\t\t\t}\n\n\t\t\tif (renderer.autoClear || forceClear) {\n\t\t\t\trenderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n\t\t\t}\n\n\t\t\tif (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {\n\t\t\t\tif (boxMesh === undefined) {\n\t\t\t\t\tboxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({\n\t\t\t\t\t\tname: 'BackgroundCubeMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms(ShaderLib.cube.uniforms),\n\t\t\t\t\t\tvertexShader: ShaderLib.cube.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.cube.fragmentShader,\n\t\t\t\t\t\tside: BackSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t}));\n\t\t\t\t\tboxMesh.geometry.deleteAttribute('normal');\n\t\t\t\t\tboxMesh.geometry.deleteAttribute('uv');\n\n\t\t\t\t\tboxMesh.onBeforeRender = function (renderer, scene, camera) {\n\t\t\t\t\t\tthis.matrixWorld.copyPosition(camera.matrixWorld);\n\t\t\t\t\t}; // enable code injection for non-built-in material\n\n\n\t\t\t\t\tObject.defineProperty(boxMesh.material, 'envMap', {\n\t\t\t\t\t\tget: function () {\n\t\t\t\t\t\t\treturn this.uniforms.envMap.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tobjects.update(boxMesh);\n\t\t\t\t}\n\n\t\t\t\tboxMesh.material.uniforms.envMap.value = background;\n\t\t\t\tboxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;\n\n\t\t\t\tif (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n\t\t\t\t\tboxMesh.material.needsUpdate = true;\n\t\t\t\t\tcurrentBackground = background;\n\t\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\t\t\t\t} // push to the pre-sorted opaque render list\n\n\n\t\t\t\trenderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);\n\t\t\t} else if (background && background.isTexture) {\n\t\t\t\tif (planeMesh === undefined) {\n\t\t\t\t\tplaneMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({\n\t\t\t\t\t\tname: 'BackgroundMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms(ShaderLib.background.uniforms),\n\t\t\t\t\t\tvertexShader: ShaderLib.background.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.background.fragmentShader,\n\t\t\t\t\t\tside: FrontSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t}));\n\t\t\t\t\tplaneMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material\n\n\t\t\t\t\tObject.defineProperty(planeMesh.material, 'map', {\n\t\t\t\t\t\tget: function () {\n\t\t\t\t\t\t\treturn this.uniforms.t2D.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tobjects.update(planeMesh);\n\t\t\t\t}\n\n\t\t\t\tplaneMesh.material.uniforms.t2D.value = background;\n\n\t\t\t\tif (background.matrixAutoUpdate === true) {\n\t\t\t\t\tbackground.updateMatrix();\n\t\t\t\t}\n\n\t\t\t\tplaneMesh.material.uniforms.uvTransform.value.copy(background.matrix);\n\n\t\t\t\tif (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n\t\t\t\t\tplaneMesh.material.needsUpdate = true;\n\t\t\t\t\tcurrentBackground = background;\n\t\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\t\t\t\t} // push to the pre-sorted opaque render list\n\n\n\t\t\t\trenderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);\n\t\t\t}\n\t\t}\n\n\t\tfunction setClear(color, alpha) {\n\t\t\tstate.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);\n\t\t}\n\n\t\treturn {\n\t\t\tgetClearColor: function () {\n\t\t\t\treturn clearColor;\n\t\t\t},\n\t\t\tsetClearColor: function (color, alpha = 1) {\n\t\t\t\tclearColor.set(color);\n\t\t\t\tclearAlpha = alpha;\n\t\t\t\tsetClear(clearColor, clearAlpha);\n\t\t\t},\n\t\t\tgetClearAlpha: function () {\n\t\t\t\treturn clearAlpha;\n\t\t\t},\n\t\t\tsetClearAlpha: function (alpha) {\n\t\t\t\tclearAlpha = alpha;\n\t\t\t\tsetClear(clearColor, clearAlpha);\n\t\t\t},\n\t\t\trender: render\n\t\t};\n\t}\n\n\tfunction WebGLBindingStates(gl, extensions, attributes, capabilities) {\n\t\tconst maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n\t\tconst extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');\n\t\tconst vaoAvailable = capabilities.isWebGL2 || extension !== null;\n\t\tconst bindingStates = {};\n\t\tconst defaultState = createBindingState(null);\n\t\tlet currentState = defaultState;\n\n\t\tfunction setup(object, material, program, geometry, index) {\n\t\t\tlet updateBuffers = false;\n\n\t\t\tif (vaoAvailable) {\n\t\t\t\tconst state = getBindingState(geometry, program, material);\n\n\t\t\t\tif (currentState !== state) {\n\t\t\t\t\tcurrentState = state;\n\t\t\t\t\tbindVertexArrayObject(currentState.object);\n\t\t\t\t}\n\n\t\t\t\tupdateBuffers = needsUpdate(geometry, index);\n\t\t\t\tif (updateBuffers) saveCache(geometry, index);\n\t\t\t} else {\n\t\t\t\tconst wireframe = material.wireframe === true;\n\n\t\t\t\tif (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {\n\t\t\t\t\tcurrentState.geometry = geometry.id;\n\t\t\t\t\tcurrentState.program = program.id;\n\t\t\t\t\tcurrentState.wireframe = wireframe;\n\t\t\t\t\tupdateBuffers = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (object.isInstancedMesh === true) {\n\t\t\t\tupdateBuffers = true;\n\t\t\t}\n\n\t\t\tif (index !== null) {\n\t\t\t\tattributes.update(index, gl.ELEMENT_ARRAY_BUFFER);\n\t\t\t}\n\n\t\t\tif (updateBuffers) {\n\t\t\t\tsetupVertexAttributes(object, material, program, geometry);\n\n\t\t\t\tif (index !== null) {\n\t\t\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction createVertexArrayObject() {\n\t\t\tif (capabilities.isWebGL2) return gl.createVertexArray();\n\t\t\treturn extension.createVertexArrayOES();\n\t\t}\n\n\t\tfunction bindVertexArrayObject(vao) {\n\t\t\tif (capabilities.isWebGL2) return gl.bindVertexArray(vao);\n\t\t\treturn extension.bindVertexArrayOES(vao);\n\t\t}\n\n\t\tfunction deleteVertexArrayObject(vao) {\n\t\t\tif (capabilities.isWebGL2) return gl.deleteVertexArray(vao);\n\t\t\treturn extension.deleteVertexArrayOES(vao);\n\t\t}\n\n\t\tfunction getBindingState(geometry, program, material) {\n\t\t\tconst wireframe = material.wireframe === true;\n\t\t\tlet programMap = bindingStates[geometry.id];\n\n\t\t\tif (programMap === undefined) {\n\t\t\t\tprogramMap = {};\n\t\t\t\tbindingStates[geometry.id] = programMap;\n\t\t\t}\n\n\t\t\tlet stateMap = programMap[program.id];\n\n\t\t\tif (stateMap === undefined) {\n\t\t\t\tstateMap = {};\n\t\t\t\tprogramMap[program.id] = stateMap;\n\t\t\t}\n\n\t\t\tlet state = stateMap[wireframe];\n\n\t\t\tif (state === undefined) {\n\t\t\t\tstate = createBindingState(createVertexArrayObject());\n\t\t\t\tstateMap[wireframe] = state;\n\t\t\t}\n\n\t\t\treturn state;\n\t\t}\n\n\t\tfunction createBindingState(vao) {\n\t\t\tconst newAttributes = [];\n\t\t\tconst enabledAttributes = [];\n\t\t\tconst attributeDivisors = [];\n\n\t\t\tfor (let i = 0; i < maxVertexAttributes; i++) {\n\t\t\t\tnewAttributes[i] = 0;\n\t\t\t\tenabledAttributes[i] = 0;\n\t\t\t\tattributeDivisors[i] = 0;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t// for backward compatibility on non-VAO support browser\n\t\t\t\tgeometry: null,\n\t\t\t\tprogram: null,\n\t\t\t\twireframe: false,\n\t\t\t\tnewAttributes: newAttributes,\n\t\t\t\tenabledAttributes: enabledAttributes,\n\t\t\t\tattributeDivisors: attributeDivisors,\n\t\t\t\tobject: vao,\n\t\t\t\tattributes: {},\n\t\t\t\tindex: null\n\t\t\t};\n\t\t}\n\n\t\tfunction needsUpdate(geometry, index) {\n\t\t\tconst cachedAttributes = currentState.attributes;\n\t\t\tconst geometryAttributes = geometry.attributes;\n\t\t\tlet attributesNum = 0;\n\n\t\t\tfor (const key in geometryAttributes) {\n\t\t\t\tconst cachedAttribute = cachedAttributes[key];\n\t\t\t\tconst geometryAttribute = geometryAttributes[key];\n\t\t\t\tif (cachedAttribute === undefined) return true;\n\t\t\t\tif (cachedAttribute.attribute !== geometryAttribute) return true;\n\t\t\t\tif (cachedAttribute.data !== geometryAttribute.data) return true;\n\t\t\t\tattributesNum++;\n\t\t\t}\n\n\t\t\tif (currentState.attributesNum !== attributesNum) return true;\n\t\t\tif (currentState.index !== index) return true;\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction saveCache(geometry, index) {\n\t\t\tconst cache = {};\n\t\t\tconst attributes = geometry.attributes;\n\t\t\tlet attributesNum = 0;\n\n\t\t\tfor (const key in attributes) {\n\t\t\t\tconst attribute = attributes[key];\n\t\t\t\tconst data = {};\n\t\t\t\tdata.attribute = attribute;\n\n\t\t\t\tif (attribute.data) {\n\t\t\t\t\tdata.data = attribute.data;\n\t\t\t\t}\n\n\t\t\t\tcache[key] = data;\n\t\t\t\tattributesNum++;\n\t\t\t}\n\n\t\t\tcurrentState.attributes = cache;\n\t\t\tcurrentState.attributesNum = attributesNum;\n\t\t\tcurrentState.index = index;\n\t\t}\n\n\t\tfunction initAttributes() {\n\t\t\tconst newAttributes = currentState.newAttributes;\n\n\t\t\tfor (let i = 0, il = newAttributes.length; i < il; i++) {\n\t\t\t\tnewAttributes[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfunction enableAttribute(attribute) {\n\t\t\tenableAttributeAndDivisor(attribute, 0);\n\t\t}\n\n\t\tfunction enableAttributeAndDivisor(attribute, meshPerAttribute) {\n\t\t\tconst newAttributes = currentState.newAttributes;\n\t\t\tconst enabledAttributes = currentState.enabledAttributes;\n\t\t\tconst attributeDivisors = currentState.attributeDivisors;\n\t\t\tnewAttributes[attribute] = 1;\n\n\t\t\tif (enabledAttributes[attribute] === 0) {\n\t\t\t\tgl.enableVertexAttribArray(attribute);\n\t\t\t\tenabledAttributes[attribute] = 1;\n\t\t\t}\n\n\t\t\tif (attributeDivisors[attribute] !== meshPerAttribute) {\n\t\t\t\tconst extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');\n\t\t\t\textension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);\n\t\t\t\tattributeDivisors[attribute] = meshPerAttribute;\n\t\t\t}\n\t\t}\n\n\t\tfunction disableUnusedAttributes() {\n\t\t\tconst newAttributes = currentState.newAttributes;\n\t\t\tconst enabledAttributes = currentState.enabledAttributes;\n\n\t\t\tfor (let i = 0, il = enabledAttributes.length; i < il; i++) {\n\t\t\t\tif (enabledAttributes[i] !== newAttributes[i]) {\n\t\t\t\t\tgl.disableVertexAttribArray(i);\n\t\t\t\t\tenabledAttributes[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction vertexAttribPointer(index, size, type, normalized, stride, offset) {\n\t\t\tif (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {\n\t\t\t\tgl.vertexAttribIPointer(index, size, type, stride, offset);\n\t\t\t} else {\n\t\t\t\tgl.vertexAttribPointer(index, size, type, normalized, stride, offset);\n\t\t\t}\n\t\t}\n\n\t\tfunction setupVertexAttributes(object, material, program, geometry) {\n\t\t\tif (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {\n\t\t\t\tif (extensions.get('ANGLE_instanced_arrays') === null) return;\n\t\t\t}\n\n\t\t\tinitAttributes();\n\t\t\tconst geometryAttributes = geometry.attributes;\n\t\t\tconst programAttributes = program.getAttributes();\n\t\t\tconst materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\t\tfor (const name in programAttributes) {\n\t\t\t\tconst programAttribute = programAttributes[name];\n\n\t\t\t\tif (programAttribute >= 0) {\n\t\t\t\t\tconst geometryAttribute = geometryAttributes[name];\n\n\t\t\t\t\tif (geometryAttribute !== undefined) {\n\t\t\t\t\t\tconst normalized = geometryAttribute.normalized;\n\t\t\t\t\t\tconst size = geometryAttribute.itemSize;\n\t\t\t\t\t\tconst attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore\n\n\t\t\t\t\t\tif (attribute === undefined) continue;\n\t\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\t\tconst bytesPerElement = attribute.bytesPerElement;\n\n\t\t\t\t\t\tif (geometryAttribute.isInterleavedBufferAttribute) {\n\t\t\t\t\t\t\tconst data = geometryAttribute.data;\n\t\t\t\t\t\t\tconst stride = data.stride;\n\t\t\t\t\t\t\tconst offset = geometryAttribute.offset;\n\n\t\t\t\t\t\t\tif (data && data.isInstancedInterleavedBuffer) {\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute, data.meshPerAttribute);\n\n\t\t\t\t\t\t\t\tif (geometry._maxInstanceCount === undefined) {\n\t\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = data.meshPerAttribute * data.count;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tenableAttribute(programAttribute);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t\t\t\t\t\tvertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (geometryAttribute.isInstancedBufferAttribute) {\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);\n\n\t\t\t\t\t\t\t\tif (geometry._maxInstanceCount === undefined) {\n\t\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tenableAttribute(programAttribute);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t\t\t\t\t\tvertexAttribPointer(programAttribute, size, type, normalized, 0, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (name === 'instanceMatrix') {\n\t\t\t\t\t\tconst attribute = attributes.get(object.instanceMatrix); // TODO Attribute may not be available on context restore\n\n\t\t\t\t\t\tif (attribute === undefined) continue;\n\t\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute + 0, 1);\n\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute + 1, 1);\n\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute + 2, 1);\n\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute + 3, 1);\n\t\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t\t\t\t\tgl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);\n\t\t\t\t\t\tgl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);\n\t\t\t\t\t\tgl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);\n\t\t\t\t\t\tgl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);\n\t\t\t\t\t} else if (name === 'instanceColor') {\n\t\t\t\t\t\tconst attribute = attributes.get(object.instanceColor); // TODO Attribute may not be available on context restore\n\n\t\t\t\t\t\tif (attribute === undefined) continue;\n\t\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\t\tenableAttributeAndDivisor(programAttribute, 1);\n\t\t\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\t\t\t\t\t\tgl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);\n\t\t\t\t\t} else if (materialDefaultAttributeValues !== undefined) {\n\t\t\t\t\t\tconst value = materialDefaultAttributeValues[name];\n\n\t\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\t\tswitch (value.length) {\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tgl.vertexAttrib2fv(programAttribute, value);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tgl.vertexAttrib3fv(programAttribute, value);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tgl.vertexAttrib4fv(programAttribute, value);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tgl.vertexAttrib1fv(programAttribute, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdisableUnusedAttributes();\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\treset();\n\n\t\t\tfor (const geometryId in bindingStates) {\n\t\t\t\tconst programMap = bindingStates[geometryId];\n\n\t\t\t\tfor (const programId in programMap) {\n\t\t\t\t\tconst stateMap = programMap[programId];\n\n\t\t\t\t\tfor (const wireframe in stateMap) {\n\t\t\t\t\t\tdeleteVertexArrayObject(stateMap[wireframe].object);\n\t\t\t\t\t\tdelete stateMap[wireframe];\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete programMap[programId];\n\t\t\t\t}\n\n\t\t\t\tdelete bindingStates[geometryId];\n\t\t\t}\n\t\t}\n\n\t\tfunction releaseStatesOfGeometry(geometry) {\n\t\t\tif (bindingStates[geometry.id] === undefined) return;\n\t\t\tconst programMap = bindingStates[geometry.id];\n\n\t\t\tfor (const programId in programMap) {\n\t\t\t\tconst stateMap = programMap[programId];\n\n\t\t\t\tfor (const wireframe in stateMap) {\n\t\t\t\t\tdeleteVertexArrayObject(stateMap[wireframe].object);\n\t\t\t\t\tdelete stateMap[wireframe];\n\t\t\t\t}\n\n\t\t\t\tdelete programMap[programId];\n\t\t\t}\n\n\t\t\tdelete bindingStates[geometry.id];\n\t\t}\n\n\t\tfunction releaseStatesOfProgram(program) {\n\t\t\tfor (const geometryId in bindingStates) {\n\t\t\t\tconst programMap = bindingStates[geometryId];\n\t\t\t\tif (programMap[program.id] === undefined) continue;\n\t\t\t\tconst stateMap = programMap[program.id];\n\n\t\t\t\tfor (const wireframe in stateMap) {\n\t\t\t\t\tdeleteVertexArrayObject(stateMap[wireframe].object);\n\t\t\t\t\tdelete stateMap[wireframe];\n\t\t\t\t}\n\n\t\t\t\tdelete programMap[program.id];\n\t\t\t}\n\t\t}\n\n\t\tfunction reset() {\n\t\t\tresetDefaultState();\n\t\t\tif (currentState === defaultState) return;\n\t\t\tcurrentState = defaultState;\n\t\t\tbindVertexArrayObject(currentState.object);\n\t\t} // for backward-compatilibity\n\n\n\t\tfunction resetDefaultState() {\n\t\t\tdefaultState.geometry = null;\n\t\t\tdefaultState.program = null;\n\t\t\tdefaultState.wireframe = false;\n\t\t}\n\n\t\treturn {\n\t\t\tsetup: setup,\n\t\t\treset: reset,\n\t\t\tresetDefaultState: resetDefaultState,\n\t\t\tdispose: dispose,\n\t\t\treleaseStatesOfGeometry: releaseStatesOfGeometry,\n\t\t\treleaseStatesOfProgram: releaseStatesOfProgram,\n\t\t\tinitAttributes: initAttributes,\n\t\t\tenableAttribute: enableAttribute,\n\t\t\tdisableUnusedAttributes: disableUnusedAttributes\n\t\t};\n\t}\n\n\tfunction WebGLBufferRenderer(gl, extensions, info, capabilities) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\t\tlet mode;\n\n\t\tfunction setMode(value) {\n\t\t\tmode = value;\n\t\t}\n\n\t\tfunction render(start, count) {\n\t\t\tgl.drawArrays(mode, start, count);\n\t\t\tinfo.update(count, mode, 1);\n\t\t}\n\n\t\tfunction renderInstances(start, count, primcount) {\n\t\t\tif (primcount === 0) return;\n\t\t\tlet extension, methodName;\n\n\t\t\tif (isWebGL2) {\n\t\t\t\textension = gl;\n\t\t\t\tmethodName = 'drawArraysInstanced';\n\t\t\t} else {\n\t\t\t\textension = extensions.get('ANGLE_instanced_arrays');\n\t\t\t\tmethodName = 'drawArraysInstancedANGLE';\n\n\t\t\t\tif (extension === null) {\n\t\t\t\t\tconsole.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\textension[methodName](mode, start, count, primcount);\n\t\t\tinfo.update(count, mode, primcount);\n\t\t} //\n\n\n\t\tthis.setMode = setMode;\n\t\tthis.render = render;\n\t\tthis.renderInstances = renderInstances;\n\t}\n\n\tfunction WebGLCapabilities(gl, extensions, parameters) {\n\t\tlet maxAnisotropy;\n\n\t\tfunction getMaxAnisotropy() {\n\t\t\tif (maxAnisotropy !== undefined) return maxAnisotropy;\n\n\t\t\tif (extensions.has('EXT_texture_filter_anisotropic') === true) {\n\t\t\t\tconst extension = extensions.get('EXT_texture_filter_anisotropic');\n\t\t\t\tmaxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n\t\t\t} else {\n\t\t\t\tmaxAnisotropy = 0;\n\t\t\t}\n\n\t\t\treturn maxAnisotropy;\n\t\t}\n\n\t\tfunction getMaxPrecision(precision) {\n\t\t\tif (precision === 'highp') {\n\t\t\t\tif (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {\n\t\t\t\t\treturn 'highp';\n\t\t\t\t}\n\n\t\t\t\tprecision = 'mediump';\n\t\t\t}\n\n\t\t\tif (precision === 'mediump') {\n\t\t\t\tif (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {\n\t\t\t\t\treturn 'mediump';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 'lowp';\n\t\t}\n\t\t/* eslint-disable no-undef */\n\n\n\t\tconst isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;\n\t\t/* eslint-enable no-undef */\n\n\t\tlet precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\t\tconst maxPrecision = getMaxPrecision(precision);\n\n\t\tif (maxPrecision !== precision) {\n\t\t\tconsole.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');\n\t\t\tprecision = maxPrecision;\n\t\t}\n\n\t\tconst drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');\n\t\tconst logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n\t\tconst maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\t\tconst maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n\t\tconst maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n\t\tconst maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n\t\tconst maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n\t\tconst maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n\t\tconst maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);\n\t\tconst maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n\t\tconst vertexTextures = maxVertexTextures > 0;\n\t\tconst floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');\n\t\tconst floatVertexTextures = vertexTextures && floatFragmentTextures;\n\t\tconst maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;\n\t\treturn {\n\t\t\tisWebGL2: isWebGL2,\n\t\t\tdrawBuffers: drawBuffers,\n\t\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\t\tgetMaxPrecision: getMaxPrecision,\n\t\t\tprecision: precision,\n\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\t\t\tmaxTextures: maxTextures,\n\t\t\tmaxVertexTextures: maxVertexTextures,\n\t\t\tmaxTextureSize: maxTextureSize,\n\t\t\tmaxCubemapSize: maxCubemapSize,\n\t\t\tmaxAttributes: maxAttributes,\n\t\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\t\tmaxVaryings: maxVaryings,\n\t\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\t\t\tvertexTextures: vertexTextures,\n\t\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\t\tfloatVertexTextures: floatVertexTextures,\n\t\t\tmaxSamples: maxSamples\n\t\t};\n\t}\n\n\tfunction WebGLClipping(properties) {\n\t\tconst scope = this;\n\t\tlet globalState = null,\n\t\t\t\tnumGlobalPlanes = 0,\n\t\t\t\tlocalClippingEnabled = false,\n\t\t\t\trenderingShadows = false;\n\t\tconst plane = new Plane(),\n\t\t\t\t\tviewNormalMatrix = new Matrix3(),\n\t\t\t\t\tuniform = {\n\t\t\tvalue: null,\n\t\t\tneedsUpdate: false\n\t\t};\n\t\tthis.uniform = uniform;\n\t\tthis.numPlanes = 0;\n\t\tthis.numIntersection = 0;\n\n\t\tthis.init = function (planes, enableLocalClipping, camera) {\n\t\t\tconst enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 || localClippingEnabled;\n\t\t\tlocalClippingEnabled = enableLocalClipping;\n\t\t\tglobalState = projectPlanes(planes, camera, 0);\n\t\t\tnumGlobalPlanes = planes.length;\n\t\t\treturn enabled;\n\t\t};\n\n\t\tthis.beginShadows = function () {\n\t\t\trenderingShadows = true;\n\t\t\tprojectPlanes(null);\n\t\t};\n\n\t\tthis.endShadows = function () {\n\t\t\trenderingShadows = false;\n\t\t\tresetGlobalState();\n\t\t};\n\n\t\tthis.setState = function (material, camera, useCache) {\n\t\t\tconst planes = material.clippingPlanes,\n\t\t\t\t\t\tclipIntersection = material.clipIntersection,\n\t\t\t\t\t\tclipShadows = material.clipShadows;\n\t\t\tconst materialProperties = properties.get(material);\n\n\t\t\tif (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {\n\t\t\t\t// there's no local clipping\n\t\t\t\tif (renderingShadows) {\n\t\t\t\t\t// there's no global clipping\n\t\t\t\t\tprojectPlanes(null);\n\t\t\t\t} else {\n\t\t\t\t\tresetGlobalState();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\t\t\t\tlGlobal = nGlobal * 4;\n\t\t\t\tlet dstArray = materialProperties.clippingState || null;\n\t\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\t\tdstArray = projectPlanes(planes, camera, lGlobal, useCache);\n\n\t\t\t\tfor (let i = 0; i !== lGlobal; ++i) {\n\t\t\t\t\tdstArray[i] = globalState[i];\n\t\t\t\t}\n\n\t\t\t\tmaterialProperties.clippingState = dstArray;\n\t\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\t\tthis.numPlanes += nGlobal;\n\t\t\t}\n\t\t};\n\n\t\tfunction resetGlobalState() {\n\t\t\tif (uniform.value !== globalState) {\n\t\t\t\tuniform.value = globalState;\n\t\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\t\t\t}\n\n\t\t\tscope.numPlanes = numGlobalPlanes;\n\t\t\tscope.numIntersection = 0;\n\t\t}\n\n\t\tfunction projectPlanes(planes, camera, dstOffset, skipTransform) {\n\t\t\tconst nPlanes = planes !== null ? planes.length : 0;\n\t\t\tlet dstArray = null;\n\n\t\t\tif (nPlanes !== 0) {\n\t\t\t\tdstArray = uniform.value;\n\n\t\t\t\tif (skipTransform !== true || dstArray === null) {\n\t\t\t\t\tconst flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\t\t\t\t\tviewNormalMatrix.getNormalMatrix(viewMatrix);\n\n\t\t\t\t\tif (dstArray === null || dstArray.length < flatSize) {\n\t\t\t\t\t\tdstArray = new Float32Array(flatSize);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {\n\t\t\t\t\t\tplane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);\n\t\t\t\t\t\tplane.normal.toArray(dstArray, i4);\n\t\t\t\t\t\tdstArray[i4 + 3] = plane.constant;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuniform.value = dstArray;\n\t\t\t\tuniform.needsUpdate = true;\n\t\t\t}\n\n\t\t\tscope.numPlanes = nPlanes;\n\t\t\tscope.numIntersection = 0;\n\t\t\treturn dstArray;\n\t\t}\n\t}\n\n\tfunction WebGLCubeMaps(renderer) {\n\t\tlet cubemaps = new WeakMap();\n\n\t\tfunction mapTextureMapping(texture, mapping) {\n\t\t\tif (mapping === EquirectangularReflectionMapping) {\n\t\t\t\ttexture.mapping = CubeReflectionMapping;\n\t\t\t} else if (mapping === EquirectangularRefractionMapping) {\n\t\t\t\ttexture.mapping = CubeRefractionMapping;\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t}\n\n\t\tfunction get(texture) {\n\t\t\tif (texture && texture.isTexture) {\n\t\t\t\tconst mapping = texture.mapping;\n\n\t\t\t\tif (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {\n\t\t\t\t\tif (cubemaps.has(texture)) {\n\t\t\t\t\t\tconst cubemap = cubemaps.get(texture).texture;\n\t\t\t\t\t\treturn mapTextureMapping(cubemap, texture.mapping);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\t\tif (image && image.height > 0) {\n\t\t\t\t\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\t\t\t\t\t\tconst renderTarget = new WebGLCubeRenderTarget(image.height / 2);\n\t\t\t\t\t\t\trenderTarget.fromEquirectangularTexture(renderer, texture);\n\t\t\t\t\t\t\tcubemaps.set(texture, renderTarget);\n\t\t\t\t\t\t\trenderer.setRenderTarget(currentRenderTarget);\n\t\t\t\t\t\t\ttexture.addEventListener('dispose', onTextureDispose);\n\t\t\t\t\t\t\treturn mapTextureMapping(renderTarget.texture, texture.mapping);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// image not yet ready. try the conversion next frame\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t}\n\n\t\tfunction onTextureDispose(event) {\n\t\t\tconst texture = event.target;\n\t\t\ttexture.removeEventListener('dispose', onTextureDispose);\n\t\t\tconst cubemap = cubemaps.get(texture);\n\n\t\t\tif (cubemap !== undefined) {\n\t\t\t\tcubemaps.delete(texture);\n\t\t\t\tcubemap.dispose();\n\t\t\t}\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\tcubemaps = new WeakMap();\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tdispose: dispose\n\t\t};\n\t}\n\n\tfunction WebGLExtensions(gl) {\n\t\tconst extensions = {};\n\n\t\tfunction getExtension(name) {\n\t\t\tif (extensions[name] !== undefined) {\n\t\t\t\treturn extensions[name];\n\t\t\t}\n\n\t\t\tlet extension;\n\n\t\t\tswitch (name) {\n\t\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\t\textension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\t\textension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\t\textension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\t\textension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\textension = gl.getExtension(name);\n\t\t\t}\n\n\t\t\textensions[name] = extension;\n\t\t\treturn extension;\n\t\t}\n\n\t\treturn {\n\t\t\thas: function (name) {\n\t\t\t\treturn getExtension(name) !== null;\n\t\t\t},\n\t\t\tinit: function (capabilities) {\n\t\t\t\tif (capabilities.isWebGL2) {\n\t\t\t\t\tgetExtension('EXT_color_buffer_float');\n\t\t\t\t} else {\n\t\t\t\t\tgetExtension('WEBGL_depth_texture');\n\t\t\t\t\tgetExtension('OES_texture_float');\n\t\t\t\t\tgetExtension('OES_texture_half_float');\n\t\t\t\t\tgetExtension('OES_texture_half_float_linear');\n\t\t\t\t\tgetExtension('OES_standard_derivatives');\n\t\t\t\t\tgetExtension('OES_element_index_uint');\n\t\t\t\t\tgetExtension('OES_vertex_array_object');\n\t\t\t\t\tgetExtension('ANGLE_instanced_arrays');\n\t\t\t\t}\n\n\t\t\t\tgetExtension('OES_texture_float_linear');\n\t\t\t\tgetExtension('EXT_color_buffer_half_float');\n\t\t\t},\n\t\t\tget: function (name) {\n\t\t\t\tconst extension = getExtension(name);\n\n\t\t\t\tif (extension === null) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');\n\t\t\t\t}\n\n\t\t\t\treturn extension;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction WebGLGeometries(gl, attributes, info, bindingStates) {\n\t\tconst geometries = {};\n\t\tconst wireframeAttributes = new WeakMap();\n\n\t\tfunction onGeometryDispose(event) {\n\t\t\tconst geometry = event.target;\n\n\t\t\tif (geometry.index !== null) {\n\t\t\t\tattributes.remove(geometry.index);\n\t\t\t}\n\n\t\t\tfor (const name in geometry.attributes) {\n\t\t\t\tattributes.remove(geometry.attributes[name]);\n\t\t\t}\n\n\t\t\tgeometry.removeEventListener('dispose', onGeometryDispose);\n\t\t\tdelete geometries[geometry.id];\n\t\t\tconst attribute = wireframeAttributes.get(geometry);\n\n\t\t\tif (attribute) {\n\t\t\t\tattributes.remove(attribute);\n\t\t\t\twireframeAttributes.delete(geometry);\n\t\t\t}\n\n\t\t\tbindingStates.releaseStatesOfGeometry(geometry);\n\n\t\t\tif (geometry.isInstancedBufferGeometry === true) {\n\t\t\t\tdelete geometry._maxInstanceCount;\n\t\t\t} //\n\n\n\t\t\tinfo.memory.geometries--;\n\t\t}\n\n\t\tfunction get(object, geometry) {\n\t\t\tif (geometries[geometry.id] === true) return geometry;\n\t\t\tgeometry.addEventListener('dispose', onGeometryDispose);\n\t\t\tgeometries[geometry.id] = true;\n\t\t\tinfo.memory.geometries++;\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction update(geometry) {\n\t\t\tconst geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.\n\n\t\t\tfor (const name in geometryAttributes) {\n\t\t\t\tattributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);\n\t\t\t} // morph targets\n\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\n\t\t\tfor (const name in morphAttributes) {\n\t\t\t\tconst array = morphAttributes[name];\n\n\t\t\t\tfor (let i = 0, l = array.length; i < l; i++) {\n\t\t\t\t\tattributes.update(array[i], gl.ARRAY_BUFFER);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction updateWireframeAttribute(geometry) {\n\t\t\tconst indices = [];\n\t\t\tconst geometryIndex = geometry.index;\n\t\t\tconst geometryPosition = geometry.attributes.position;\n\t\t\tlet version = 0;\n\n\t\t\tif (geometryIndex !== null) {\n\t\t\t\tconst array = geometryIndex.array;\n\t\t\t\tversion = geometryIndex.version;\n\n\t\t\t\tfor (let i = 0, l = array.length; i < l; i += 3) {\n\t\t\t\t\tconst a = array[i + 0];\n\t\t\t\t\tconst b = array[i + 1];\n\t\t\t\t\tconst c = array[i + 2];\n\t\t\t\t\tindices.push(a, b, b, c, c, a);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst array = geometryPosition.array;\n\t\t\t\tversion = geometryPosition.version;\n\n\t\t\t\tfor (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {\n\t\t\t\t\tconst a = i + 0;\n\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\tconst c = i + 2;\n\t\t\t\t\tindices.push(a, b, b, c, c, a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);\n\t\t\tattribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates\n\t\t\t//\n\n\t\t\tconst previousAttribute = wireframeAttributes.get(geometry);\n\t\t\tif (previousAttribute) attributes.remove(previousAttribute); //\n\n\t\t\twireframeAttributes.set(geometry, attribute);\n\t\t}\n\n\t\tfunction getWireframeAttribute(geometry) {\n\t\t\tconst currentAttribute = wireframeAttributes.get(geometry);\n\n\t\t\tif (currentAttribute) {\n\t\t\t\tconst geometryIndex = geometry.index;\n\n\t\t\t\tif (geometryIndex !== null) {\n\t\t\t\t\t// if the attribute is obsolete, create a new one\n\t\t\t\t\tif (currentAttribute.version < geometryIndex.version) {\n\t\t\t\t\t\tupdateWireframeAttribute(geometry);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tupdateWireframeAttribute(geometry);\n\t\t\t}\n\n\t\t\treturn wireframeAttributes.get(geometry);\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tupdate: update,\n\t\t\tgetWireframeAttribute: getWireframeAttribute\n\t\t};\n\t}\n\n\tfunction WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\t\tlet mode;\n\n\t\tfunction setMode(value) {\n\t\t\tmode = value;\n\t\t}\n\n\t\tlet type, bytesPerElement;\n\n\t\tfunction setIndex(value) {\n\t\t\ttype = value.type;\n\t\t\tbytesPerElement = value.bytesPerElement;\n\t\t}\n\n\t\tfunction render(start, count) {\n\t\t\tgl.drawElements(mode, count, type, start * bytesPerElement);\n\t\t\tinfo.update(count, mode, 1);\n\t\t}\n\n\t\tfunction renderInstances(start, count, primcount) {\n\t\t\tif (primcount === 0) return;\n\t\t\tlet extension, methodName;\n\n\t\t\tif (isWebGL2) {\n\t\t\t\textension = gl;\n\t\t\t\tmethodName = 'drawElementsInstanced';\n\t\t\t} else {\n\t\t\t\textension = extensions.get('ANGLE_instanced_arrays');\n\t\t\t\tmethodName = 'drawElementsInstancedANGLE';\n\n\t\t\t\tif (extension === null) {\n\t\t\t\t\tconsole.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\textension[methodName](mode, count, type, start * bytesPerElement, primcount);\n\t\t\tinfo.update(count, mode, primcount);\n\t\t} //\n\n\n\t\tthis.setMode = setMode;\n\t\tthis.setIndex = setIndex;\n\t\tthis.render = render;\n\t\tthis.renderInstances = renderInstances;\n\t}\n\n\tfunction WebGLInfo(gl) {\n\t\tconst memory = {\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\t\t};\n\t\tconst render = {\n\t\t\tframe: 0,\n\t\t\tcalls: 0,\n\t\t\ttriangles: 0,\n\t\t\tpoints: 0,\n\t\t\tlines: 0\n\t\t};\n\n\t\tfunction update(count, mode, instanceCount) {\n\t\t\trender.calls++;\n\n\t\t\tswitch (mode) {\n\t\t\t\tcase gl.TRIANGLES:\n\t\t\t\t\trender.triangles += instanceCount * (count / 3);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.LINES:\n\t\t\t\t\trender.lines += instanceCount * (count / 2);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.LINE_STRIP:\n\t\t\t\t\trender.lines += instanceCount * (count - 1);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.LINE_LOOP:\n\t\t\t\t\trender.lines += instanceCount * count;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase gl.POINTS:\n\t\t\t\t\trender.points += instanceCount * count;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error('THREE.WebGLInfo: Unknown draw mode:', mode);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfunction reset() {\n\t\t\trender.frame++;\n\t\t\trender.calls = 0;\n\t\t\trender.triangles = 0;\n\t\t\trender.points = 0;\n\t\t\trender.lines = 0;\n\t\t}\n\n\t\treturn {\n\t\t\tmemory: memory,\n\t\t\trender: render,\n\t\t\tprograms: null,\n\t\t\tautoReset: true,\n\t\t\treset: reset,\n\t\t\tupdate: update\n\t\t};\n\t}\n\n\tfunction numericalSort(a, b) {\n\t\treturn a[0] - b[0];\n\t}\n\n\tfunction absNumericalSort(a, b) {\n\t\treturn Math.abs(b[1]) - Math.abs(a[1]);\n\t}\n\n\tfunction WebGLMorphtargets(gl) {\n\t\tconst influencesList = {};\n\t\tconst morphInfluences = new Float32Array(8);\n\t\tconst workInfluences = [];\n\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\tworkInfluences[i] = [i, 0];\n\t\t}\n\n\t\tfunction update(object, geometry, material, program) {\n\t\t\tconst objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array\n\t\t\t// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n\n\t\t\tconst length = objectInfluences === undefined ? 0 : objectInfluences.length;\n\t\t\tlet influences = influencesList[geometry.id];\n\n\t\t\tif (influences === undefined) {\n\t\t\t\t// initialise list\n\t\t\t\tinfluences = [];\n\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tinfluences[i] = [i, 0];\n\t\t\t\t}\n\n\t\t\t\tinfluencesList[geometry.id] = influences;\n\t\t\t} // Collect influences\n\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst influence = influences[i];\n\t\t\t\tinfluence[0] = i;\n\t\t\t\tinfluence[1] = objectInfluences[i];\n\t\t\t}\n\n\t\t\tinfluences.sort(absNumericalSort);\n\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tif (i < length && influences[i][1]) {\n\t\t\t\t\tworkInfluences[i][0] = influences[i][0];\n\t\t\t\t\tworkInfluences[i][1] = influences[i][1];\n\t\t\t\t} else {\n\t\t\t\t\tworkInfluences[i][0] = Number.MAX_SAFE_INTEGER;\n\t\t\t\t\tworkInfluences[i][1] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tworkInfluences.sort(numericalSort);\n\t\t\tconst morphTargets = material.morphTargets && geometry.morphAttributes.position;\n\t\t\tconst morphNormals = material.morphNormals && geometry.morphAttributes.normal;\n\t\t\tlet morphInfluencesSum = 0;\n\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tconst influence = workInfluences[i];\n\t\t\t\tconst index = influence[0];\n\t\t\t\tconst value = influence[1];\n\n\t\t\t\tif (index !== Number.MAX_SAFE_INTEGER && value) {\n\t\t\t\t\tif (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {\n\t\t\t\t\t\tgeometry.setAttribute('morphTarget' + i, morphTargets[index]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {\n\t\t\t\t\t\tgeometry.setAttribute('morphNormal' + i, morphNormals[index]);\n\t\t\t\t\t}\n\n\t\t\t\t\tmorphInfluences[i] = value;\n\t\t\t\t\tmorphInfluencesSum += value;\n\t\t\t\t} else {\n\t\t\t\t\tif (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {\n\t\t\t\t\t\tgeometry.deleteAttribute('morphTarget' + i);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {\n\t\t\t\t\t\tgeometry.deleteAttribute('morphNormal' + i);\n\t\t\t\t\t}\n\n\t\t\t\t\tmorphInfluences[i] = 0;\n\t\t\t\t}\n\t\t\t} // GLSL shader uses formula baseinfluence * base + sum(target * influence)\n\t\t\t// This allows us to switch between absolute morphs and relative morphs without changing shader code\n\t\t\t// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\n\n\t\t\tconst morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\t\t\tprogram.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n\t\t\tprogram.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);\n\t\t}\n\n\t\treturn {\n\t\t\tupdate: update\n\t\t};\n\t}\n\n\tfunction WebGLObjects(gl, geometries, attributes, info) {\n\t\tlet updateMap = new WeakMap();\n\n\t\tfunction update(object) {\n\t\t\tconst frame = info.render.frame;\n\t\t\tconst geometry = object.geometry;\n\t\t\tconst buffergeometry = geometries.get(object, geometry); // Update once per frame\n\n\t\t\tif (updateMap.get(buffergeometry) !== frame) {\n\t\t\t\tgeometries.update(buffergeometry);\n\t\t\t\tupdateMap.set(buffergeometry, frame);\n\t\t\t}\n\n\t\t\tif (object.isInstancedMesh) {\n\t\t\t\tif (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {\n\t\t\t\t\tobject.addEventListener('dispose', onInstancedMeshDispose);\n\t\t\t\t}\n\n\t\t\t\tattributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);\n\n\t\t\t\tif (object.instanceColor !== null) {\n\t\t\t\t\tattributes.update(object.instanceColor, gl.ARRAY_BUFFER);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn buffergeometry;\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\tupdateMap = new WeakMap();\n\t\t}\n\n\t\tfunction onInstancedMeshDispose(event) {\n\t\t\tconst instancedMesh = event.target;\n\t\t\tinstancedMesh.removeEventListener('dispose', onInstancedMeshDispose);\n\t\t\tattributes.remove(instancedMesh.instanceMatrix);\n\t\t\tif (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);\n\t\t}\n\n\t\treturn {\n\t\t\tupdate: update,\n\t\t\tdispose: dispose\n\t\t};\n\t}\n\n\tclass DataTexture2DArray extends Texture {\n\t\tconstructor(data = null, width = 1, height = 1, depth = 1) {\n\t\t\tsuper(null);\n\t\t\tthis.image = {\n\t\t\t\tdata,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tdepth\n\t\t\t};\n\t\t\tthis.magFilter = NearestFilter;\n\t\t\tthis.minFilter = NearestFilter;\n\t\t\tthis.wrapR = ClampToEdgeWrapping;\n\t\t\tthis.generateMipmaps = false;\n\t\t\tthis.flipY = false;\n\t\t\tthis.unpackAlignment = 1;\n\t\t\tthis.needsUpdate = true;\n\t\t}\n\n\t}\n\n\tDataTexture2DArray.prototype.isDataTexture2DArray = true;\n\n\tclass DataTexture3D extends Texture {\n\t\tconstructor(data = null, width = 1, height = 1, depth = 1) {\n\t\t\t// We're going to add .setXXX() methods for setting properties later.\n\t\t\t// Users can still set in DataTexture3D directly.\n\t\t\t//\n\t\t\t//\tconst texture = new THREE.DataTexture3D( data, width, height, depth );\n\t\t\t// \ttexture.anisotropy = 16;\n\t\t\t//\n\t\t\t// See #14839\n\t\t\tsuper(null);\n\t\t\tthis.image = {\n\t\t\t\tdata,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tdepth\n\t\t\t};\n\t\t\tthis.magFilter = NearestFilter;\n\t\t\tthis.minFilter = NearestFilter;\n\t\t\tthis.wrapR = ClampToEdgeWrapping;\n\t\t\tthis.generateMipmaps = false;\n\t\t\tthis.flipY = false;\n\t\t\tthis.unpackAlignment = 1;\n\t\t\tthis.needsUpdate = true;\n\t\t}\n\n\t}\n\n\tDataTexture3D.prototype.isDataTexture3D = true;\n\n\t/**\n\t * Uniforms of a program.\n\t * Those form a tree structure with a special top-level container for the root,\n\t * which you get by calling 'new WebGLUniforms( gl, program )'.\n\t *\n\t *\n\t * Properties of inner nodes including the top-level container:\n\t *\n\t * .seq - array of nested uniforms\n\t * .map - nested uniforms by name\n\t *\n\t *\n\t * Methods of all nodes except the top-level container:\n\t *\n\t * .setValue( gl, value, [textures] )\n\t *\n\t * \t\tuploads a uniform value(s)\n\t *\t\tthe 'textures' parameter is needed for sampler uniforms\n\t *\n\t *\n\t * Static methods of the top-level container (textures factorizations):\n\t *\n\t * .upload( gl, seq, values, textures )\n\t *\n\t * \t\tsets uniforms in 'seq' to 'values[id].value'\n\t *\n\t * .seqWithValue( seq, values ) : filteredSeq\n\t *\n\t * \t\tfilters 'seq' entries with corresponding entry in values\n\t *\n\t *\n\t * Methods of the top-level container (textures factorizations):\n\t *\n\t * .setValue( gl, name, value, textures )\n\t *\n\t * \t\tsets uniform with\tname 'name' to 'value'\n\t *\n\t * .setOptional( gl, obj, prop )\n\t *\n\t * \t\tlike .set for an optional property of the object\n\t *\n\t */\n\tconst emptyTexture = new Texture();\n\tconst emptyTexture2dArray = new DataTexture2DArray();\n\tconst emptyTexture3d = new DataTexture3D();\n\tconst emptyCubeTexture = new CubeTexture(); // --- Utilities ---\n\t// Array Caches (provide typed arrays for temporary by size)\n\n\tconst arrayCacheF32 = [];\n\tconst arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms\n\n\tconst mat4array = new Float32Array(16);\n\tconst mat3array = new Float32Array(9);\n\tconst mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices\n\n\tfunction flatten(array, nBlocks, blockSize) {\n\t\tconst firstElem = array[0];\n\t\tif (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )\n\t\t// see http://jacksondunstan.com/articles/983\n\n\t\tconst n = nBlocks * blockSize;\n\t\tlet r = arrayCacheF32[n];\n\n\t\tif (r === undefined) {\n\t\t\tr = new Float32Array(n);\n\t\t\tarrayCacheF32[n] = r;\n\t\t}\n\n\t\tif (nBlocks !== 0) {\n\t\t\tfirstElem.toArray(r, 0);\n\n\t\t\tfor (let i = 1, offset = 0; i !== nBlocks; ++i) {\n\t\t\t\toffset += blockSize;\n\t\t\t\tarray[i].toArray(r, offset);\n\t\t\t}\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tfunction arraysEqual(a, b) {\n\t\tif (a.length !== b.length) return false;\n\n\t\tfor (let i = 0, l = a.length; i < l; i++) {\n\t\t\tif (a[i] !== b[i]) return false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction copyArray(a, b) {\n\t\tfor (let i = 0, l = b.length; i < l; i++) {\n\t\t\ta[i] = b[i];\n\t\t}\n\t} // Texture unit allocation\n\n\n\tfunction allocTexUnits(textures, n) {\n\t\tlet r = arrayCacheI32[n];\n\n\t\tif (r === undefined) {\n\t\t\tr = new Int32Array(n);\n\t\t\tarrayCacheI32[n] = r;\n\t\t}\n\n\t\tfor (let i = 0; i !== n; ++i) {\n\t\t\tr[i] = textures.allocateTextureUnit();\n\t\t}\n\n\t\treturn r;\n\t} // --- Setters ---\n\t// Note: Defining these methods externally, because they come in a bunch\n\t// and this way their names minify.\n\t// Single scalar\n\n\n\tfunction setValueV1f(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (cache[0] === v) return;\n\t\tgl.uniform1f(this.addr, v);\n\t\tcache[0] = v;\n\t} // Single float vector (from flat array or THREE.VectorN)\n\n\n\tfunction setValueV2f(gl, v) {\n\t\tconst cache = this.cache;\n\n\t\tif (v.x !== undefined) {\n\t\t\tif (cache[0] !== v.x || cache[1] !== v.y) {\n\t\t\t\tgl.uniform2f(this.addr, v.x, v.y);\n\t\t\t\tcache[0] = v.x;\n\t\t\t\tcache[1] = v.y;\n\t\t\t}\n\t\t} else {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniform2fv(this.addr, v);\n\t\t\tcopyArray(cache, v);\n\t\t}\n\t}\n\n\tfunction setValueV3f(gl, v) {\n\t\tconst cache = this.cache;\n\n\t\tif (v.x !== undefined) {\n\t\t\tif (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {\n\t\t\t\tgl.uniform3f(this.addr, v.x, v.y, v.z);\n\t\t\t\tcache[0] = v.x;\n\t\t\t\tcache[1] = v.y;\n\t\t\t\tcache[2] = v.z;\n\t\t\t}\n\t\t} else if (v.r !== undefined) {\n\t\t\tif (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {\n\t\t\t\tgl.uniform3f(this.addr, v.r, v.g, v.b);\n\t\t\t\tcache[0] = v.r;\n\t\t\t\tcache[1] = v.g;\n\t\t\t\tcache[2] = v.b;\n\t\t\t}\n\t\t} else {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniform3fv(this.addr, v);\n\t\t\tcopyArray(cache, v);\n\t\t}\n\t}\n\n\tfunction setValueV4f(gl, v) {\n\t\tconst cache = this.cache;\n\n\t\tif (v.x !== undefined) {\n\t\t\tif (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {\n\t\t\t\tgl.uniform4f(this.addr, v.x, v.y, v.z, v.w);\n\t\t\t\tcache[0] = v.x;\n\t\t\t\tcache[1] = v.y;\n\t\t\t\tcache[2] = v.z;\n\t\t\t\tcache[3] = v.w;\n\t\t\t}\n\t\t} else {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniform4fv(this.addr, v);\n\t\t\tcopyArray(cache, v);\n\t\t}\n\t} // Single matrix (from flat array or THREE.MatrixN)\n\n\n\tfunction setValueM2(gl, v) {\n\t\tconst cache = this.cache;\n\t\tconst elements = v.elements;\n\n\t\tif (elements === undefined) {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniformMatrix2fv(this.addr, false, v);\n\t\t\tcopyArray(cache, v);\n\t\t} else {\n\t\t\tif (arraysEqual(cache, elements)) return;\n\t\t\tmat2array.set(elements);\n\t\t\tgl.uniformMatrix2fv(this.addr, false, mat2array);\n\t\t\tcopyArray(cache, elements);\n\t\t}\n\t}\n\n\tfunction setValueM3(gl, v) {\n\t\tconst cache = this.cache;\n\t\tconst elements = v.elements;\n\n\t\tif (elements === undefined) {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniformMatrix3fv(this.addr, false, v);\n\t\t\tcopyArray(cache, v);\n\t\t} else {\n\t\t\tif (arraysEqual(cache, elements)) return;\n\t\t\tmat3array.set(elements);\n\t\t\tgl.uniformMatrix3fv(this.addr, false, mat3array);\n\t\t\tcopyArray(cache, elements);\n\t\t}\n\t}\n\n\tfunction setValueM4(gl, v) {\n\t\tconst cache = this.cache;\n\t\tconst elements = v.elements;\n\n\t\tif (elements === undefined) {\n\t\t\tif (arraysEqual(cache, v)) return;\n\t\t\tgl.uniformMatrix4fv(this.addr, false, v);\n\t\t\tcopyArray(cache, v);\n\t\t} else {\n\t\t\tif (arraysEqual(cache, elements)) return;\n\t\t\tmat4array.set(elements);\n\t\t\tgl.uniformMatrix4fv(this.addr, false, mat4array);\n\t\t\tcopyArray(cache, elements);\n\t\t}\n\t} // Single integer / boolean\n\n\n\tfunction setValueV1i(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (cache[0] === v) return;\n\t\tgl.uniform1i(this.addr, v);\n\t\tcache[0] = v;\n\t} // Single integer / boolean vector (from flat array)\n\n\n\tfunction setValueV2i(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform2iv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t}\n\n\tfunction setValueV3i(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform3iv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t}\n\n\tfunction setValueV4i(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform4iv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t} // Single unsigned integer\n\n\n\tfunction setValueV1ui(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (cache[0] === v) return;\n\t\tgl.uniform1ui(this.addr, v);\n\t\tcache[0] = v;\n\t} // Single unsigned integer vector (from flat array)\n\n\n\tfunction setValueV2ui(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform2uiv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t}\n\n\tfunction setValueV3ui(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform3uiv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t}\n\n\tfunction setValueV4ui(gl, v) {\n\t\tconst cache = this.cache;\n\t\tif (arraysEqual(cache, v)) return;\n\t\tgl.uniform4uiv(this.addr, v);\n\t\tcopyArray(cache, v);\n\t} // Single texture (2D / Cube)\n\n\n\tfunction setValueT1(gl, v, textures) {\n\t\tconst cache = this.cache;\n\t\tconst unit = textures.allocateTextureUnit();\n\n\t\tif (cache[0] !== unit) {\n\t\t\tgl.uniform1i(this.addr, unit);\n\t\t\tcache[0] = unit;\n\t\t}\n\n\t\ttextures.safeSetTexture2D(v || emptyTexture, unit);\n\t}\n\n\tfunction setValueT3D1(gl, v, textures) {\n\t\tconst cache = this.cache;\n\t\tconst unit = textures.allocateTextureUnit();\n\n\t\tif (cache[0] !== unit) {\n\t\t\tgl.uniform1i(this.addr, unit);\n\t\t\tcache[0] = unit;\n\t\t}\n\n\t\ttextures.setTexture3D(v || emptyTexture3d, unit);\n\t}\n\n\tfunction setValueT6(gl, v, textures) {\n\t\tconst cache = this.cache;\n\t\tconst unit = textures.allocateTextureUnit();\n\n\t\tif (cache[0] !== unit) {\n\t\t\tgl.uniform1i(this.addr, unit);\n\t\t\tcache[0] = unit;\n\t\t}\n\n\t\ttextures.safeSetTextureCube(v || emptyCubeTexture, unit);\n\t}\n\n\tfunction setValueT2DArray1(gl, v, textures) {\n\t\tconst cache = this.cache;\n\t\tconst unit = textures.allocateTextureUnit();\n\n\t\tif (cache[0] !== unit) {\n\t\t\tgl.uniform1i(this.addr, unit);\n\t\t\tcache[0] = unit;\n\t\t}\n\n\t\ttextures.setTexture2DArray(v || emptyTexture2dArray, unit);\n\t} // Helper to pick the right setter for the singular case\n\n\n\tfunction getSingularSetter(type) {\n\t\tswitch (type) {\n\t\t\tcase 0x1406:\n\t\t\t\treturn setValueV1f;\n\t\t\t// FLOAT\n\n\t\t\tcase 0x8b50:\n\t\t\t\treturn setValueV2f;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8b51:\n\t\t\t\treturn setValueV3f;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8b52:\n\t\t\t\treturn setValueV4f;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x8b5a:\n\t\t\t\treturn setValueM2;\n\t\t\t// _MAT2\n\n\t\t\tcase 0x8b5b:\n\t\t\t\treturn setValueM3;\n\t\t\t// _MAT3\n\n\t\t\tcase 0x8b5c:\n\t\t\t\treturn setValueM4;\n\t\t\t// _MAT4\n\n\t\t\tcase 0x1404:\n\t\t\tcase 0x8b56:\n\t\t\t\treturn setValueV1i;\n\t\t\t// INT, BOOL\n\n\t\t\tcase 0x8b53:\n\t\t\tcase 0x8b57:\n\t\t\t\treturn setValueV2i;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8b54:\n\t\t\tcase 0x8b58:\n\t\t\t\treturn setValueV3i;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8b55:\n\t\t\tcase 0x8b59:\n\t\t\t\treturn setValueV4i;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x1405:\n\t\t\t\treturn setValueV1ui;\n\t\t\t// UINT\n\n\t\t\tcase 0x8dc6:\n\t\t\t\treturn setValueV2ui;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8dc7:\n\t\t\t\treturn setValueV3ui;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8dc8:\n\t\t\t\treturn setValueV4ui;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x8b5e: // SAMPLER_2D\n\n\t\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\n\t\t\tcase 0x8dca: // INT_SAMPLER_2D\n\n\t\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\n\t\t\tcase 0x8b62:\n\t\t\t\t// SAMPLER_2D_SHADOW\n\t\t\t\treturn setValueT1;\n\n\t\t\tcase 0x8b5f: // SAMPLER_3D\n\n\t\t\tcase 0x8dcb: // INT_SAMPLER_3D\n\n\t\t\tcase 0x8dd3:\n\t\t\t\t// UNSIGNED_INT_SAMPLER_3D\n\t\t\t\treturn setValueT3D1;\n\n\t\t\tcase 0x8b60: // SAMPLER_CUBE\n\n\t\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\n\t\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\n\t\t\tcase 0x8dc5:\n\t\t\t\t// SAMPLER_CUBE_SHADOW\n\t\t\t\treturn setValueT6;\n\n\t\t\tcase 0x8dc1: // SAMPLER_2D_ARRAY\n\n\t\t\tcase 0x8dcf: // INT_SAMPLER_2D_ARRAY\n\n\t\t\tcase 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n\n\t\t\tcase 0x8dc4:\n\t\t\t\t// SAMPLER_2D_ARRAY_SHADOW\n\t\t\t\treturn setValueT2DArray1;\n\t\t}\n\t} // Array of scalars\n\n\n\tfunction setValueV1fArray(gl, v) {\n\t\tgl.uniform1fv(this.addr, v);\n\t} // Array of vectors (from flat array or array of THREE.VectorN)\n\n\n\tfunction setValueV2fArray(gl, v) {\n\t\tconst data = flatten(v, this.size, 2);\n\t\tgl.uniform2fv(this.addr, data);\n\t}\n\n\tfunction setValueV3fArray(gl, v) {\n\t\tconst data = flatten(v, this.size, 3);\n\t\tgl.uniform3fv(this.addr, data);\n\t}\n\n\tfunction setValueV4fArray(gl, v) {\n\t\tconst data = flatten(v, this.size, 4);\n\t\tgl.uniform4fv(this.addr, data);\n\t} // Array of matrices (from flat array or array of THREE.MatrixN)\n\n\n\tfunction setValueM2Array(gl, v) {\n\t\tconst data = flatten(v, this.size, 4);\n\t\tgl.uniformMatrix2fv(this.addr, false, data);\n\t}\n\n\tfunction setValueM3Array(gl, v) {\n\t\tconst data = flatten(v, this.size, 9);\n\t\tgl.uniformMatrix3fv(this.addr, false, data);\n\t}\n\n\tfunction setValueM4Array(gl, v) {\n\t\tconst data = flatten(v, this.size, 16);\n\t\tgl.uniformMatrix4fv(this.addr, false, data);\n\t} // Array of integer / boolean\n\n\n\tfunction setValueV1iArray(gl, v) {\n\t\tgl.uniform1iv(this.addr, v);\n\t} // Array of integer / boolean vectors (from flat array)\n\n\n\tfunction setValueV2iArray(gl, v) {\n\t\tgl.uniform2iv(this.addr, v);\n\t}\n\n\tfunction setValueV3iArray(gl, v) {\n\t\tgl.uniform3iv(this.addr, v);\n\t}\n\n\tfunction setValueV4iArray(gl, v) {\n\t\tgl.uniform4iv(this.addr, v);\n\t} // Array of unsigned integer\n\n\n\tfunction setValueV1uiArray(gl, v) {\n\t\tgl.uniform1uiv(this.addr, v);\n\t} // Array of unsigned integer vectors (from flat array)\n\n\n\tfunction setValueV2uiArray(gl, v) {\n\t\tgl.uniform2uiv(this.addr, v);\n\t}\n\n\tfunction setValueV3uiArray(gl, v) {\n\t\tgl.uniform3uiv(this.addr, v);\n\t}\n\n\tfunction setValueV4uiArray(gl, v) {\n\t\tgl.uniform4uiv(this.addr, v);\n\t} // Array of textures (2D / Cube)\n\n\n\tfunction setValueT1Array(gl, v, textures) {\n\t\tconst n = v.length;\n\t\tconst units = allocTexUnits(textures, n);\n\t\tgl.uniform1iv(this.addr, units);\n\n\t\tfor (let i = 0; i !== n; ++i) {\n\t\t\ttextures.safeSetTexture2D(v[i] || emptyTexture, units[i]);\n\t\t}\n\t}\n\n\tfunction setValueT6Array(gl, v, textures) {\n\t\tconst n = v.length;\n\t\tconst units = allocTexUnits(textures, n);\n\t\tgl.uniform1iv(this.addr, units);\n\n\t\tfor (let i = 0; i !== n; ++i) {\n\t\t\ttextures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);\n\t\t}\n\t} // Helper to pick the right setter for a pure (bottom-level) array\n\n\n\tfunction getPureArraySetter(type) {\n\t\tswitch (type) {\n\t\t\tcase 0x1406:\n\t\t\t\treturn setValueV1fArray;\n\t\t\t// FLOAT\n\n\t\t\tcase 0x8b50:\n\t\t\t\treturn setValueV2fArray;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8b51:\n\t\t\t\treturn setValueV3fArray;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8b52:\n\t\t\t\treturn setValueV4fArray;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x8b5a:\n\t\t\t\treturn setValueM2Array;\n\t\t\t// _MAT2\n\n\t\t\tcase 0x8b5b:\n\t\t\t\treturn setValueM3Array;\n\t\t\t// _MAT3\n\n\t\t\tcase 0x8b5c:\n\t\t\t\treturn setValueM4Array;\n\t\t\t// _MAT4\n\n\t\t\tcase 0x1404:\n\t\t\tcase 0x8b56:\n\t\t\t\treturn setValueV1iArray;\n\t\t\t// INT, BOOL\n\n\t\t\tcase 0x8b53:\n\t\t\tcase 0x8b57:\n\t\t\t\treturn setValueV2iArray;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8b54:\n\t\t\tcase 0x8b58:\n\t\t\t\treturn setValueV3iArray;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8b55:\n\t\t\tcase 0x8b59:\n\t\t\t\treturn setValueV4iArray;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x1405:\n\t\t\t\treturn setValueV1uiArray;\n\t\t\t// UINT\n\n\t\t\tcase 0x8dc6:\n\t\t\t\treturn setValueV2uiArray;\n\t\t\t// _VEC2\n\n\t\t\tcase 0x8dc7:\n\t\t\t\treturn setValueV3uiArray;\n\t\t\t// _VEC3\n\n\t\t\tcase 0x8dc8:\n\t\t\t\treturn setValueV4uiArray;\n\t\t\t// _VEC4\n\n\t\t\tcase 0x8b5e: // SAMPLER_2D\n\n\t\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\n\t\t\tcase 0x8dca: // INT_SAMPLER_2D\n\n\t\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\n\t\t\tcase 0x8b62:\n\t\t\t\t// SAMPLER_2D_SHADOW\n\t\t\t\treturn setValueT1Array;\n\n\t\t\tcase 0x8b60: // SAMPLER_CUBE\n\n\t\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\n\t\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\n\t\t\tcase 0x8dc5:\n\t\t\t\t// SAMPLER_CUBE_SHADOW\n\t\t\t\treturn setValueT6Array;\n\t\t}\n\t} // --- Uniform Classes ---\n\n\n\tfunction SingleUniform(id, activeInfo, addr) {\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.cache = [];\n\t\tthis.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG\n\t}\n\n\tfunction PureArrayUniform(id, activeInfo, addr) {\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.cache = [];\n\t\tthis.size = activeInfo.size;\n\t\tthis.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG\n\t}\n\n\tPureArrayUniform.prototype.updateCache = function (data) {\n\t\tconst cache = this.cache;\n\n\t\tif (data instanceof Float32Array && cache.length !== data.length) {\n\t\t\tthis.cache = new Float32Array(data.length);\n\t\t}\n\n\t\tcopyArray(cache, data);\n\t};\n\n\tfunction StructuredUniform(id) {\n\t\tthis.id = id;\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\t}\n\n\tStructuredUniform.prototype.setValue = function (gl, value, textures) {\n\t\tconst seq = this.seq;\n\n\t\tfor (let i = 0, n = seq.length; i !== n; ++i) {\n\t\t\tconst u = seq[i];\n\t\t\tu.setValue(gl, value[u.id], textures);\n\t\t}\n\t}; // --- Top-level ---\n\t// Parser - builds up the property tree from the path strings\n\n\n\tconst RePathPart = /(\\w+)(\\])?(\\[|\\.)?/g; // extracts\n\t// \t- the identifier (member name or array index)\n\t//\t- followed by an optional right bracket (found when array index)\n\t//\t- followed by an optional left bracket or dot (type of subscript)\n\t//\n\t// Note: These portions can be read in a non-overlapping fashion and\n\t// allow straightforward parsing of the hierarchy that WebGL encodes\n\t// in the uniform names.\n\n\tfunction addUniform(container, uniformObject) {\n\t\tcontainer.seq.push(uniformObject);\n\t\tcontainer.map[uniformObject.id] = uniformObject;\n\t}\n\n\tfunction parseUniform(activeInfo, addr, container) {\n\t\tconst path = activeInfo.name,\n\t\t\t\t\tpathLength = path.length; // reset RegExp object, because of the early exit of a previous run\n\n\t\tRePathPart.lastIndex = 0;\n\n\t\twhile (true) {\n\t\t\tconst match = RePathPart.exec(path),\n\t\t\t\t\t\tmatchEnd = RePathPart.lastIndex;\n\t\t\tlet id = match[1];\n\t\t\tconst idIsIndex = match[2] === ']',\n\t\t\t\t\t\tsubscript = match[3];\n\t\t\tif (idIsIndex) id = id | 0; // convert to integer\n\n\t\t\tif (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {\n\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\t\t\t\taddUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// step into inner node / create it in case it doesn't exist\n\t\t\t\tconst map = container.map;\n\t\t\t\tlet next = map[id];\n\n\t\t\t\tif (next === undefined) {\n\t\t\t\t\tnext = new StructuredUniform(id);\n\t\t\t\t\taddUniform(container, next);\n\t\t\t\t}\n\n\t\t\t\tcontainer = next;\n\t\t\t}\n\t\t}\n\t} // Root Container\n\n\n\tfunction WebGLUniforms(gl, program) {\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\t\tconst n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n\t\tfor (let i = 0; i < n; ++i) {\n\t\t\tconst info = gl.getActiveUniform(program, i),\n\t\t\t\t\t\taddr = gl.getUniformLocation(program, info.name);\n\t\t\tparseUniform(info, addr, this);\n\t\t}\n\t}\n\n\tWebGLUniforms.prototype.setValue = function (gl, name, value, textures) {\n\t\tconst u = this.map[name];\n\t\tif (u !== undefined) u.setValue(gl, value, textures);\n\t};\n\n\tWebGLUniforms.prototype.setOptional = function (gl, object, name) {\n\t\tconst v = object[name];\n\t\tif (v !== undefined) this.setValue(gl, name, v);\n\t}; // Static interface\n\n\n\tWebGLUniforms.upload = function (gl, seq, values, textures) {\n\t\tfor (let i = 0, n = seq.length; i !== n; ++i) {\n\t\t\tconst u = seq[i],\n\t\t\t\t\t\tv = values[u.id];\n\n\t\t\tif (v.needsUpdate !== false) {\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\t\t\t\tu.setValue(gl, v.value, textures);\n\t\t\t}\n\t\t}\n\t};\n\n\tWebGLUniforms.seqWithValue = function (seq, values) {\n\t\tconst r = [];\n\n\t\tfor (let i = 0, n = seq.length; i !== n; ++i) {\n\t\t\tconst u = seq[i];\n\t\t\tif (u.id in values) r.push(u);\n\t\t}\n\n\t\treturn r;\n\t};\n\n\tfunction WebGLShader(gl, type, string) {\n\t\tconst shader = gl.createShader(type);\n\t\tgl.shaderSource(shader, string);\n\t\tgl.compileShader(shader);\n\t\treturn shader;\n\t}\n\n\tlet programIdCount = 0;\n\n\tfunction addLineNumbers(string) {\n\t\tconst lines = string.split('\\n');\n\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tlines[i] = i + 1 + ': ' + lines[i];\n\t\t}\n\n\t\treturn lines.join('\\n');\n\t}\n\n\tfunction getEncodingComponents(encoding) {\n\t\tswitch (encoding) {\n\t\t\tcase LinearEncoding:\n\t\t\t\treturn ['Linear', '( value )'];\n\n\t\t\tcase sRGBEncoding:\n\t\t\t\treturn ['sRGB', '( value )'];\n\n\t\t\tcase RGBEEncoding:\n\t\t\t\treturn ['RGBE', '( value )'];\n\n\t\t\tcase RGBM7Encoding:\n\t\t\t\treturn ['RGBM', '( value, 7.0 )'];\n\n\t\t\tcase RGBM16Encoding:\n\t\t\t\treturn ['RGBM', '( value, 16.0 )'];\n\n\t\t\tcase RGBDEncoding:\n\t\t\t\treturn ['RGBD', '( value, 256.0 )'];\n\n\t\t\tcase GammaEncoding:\n\t\t\t\treturn ['Gamma', '( value, float( GAMMA_FACTOR ) )'];\n\n\t\t\tcase LogLuvEncoding:\n\t\t\t\treturn ['LogLuv', '( value )'];\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);\n\t\t\t\treturn ['Linear', '( value )'];\n\t\t}\n\t}\n\n\tfunction getShaderErrors(gl, shader, type) {\n\t\tconst status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\t\tconst log = gl.getShaderInfoLog(shader).trim();\n\t\tif (status && log === '') return ''; // --enable-privileged-webgl-extension\n\t\t// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\tconst source = gl.getShaderSource(shader);\n\t\treturn 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\\n' + log + addLineNumbers(source);\n\t}\n\n\tfunction getTexelDecodingFunction(functionName, encoding) {\n\t\tconst components = getEncodingComponents(encoding);\n\t\treturn 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';\n\t}\n\n\tfunction getTexelEncodingFunction(functionName, encoding) {\n\t\tconst components = getEncodingComponents(encoding);\n\t\treturn 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';\n\t}\n\n\tfunction getToneMappingFunction(functionName, toneMapping) {\n\t\tlet toneMappingName;\n\n\t\tswitch (toneMapping) {\n\t\t\tcase LinearToneMapping:\n\t\t\t\ttoneMappingName = 'Linear';\n\t\t\t\tbreak;\n\n\t\t\tcase ReinhardToneMapping:\n\t\t\t\ttoneMappingName = 'Reinhard';\n\t\t\t\tbreak;\n\n\t\t\tcase CineonToneMapping:\n\t\t\t\ttoneMappingName = 'OptimizedCineon';\n\t\t\t\tbreak;\n\n\t\t\tcase ACESFilmicToneMapping:\n\t\t\t\ttoneMappingName = 'ACESFilmic';\n\t\t\t\tbreak;\n\n\t\t\tcase CustomToneMapping:\n\t\t\t\ttoneMappingName = 'Custom';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);\n\t\t\t\ttoneMappingName = 'Linear';\n\t\t}\n\n\t\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\n\t}\n\n\tfunction generateExtensions(parameters) {\n\t\tconst chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission > 0.0) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];\n\t\treturn chunks.filter(filterEmptyLine).join('\\n');\n\t}\n\n\tfunction generateDefines(defines) {\n\t\tconst chunks = [];\n\n\t\tfor (const name in defines) {\n\t\t\tconst value = defines[name];\n\t\t\tif (value === false) continue;\n\t\t\tchunks.push('#define ' + name + ' ' + value);\n\t\t}\n\n\t\treturn chunks.join('\\n');\n\t}\n\n\tfunction fetchAttributeLocations(gl, program) {\n\t\tconst attributes = {};\n\t\tconst n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tconst info = gl.getActiveAttrib(program, i);\n\t\t\tconst name = info.name; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\n\n\t\t\tattributes[name] = gl.getAttribLocation(program, name);\n\t\t}\n\n\t\treturn attributes;\n\t}\n\n\tfunction filterEmptyLine(string) {\n\t\treturn string !== '';\n\t}\n\n\tfunction replaceLightNums(string, parameters) {\n\t\treturn string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);\n\t}\n\n\tfunction replaceClippingPlaneNums(string, parameters) {\n\t\treturn string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);\n\t} // Resolve Includes\n\n\n\tconst includePattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\n\tfunction resolveIncludes(string) {\n\t\treturn string.replace(includePattern, includeReplacer);\n\t}\n\n\tfunction includeReplacer(match, include) {\n\t\tconst string = ShaderChunk[include];\n\n\t\tif (string === undefined) {\n\t\t\tthrow new Error('Can not resolve #include <' + include + '>');\n\t\t}\n\n\t\treturn resolveIncludes(string);\n\t} // Unroll Loops\n\n\n\tconst deprecatedUnrollLoopPattern = /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\n\tconst unrollLoopPattern = /#pragma unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma unroll_loop_end/g;\n\n\tfunction unrollLoops(string) {\n\t\treturn string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);\n\t}\n\n\tfunction deprecatedLoopReplacer(match, start, end, snippet) {\n\t\tconsole.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');\n\t\treturn loopReplacer(match, start, end, snippet);\n\t}\n\n\tfunction loopReplacer(match, start, end, snippet) {\n\t\tlet string = '';\n\n\t\tfor (let i = parseInt(start); i < parseInt(end); i++) {\n\t\t\tstring += snippet.replace(/\\[\\s*i\\s*\\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);\n\t\t}\n\n\t\treturn string;\n\t} //\n\n\n\tfunction generatePrecision(parameters) {\n\t\tlet precisionstring = 'precision ' + parameters.precision + ' float;\\nprecision ' + parameters.precision + ' int;';\n\n\t\tif (parameters.precision === 'highp') {\n\t\t\tprecisionstring += '\\n#define HIGH_PRECISION';\n\t\t} else if (parameters.precision === 'mediump') {\n\t\t\tprecisionstring += '\\n#define MEDIUM_PRECISION';\n\t\t} else if (parameters.precision === 'lowp') {\n\t\t\tprecisionstring += '\\n#define LOW_PRECISION';\n\t\t}\n\n\t\treturn precisionstring;\n\t}\n\n\tfunction generateShadowMapTypeDefine(parameters) {\n\t\tlet shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\t\tif (parameters.shadowMapType === PCFShadowMap) {\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\t\t} else if (parameters.shadowMapType === PCFSoftShadowMap) {\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\t\t} else if (parameters.shadowMapType === VSMShadowMap) {\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';\n\t\t}\n\n\t\treturn shadowMapTypeDefine;\n\t}\n\n\tfunction generateEnvMapTypeDefine(parameters) {\n\t\tlet envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\n\t\tif (parameters.envMap) {\n\t\t\tswitch (parameters.envMapMode) {\n\t\t\t\tcase CubeReflectionMapping:\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CubeUVReflectionMapping:\n\t\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn envMapTypeDefine;\n\t}\n\n\tfunction generateEnvMapModeDefine(parameters) {\n\t\tlet envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\n\t\tif (parameters.envMap) {\n\t\t\tswitch (parameters.envMapMode) {\n\t\t\t\tcase CubeRefractionMapping:\n\t\t\t\tcase CubeUVRefractionMapping:\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn envMapModeDefine;\n\t}\n\n\tfunction generateEnvMapBlendingDefine(parameters) {\n\t\tlet envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';\n\n\t\tif (parameters.envMap) {\n\t\t\tswitch (parameters.combine) {\n\t\t\t\tcase MultiplyOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MixOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AddOperation:\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn envMapBlendingDefine;\n\t}\n\n\tfunction WebGLProgram(renderer, cacheKey, parameters, bindingStates) {\n\t\tconst gl = renderer.getContext();\n\t\tconst defines = parameters.defines;\n\t\tlet vertexShader = parameters.vertexShader;\n\t\tlet fragmentShader = parameters.fragmentShader;\n\t\tconst shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);\n\t\tconst envMapTypeDefine = generateEnvMapTypeDefine(parameters);\n\t\tconst envMapModeDefine = generateEnvMapModeDefine(parameters);\n\t\tconst envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);\n\t\tconst gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;\n\t\tconst customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);\n\t\tconst customDefines = generateDefines(defines);\n\t\tconst program = gl.createProgram();\n\t\tlet prefixVertex, prefixFragment;\n\t\tlet versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\\n' : '';\n\n\t\tif (parameters.isRawShaderMaterial) {\n\t\t\tprefixVertex = [customDefines].filter(filterEmptyLine).join('\\n');\n\n\t\t\tif (prefixVertex.length > 0) {\n\t\t\t\tprefixVertex += '\\n';\n\t\t\t}\n\n\t\t\tprefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\\n');\n\n\t\t\tif (prefixFragment.length > 0) {\n\t\t\t\tprefixFragment += '\\n';\n\t\t\t}\n\t\t} else {\n\t\t\tprefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '\tattribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '\tattribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '\tattribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '\tattribute vec4 color;', '#elif defined( USE_COLOR )', '\tattribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '\tattribute vec3 morphTarget0;', '\tattribute vec3 morphTarget1;', '\tattribute vec3 morphTarget2;', '\tattribute vec3 morphTarget3;', '\t#ifdef USE_MORPHNORMALS', '\t\tattribute vec3 morphNormal0;', '\t\tattribute vec3 morphNormal1;', '\t\tattribute vec3 morphNormal2;', '\t\tattribute vec3 morphNormal3;', '\t#else', '\t\tattribute vec3 morphTarget4;', '\t\tattribute vec3 morphTarget5;', '\t\tattribute vec3 morphTarget6;', '\t\tattribute vec3 morphTarget7;', '\t#endif', '#endif', '#ifdef USE_SKINNING', '\tattribute vec4 skinIndex;', '\tattribute vec4 skinWeight;', '#endif', '\\n'].filter(filterEmptyLine).join('\\n');\n\t\t\tprefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer\n\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below\n\t\t\tparameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\tparameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\\n'].filter(filterEmptyLine).join('\\n');\n\t\t}\n\n\t\tvertexShader = resolveIncludes(vertexShader);\n\t\tvertexShader = replaceLightNums(vertexShader, parameters);\n\t\tvertexShader = replaceClippingPlaneNums(vertexShader, parameters);\n\t\tfragmentShader = resolveIncludes(fragmentShader);\n\t\tfragmentShader = replaceLightNums(fragmentShader, parameters);\n\t\tfragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);\n\t\tvertexShader = unrollLoops(vertexShader);\n\t\tfragmentShader = unrollLoops(fragmentShader);\n\n\t\tif (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {\n\t\t\t// GLSL 3.0 conversion for built-in materials and ShaderMaterial\n\t\t\tversionString = '#version 300 es\\n';\n\t\t\tprefixVertex = ['#define attribute in', '#define varying out', '#define texture2D texture'].join('\\n') + '\\n' + prefixVertex;\n\t\t\tprefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\\n') + '\\n' + prefixFragment;\n\t\t}\n\n\t\tconst vertexGlsl = versionString + prefixVertex + vertexShader;\n\t\tconst fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\t\tconst glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);\n\t\tconst glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);\n\t\tgl.attachShader(program, glVertexShader);\n\t\tgl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.\n\n\t\tif (parameters.index0AttributeName !== undefined) {\n\t\t\tgl.bindAttribLocation(program, 0, parameters.index0AttributeName);\n\t\t} else if (parameters.morphTargets === true) {\n\t\t\t// programs with morphTargets displace position out of attribute 0\n\t\t\tgl.bindAttribLocation(program, 0, 'position');\n\t\t}\n\n\t\tgl.linkProgram(program); // check for link errors\n\n\t\tif (renderer.debug.checkShaderErrors) {\n\t\t\tconst programLog = gl.getProgramInfoLog(program).trim();\n\t\t\tconst vertexLog = gl.getShaderInfoLog(glVertexShader).trim();\n\t\t\tconst fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();\n\t\t\tlet runnable = true;\n\t\t\tlet haveDiagnostics = true;\n\n\t\t\tif (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n\t\t\t\trunnable = false;\n\t\t\t\tconst vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');\n\t\t\t\tconst fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');\n\t\t\t\tconsole.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);\n\t\t\t} else if (programLog !== '') {\n\t\t\t\tconsole.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);\n\t\t\t} else if (vertexLog === '' || fragmentLog === '') {\n\t\t\t\thaveDiagnostics = false;\n\t\t\t}\n\n\t\t\tif (haveDiagnostics) {\n\t\t\t\tthis.diagnostics = {\n\t\t\t\t\trunnable: runnable,\n\t\t\t\t\tprogramLog: programLog,\n\t\t\t\t\tvertexShader: {\n\t\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\t\tprefix: prefixVertex\n\t\t\t\t\t},\n\t\t\t\t\tfragmentShader: {\n\t\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\t\tprefix: prefixFragment\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t} // Clean up\n\t\t// Crashes in iOS9 and iOS10. #18402\n\t\t// gl.detachShader( program, glVertexShader );\n\t\t// gl.detachShader( program, glFragmentShader );\n\n\n\t\tgl.deleteShader(glVertexShader);\n\t\tgl.deleteShader(glFragmentShader); // set up caching for uniform locations\n\n\t\tlet cachedUniforms;\n\n\t\tthis.getUniforms = function () {\n\t\t\tif (cachedUniforms === undefined) {\n\t\t\t\tcachedUniforms = new WebGLUniforms(gl, program);\n\t\t\t}\n\n\t\t\treturn cachedUniforms;\n\t\t}; // set up caching for attribute locations\n\n\n\t\tlet cachedAttributes;\n\n\t\tthis.getAttributes = function () {\n\t\t\tif (cachedAttributes === undefined) {\n\t\t\t\tcachedAttributes = fetchAttributeLocations(gl, program);\n\t\t\t}\n\n\t\t\treturn cachedAttributes;\n\t\t}; // free resource\n\n\n\t\tthis.destroy = function () {\n\t\t\tbindingStates.releaseStatesOfProgram(this);\n\t\t\tgl.deleteProgram(program);\n\t\t\tthis.program = undefined;\n\t\t}; //\n\n\n\t\tthis.name = parameters.shaderName;\n\t\tthis.id = programIdCount++;\n\t\tthis.cacheKey = cacheKey;\n\t\tthis.usedTimes = 1;\n\t\tthis.program = program;\n\t\tthis.vertexShader = glVertexShader;\n\t\tthis.fragmentShader = glFragmentShader;\n\t\treturn this;\n\t}\n\n\tfunction WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {\n\t\tconst programs = [];\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\t\tconst logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\n\t\tconst floatVertexTextures = capabilities.floatVertexTextures;\n\t\tconst maxVertexUniforms = capabilities.maxVertexUniforms;\n\t\tconst vertexTextures = capabilities.vertexTextures;\n\t\tlet precision = capabilities.precision;\n\t\tconst shaderIDs = {\n\t\t\tMeshDepthMaterial: 'depth',\n\t\t\tMeshDistanceMaterial: 'distanceRGBA',\n\t\t\tMeshNormalMaterial: 'normal',\n\t\t\tMeshBasicMaterial: 'basic',\n\t\t\tMeshLambertMaterial: 'lambert',\n\t\t\tMeshPhongMaterial: 'phong',\n\t\t\tMeshToonMaterial: 'toon',\n\t\t\tMeshStandardMaterial: 'physical',\n\t\t\tMeshPhysicalMaterial: 'physical',\n\t\t\tMeshMatcapMaterial: 'matcap',\n\t\t\tLineBasicMaterial: 'basic',\n\t\t\tLineDashedMaterial: 'dashed',\n\t\t\tPointsMaterial: 'points',\n\t\t\tShadowMaterial: 'shadow',\n\t\t\tSpriteMaterial: 'sprite'\n\t\t};\n\t\tconst parameterNames = ['precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor', 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV', 'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap', 'roughnessMap', 'metalnessMap', 'gradientMap', 'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2', 'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning', 'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha', 'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights', 'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows', 'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights', 'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering', 'sheen', 'transmission', 'transmissionMap', 'thicknessMap'];\n\n\t\tfunction getMaxBones(object) {\n\t\t\tconst skeleton = object.skeleton;\n\t\t\tconst bones = skeleton.bones;\n\n\t\t\tif (floatVertexTextures) {\n\t\t\t\treturn 1024;\n\t\t\t} else {\n\t\t\t\t// default for when object is not specified\n\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\n\t\t\t\t//\n\t\t\t\t//\t- leave some extra space for other uniforms\n\t\t\t\t//\t- limit here is ANGLE's 254 max uniform vectors\n\t\t\t\t//\t\t(up to 54 should be safe)\n\t\t\t\tconst nVertexUniforms = maxVertexUniforms;\n\t\t\t\tconst nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);\n\t\t\t\tconst maxBones = Math.min(nVertexMatrices, bones.length);\n\n\t\t\t\tif (maxBones < bones.length) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn maxBones;\n\t\t\t}\n\t\t}\n\n\t\tfunction getTextureEncodingFromMap(map) {\n\t\t\tlet encoding;\n\n\t\t\tif (map && map.isTexture) {\n\t\t\t\tencoding = map.encoding;\n\t\t\t} else if (map && map.isWebGLRenderTarget) {\n\t\t\t\tconsole.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\\'t use render targets as textures. Use their .texture property instead.');\n\t\t\t\tencoding = map.texture.encoding;\n\t\t\t} else {\n\t\t\t\tencoding = LinearEncoding;\n\t\t\t}\n\n\t\t\treturn encoding;\n\t\t}\n\n\t\tfunction getParameters(material, lights, shadows, scene, object) {\n\t\t\tconst fog = scene.fog;\n\t\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tconst envMap = cubemaps.get(material.envMap || environment);\n\t\t\tconst shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene\n\t\t\t// (not to blow over maxLights budget)\n\n\t\t\tconst maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;\n\n\t\t\tif (material.precision !== null) {\n\t\t\t\tprecision = capabilities.getMaxPrecision(material.precision);\n\n\t\t\t\tif (precision !== material.precision) {\n\t\t\t\t\tconsole.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet vertexShader, fragmentShader;\n\n\t\t\tif (shaderID) {\n\t\t\t\tconst shader = ShaderLib[shaderID];\n\t\t\t\tvertexShader = shader.vertexShader;\n\t\t\t\tfragmentShader = shader.fragmentShader;\n\t\t\t} else {\n\t\t\t\tvertexShader = material.vertexShader;\n\t\t\t\tfragmentShader = material.fragmentShader;\n\t\t\t}\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\t\t\tconst parameters = {\n\t\t\t\tisWebGL2: isWebGL2,\n\t\t\t\tshaderID: shaderID,\n\t\t\t\tshaderName: material.type,\n\t\t\t\tvertexShader: vertexShader,\n\t\t\t\tfragmentShader: fragmentShader,\n\t\t\t\tdefines: material.defines,\n\t\t\t\tisRawShaderMaterial: material.isRawShaderMaterial === true,\n\t\t\t\tglslVersion: material.glslVersion,\n\t\t\t\tprecision: precision,\n\t\t\t\tinstancing: object.isInstancedMesh === true,\n\t\t\t\tinstancingColor: object.isInstancedMesh === true && object.instanceColor !== null,\n\t\t\t\tsupportsVertexTextures: vertexTextures,\n\t\t\t\toutputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,\n\t\t\t\tmap: !!material.map,\n\t\t\t\tmapEncoding: getTextureEncodingFromMap(material.map),\n\t\t\t\tmatcap: !!material.matcap,\n\t\t\t\tmatcapEncoding: getTextureEncodingFromMap(material.matcap),\n\t\t\t\tenvMap: !!envMap,\n\t\t\t\tenvMapMode: envMap && envMap.mapping,\n\t\t\t\tenvMapEncoding: getTextureEncodingFromMap(envMap),\n\t\t\t\tenvMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),\n\t\t\t\tlightMap: !!material.lightMap,\n\t\t\t\tlightMapEncoding: getTextureEncodingFromMap(material.lightMap),\n\t\t\t\taoMap: !!material.aoMap,\n\t\t\t\temissiveMap: !!material.emissiveMap,\n\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),\n\t\t\t\tbumpMap: !!material.bumpMap,\n\t\t\t\tnormalMap: !!material.normalMap,\n\t\t\t\tobjectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,\n\t\t\t\ttangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,\n\t\t\t\tclearcoatMap: !!material.clearcoatMap,\n\t\t\t\tclearcoatRoughnessMap: !!material.clearcoatRoughnessMap,\n\t\t\t\tclearcoatNormalMap: !!material.clearcoatNormalMap,\n\t\t\t\tdisplacementMap: !!material.displacementMap,\n\t\t\t\troughnessMap: !!material.roughnessMap,\n\t\t\t\tmetalnessMap: !!material.metalnessMap,\n\t\t\t\tspecularMap: !!material.specularMap,\n\t\t\t\talphaMap: !!material.alphaMap,\n\t\t\t\tgradientMap: !!material.gradientMap,\n\t\t\t\tsheen: !!material.sheen,\n\t\t\t\ttransmission: !!material.transmission,\n\t\t\t\ttransmissionMap: !!material.transmissionMap,\n\t\t\t\tthicknessMap: !!material.thicknessMap,\n\t\t\t\tcombine: material.combine,\n\t\t\t\tvertexTangents: material.normalMap && material.vertexTangents,\n\t\t\t\tvertexColors: material.vertexColors,\n\t\t\t\tvertexAlphas: material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,\n\t\t\t\tvertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmission || !!material.transmissionMap || !!material.thicknessMap,\n\t\t\t\tuvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmission || !!material.transmissionMap || !!material.thicknessMap) && !!material.displacementMap,\n\t\t\t\tfog: !!fog,\n\t\t\t\tuseFog: material.fog,\n\t\t\t\tfogExp2: fog && fog.isFogExp2,\n\t\t\t\tflatShading: !!material.flatShading,\n\t\t\t\tsizeAttenuation: material.sizeAttenuation,\n\t\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\t\t\t\tskinning: object.isSkinnedMesh === true && maxBones > 0,\n\t\t\t\tmaxBones: maxBones,\n\t\t\t\tuseVertexTexture: floatVertexTextures,\n\t\t\t\tmorphTargets: material.morphTargets,\n\t\t\t\tmorphNormals: material.morphNormals,\n\t\t\t\tnumDirLights: lights.directional.length,\n\t\t\t\tnumPointLights: lights.point.length,\n\t\t\t\tnumSpotLights: lights.spot.length,\n\t\t\t\tnumRectAreaLights: lights.rectArea.length,\n\t\t\t\tnumHemiLights: lights.hemi.length,\n\t\t\t\tnumDirLightShadows: lights.directionalShadowMap.length,\n\t\t\t\tnumPointLightShadows: lights.pointShadowMap.length,\n\t\t\t\tnumSpotLightShadows: lights.spotShadowMap.length,\n\t\t\t\tnumClippingPlanes: clipping.numPlanes,\n\t\t\t\tnumClipIntersection: clipping.numIntersection,\n\t\t\t\tdithering: material.dithering,\n\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,\n\t\t\t\tshadowMapType: renderer.shadowMap.type,\n\t\t\t\ttoneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,\n\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\n\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\t\t\t\talphaTest: material.alphaTest,\n\t\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\t\tflipSided: material.side === BackSide,\n\t\t\t\tdepthPacking: material.depthPacking !== undefined ? material.depthPacking : false,\n\t\t\t\tindex0AttributeName: material.index0AttributeName,\n\t\t\t\textensionDerivatives: material.extensions && material.extensions.derivatives,\n\t\t\t\textensionFragDepth: material.extensions && material.extensions.fragDepth,\n\t\t\t\textensionDrawBuffers: material.extensions && material.extensions.drawBuffers,\n\t\t\t\textensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,\n\t\t\t\trendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),\n\t\t\t\trendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),\n\t\t\t\trendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),\n\t\t\t\tcustomProgramCacheKey: material.customProgramCacheKey()\n\t\t\t};\n\t\t\treturn parameters;\n\t\t}\n\n\t\tfunction getProgramCacheKey(parameters) {\n\t\t\tconst array = [];\n\n\t\t\tif (parameters.shaderID) {\n\t\t\t\tarray.push(parameters.shaderID);\n\t\t\t} else {\n\t\t\t\tarray.push(parameters.fragmentShader);\n\t\t\t\tarray.push(parameters.vertexShader);\n\t\t\t}\n\n\t\t\tif (parameters.defines !== undefined) {\n\t\t\t\tfor (const name in parameters.defines) {\n\t\t\t\t\tarray.push(name);\n\t\t\t\t\tarray.push(parameters.defines[name]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (parameters.isRawShaderMaterial === false) {\n\t\t\t\tfor (let i = 0; i < parameterNames.length; i++) {\n\t\t\t\t\tarray.push(parameters[parameterNames[i]]);\n\t\t\t\t}\n\n\t\t\t\tarray.push(renderer.outputEncoding);\n\t\t\t\tarray.push(renderer.gammaFactor);\n\t\t\t}\n\n\t\t\tarray.push(parameters.customProgramCacheKey);\n\t\t\treturn array.join();\n\t\t}\n\n\t\tfunction getUniforms(material) {\n\t\t\tconst shaderID = shaderIDs[material.type];\n\t\t\tlet uniforms;\n\n\t\t\tif (shaderID) {\n\t\t\t\tconst shader = ShaderLib[shaderID];\n\t\t\t\tuniforms = UniformsUtils.clone(shader.uniforms);\n\t\t\t} else {\n\t\t\t\tuniforms = material.uniforms;\n\t\t\t}\n\n\t\t\treturn uniforms;\n\t\t}\n\n\t\tfunction acquireProgram(parameters, cacheKey) {\n\t\t\tlet program; // Check if code has been already compiled\n\n\t\t\tfor (let p = 0, pl = programs.length; p < pl; p++) {\n\t\t\t\tconst preexistingProgram = programs[p];\n\n\t\t\t\tif (preexistingProgram.cacheKey === cacheKey) {\n\t\t\t\t\tprogram = preexistingProgram;\n\t\t\t\t\t++program.usedTimes;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (program === undefined) {\n\t\t\t\tprogram = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);\n\t\t\t\tprograms.push(program);\n\t\t\t}\n\n\t\t\treturn program;\n\t\t}\n\n\t\tfunction releaseProgram(program) {\n\t\t\tif (--program.usedTimes === 0) {\n\t\t\t\t// Remove from unordered set\n\t\t\t\tconst i = programs.indexOf(program);\n\t\t\t\tprograms[i] = programs[programs.length - 1];\n\t\t\t\tprograms.pop(); // Free WebGL resources\n\n\t\t\t\tprogram.destroy();\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tgetParameters: getParameters,\n\t\t\tgetProgramCacheKey: getProgramCacheKey,\n\t\t\tgetUniforms: getUniforms,\n\t\t\tacquireProgram: acquireProgram,\n\t\t\treleaseProgram: releaseProgram,\n\t\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\t\tprograms: programs\n\t\t};\n\t}\n\n\tfunction WebGLProperties() {\n\t\tlet properties = new WeakMap();\n\n\t\tfunction get(object) {\n\t\t\tlet map = properties.get(object);\n\n\t\t\tif (map === undefined) {\n\t\t\t\tmap = {};\n\t\t\t\tproperties.set(object, map);\n\t\t\t}\n\n\t\t\treturn map;\n\t\t}\n\n\t\tfunction remove(object) {\n\t\t\tproperties.delete(object);\n\t\t}\n\n\t\tfunction update(object, key, value) {\n\t\t\tproperties.get(object)[key] = value;\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\tproperties = new WeakMap();\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tremove: remove,\n\t\t\tupdate: update,\n\t\t\tdispose: dispose\n\t\t};\n\t}\n\n\tfunction painterSortStable(a, b) {\n\t\tif (a.groupOrder !== b.groupOrder) {\n\t\t\treturn a.groupOrder - b.groupOrder;\n\t\t} else if (a.renderOrder !== b.renderOrder) {\n\t\t\treturn a.renderOrder - b.renderOrder;\n\t\t} else if (a.program !== b.program) {\n\t\t\treturn a.program.id - b.program.id;\n\t\t} else if (a.material.id !== b.material.id) {\n\t\t\treturn a.material.id - b.material.id;\n\t\t} else if (a.z !== b.z) {\n\t\t\treturn a.z - b.z;\n\t\t} else {\n\t\t\treturn a.id - b.id;\n\t\t}\n\t}\n\n\tfunction reversePainterSortStable(a, b) {\n\t\tif (a.groupOrder !== b.groupOrder) {\n\t\t\treturn a.groupOrder - b.groupOrder;\n\t\t} else if (a.renderOrder !== b.renderOrder) {\n\t\t\treturn a.renderOrder - b.renderOrder;\n\t\t} else if (a.z !== b.z) {\n\t\t\treturn b.z - a.z;\n\t\t} else {\n\t\t\treturn a.id - b.id;\n\t\t}\n\t}\n\n\tfunction WebGLRenderList(properties) {\n\t\tconst renderItems = [];\n\t\tlet renderItemsIndex = 0;\n\t\tconst opaque = [];\n\t\tconst transmissive = [];\n\t\tconst transparent = [];\n\t\tconst defaultProgram = {\n\t\t\tid: -1\n\t\t};\n\n\t\tfunction init() {\n\t\t\trenderItemsIndex = 0;\n\t\t\topaque.length = 0;\n\t\t\ttransmissive.length = 0;\n\t\t\ttransparent.length = 0;\n\t\t}\n\n\t\tfunction getNextRenderItem(object, geometry, material, groupOrder, z, group) {\n\t\t\tlet renderItem = renderItems[renderItemsIndex];\n\t\t\tconst materialProperties = properties.get(material);\n\n\t\t\tif (renderItem === undefined) {\n\t\t\t\trenderItem = {\n\t\t\t\t\tid: object.id,\n\t\t\t\t\tobject: object,\n\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\tmaterial: material,\n\t\t\t\t\tprogram: materialProperties.program || defaultProgram,\n\t\t\t\t\tgroupOrder: groupOrder,\n\t\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\t\tz: z,\n\t\t\t\t\tgroup: group\n\t\t\t\t};\n\t\t\t\trenderItems[renderItemsIndex] = renderItem;\n\t\t\t} else {\n\t\t\t\trenderItem.id = object.id;\n\t\t\t\trenderItem.object = object;\n\t\t\t\trenderItem.geometry = geometry;\n\t\t\t\trenderItem.material = material;\n\t\t\t\trenderItem.program = materialProperties.program || defaultProgram;\n\t\t\t\trenderItem.groupOrder = groupOrder;\n\t\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\t\trenderItem.z = z;\n\t\t\t\trenderItem.group = group;\n\t\t\t}\n\n\t\t\trenderItemsIndex++;\n\t\t\treturn renderItem;\n\t\t}\n\n\t\tfunction push(object, geometry, material, groupOrder, z, group) {\n\t\t\tconst renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);\n\n\t\t\tif (material.transmission > 0.0) {\n\t\t\t\ttransmissive.push(renderItem);\n\t\t\t} else if (material.transparent === true) {\n\t\t\t\ttransparent.push(renderItem);\n\t\t\t} else {\n\t\t\t\topaque.push(renderItem);\n\t\t\t}\n\t\t}\n\n\t\tfunction unshift(object, geometry, material, groupOrder, z, group) {\n\t\t\tconst renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);\n\n\t\t\tif (material.transmission > 0.0) {\n\t\t\t\ttransmissive.unshift(renderItem);\n\t\t\t} else if (material.transparent === true) {\n\t\t\t\ttransparent.unshift(renderItem);\n\t\t\t} else {\n\t\t\t\topaque.unshift(renderItem);\n\t\t\t}\n\t\t}\n\n\t\tfunction sort(customOpaqueSort, customTransparentSort) {\n\t\t\tif (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);\n\t\t\tif (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);\n\t\t\tif (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);\n\t\t}\n\n\t\tfunction finish() {\n\t\t\t// Clear references from inactive renderItems in the list\n\t\t\tfor (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {\n\t\t\t\tconst renderItem = renderItems[i];\n\t\t\t\tif (renderItem.id === null) break;\n\t\t\t\trenderItem.id = null;\n\t\t\t\trenderItem.object = null;\n\t\t\t\trenderItem.geometry = null;\n\t\t\t\trenderItem.material = null;\n\t\t\t\trenderItem.program = null;\n\t\t\t\trenderItem.group = null;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\topaque: opaque,\n\t\t\ttransmissive: transmissive,\n\t\t\ttransparent: transparent,\n\t\t\tinit: init,\n\t\t\tpush: push,\n\t\t\tunshift: unshift,\n\t\t\tfinish: finish,\n\t\t\tsort: sort\n\t\t};\n\t}\n\n\tfunction WebGLRenderLists(properties) {\n\t\tlet lists = new WeakMap();\n\n\t\tfunction get(scene, renderCallDepth) {\n\t\t\tlet list;\n\n\t\t\tif (lists.has(scene) === false) {\n\t\t\t\tlist = new WebGLRenderList(properties);\n\t\t\t\tlists.set(scene, [list]);\n\t\t\t} else {\n\t\t\t\tif (renderCallDepth >= lists.get(scene).length) {\n\t\t\t\t\tlist = new WebGLRenderList(properties);\n\t\t\t\t\tlists.get(scene).push(list);\n\t\t\t\t} else {\n\t\t\t\t\tlist = lists.get(scene)[renderCallDepth];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn list;\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\tlists = new WeakMap();\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tdispose: dispose\n\t\t};\n\t}\n\n\tfunction UniformsCache() {\n\t\tconst lights = {};\n\t\treturn {\n\t\t\tget: function (light) {\n\t\t\t\tif (lights[light.id] !== undefined) {\n\t\t\t\t\treturn lights[light.id];\n\t\t\t\t}\n\n\t\t\t\tlet uniforms;\n\n\t\t\t\tswitch (light.type) {\n\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\t\thalfWidth: new Vector3(),\n\t\t\t\t\t\t\thalfHeight: new Vector3()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlights[light.id] = uniforms;\n\t\t\t\treturn uniforms;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction ShadowUniformsCache() {\n\t\tconst lights = {};\n\t\treturn {\n\t\t\tget: function (light) {\n\t\t\t\tif (lights[light.id] !== undefined) {\n\t\t\t\t\treturn lights[light.id];\n\t\t\t\t}\n\n\t\t\t\tlet uniforms;\n\n\t\t\t\tswitch (light.type) {\n\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\tuniforms = {\n\t\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\t\tshadowMapSize: new Vector2(),\n\t\t\t\t\t\t\tshadowCameraNear: 1,\n\t\t\t\t\t\t\tshadowCameraFar: 1000\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// TODO (abelnation): set RectAreaLight shadow uniforms\n\t\t\t\t}\n\n\t\t\t\tlights[light.id] = uniforms;\n\t\t\t\treturn uniforms;\n\t\t\t}\n\t\t};\n\t}\n\n\tlet nextVersion = 0;\n\n\tfunction shadowCastingLightsFirst(lightA, lightB) {\n\t\treturn (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);\n\t}\n\n\tfunction WebGLLights(extensions, capabilities) {\n\t\tconst cache = new UniformsCache();\n\t\tconst shadowCache = ShadowUniformsCache();\n\t\tconst state = {\n\t\t\tversion: 0,\n\t\t\thash: {\n\t\t\t\tdirectionalLength: -1,\n\t\t\t\tpointLength: -1,\n\t\t\t\tspotLength: -1,\n\t\t\t\trectAreaLength: -1,\n\t\t\t\themiLength: -1,\n\t\t\t\tnumDirectionalShadows: -1,\n\t\t\t\tnumPointShadows: -1,\n\t\t\t\tnumSpotShadows: -1\n\t\t\t},\n\t\t\tambient: [0, 0, 0],\n\t\t\tprobe: [],\n\t\t\tdirectional: [],\n\t\t\tdirectionalShadow: [],\n\t\t\tdirectionalShadowMap: [],\n\t\t\tdirectionalShadowMatrix: [],\n\t\t\tspot: [],\n\t\t\tspotShadow: [],\n\t\t\tspotShadowMap: [],\n\t\t\tspotShadowMatrix: [],\n\t\t\trectArea: [],\n\t\t\trectAreaLTC1: null,\n\t\t\trectAreaLTC2: null,\n\t\t\tpoint: [],\n\t\t\tpointShadow: [],\n\t\t\tpointShadowMap: [],\n\t\t\tpointShadowMatrix: [],\n\t\t\themi: []\n\t\t};\n\n\t\tfor (let i = 0; i < 9; i++) state.probe.push(new Vector3());\n\n\t\tconst vector3 = new Vector3();\n\t\tconst matrix4 = new Matrix4();\n\t\tconst matrix42 = new Matrix4();\n\n\t\tfunction setup(lights) {\n\t\t\tlet r = 0,\n\t\t\t\t\tg = 0,\n\t\t\t\t\tb = 0;\n\n\t\t\tfor (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);\n\n\t\t\tlet directionalLength = 0;\n\t\t\tlet pointLength = 0;\n\t\t\tlet spotLength = 0;\n\t\t\tlet rectAreaLength = 0;\n\t\t\tlet hemiLength = 0;\n\t\t\tlet numDirectionalShadows = 0;\n\t\t\tlet numPointShadows = 0;\n\t\t\tlet numSpotShadows = 0;\n\t\t\tlights.sort(shadowCastingLightsFirst);\n\n\t\t\tfor (let i = 0, l = lights.length; i < l; i++) {\n\t\t\t\tconst light = lights[i];\n\t\t\t\tconst color = light.color;\n\t\t\t\tconst intensity = light.intensity;\n\t\t\t\tconst distance = light.distance;\n\t\t\t\tconst shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;\n\n\t\t\t\tif (light.isAmbientLight) {\n\t\t\t\t\tr += color.r * intensity;\n\t\t\t\t\tg += color.g * intensity;\n\t\t\t\t\tb += color.b * intensity;\n\t\t\t\t} else if (light.isLightProbe) {\n\t\t\t\t\tfor (let j = 0; j < 9; j++) {\n\t\t\t\t\t\tstate.probe[j].addScaledVector(light.sh.coefficients[j], intensity);\n\t\t\t\t\t}\n\t\t\t\t} else if (light.isDirectionalLight) {\n\t\t\t\t\tconst uniforms = cache.get(light);\n\t\t\t\t\tuniforms.color.copy(light.color).multiplyScalar(light.intensity);\n\n\t\t\t\t\tif (light.castShadow) {\n\t\t\t\t\t\tconst shadow = light.shadow;\n\t\t\t\t\t\tconst shadowUniforms = shadowCache.get(light);\n\t\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\t\tstate.directionalShadow[directionalLength] = shadowUniforms;\n\t\t\t\t\t\tstate.directionalShadowMap[directionalLength] = shadowMap;\n\t\t\t\t\t\tstate.directionalShadowMatrix[directionalLength] = light.shadow.matrix;\n\t\t\t\t\t\tnumDirectionalShadows++;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.directional[directionalLength] = uniforms;\n\t\t\t\t\tdirectionalLength++;\n\t\t\t\t} else if (light.isSpotLight) {\n\t\t\t\t\tconst uniforms = cache.get(light);\n\t\t\t\t\tuniforms.position.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tuniforms.color.copy(color).multiplyScalar(intensity);\n\t\t\t\t\tuniforms.distance = distance;\n\t\t\t\t\tuniforms.coneCos = Math.cos(light.angle);\n\t\t\t\t\tuniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));\n\t\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\t\tif (light.castShadow) {\n\t\t\t\t\t\tconst shadow = light.shadow;\n\t\t\t\t\t\tconst shadowUniforms = shadowCache.get(light);\n\t\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\t\tstate.spotShadow[spotLength] = shadowUniforms;\n\t\t\t\t\t\tstate.spotShadowMap[spotLength] = shadowMap;\n\t\t\t\t\t\tstate.spotShadowMatrix[spotLength] = light.shadow.matrix;\n\t\t\t\t\t\tnumSpotShadows++;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.spot[spotLength] = uniforms;\n\t\t\t\t\tspotLength++;\n\t\t\t\t} else if (light.isRectAreaLight) {\n\t\t\t\t\tconst uniforms = cache.get(light); // (a) intensity is the total visible light emitted\n\t\t\t\t\t//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );\n\t\t\t\t\t// (b) intensity is the brightness of the light\n\n\t\t\t\t\tuniforms.color.copy(color).multiplyScalar(intensity);\n\t\t\t\t\tuniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n\t\t\t\t\tuniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);\n\t\t\t\t\tstate.rectArea[rectAreaLength] = uniforms;\n\t\t\t\t\trectAreaLength++;\n\t\t\t\t} else if (light.isPointLight) {\n\t\t\t\t\tconst uniforms = cache.get(light);\n\t\t\t\t\tuniforms.color.copy(light.color).multiplyScalar(light.intensity);\n\t\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\t\tif (light.castShadow) {\n\t\t\t\t\t\tconst shadow = light.shadow;\n\t\t\t\t\t\tconst shadowUniforms = shadowCache.get(light);\n\t\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\t\tshadowUniforms.shadowCameraNear = shadow.camera.near;\n\t\t\t\t\t\tshadowUniforms.shadowCameraFar = shadow.camera.far;\n\t\t\t\t\t\tstate.pointShadow[pointLength] = shadowUniforms;\n\t\t\t\t\t\tstate.pointShadowMap[pointLength] = shadowMap;\n\t\t\t\t\t\tstate.pointShadowMatrix[pointLength] = light.shadow.matrix;\n\t\t\t\t\t\tnumPointShadows++;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.point[pointLength] = uniforms;\n\t\t\t\t\tpointLength++;\n\t\t\t\t} else if (light.isHemisphereLight) {\n\t\t\t\t\tconst uniforms = cache.get(light);\n\t\t\t\t\tuniforms.skyColor.copy(light.color).multiplyScalar(intensity);\n\t\t\t\t\tuniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);\n\t\t\t\t\tstate.hemi[hemiLength] = uniforms;\n\t\t\t\t\themiLength++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rectAreaLength > 0) {\n\t\t\t\tif (capabilities.isWebGL2) {\n\t\t\t\t\t// WebGL 2\n\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\t\t\t\t} else {\n\t\t\t\t\t// WebGL 1\n\t\t\t\t\tif (extensions.has('OES_texture_float_linear') === true) {\n\t\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\t\t\t\t\t} else if (extensions.has('OES_texture_half_float_linear') === true) {\n\t\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n\t\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.ambient[0] = r;\n\t\t\tstate.ambient[1] = g;\n\t\t\tstate.ambient[2] = b;\n\t\t\tconst hash = state.hash;\n\n\t\t\tif (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {\n\t\t\t\tstate.directional.length = directionalLength;\n\t\t\t\tstate.spot.length = spotLength;\n\t\t\t\tstate.rectArea.length = rectAreaLength;\n\t\t\t\tstate.point.length = pointLength;\n\t\t\t\tstate.hemi.length = hemiLength;\n\t\t\t\tstate.directionalShadow.length = numDirectionalShadows;\n\t\t\t\tstate.directionalShadowMap.length = numDirectionalShadows;\n\t\t\t\tstate.pointShadow.length = numPointShadows;\n\t\t\t\tstate.pointShadowMap.length = numPointShadows;\n\t\t\t\tstate.spotShadow.length = numSpotShadows;\n\t\t\t\tstate.spotShadowMap.length = numSpotShadows;\n\t\t\t\tstate.directionalShadowMatrix.length = numDirectionalShadows;\n\t\t\t\tstate.pointShadowMatrix.length = numPointShadows;\n\t\t\t\tstate.spotShadowMatrix.length = numSpotShadows;\n\t\t\t\thash.directionalLength = directionalLength;\n\t\t\t\thash.pointLength = pointLength;\n\t\t\t\thash.spotLength = spotLength;\n\t\t\t\thash.rectAreaLength = rectAreaLength;\n\t\t\t\thash.hemiLength = hemiLength;\n\t\t\t\thash.numDirectionalShadows = numDirectionalShadows;\n\t\t\t\thash.numPointShadows = numPointShadows;\n\t\t\t\thash.numSpotShadows = numSpotShadows;\n\t\t\t\tstate.version = nextVersion++;\n\t\t\t}\n\t\t}\n\n\t\tfunction setupView(lights, camera) {\n\t\t\tlet directionalLength = 0;\n\t\t\tlet pointLength = 0;\n\t\t\tlet spotLength = 0;\n\t\t\tlet rectAreaLength = 0;\n\t\t\tlet hemiLength = 0;\n\t\t\tconst viewMatrix = camera.matrixWorldInverse;\n\n\t\t\tfor (let i = 0, l = lights.length; i < l; i++) {\n\t\t\t\tconst light = lights[i];\n\n\t\t\t\tif (light.isDirectionalLight) {\n\t\t\t\t\tconst uniforms = state.directional[directionalLength];\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tvector3.setFromMatrixPosition(light.target.matrixWorld);\n\t\t\t\t\tuniforms.direction.sub(vector3);\n\t\t\t\t\tuniforms.direction.transformDirection(viewMatrix);\n\t\t\t\t\tdirectionalLength++;\n\t\t\t\t} else if (light.isSpotLight) {\n\t\t\t\t\tconst uniforms = state.spot[spotLength];\n\t\t\t\t\tuniforms.position.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tuniforms.position.applyMatrix4(viewMatrix);\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tvector3.setFromMatrixPosition(light.target.matrixWorld);\n\t\t\t\t\tuniforms.direction.sub(vector3);\n\t\t\t\t\tuniforms.direction.transformDirection(viewMatrix);\n\t\t\t\t\tspotLength++;\n\t\t\t\t} else if (light.isRectAreaLight) {\n\t\t\t\t\tconst uniforms = state.rectArea[rectAreaLength];\n\t\t\t\t\tuniforms.position.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tuniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors\n\n\t\t\t\t\tmatrix42.identity();\n\t\t\t\t\tmatrix4.copy(light.matrixWorld);\n\t\t\t\t\tmatrix4.premultiply(viewMatrix);\n\t\t\t\t\tmatrix42.extractRotation(matrix4);\n\t\t\t\t\tuniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);\n\t\t\t\t\tuniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);\n\t\t\t\t\tuniforms.halfWidth.applyMatrix4(matrix42);\n\t\t\t\t\tuniforms.halfHeight.applyMatrix4(matrix42);\n\t\t\t\t\trectAreaLength++;\n\t\t\t\t} else if (light.isPointLight) {\n\t\t\t\t\tconst uniforms = state.point[pointLength];\n\t\t\t\t\tuniforms.position.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tuniforms.position.applyMatrix4(viewMatrix);\n\t\t\t\t\tpointLength++;\n\t\t\t\t} else if (light.isHemisphereLight) {\n\t\t\t\t\tconst uniforms = state.hemi[hemiLength];\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\t\tuniforms.direction.transformDirection(viewMatrix);\n\t\t\t\t\tuniforms.direction.normalize();\n\t\t\t\t\themiLength++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tsetup: setup,\n\t\t\tsetupView: setupView,\n\t\t\tstate: state\n\t\t};\n\t}\n\n\tfunction WebGLRenderState(extensions, capabilities) {\n\t\tconst lights = new WebGLLights(extensions, capabilities);\n\t\tconst lightsArray = [];\n\t\tconst shadowsArray = [];\n\n\t\tfunction init() {\n\t\t\tlightsArray.length = 0;\n\t\t\tshadowsArray.length = 0;\n\t\t}\n\n\t\tfunction pushLight(light) {\n\t\t\tlightsArray.push(light);\n\t\t}\n\n\t\tfunction pushShadow(shadowLight) {\n\t\t\tshadowsArray.push(shadowLight);\n\t\t}\n\n\t\tfunction setupLights() {\n\t\t\tlights.setup(lightsArray);\n\t\t}\n\n\t\tfunction setupLightsView(camera) {\n\t\t\tlights.setupView(lightsArray, camera);\n\t\t}\n\n\t\tconst state = {\n\t\t\tlightsArray: lightsArray,\n\t\t\tshadowsArray: shadowsArray,\n\t\t\tlights: lights\n\t\t};\n\t\treturn {\n\t\t\tinit: init,\n\t\t\tstate: state,\n\t\t\tsetupLights: setupLights,\n\t\t\tsetupLightsView: setupLightsView,\n\t\t\tpushLight: pushLight,\n\t\t\tpushShadow: pushShadow\n\t\t};\n\t}\n\n\tfunction WebGLRenderStates(extensions, capabilities) {\n\t\tlet renderStates = new WeakMap();\n\n\t\tfunction get(scene, renderCallDepth = 0) {\n\t\t\tlet renderState;\n\n\t\t\tif (renderStates.has(scene) === false) {\n\t\t\t\trenderState = new WebGLRenderState(extensions, capabilities);\n\t\t\t\trenderStates.set(scene, [renderState]);\n\t\t\t} else {\n\t\t\t\tif (renderCallDepth >= renderStates.get(scene).length) {\n\t\t\t\t\trenderState = new WebGLRenderState(extensions, capabilities);\n\t\t\t\t\trenderStates.get(scene).push(renderState);\n\t\t\t\t} else {\n\t\t\t\t\trenderState = renderStates.get(scene)[renderCallDepth];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn renderState;\n\t\t}\n\n\t\tfunction dispose() {\n\t\t\trenderStates = new WeakMap();\n\t\t}\n\n\t\treturn {\n\t\t\tget: get,\n\t\t\tdispose: dispose\n\t\t};\n\t}\n\n\t/**\n\t * parameters = {\n\t *\n\t *\topacity: <float>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>\n\t * }\n\t */\n\n\tclass MeshDepthMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshDepthMaterial';\n\t\t\tthis.depthPacking = BasicDepthPacking;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.map = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.fog = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.depthPacking = source.depthPacking;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.map = source.map;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\n\t *\treferencePosition: <float>,\n\t *\tnearDistance: <float>,\n\t *\tfarDistance: <float>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>\n\t *\n\t * }\n\t */\n\n\tclass MeshDistanceMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshDistanceMaterial';\n\t\t\tthis.referencePosition = new Vector3();\n\t\t\tthis.nearDistance = 1;\n\t\t\tthis.farDistance = 1000;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.map = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.fog = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.referencePosition.copy(source.referencePosition);\n\t\t\tthis.nearDistance = source.nearDistance;\n\t\t\tthis.farDistance = source.farDistance;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.map = source.map;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\n\n\tvar vsm_frag = \"uniform sampler2D shadow_pass;\\nuniform vec2 resolution;\\nuniform float radius;\\n#include <packing>\\nvoid main() {\\n\\tfloat mean = 0.0;\\n\\tfloat squared_mean = 0.0;\\n\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\\n\\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\\n\\t\\t#ifdef HORIZONTAL_PASS\\n\\t\\t\\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\\n\\t\\t\\tmean += distribution.x;\\n\\t\\t\\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\\n\\t\\t#else\\n\\t\\t\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\\n\\t\\t\\tmean += depth;\\n\\t\\t\\tsquared_mean += depth * depth;\\n\\t\\t#endif\\n\\t}\\n\\tmean = mean * HALF_SAMPLE_RATE;\\n\\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\\n\\tfloat std_dev = sqrt( squared_mean - mean * mean );\\n\\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\\n}\";\n\n\tvar vsm_vert = \"void main() {\\n\\tgl_Position = vec4( position, 1.0 );\\n}\";\n\n\tfunction WebGLShadowMap(_renderer, _objects, _capabilities) {\n\t\tlet _frustum = new Frustum();\n\n\t\tconst _shadowMapSize = new Vector2(),\n\t\t\t\t\t_viewportSize = new Vector2(),\n\t\t\t\t\t_viewport = new Vector4(),\n\t\t\t\t\t_depthMaterials = [],\n\t\t\t\t\t_distanceMaterials = [],\n\t\t\t\t\t_materialCache = {},\n\t\t\t\t\t_maxTextureSize = _capabilities.maxTextureSize;\n\n\t\tconst shadowSide = {\n\t\t\t0: BackSide,\n\t\t\t1: FrontSide,\n\t\t\t2: DoubleSide\n\t\t};\n\t\tconst shadowMaterialVertical = new ShaderMaterial({\n\t\t\tdefines: {\n\t\t\t\tSAMPLE_RATE: 2.0 / 8.0,\n\t\t\t\tHALF_SAMPLE_RATE: 1.0 / 8.0\n\t\t\t},\n\t\t\tuniforms: {\n\t\t\t\tshadow_pass: {\n\t\t\t\t\tvalue: null\n\t\t\t\t},\n\t\t\t\tresolution: {\n\t\t\t\t\tvalue: new Vector2()\n\t\t\t\t},\n\t\t\t\tradius: {\n\t\t\t\t\tvalue: 4.0\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: vsm_vert,\n\t\t\tfragmentShader: vsm_frag\n\t\t});\n\t\tconst shadowMaterialHorizontal = shadowMaterialVertical.clone();\n\t\tshadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n\t\tconst fullScreenTri = new BufferGeometry();\n\t\tfullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));\n\t\tconst fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);\n\t\tconst scope = this;\n\t\tthis.enabled = false;\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\t\tthis.type = PCFShadowMap;\n\n\t\tthis.render = function (lights, scene, camera) {\n\t\t\tif (scope.enabled === false) return;\n\t\t\tif (scope.autoUpdate === false && scope.needsUpdate === false) return;\n\t\t\tif (lights.length === 0) return;\n\n\t\t\tconst currentRenderTarget = _renderer.getRenderTarget();\n\n\t\t\tconst activeCubeFace = _renderer.getActiveCubeFace();\n\n\t\t\tconst activeMipmapLevel = _renderer.getActiveMipmapLevel();\n\n\t\t\tconst _state = _renderer.state; // Set GL state for depth map.\n\n\t\t\t_state.setBlending(NoBlending);\n\n\t\t\t_state.buffers.color.setClear(1, 1, 1, 1);\n\n\t\t\t_state.buffers.depth.setTest(true);\n\n\t\t\t_state.setScissorTest(false); // render depth map\n\n\n\t\t\tfor (let i = 0, il = lights.length; i < il; i++) {\n\t\t\t\tconst light = lights[i];\n\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\tif (shadow === undefined) {\n\t\t\t\t\tconsole.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;\n\n\t\t\t\t_shadowMapSize.copy(shadow.mapSize);\n\n\t\t\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t\t\t_shadowMapSize.multiply(shadowFrameExtents);\n\n\t\t\t\t_viewportSize.copy(shadow.mapSize);\n\n\t\t\t\tif (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {\n\t\t\t\t\tif (_shadowMapSize.x > _maxTextureSize) {\n\t\t\t\t\t\t_viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);\n\t\t\t\t\t\t_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n\t\t\t\t\t\tshadow.mapSize.x = _viewportSize.x;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_shadowMapSize.y > _maxTextureSize) {\n\t\t\t\t\t\t_viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);\n\t\t\t\t\t\t_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n\t\t\t\t\t\tshadow.mapSize.y = _viewportSize.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {\n\t\t\t\t\tconst pars = {\n\t\t\t\t\t\tminFilter: LinearFilter,\n\t\t\t\t\t\tmagFilter: LinearFilter,\n\t\t\t\t\t\tformat: RGBAFormat\n\t\t\t\t\t};\n\t\t\t\t\tshadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n\t\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\n\t\t\t\t\tshadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n\t\t\t\t\tshadow.camera.updateProjectionMatrix();\n\t\t\t\t}\n\n\t\t\t\tif (shadow.map === null) {\n\t\t\t\t\tconst pars = {\n\t\t\t\t\t\tminFilter: NearestFilter,\n\t\t\t\t\t\tmagFilter: NearestFilter,\n\t\t\t\t\t\tformat: RGBAFormat\n\t\t\t\t\t};\n\t\t\t\t\tshadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n\t\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\n\t\t\t\t\tshadow.camera.updateProjectionMatrix();\n\t\t\t\t}\n\n\t\t\t\t_renderer.setRenderTarget(shadow.map);\n\n\t\t\t\t_renderer.clear();\n\n\t\t\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\t\t\tfor (let vp = 0; vp < viewportCount; vp++) {\n\t\t\t\t\tconst viewport = shadow.getViewport(vp);\n\n\t\t\t\t\t_viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);\n\n\t\t\t\t\t_state.viewport(_viewport);\n\n\t\t\t\t\tshadow.updateMatrices(light, vp);\n\t\t\t\t\t_frustum = shadow.getFrustum();\n\t\t\t\t\trenderObject(scene, camera, shadow.camera, light, this.type);\n\t\t\t\t} // do blur pass for VSM\n\n\n\t\t\t\tif (!shadow.isPointLightShadow && this.type === VSMShadowMap) {\n\t\t\t\t\tVSMPass(shadow, camera);\n\t\t\t\t}\n\n\t\t\t\tshadow.needsUpdate = false;\n\t\t\t}\n\n\t\t\tscope.needsUpdate = false;\n\n\t\t\t_renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);\n\t\t};\n\n\t\tfunction VSMPass(shadow, camera) {\n\t\t\tconst geometry = _objects.update(fullScreenMesh); // vertical pass\n\n\n\t\t\tshadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n\t\t\tshadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n\t\t\tshadowMaterialVertical.uniforms.radius.value = shadow.radius;\n\n\t\t\t_renderer.setRenderTarget(shadow.mapPass);\n\n\t\t\t_renderer.clear();\n\n\t\t\t_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizontal pass\n\n\n\t\t\tshadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n\t\t\tshadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n\t\t\tshadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n\n\t\t\t_renderer.setRenderTarget(shadow.map);\n\n\t\t\t_renderer.clear();\n\n\t\t\t_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);\n\t\t}\n\n\t\tfunction getDepthMaterialVariant(useMorphing) {\n\t\t\tconst index = useMorphing << 0;\n\t\t\tlet material = _depthMaterials[index];\n\n\t\t\tif (material === undefined) {\n\t\t\t\tmaterial = new MeshDepthMaterial({\n\t\t\t\t\tdepthPacking: RGBADepthPacking,\n\t\t\t\t\tmorphTargets: useMorphing\n\t\t\t\t});\n\t\t\t\t_depthMaterials[index] = material;\n\t\t\t}\n\n\t\t\treturn material;\n\t\t}\n\n\t\tfunction getDistanceMaterialVariant(useMorphing) {\n\t\t\tconst index = useMorphing << 0;\n\t\t\tlet material = _distanceMaterials[index];\n\n\t\t\tif (material === undefined) {\n\t\t\t\tmaterial = new MeshDistanceMaterial({\n\t\t\t\t\tmorphTargets: useMorphing\n\t\t\t\t});\n\t\t\t\t_distanceMaterials[index] = material;\n\t\t\t}\n\n\t\t\treturn material;\n\t\t}\n\n\t\tfunction getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {\n\t\t\tlet result = null;\n\t\t\tlet getMaterialVariant = getDepthMaterialVariant;\n\t\t\tlet customMaterial = object.customDepthMaterial;\n\n\t\t\tif (light.isPointLight === true) {\n\t\t\t\tgetMaterialVariant = getDistanceMaterialVariant;\n\t\t\t\tcustomMaterial = object.customDistanceMaterial;\n\t\t\t}\n\n\t\t\tif (customMaterial === undefined) {\n\t\t\t\tlet useMorphing = false;\n\n\t\t\t\tif (material.morphTargets === true) {\n\t\t\t\t\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n\t\t\t\t}\n\n\t\t\t\tresult = getMaterialVariant(useMorphing);\n\t\t\t} else {\n\t\t\t\tresult = customMaterial;\n\t\t\t}\n\n\t\t\tif (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {\n\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t// appropriate state\n\t\t\t\tconst keyA = result.uuid,\n\t\t\t\t\t\t\tkeyB = material.uuid;\n\t\t\t\tlet materialsForVariant = _materialCache[keyA];\n\n\t\t\t\tif (materialsForVariant === undefined) {\n\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t_materialCache[keyA] = materialsForVariant;\n\t\t\t\t}\n\n\t\t\t\tlet cachedMaterial = materialsForVariant[keyB];\n\n\t\t\t\tif (cachedMaterial === undefined) {\n\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\tmaterialsForVariant[keyB] = cachedMaterial;\n\t\t\t\t}\n\n\t\t\t\tresult = cachedMaterial;\n\t\t\t}\n\n\t\t\tresult.visible = material.visible;\n\t\t\tresult.wireframe = material.wireframe;\n\n\t\t\tif (type === VSMShadowMap) {\n\t\t\t\tresult.side = material.shadowSide !== null ? material.shadowSide : material.side;\n\t\t\t} else {\n\t\t\t\tresult.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];\n\t\t\t}\n\n\t\t\tresult.clipShadows = material.clipShadows;\n\t\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\t\tresult.clipIntersection = material.clipIntersection;\n\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\t\tresult.linewidth = material.linewidth;\n\n\t\t\tif (light.isPointLight === true && result.isMeshDistanceMaterial === true) {\n\t\t\t\tresult.referencePosition.setFromMatrixPosition(light.matrixWorld);\n\t\t\t\tresult.nearDistance = shadowCameraNear;\n\t\t\t\tresult.farDistance = shadowCameraFar;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction renderObject(object, camera, shadowCamera, light, type) {\n\t\t\tif (object.visible === false) return;\n\t\t\tconst visible = object.layers.test(camera.layers);\n\n\t\t\tif (visible && (object.isMesh || object.isLine || object.isPoints)) {\n\t\t\t\tif ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {\n\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);\n\n\t\t\t\t\tconst geometry = _objects.update(object);\n\n\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\tif (Array.isArray(material)) {\n\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\tfor (let k = 0, kl = groups.length; k < kl; k++) {\n\t\t\t\t\t\t\tconst group = groups[k];\n\t\t\t\t\t\t\tconst groupMaterial = material[group.materialIndex];\n\n\t\t\t\t\t\t\tif (groupMaterial && groupMaterial.visible) {\n\t\t\t\t\t\t\t\tconst depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);\n\n\t\t\t\t\t\t\t\t_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (material.visible) {\n\t\t\t\t\t\tconst depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);\n\n\t\t\t\t\t\t_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst children = object.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\trenderObject(children[i], camera, shadowCamera, light, type);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction WebGLState(gl, extensions, capabilities) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\n\t\tfunction ColorBuffer() {\n\t\t\tlet locked = false;\n\t\t\tconst color = new Vector4();\n\t\t\tlet currentColorMask = null;\n\t\t\tconst currentColorClear = new Vector4(0, 0, 0, 0);\n\t\t\treturn {\n\t\t\t\tsetMask: function (colorMask) {\n\t\t\t\t\tif (currentColorMask !== colorMask && !locked) {\n\t\t\t\t\t\tgl.colorMask(colorMask, colorMask, colorMask, colorMask);\n\t\t\t\t\t\tcurrentColorMask = colorMask;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetLocked: function (lock) {\n\t\t\t\t\tlocked = lock;\n\t\t\t\t},\n\t\t\t\tsetClear: function (r, g, b, a, premultipliedAlpha) {\n\t\t\t\t\tif (premultipliedAlpha === true) {\n\t\t\t\t\t\tr *= a;\n\t\t\t\t\t\tg *= a;\n\t\t\t\t\t\tb *= a;\n\t\t\t\t\t}\n\n\t\t\t\t\tcolor.set(r, g, b, a);\n\n\t\t\t\t\tif (currentColorClear.equals(color) === false) {\n\t\t\t\t\t\tgl.clearColor(r, g, b, a);\n\t\t\t\t\t\tcurrentColorClear.copy(color);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treset: function () {\n\t\t\t\t\tlocked = false;\n\t\t\t\t\tcurrentColorMask = null;\n\t\t\t\t\tcurrentColorClear.set(-1, 0, 0, 0); // set to invalid state\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction DepthBuffer() {\n\t\t\tlet locked = false;\n\t\t\tlet currentDepthMask = null;\n\t\t\tlet currentDepthFunc = null;\n\t\t\tlet currentDepthClear = null;\n\t\t\treturn {\n\t\t\t\tsetTest: function (depthTest) {\n\t\t\t\t\tif (depthTest) {\n\t\t\t\t\t\tenable(gl.DEPTH_TEST);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdisable(gl.DEPTH_TEST);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetMask: function (depthMask) {\n\t\t\t\t\tif (currentDepthMask !== depthMask && !locked) {\n\t\t\t\t\t\tgl.depthMask(depthMask);\n\t\t\t\t\t\tcurrentDepthMask = depthMask;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetFunc: function (depthFunc) {\n\t\t\t\t\tif (currentDepthFunc !== depthFunc) {\n\t\t\t\t\t\tif (depthFunc) {\n\t\t\t\t\t\t\tswitch (depthFunc) {\n\t\t\t\t\t\t\t\tcase NeverDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.NEVER);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase AlwaysDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.ALWAYS);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.LESS);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase LessEqualDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.LEQUAL);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase EqualDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.EQUAL);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterEqualDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.GEQUAL);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase GreaterDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.GREATER);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase NotEqualDepth:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.NOTEQUAL);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tgl.depthFunc(gl.LEQUAL);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgl.depthFunc(gl.LEQUAL);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetLocked: function (lock) {\n\t\t\t\t\tlocked = lock;\n\t\t\t\t},\n\t\t\t\tsetClear: function (depth) {\n\t\t\t\t\tif (currentDepthClear !== depth) {\n\t\t\t\t\t\tgl.clearDepth(depth);\n\t\t\t\t\t\tcurrentDepthClear = depth;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treset: function () {\n\t\t\t\t\tlocked = false;\n\t\t\t\t\tcurrentDepthMask = null;\n\t\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\t\tcurrentDepthClear = null;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tfunction StencilBuffer() {\n\t\t\tlet locked = false;\n\t\t\tlet currentStencilMask = null;\n\t\t\tlet currentStencilFunc = null;\n\t\t\tlet currentStencilRef = null;\n\t\t\tlet currentStencilFuncMask = null;\n\t\t\tlet currentStencilFail = null;\n\t\t\tlet currentStencilZFail = null;\n\t\t\tlet currentStencilZPass = null;\n\t\t\tlet currentStencilClear = null;\n\t\t\treturn {\n\t\t\t\tsetTest: function (stencilTest) {\n\t\t\t\t\tif (!locked) {\n\t\t\t\t\t\tif (stencilTest) {\n\t\t\t\t\t\t\tenable(gl.STENCIL_TEST);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdisable(gl.STENCIL_TEST);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetMask: function (stencilMask) {\n\t\t\t\t\tif (currentStencilMask !== stencilMask && !locked) {\n\t\t\t\t\t\tgl.stencilMask(stencilMask);\n\t\t\t\t\t\tcurrentStencilMask = stencilMask;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetFunc: function (stencilFunc, stencilRef, stencilMask) {\n\t\t\t\t\tif (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {\n\t\t\t\t\t\tgl.stencilFunc(stencilFunc, stencilRef, stencilMask);\n\t\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\t\tcurrentStencilRef = stencilRef;\n\t\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetOp: function (stencilFail, stencilZFail, stencilZPass) {\n\t\t\t\t\tif (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {\n\t\t\t\t\t\tgl.stencilOp(stencilFail, stencilZFail, stencilZPass);\n\t\t\t\t\t\tcurrentStencilFail = stencilFail;\n\t\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tsetLocked: function (lock) {\n\t\t\t\t\tlocked = lock;\n\t\t\t\t},\n\t\t\t\tsetClear: function (stencil) {\n\t\t\t\t\tif (currentStencilClear !== stencil) {\n\t\t\t\t\t\tgl.clearStencil(stencil);\n\t\t\t\t\t\tcurrentStencilClear = stencil;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treset: function () {\n\t\t\t\t\tlocked = false;\n\t\t\t\t\tcurrentStencilMask = null;\n\t\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\t\tcurrentStencilRef = null;\n\t\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\t\tcurrentStencilFail = null;\n\t\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\t\tcurrentStencilClear = null;\n\t\t\t\t}\n\t\t\t};\n\t\t} //\n\n\n\t\tconst colorBuffer = new ColorBuffer();\n\t\tconst depthBuffer = new DepthBuffer();\n\t\tconst stencilBuffer = new StencilBuffer();\n\t\tlet enabledCapabilities = {};\n\t\tlet xrFramebuffer = null;\n\t\tlet currentBoundFramebuffers = {};\n\t\tlet currentProgram = null;\n\t\tlet currentBlendingEnabled = false;\n\t\tlet currentBlending = null;\n\t\tlet currentBlendEquation = null;\n\t\tlet currentBlendSrc = null;\n\t\tlet currentBlendDst = null;\n\t\tlet currentBlendEquationAlpha = null;\n\t\tlet currentBlendSrcAlpha = null;\n\t\tlet currentBlendDstAlpha = null;\n\t\tlet currentPremultipledAlpha = false;\n\t\tlet currentFlipSided = null;\n\t\tlet currentCullFace = null;\n\t\tlet currentLineWidth = null;\n\t\tlet currentPolygonOffsetFactor = null;\n\t\tlet currentPolygonOffsetUnits = null;\n\t\tconst maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n\t\tlet lineWidthAvailable = false;\n\t\tlet version = 0;\n\t\tconst glVersion = gl.getParameter(gl.VERSION);\n\n\t\tif (glVersion.indexOf('WebGL') !== -1) {\n\t\t\tversion = parseFloat(/^WebGL (\\d)/.exec(glVersion)[1]);\n\t\t\tlineWidthAvailable = version >= 1.0;\n\t\t} else if (glVersion.indexOf('OpenGL ES') !== -1) {\n\t\t\tversion = parseFloat(/^OpenGL ES (\\d)/.exec(glVersion)[1]);\n\t\t\tlineWidthAvailable = version >= 2.0;\n\t\t}\n\n\t\tlet currentTextureSlot = null;\n\t\tlet currentBoundTextures = {};\n\t\tconst scissorParam = gl.getParameter(gl.SCISSOR_BOX);\n\t\tconst viewportParam = gl.getParameter(gl.VIEWPORT);\n\t\tconst currentScissor = new Vector4().fromArray(scissorParam);\n\t\tconst currentViewport = new Vector4().fromArray(viewportParam);\n\n\t\tfunction createTexture(type, target, count) {\n\t\t\tconst data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.\n\n\t\t\tconst texture = gl.createTexture();\n\t\t\tgl.bindTexture(type, texture);\n\t\t\tgl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\t\t\tgl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tgl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t}\n\n\t\tconst emptyTextures = {};\n\t\temptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);\n\t\temptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6); // init\n\n\t\tcolorBuffer.setClear(0, 0, 0, 1);\n\t\tdepthBuffer.setClear(1);\n\t\tstencilBuffer.setClear(0);\n\t\tenable(gl.DEPTH_TEST);\n\t\tdepthBuffer.setFunc(LessEqualDepth);\n\t\tsetFlipSided(false);\n\t\tsetCullFace(CullFaceBack);\n\t\tenable(gl.CULL_FACE);\n\t\tsetBlending(NoBlending); //\n\n\t\tfunction enable(id) {\n\t\t\tif (enabledCapabilities[id] !== true) {\n\t\t\t\tgl.enable(id);\n\t\t\t\tenabledCapabilities[id] = true;\n\t\t\t}\n\t\t}\n\n\t\tfunction disable(id) {\n\t\t\tif (enabledCapabilities[id] !== false) {\n\t\t\t\tgl.disable(id);\n\t\t\t\tenabledCapabilities[id] = false;\n\t\t\t}\n\t\t}\n\n\t\tfunction bindXRFramebuffer(framebuffer) {\n\t\t\tif (framebuffer !== xrFramebuffer) {\n\t\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\t\t\t\txrFramebuffer = framebuffer;\n\t\t\t}\n\t\t}\n\n\t\tfunction bindFramebuffer(target, framebuffer) {\n\t\t\tif (framebuffer === null && xrFramebuffer !== null) framebuffer = xrFramebuffer; // use active XR framebuffer if available\n\n\t\t\tif (currentBoundFramebuffers[target] !== framebuffer) {\n\t\t\t\tgl.bindFramebuffer(target, framebuffer);\n\t\t\t\tcurrentBoundFramebuffers[target] = framebuffer;\n\n\t\t\t\tif (isWebGL2) {\n\t\t\t\t\t// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER\n\t\t\t\t\tif (target === gl.DRAW_FRAMEBUFFER) {\n\t\t\t\t\t\tcurrentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (target === gl.FRAMEBUFFER) {\n\t\t\t\t\t\tcurrentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction useProgram(program) {\n\t\t\tif (currentProgram !== program) {\n\t\t\t\tgl.useProgram(program);\n\t\t\t\tcurrentProgram = program;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tconst equationToGL = {\n\t\t\t[AddEquation]: gl.FUNC_ADD,\n\t\t\t[SubtractEquation]: gl.FUNC_SUBTRACT,\n\t\t\t[ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT\n\t\t};\n\n\t\tif (isWebGL2) {\n\t\t\tequationToGL[MinEquation] = gl.MIN;\n\t\t\tequationToGL[MaxEquation] = gl.MAX;\n\t\t} else {\n\t\t\tconst extension = extensions.get('EXT_blend_minmax');\n\n\t\t\tif (extension !== null) {\n\t\t\t\tequationToGL[MinEquation] = extension.MIN_EXT;\n\t\t\t\tequationToGL[MaxEquation] = extension.MAX_EXT;\n\t\t\t}\n\t\t}\n\n\t\tconst factorToGL = {\n\t\t\t[ZeroFactor]: gl.ZERO,\n\t\t\t[OneFactor]: gl.ONE,\n\t\t\t[SrcColorFactor]: gl.SRC_COLOR,\n\t\t\t[SrcAlphaFactor]: gl.SRC_ALPHA,\n\t\t\t[SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,\n\t\t\t[DstColorFactor]: gl.DST_COLOR,\n\t\t\t[DstAlphaFactor]: gl.DST_ALPHA,\n\t\t\t[OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,\n\t\t\t[OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,\n\t\t\t[OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,\n\t\t\t[OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA\n\t\t};\n\n\t\tfunction setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {\n\t\t\tif (blending === NoBlending) {\n\t\t\t\tif (currentBlendingEnabled === true) {\n\t\t\t\t\tdisable(gl.BLEND);\n\t\t\t\t\tcurrentBlendingEnabled = false;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (currentBlendingEnabled === false) {\n\t\t\t\tenable(gl.BLEND);\n\t\t\t\tcurrentBlendingEnabled = true;\n\t\t\t}\n\n\t\t\tif (blending !== CustomBlending) {\n\t\t\t\tif (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {\n\t\t\t\t\tif (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {\n\t\t\t\t\t\tgl.blendEquation(gl.FUNC_ADD);\n\t\t\t\t\t\tcurrentBlendEquation = AddEquation;\n\t\t\t\t\t\tcurrentBlendEquationAlpha = AddEquation;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (premultipliedAlpha) {\n\t\t\t\t\t\tswitch (blending) {\n\t\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\t\tgl.blendFunc(gl.ONE, gl.ONE);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.error('THREE.WebGLState: Invalid blending: ', blending);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tswitch (blending) {\n\t\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\t\tgl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\t\tgl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\t\tgl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\t\tgl.blendFunc(gl.ZERO, gl.SRC_COLOR);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.error('THREE.WebGLState: Invalid blending: ', blending);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\t\tcurrentBlendDst = null;\n\t\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\t\tcurrentBlendDstAlpha = null;\n\t\t\t\t\tcurrentBlending = blending;\n\t\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t} // custom blending\n\n\n\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\t\tif (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {\n\t\t\t\tgl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);\n\t\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\t\t\t}\n\n\t\t\tif (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {\n\t\t\t\tgl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);\n\t\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\t\tcurrentBlendDst = blendDst;\n\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\t\t\t}\n\n\t\t\tcurrentBlending = blending;\n\t\t\tcurrentPremultipledAlpha = null;\n\t\t}\n\n\t\tfunction setMaterial(material, frontFaceCW) {\n\t\t\tmaterial.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);\n\t\t\tlet flipSided = material.side === BackSide;\n\t\t\tif (frontFaceCW) flipSided = !flipSided;\n\t\t\tsetFlipSided(flipSided);\n\t\t\tmaterial.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);\n\t\t\tdepthBuffer.setFunc(material.depthFunc);\n\t\t\tdepthBuffer.setTest(material.depthTest);\n\t\t\tdepthBuffer.setMask(material.depthWrite);\n\t\t\tcolorBuffer.setMask(material.colorWrite);\n\t\t\tconst stencilWrite = material.stencilWrite;\n\t\t\tstencilBuffer.setTest(stencilWrite);\n\n\t\t\tif (stencilWrite) {\n\t\t\t\tstencilBuffer.setMask(material.stencilWriteMask);\n\t\t\t\tstencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);\n\t\t\t\tstencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);\n\t\t\t}\n\n\t\t\tsetPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);\n\t\t\tmaterial.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n\t\t} //\n\n\n\t\tfunction setFlipSided(flipSided) {\n\t\t\tif (currentFlipSided !== flipSided) {\n\t\t\t\tif (flipSided) {\n\t\t\t\t\tgl.frontFace(gl.CW);\n\t\t\t\t} else {\n\t\t\t\t\tgl.frontFace(gl.CCW);\n\t\t\t\t}\n\n\t\t\t\tcurrentFlipSided = flipSided;\n\t\t\t}\n\t\t}\n\n\t\tfunction setCullFace(cullFace) {\n\t\t\tif (cullFace !== CullFaceNone) {\n\t\t\t\tenable(gl.CULL_FACE);\n\n\t\t\t\tif (cullFace !== currentCullFace) {\n\t\t\t\t\tif (cullFace === CullFaceBack) {\n\t\t\t\t\t\tgl.cullFace(gl.BACK);\n\t\t\t\t\t} else if (cullFace === CullFaceFront) {\n\t\t\t\t\t\tgl.cullFace(gl.FRONT);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgl.cullFace(gl.FRONT_AND_BACK);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdisable(gl.CULL_FACE);\n\t\t\t}\n\n\t\t\tcurrentCullFace = cullFace;\n\t\t}\n\n\t\tfunction setLineWidth(width) {\n\t\t\tif (width !== currentLineWidth) {\n\t\t\t\tif (lineWidthAvailable) gl.lineWidth(width);\n\t\t\t\tcurrentLineWidth = width;\n\t\t\t}\n\t\t}\n\n\t\tfunction setPolygonOffset(polygonOffset, factor, units) {\n\t\t\tif (polygonOffset) {\n\t\t\t\tenable(gl.POLYGON_OFFSET_FILL);\n\n\t\t\t\tif (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {\n\t\t\t\t\tgl.polygonOffset(factor, units);\n\t\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\t\tcurrentPolygonOffsetUnits = units;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdisable(gl.POLYGON_OFFSET_FILL);\n\t\t\t}\n\t\t}\n\n\t\tfunction setScissorTest(scissorTest) {\n\t\t\tif (scissorTest) {\n\t\t\t\tenable(gl.SCISSOR_TEST);\n\t\t\t} else {\n\t\t\t\tdisable(gl.SCISSOR_TEST);\n\t\t\t}\n\t\t} // texture\n\n\n\t\tfunction activeTexture(webglSlot) {\n\t\t\tif (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\tif (currentTextureSlot !== webglSlot) {\n\t\t\t\tgl.activeTexture(webglSlot);\n\t\t\t\tcurrentTextureSlot = webglSlot;\n\t\t\t}\n\t\t}\n\n\t\tfunction bindTexture(webglType, webglTexture) {\n\t\t\tif (currentTextureSlot === null) {\n\t\t\t\tactiveTexture();\n\t\t\t}\n\n\t\t\tlet boundTexture = currentBoundTextures[currentTextureSlot];\n\n\t\t\tif (boundTexture === undefined) {\n\t\t\t\tboundTexture = {\n\t\t\t\t\ttype: undefined,\n\t\t\t\t\ttexture: undefined\n\t\t\t\t};\n\t\t\t\tcurrentBoundTextures[currentTextureSlot] = boundTexture;\n\t\t\t}\n\n\t\t\tif (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {\n\t\t\t\tgl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);\n\t\t\t\tboundTexture.type = webglType;\n\t\t\t\tboundTexture.texture = webglTexture;\n\t\t\t}\n\t\t}\n\n\t\tfunction unbindTexture() {\n\t\t\tconst boundTexture = currentBoundTextures[currentTextureSlot];\n\n\t\t\tif (boundTexture !== undefined && boundTexture.type !== undefined) {\n\t\t\t\tgl.bindTexture(boundTexture.type, null);\n\t\t\t\tboundTexture.type = undefined;\n\t\t\t\tboundTexture.texture = undefined;\n\t\t\t}\n\t\t}\n\n\t\tfunction compressedTexImage2D() {\n\t\t\ttry {\n\t\t\t\tgl.compressedTexImage2D.apply(gl, arguments);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('THREE.WebGLState:', error);\n\t\t\t}\n\t\t}\n\n\t\tfunction texImage2D() {\n\t\t\ttry {\n\t\t\t\tgl.texImage2D.apply(gl, arguments);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('THREE.WebGLState:', error);\n\t\t\t}\n\t\t}\n\n\t\tfunction texImage3D() {\n\t\t\ttry {\n\t\t\t\tgl.texImage3D.apply(gl, arguments);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error('THREE.WebGLState:', error);\n\t\t\t}\n\t\t} //\n\n\n\t\tfunction scissor(scissor) {\n\t\t\tif (currentScissor.equals(scissor) === false) {\n\t\t\t\tgl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);\n\t\t\t\tcurrentScissor.copy(scissor);\n\t\t\t}\n\t\t}\n\n\t\tfunction viewport(viewport) {\n\t\t\tif (currentViewport.equals(viewport) === false) {\n\t\t\t\tgl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);\n\t\t\t\tcurrentViewport.copy(viewport);\n\t\t\t}\n\t\t} //\n\n\n\t\tfunction reset() {\n\t\t\t// reset state\n\t\t\tgl.disable(gl.BLEND);\n\t\t\tgl.disable(gl.CULL_FACE);\n\t\t\tgl.disable(gl.DEPTH_TEST);\n\t\t\tgl.disable(gl.POLYGON_OFFSET_FILL);\n\t\t\tgl.disable(gl.SCISSOR_TEST);\n\t\t\tgl.disable(gl.STENCIL_TEST);\n\t\t\tgl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n\t\t\tgl.blendEquation(gl.FUNC_ADD);\n\t\t\tgl.blendFunc(gl.ONE, gl.ZERO);\n\t\t\tgl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);\n\t\t\tgl.colorMask(true, true, true, true);\n\t\t\tgl.clearColor(0, 0, 0, 0);\n\t\t\tgl.depthMask(true);\n\t\t\tgl.depthFunc(gl.LESS);\n\t\t\tgl.clearDepth(1);\n\t\t\tgl.stencilMask(0xffffffff);\n\t\t\tgl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);\n\t\t\tgl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n\t\t\tgl.clearStencil(0);\n\t\t\tgl.cullFace(gl.BACK);\n\t\t\tgl.frontFace(gl.CCW);\n\t\t\tgl.polygonOffset(0, 0);\n\t\t\tgl.activeTexture(gl.TEXTURE0);\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n\t\t\tif (isWebGL2 === true) {\n\t\t\t\tgl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);\n\t\t\t\tgl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n\t\t\t}\n\n\t\t\tgl.useProgram(null);\n\t\t\tgl.lineWidth(1);\n\t\t\tgl.scissor(0, 0, gl.canvas.width, gl.canvas.height);\n\t\t\tgl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // reset internals\n\n\t\t\tenabledCapabilities = {};\n\t\t\tcurrentTextureSlot = null;\n\t\t\tcurrentBoundTextures = {};\n\t\t\txrFramebuffer = null;\n\t\t\tcurrentBoundFramebuffers = {};\n\t\t\tcurrentProgram = null;\n\t\t\tcurrentBlendingEnabled = false;\n\t\t\tcurrentBlending = null;\n\t\t\tcurrentBlendEquation = null;\n\t\t\tcurrentBlendSrc = null;\n\t\t\tcurrentBlendDst = null;\n\t\t\tcurrentBlendEquationAlpha = null;\n\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\tcurrentBlendDstAlpha = null;\n\t\t\tcurrentPremultipledAlpha = false;\n\t\t\tcurrentFlipSided = null;\n\t\t\tcurrentCullFace = null;\n\t\t\tcurrentLineWidth = null;\n\t\t\tcurrentPolygonOffsetFactor = null;\n\t\t\tcurrentPolygonOffsetUnits = null;\n\t\t\tcurrentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);\n\t\t\tcurrentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);\n\t\t\tcolorBuffer.reset();\n\t\t\tdepthBuffer.reset();\n\t\t\tstencilBuffer.reset();\n\t\t}\n\n\t\treturn {\n\t\t\tbuffers: {\n\t\t\t\tcolor: colorBuffer,\n\t\t\t\tdepth: depthBuffer,\n\t\t\t\tstencil: stencilBuffer\n\t\t\t},\n\t\t\tenable: enable,\n\t\t\tdisable: disable,\n\t\t\tbindFramebuffer: bindFramebuffer,\n\t\t\tbindXRFramebuffer: bindXRFramebuffer,\n\t\t\tuseProgram: useProgram,\n\t\t\tsetBlending: setBlending,\n\t\t\tsetMaterial: setMaterial,\n\t\t\tsetFlipSided: setFlipSided,\n\t\t\tsetCullFace: setCullFace,\n\t\t\tsetLineWidth: setLineWidth,\n\t\t\tsetPolygonOffset: setPolygonOffset,\n\t\t\tsetScissorTest: setScissorTest,\n\t\t\tactiveTexture: activeTexture,\n\t\t\tbindTexture: bindTexture,\n\t\t\tunbindTexture: unbindTexture,\n\t\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\t\ttexImage2D: texImage2D,\n\t\t\ttexImage3D: texImage3D,\n\t\t\tscissor: scissor,\n\t\t\tviewport: viewport,\n\t\t\treset: reset\n\t\t};\n\t}\n\n\tfunction WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\t\tconst maxTextures = capabilities.maxTextures;\n\t\tconst maxCubemapSize = capabilities.maxCubemapSize;\n\t\tconst maxTextureSize = capabilities.maxTextureSize;\n\t\tconst maxSamples = capabilities.maxSamples;\n\n\t\tconst _videoTextures = new WeakMap();\n\n\t\tlet _canvas; // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,\n\t\t// also OffscreenCanvas.getContext(\"webgl\"), but not OffscreenCanvas.getContext(\"2d\")!\n\t\t// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).\n\n\n\t\tlet useOffscreenCanvas = false;\n\n\t\ttry {\n\t\t\tuseOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;\n\t\t} catch (err) {// Ignore any errors\n\t\t}\n\n\t\tfunction createCanvas(width, height) {\n\t\t\t// Use OffscreenCanvas when available. Specially needed in web workers\n\t\t\treturn useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');\n\t\t}\n\n\t\tfunction resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {\n\t\t\tlet scale = 1; // handle case if texture exceeds max size\n\n\t\t\tif (image.width > maxSize || image.height > maxSize) {\n\t\t\t\tscale = maxSize / Math.max(image.width, image.height);\n\t\t\t} // only perform resize if necessary\n\n\n\t\t\tif (scale < 1 || needsPowerOfTwo === true) {\n\t\t\t\t// only perform resize for certain image types\n\t\t\t\tif (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n\t\t\t\t\tconst floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;\n\t\t\t\t\tconst width = floor(scale * image.width);\n\t\t\t\t\tconst height = floor(scale * image.height);\n\t\t\t\t\tif (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas\n\n\t\t\t\t\tconst canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;\n\t\t\t\t\tcanvas.width = width;\n\t\t\t\t\tcanvas.height = height;\n\t\t\t\t\tconst context = canvas.getContext('2d');\n\t\t\t\t\tcontext.drawImage(image, 0, 0, width, height);\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');\n\t\t\t\t\treturn canvas;\n\t\t\t\t} else {\n\t\t\t\t\tif ('data' in image) {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn image;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn image;\n\t\t}\n\n\t\tfunction isPowerOfTwo$1(image) {\n\t\t\treturn isPowerOfTwo(image.width) && isPowerOfTwo(image.height);\n\t\t}\n\n\t\tfunction textureNeedsPowerOfTwo(texture) {\n\t\t\tif (isWebGL2) return false;\n\t\t\treturn texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\t\t}\n\n\t\tfunction textureNeedsGenerateMipmaps(texture, supportsMips) {\n\t\t\treturn texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\t\t}\n\n\t\tfunction generateMipmap(target, texture, width, height) {\n\t\t\t_gl.generateMipmap(target);\n\n\t\t\tconst textureProperties = properties.get(texture);\n\t\t\ttextureProperties.__maxMipLevel = Math.log2(Math.max(width, height));\n\t\t}\n\n\t\tfunction getInternalFormat(internalFormatName, glFormat, glType) {\n\t\t\tif (isWebGL2 === false) return glFormat;\n\n\t\t\tif (internalFormatName !== null) {\n\t\t\t\tif (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'');\n\t\t\t}\n\n\t\t\tlet internalFormat = glFormat;\n\n\t\t\tif (glFormat === _gl.RED) {\n\t\t\t\tif (glType === _gl.FLOAT) internalFormat = _gl.R32F;\n\t\t\t\tif (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;\n\t\t\t\tif (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;\n\t\t\t}\n\n\t\t\tif (glFormat === _gl.RGB) {\n\t\t\t\tif (glType === _gl.FLOAT) internalFormat = _gl.RGB32F;\n\t\t\t\tif (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGB16F;\n\t\t\t\tif (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8;\n\t\t\t}\n\n\t\t\tif (glFormat === _gl.RGBA) {\n\t\t\t\tif (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;\n\t\t\t\tif (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;\n\t\t\t\tif (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8;\n\t\t\t}\n\n\t\t\tif (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {\n\t\t\t\textensions.get('EXT_color_buffer_float');\n\t\t\t}\n\n\t\t\treturn internalFormat;\n\t\t} // Fallback filters for non-power-of-2 textures\n\n\n\t\tfunction filterFallback(f) {\n\t\t\tif (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {\n\t\t\t\treturn _gl.NEAREST;\n\t\t\t}\n\n\t\t\treturn _gl.LINEAR;\n\t\t} //\n\n\n\t\tfunction onTextureDispose(event) {\n\t\t\tconst texture = event.target;\n\t\t\ttexture.removeEventListener('dispose', onTextureDispose);\n\t\t\tdeallocateTexture(texture);\n\n\t\t\tif (texture.isVideoTexture) {\n\t\t\t\t_videoTextures.delete(texture);\n\t\t\t}\n\n\t\t\tinfo.memory.textures--;\n\t\t}\n\n\t\tfunction onRenderTargetDispose(event) {\n\t\t\tconst renderTarget = event.target;\n\t\t\trenderTarget.removeEventListener('dispose', onRenderTargetDispose);\n\t\t\tdeallocateRenderTarget(renderTarget);\n\t\t} //\n\n\n\t\tfunction deallocateTexture(texture) {\n\t\t\tconst textureProperties = properties.get(texture);\n\t\t\tif (textureProperties.__webglInit === undefined) return;\n\n\t\t\t_gl.deleteTexture(textureProperties.__webglTexture);\n\n\t\t\tproperties.remove(texture);\n\t\t}\n\n\t\tfunction deallocateRenderTarget(renderTarget) {\n\t\t\tconst texture = renderTarget.texture;\n\t\t\tconst renderTargetProperties = properties.get(renderTarget);\n\t\t\tconst textureProperties = properties.get(texture);\n\t\t\tif (!renderTarget) return;\n\n\t\t\tif (textureProperties.__webglTexture !== undefined) {\n\t\t\t\t_gl.deleteTexture(textureProperties.__webglTexture);\n\n\t\t\t\tinfo.memory.textures--;\n\t\t\t}\n\n\t\t\tif (renderTarget.depthTexture) {\n\t\t\t\trenderTarget.depthTexture.dispose();\n\t\t\t}\n\n\t\t\tif (renderTarget.isWebGLCubeRenderTarget) {\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\t_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);\n\n\t\t\t\t\tif (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);\n\n\t\t\t\tif (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);\n\t\t\t\tif (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);\n\t\t\t\tif (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);\n\t\t\t\tif (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);\n\t\t\t}\n\n\t\t\tif (renderTarget.isWebGLMultipleRenderTargets) {\n\t\t\t\tfor (let i = 0, il = texture.length; i < il; i++) {\n\t\t\t\t\tconst attachmentProperties = properties.get(texture[i]);\n\n\t\t\t\t\tif (attachmentProperties.__webglTexture) {\n\t\t\t\t\t\t_gl.deleteTexture(attachmentProperties.__webglTexture);\n\n\t\t\t\t\t\tinfo.memory.textures--;\n\t\t\t\t\t}\n\n\t\t\t\t\tproperties.remove(texture[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tproperties.remove(texture);\n\t\t\tproperties.remove(renderTarget);\n\t\t} //\n\n\n\t\tlet textureUnits = 0;\n\n\t\tfunction resetTextureUnits() {\n\t\t\ttextureUnits = 0;\n\t\t}\n\n\t\tfunction allocateTextureUnit() {\n\t\t\tconst textureUnit = textureUnits;\n\n\t\t\tif (textureUnit >= maxTextures) {\n\t\t\t\tconsole.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);\n\t\t\t}\n\n\t\t\ttextureUnits += 1;\n\t\t\treturn textureUnit;\n\t\t} //\n\n\n\t\tfunction setTexture2D(texture, slot) {\n\t\t\tconst textureProperties = properties.get(texture);\n\t\t\tif (texture.isVideoTexture) updateVideoTexture(texture);\n\n\t\t\tif (texture.version > 0 && textureProperties.__version !== texture.version) {\n\t\t\t\tconst image = texture.image;\n\n\t\t\t\tif (image === undefined) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');\n\t\t\t\t} else if (image.complete === false) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');\n\t\t\t\t} else {\n\t\t\t\t\tuploadTexture(textureProperties, texture, slot);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);\n\t\t}\n\n\t\tfunction setTexture2DArray(texture, slot) {\n\t\t\tconst textureProperties = properties.get(texture);\n\n\t\t\tif (texture.version > 0 && textureProperties.__version !== texture.version) {\n\t\t\t\tuploadTexture(textureProperties, texture, slot);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);\n\t\t}\n\n\t\tfunction setTexture3D(texture, slot) {\n\t\t\tconst textureProperties = properties.get(texture);\n\n\t\t\tif (texture.version > 0 && textureProperties.__version !== texture.version) {\n\t\t\t\tuploadTexture(textureProperties, texture, slot);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);\n\t\t}\n\n\t\tfunction setTextureCube(texture, slot) {\n\t\t\tconst textureProperties = properties.get(texture);\n\n\t\t\tif (texture.version > 0 && textureProperties.__version !== texture.version) {\n\t\t\t\tuploadCubeTexture(textureProperties, texture, slot);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);\n\t\t}\n\n\t\tconst wrappingToGL = {\n\t\t\t[RepeatWrapping]: _gl.REPEAT,\n\t\t\t[ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,\n\t\t\t[MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT\n\t\t};\n\t\tconst filterToGL = {\n\t\t\t[NearestFilter]: _gl.NEAREST,\n\t\t\t[NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,\n\t\t\t[NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,\n\t\t\t[LinearFilter]: _gl.LINEAR,\n\t\t\t[LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,\n\t\t\t[LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR\n\t\t};\n\n\t\tfunction setTextureParameters(textureType, texture, supportsMips) {\n\t\t\tif (supportsMips) {\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);\n\n\t\t\t\tif (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {\n\t\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);\n\t\t\t\t}\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);\n\t\t\t} else {\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);\n\n\t\t\t\tif (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {\n\t\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);\n\t\t\t\t}\n\n\t\t\t\tif (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');\n\t\t\t\t}\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));\n\n\t\t\t\t_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));\n\n\t\t\t\tif (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (extensions.has('EXT_texture_filter_anisotropic') === true) {\n\t\t\t\tconst extension = extensions.get('EXT_texture_filter_anisotropic');\n\t\t\t\tif (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2\n\n\t\t\t\tif (isWebGL2 === false && texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false) return; // verify extension for WebGL 1 only\n\n\t\t\t\tif (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {\n\t\t\t\t\t_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));\n\n\t\t\t\t\tproperties.get(texture).__currentAnisotropy = texture.anisotropy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction initTexture(textureProperties, texture) {\n\t\t\tif (textureProperties.__webglInit === undefined) {\n\t\t\t\ttextureProperties.__webglInit = true;\n\t\t\t\ttexture.addEventListener('dispose', onTextureDispose);\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\t\t\tinfo.memory.textures++;\n\t\t\t}\n\t\t}\n\n\t\tfunction uploadTexture(textureProperties, texture, slot) {\n\t\t\tlet textureType = _gl.TEXTURE_2D;\n\t\t\tif (texture.isDataTexture2DArray) textureType = _gl.TEXTURE_2D_ARRAY;\n\t\t\tif (texture.isDataTexture3D) textureType = _gl.TEXTURE_3D;\n\t\t\tinitTexture(textureProperties, texture);\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(textureType, textureProperties.__webglTexture);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);\n\n\t\t\tconst needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;\n\t\t\tconst image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);\n\t\t\tconst supportsMips = isPowerOfTwo$1(image) || isWebGL2,\n\t\t\t\t\t\tglFormat = utils.convert(texture.format);\n\t\t\tlet glType = utils.convert(texture.type),\n\t\t\t\t\tglInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\t\t\tsetTextureParameters(textureType, texture, supportsMips);\n\t\t\tlet mipmap;\n\t\t\tconst mipmaps = texture.mipmaps;\n\n\t\t\tif (texture.isDepthTexture) {\n\t\t\t\t// populate depth texture with dummy data\n\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT;\n\n\t\t\t\tif (isWebGL2) {\n\t\t\t\t\tif (texture.type === FloatType) {\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT32F;\n\t\t\t\t\t} else if (texture.type === UnsignedIntType) {\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT24;\n\t\t\t\t\t} else if (texture.type === UnsignedInt248Type) {\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH24_STENCIL8;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (texture.type === FloatType) {\n\t\t\t\t\t\tconsole.error('WebGLRenderer: Floating point depth texture requires WebGL2.');\n\t\t\t\t\t}\n\t\t\t\t} // validation checks for WebGL 1\n\n\n\t\t\t\tif (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {\n\t\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t\t// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\tif (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');\n\t\t\t\t\t\ttexture.type = UnsignedShortType;\n\t\t\t\t\t\tglType = utils.convert(texture.type);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {\n\t\t\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\tglInternalFormat = _gl.DEPTH_STENCIL; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t\t// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\n\t\t\t\t\tif (texture.type !== UnsignedInt248Type) {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');\n\t\t\t\t\t\ttexture.type = UnsignedInt248Type;\n\t\t\t\t\t\tglType = utils.convert(texture.type);\n\t\t\t\t\t}\n\t\t\t\t} //\n\n\n\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);\n\t\t\t} else if (texture.isDataTexture) {\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\t\t\tif (mipmaps.length > 0 && supportsMips) {\n\t\t\t\t\tfor (let i = 0, il = mipmaps.length; i < il; i++) {\n\t\t\t\t\t\tmipmap = mipmaps[i];\n\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\t\t\t\t} else {\n\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);\n\t\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\t\t\t\t}\n\t\t\t} else if (texture.isCompressedTexture) {\n\t\t\t\tfor (let i = 0, il = mipmaps.length; i < il; i++) {\n\t\t\t\t\tmipmap = mipmaps[i];\n\n\t\t\t\t\tif (texture.format !== RGBAFormat && texture.format !== RGBFormat) {\n\t\t\t\t\t\tif (glFormat !== null) {\n\t\t\t\t\t\t\tstate.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\t\t\t} else if (texture.isDataTexture2DArray) {\n\t\t\t\tstate.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\t\t\t} else if (texture.isDataTexture3D) {\n\t\t\t\tstate.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\t\t\t} else {\n\t\t\t\t// regular Texture (image, video, canvas)\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\t\t\t\tif (mipmaps.length > 0 && supportsMips) {\n\t\t\t\t\tfor (let i = 0, il = mipmaps.length; i < il; i++) {\n\t\t\t\t\t\tmipmap = mipmaps[i];\n\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\t\t\t\t} else {\n\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);\n\t\t\t\t\ttextureProperties.__maxMipLevel = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n\t\t\t\tgenerateMipmap(textureType, texture, image.width, image.height);\n\t\t\t}\n\n\t\t\ttextureProperties.__version = texture.version;\n\t\t\tif (texture.onUpdate) texture.onUpdate(texture);\n\t\t}\n\n\t\tfunction uploadCubeTexture(textureProperties, texture, slot) {\n\t\t\tif (texture.image.length !== 6) return;\n\t\t\tinitTexture(textureProperties, texture);\n\t\t\tstate.activeTexture(_gl.TEXTURE0 + slot);\n\t\t\tstate.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);\n\n\t\t\tconst isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);\n\t\t\tconst isDataTexture = texture.image[0] && texture.image[0].isDataTexture;\n\t\t\tconst cubeImage = [];\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tif (!isCompressed && !isDataTexture) {\n\t\t\t\t\tcubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);\n\t\t\t\t} else {\n\t\t\t\t\tcubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst image = cubeImage[0],\n\t\t\t\t\t\tsupportsMips = isPowerOfTwo$1(image) || isWebGL2,\n\t\t\t\t\t\tglFormat = utils.convert(texture.format),\n\t\t\t\t\t\tglType = utils.convert(texture.type),\n\t\t\t\t\t\tglInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\t\t\tsetTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);\n\t\t\tlet mipmaps;\n\n\t\t\tif (isCompressed) {\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tmipmaps = cubeImage[i].mipmaps;\n\n\t\t\t\t\tfor (let j = 0; j < mipmaps.length; j++) {\n\t\t\t\t\t\tconst mipmap = mipmaps[j];\n\n\t\t\t\t\t\tif (texture.format !== RGBAFormat && texture.format !== RGBFormat) {\n\t\t\t\t\t\t\tif (glFormat !== null) {\n\t\t\t\t\t\t\t\tstate.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length - 1;\n\t\t\t} else {\n\t\t\t\tmipmaps = texture.mipmaps;\n\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tif (isDataTexture) {\n\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);\n\n\t\t\t\t\t\tfor (let j = 0; j < mipmaps.length; j++) {\n\t\t\t\t\t\t\tconst mipmap = mipmaps[j];\n\t\t\t\t\t\t\tconst mipmapImage = mipmap.image[i].image;\n\t\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);\n\n\t\t\t\t\t\tfor (let j = 0; j < mipmaps.length; j++) {\n\t\t\t\t\t\t\tconst mipmap = mipmaps[j];\n\t\t\t\t\t\t\tstate.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttextureProperties.__maxMipLevel = mipmaps.length;\n\t\t\t}\n\n\t\t\tif (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n\t\t\t\t// We assume images for cube map have the same size.\n\t\t\t\tgenerateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);\n\t\t\t}\n\n\t\t\ttextureProperties.__version = texture.version;\n\t\t\tif (texture.onUpdate) texture.onUpdate(texture);\n\t\t} // Render targets\n\t\t// Setup storage for target texture and bind it to correct framebuffer\n\n\n\t\tfunction setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {\n\t\t\tconst glFormat = utils.convert(texture.format);\n\t\t\tconst glType = utils.convert(texture.type);\n\t\t\tconst glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\n\t\t\tif (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {\n\t\t\t\tstate.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);\n\t\t\t} else {\n\t\t\t\tstate.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);\n\t\t\t}\n\n\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n\t\t\t_gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);\n\n\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, null);\n\t\t} // Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\n\n\t\tfunction setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {\n\t\t\t_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);\n\n\t\t\tif (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {\n\t\t\t\tlet glInternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\t\tif (isMultisample) {\n\t\t\t\t\tconst depthTexture = renderTarget.depthTexture;\n\n\t\t\t\t\tif (depthTexture && depthTexture.isDepthTexture) {\n\t\t\t\t\t\tif (depthTexture.type === FloatType) {\n\t\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT32F;\n\t\t\t\t\t\t} else if (depthTexture.type === UnsignedIntType) {\n\t\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT24;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst samples = getRenderTargetSamples(renderTarget);\n\n\t\t\t\t\t_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n\t\t\t\t} else {\n\t\t\t\t\t_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);\n\t\t\t\t}\n\n\t\t\t\t_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);\n\t\t\t} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {\n\t\t\t\tif (isMultisample) {\n\t\t\t\t\tconst samples = getRenderTargetSamples(renderTarget);\n\n\t\t\t\t\t_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);\n\t\t\t\t} else {\n\t\t\t\t\t_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);\n\t\t\t\t}\n\n\t\t\t\t_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);\n\t\t\t} else {\n\t\t\t\t// Use the first texture for MRT so far\n\t\t\t\tconst texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;\n\t\t\t\tconst glFormat = utils.convert(texture.format);\n\t\t\t\tconst glType = utils.convert(texture.type);\n\t\t\t\tconst glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\n\t\t\t\tif (isMultisample) {\n\t\t\t\t\tconst samples = getRenderTargetSamples(renderTarget);\n\n\t\t\t\t\t_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n\t\t\t\t} else {\n\t\t\t\t\t_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);\n\t\t} // Setup resources for a Depth Texture for a FBO (needs an extension)\n\n\n\t\tfunction setupDepthTexture(framebuffer, renderTarget) {\n\t\t\tconst isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;\n\t\t\tif (isCube) throw new Error('Depth Texture with cube render targets is not supported');\n\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n\t\t\tif (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {\n\t\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n\t\t\t} // upload an empty depth texture with framebuffer size\n\n\n\t\t\tif (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {\n\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\t\t\t}\n\n\t\t\tsetTexture2D(renderTarget.depthTexture, 0);\n\n\t\t\tconst webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;\n\n\t\t\tif (renderTarget.depthTexture.format === DepthFormat) {\n\t\t\t\t_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);\n\t\t\t} else if (renderTarget.depthTexture.format === DepthStencilFormat) {\n\t\t\t\t_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown depthTexture format');\n\t\t\t}\n\t\t} // Setup GL resources for a non-texture depth buffer\n\n\n\t\tfunction setupDepthRenderbuffer(renderTarget) {\n\t\t\tconst renderTargetProperties = properties.get(renderTarget);\n\t\t\tconst isCube = renderTarget.isWebGLCubeRenderTarget === true;\n\n\t\t\tif (renderTarget.depthTexture) {\n\t\t\t\tif (isCube) throw new Error('target.depthTexture not supported in Cube render targets');\n\t\t\t\tsetupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);\n\t\t\t} else {\n\t\t\t\tif (isCube) {\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();\n\t\t\t\t\t\tsetupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, null);\n\t\t} // Set up GL resources for the render target\n\n\n\t\tfunction setupRenderTarget(renderTarget) {\n\t\t\tconst texture = renderTarget.texture;\n\t\t\tconst renderTargetProperties = properties.get(renderTarget);\n\t\t\tconst textureProperties = properties.get(texture);\n\t\t\trenderTarget.addEventListener('dispose', onRenderTargetDispose);\n\n\t\t\tif (renderTarget.isWebGLMultipleRenderTargets !== true) {\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\t\t\t\ttextureProperties.__version = texture.version;\n\t\t\t\tinfo.memory.textures++;\n\t\t\t}\n\n\t\t\tconst isCube = renderTarget.isWebGLCubeRenderTarget === true;\n\t\t\tconst isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;\n\t\t\tconst isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;\n\t\t\tconst isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;\n\t\t\tconst supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2; // Handles WebGL2 RGBFormat fallback - #18858\n\n\t\t\tif (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {\n\t\t\t\ttexture.format = RGBAFormat;\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');\n\t\t\t} // Setup framebuffer\n\n\n\t\t\tif (isCube) {\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\t\tif (isMultipleRenderTargets) {\n\t\t\t\t\tif (capabilities.drawBuffers) {\n\t\t\t\t\t\tconst textures = renderTarget.texture;\n\n\t\t\t\t\t\tfor (let i = 0, il = textures.length; i < il; i++) {\n\t\t\t\t\t\t\tconst attachmentProperties = properties.get(textures[i]);\n\n\t\t\t\t\t\t\tif (attachmentProperties.__webglTexture === undefined) {\n\t\t\t\t\t\t\t\tattachmentProperties.__webglTexture = _gl.createTexture();\n\t\t\t\t\t\t\t\tinfo.memory.textures++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');\n\t\t\t\t\t}\n\t\t\t\t} else if (isMultisample) {\n\t\t\t\t\tif (isWebGL2) {\n\t\t\t\t\t\trenderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\n\t\t\t\t\t\trenderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();\n\n\t\t\t\t\t\t_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);\n\n\t\t\t\t\t\tconst glFormat = utils.convert(texture.format);\n\t\t\t\t\t\tconst glType = utils.convert(texture.type);\n\t\t\t\t\t\tconst glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n\t\t\t\t\t\tconst samples = getRenderTargetSamples(renderTarget);\n\n\t\t\t\t\t\t_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n\n\t\t\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n\n\t\t\t\t\t\t_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);\n\n\t\t\t\t\t\t_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);\n\n\t\t\t\t\t\tif (renderTarget.depthBuffer) {\n\t\t\t\t\t\t\trenderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n\t\t\t\t\t\t\tsetupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // Setup color buffer\n\n\n\t\t\tif (isCube) {\n\t\t\t\tstate.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);\n\t\t\t\tsetTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);\n\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tsetupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);\n\t\t\t\t}\n\n\t\t\t\tif (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n\t\t\t\t\tgenerateMipmap(_gl.TEXTURE_CUBE_MAP, texture, renderTarget.width, renderTarget.height);\n\t\t\t\t}\n\n\t\t\t\tstate.bindTexture(_gl.TEXTURE_CUBE_MAP, null);\n\t\t\t} else if (isMultipleRenderTargets) {\n\t\t\t\tconst textures = renderTarget.texture;\n\n\t\t\t\tfor (let i = 0, il = textures.length; i < il; i++) {\n\t\t\t\t\tconst attachment = textures[i];\n\t\t\t\t\tconst attachmentProperties = properties.get(attachment);\n\t\t\t\t\tstate.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);\n\t\t\t\t\tsetTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);\n\t\t\t\t\tsetupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D);\n\n\t\t\t\t\tif (textureNeedsGenerateMipmaps(attachment, supportsMips)) {\n\t\t\t\t\t\tgenerateMipmap(_gl.TEXTURE_2D, attachment, renderTarget.width, renderTarget.height);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstate.bindTexture(_gl.TEXTURE_2D, null);\n\t\t\t} else {\n\t\t\t\tlet glTextureType = _gl.TEXTURE_2D;\n\n\t\t\t\tif (isRenderTarget3D) {\n\t\t\t\t\t// Render targets containing layers, i.e: Texture 3D and 2d arrays\n\t\t\t\t\tif (isWebGL2) {\n\t\t\t\t\t\tconst isTexture3D = texture.isDataTexture3D;\n\t\t\t\t\t\tglTextureType = isTexture3D ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstate.bindTexture(glTextureType, textureProperties.__webglTexture);\n\t\t\t\tsetTextureParameters(glTextureType, texture, supportsMips);\n\t\t\t\tsetupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);\n\n\t\t\t\tif (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n\t\t\t\t\tgenerateMipmap(_gl.TEXTURE_2D, texture, renderTarget.width, renderTarget.height);\n\t\t\t\t}\n\n\t\t\t\tstate.bindTexture(_gl.TEXTURE_2D, null);\n\t\t\t} // Setup depth and stencil buffers\n\n\n\t\t\tif (renderTarget.depthBuffer) {\n\t\t\t\tsetupDepthRenderbuffer(renderTarget);\n\t\t\t}\n\t\t}\n\n\t\tfunction updateRenderTargetMipmap(renderTarget) {\n\t\t\tconst supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;\n\t\t\tconst textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];\n\n\t\t\tfor (let i = 0, il = textures.length; i < il; i++) {\n\t\t\t\tconst texture = textures[i];\n\n\t\t\t\tif (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n\t\t\t\t\tconst target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\n\t\t\t\t\tconst webglTexture = properties.get(texture).__webglTexture;\n\n\t\t\t\t\tstate.bindTexture(target, webglTexture);\n\t\t\t\t\tgenerateMipmap(target, texture, renderTarget.width, renderTarget.height);\n\t\t\t\t\tstate.bindTexture(target, null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction updateMultisampleRenderTarget(renderTarget) {\n\t\t\tif (renderTarget.isWebGLMultisampleRenderTarget) {\n\t\t\t\tif (isWebGL2) {\n\t\t\t\t\tconst width = renderTarget.width;\n\t\t\t\t\tconst height = renderTarget.height;\n\t\t\t\t\tlet mask = _gl.COLOR_BUFFER_BIT;\n\t\t\t\t\tif (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;\n\t\t\t\t\tif (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;\n\t\t\t\t\tconst renderTargetProperties = properties.get(renderTarget);\n\t\t\t\t\tstate.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n\t\t\t\t\tstate.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);\n\n\t\t\t\t\t_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);\n\n\t\t\t\t\tstate.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);\n\t\t\t\t\tstate.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction getRenderTargetSamples(renderTarget) {\n\t\t\treturn isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;\n\t\t}\n\n\t\tfunction updateVideoTexture(texture) {\n\t\t\tconst frame = info.render.frame; // Check the last frame we updated the VideoTexture\n\n\t\t\tif (_videoTextures.get(texture) !== frame) {\n\t\t\t\t_videoTextures.set(texture, frame);\n\n\t\t\t\ttexture.update();\n\t\t\t}\n\t\t} // backwards compatibility\n\n\n\t\tlet warnedTexture2D = false;\n\t\tlet warnedTextureCube = false;\n\n\t\tfunction safeSetTexture2D(texture, slot) {\n\t\t\tif (texture && texture.isWebGLRenderTarget) {\n\t\t\t\tif (warnedTexture2D === false) {\n\t\t\t\t\tconsole.warn('THREE.WebGLTextures.safeSetTexture2D: don\\'t use render targets as textures. Use their .texture property instead.');\n\t\t\t\t\twarnedTexture2D = true;\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\t\t\t}\n\n\t\t\tsetTexture2D(texture, slot);\n\t\t}\n\n\t\tfunction safeSetTextureCube(texture, slot) {\n\t\t\tif (texture && texture.isWebGLCubeRenderTarget) {\n\t\t\t\tif (warnedTextureCube === false) {\n\t\t\t\t\tconsole.warn('THREE.WebGLTextures.safeSetTextureCube: don\\'t use cube render targets as textures. Use their .texture property instead.');\n\t\t\t\t\twarnedTextureCube = true;\n\t\t\t\t}\n\n\t\t\t\ttexture = texture.texture;\n\t\t\t}\n\n\t\t\tsetTextureCube(texture, slot);\n\t\t} //\n\n\n\t\tthis.allocateTextureUnit = allocateTextureUnit;\n\t\tthis.resetTextureUnits = resetTextureUnits;\n\t\tthis.setTexture2D = setTexture2D;\n\t\tthis.setTexture2DArray = setTexture2DArray;\n\t\tthis.setTexture3D = setTexture3D;\n\t\tthis.setTextureCube = setTextureCube;\n\t\tthis.setupRenderTarget = setupRenderTarget;\n\t\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\t\tthis.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n\t\tthis.safeSetTexture2D = safeSetTexture2D;\n\t\tthis.safeSetTextureCube = safeSetTextureCube;\n\t}\n\n\tfunction WebGLUtils(gl, extensions, capabilities) {\n\t\tconst isWebGL2 = capabilities.isWebGL2;\n\n\t\tfunction convert(p) {\n\t\t\tlet extension;\n\t\t\tif (p === UnsignedByteType) return gl.UNSIGNED_BYTE;\n\t\t\tif (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\tif (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\tif (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;\n\t\t\tif (p === ByteType) return gl.BYTE;\n\t\t\tif (p === ShortType) return gl.SHORT;\n\t\t\tif (p === UnsignedShortType) return gl.UNSIGNED_SHORT;\n\t\t\tif (p === IntType) return gl.INT;\n\t\t\tif (p === UnsignedIntType) return gl.UNSIGNED_INT;\n\t\t\tif (p === FloatType) return gl.FLOAT;\n\n\t\t\tif (p === HalfFloatType) {\n\t\t\t\tif (isWebGL2) return gl.HALF_FLOAT;\n\t\t\t\textension = extensions.get('OES_texture_half_float');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\treturn extension.HALF_FLOAT_OES;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === AlphaFormat) return gl.ALPHA;\n\t\t\tif (p === RGBFormat) return gl.RGB;\n\t\t\tif (p === RGBAFormat) return gl.RGBA;\n\t\t\tif (p === LuminanceFormat) return gl.LUMINANCE;\n\t\t\tif (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;\n\t\t\tif (p === DepthFormat) return gl.DEPTH_COMPONENT;\n\t\t\tif (p === DepthStencilFormat) return gl.DEPTH_STENCIL;\n\t\t\tif (p === RedFormat) return gl.RED; // WebGL2 formats.\n\n\t\t\tif (p === RedIntegerFormat) return gl.RED_INTEGER;\n\t\t\tif (p === RGFormat) return gl.RG;\n\t\t\tif (p === RGIntegerFormat) return gl.RG_INTEGER;\n\t\t\tif (p === RGBIntegerFormat) return gl.RGB_INTEGER;\n\t\t\tif (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;\n\n\t\t\tif (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {\n\t\t\t\textension = extensions.get('WEBGL_compressed_texture_s3tc');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\tif (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {\n\t\t\t\textension = extensions.get('WEBGL_compressed_texture_pvrtc');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\tif (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\t\tif (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\t\tif (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === RGB_ETC1_Format) {\n\t\t\t\textension = extensions.get('WEBGL_compressed_texture_etc1');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\treturn extension.COMPRESSED_RGB_ETC1_WEBGL;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {\n\t\t\t\textension = extensions.get('WEBGL_compressed_texture_etc');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\tif (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;\n\t\t\t\t\tif (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {\n\t\t\t\textension = extensions.get('WEBGL_compressed_texture_astc');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\t// TODO Complete?\n\t\t\t\t\treturn p;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === RGBA_BPTC_Format) {\n\t\t\t\textension = extensions.get('EXT_texture_compression_bptc');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\t// TODO Complete?\n\t\t\t\t\treturn p;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (p === UnsignedInt248Type) {\n\t\t\t\tif (isWebGL2) return gl.UNSIGNED_INT_24_8;\n\t\t\t\textension = extensions.get('WEBGL_depth_texture');\n\n\t\t\t\tif (extension !== null) {\n\t\t\t\t\treturn extension.UNSIGNED_INT_24_8_WEBGL;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tconvert: convert\n\t\t};\n\t}\n\n\tclass ArrayCamera extends PerspectiveCamera {\n\t\tconstructor(array = []) {\n\t\t\tsuper();\n\t\t\tthis.cameras = array;\n\t\t}\n\n\t}\n\n\tArrayCamera.prototype.isArrayCamera = true;\n\n\tclass Group extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'Group';\n\t\t}\n\n\t}\n\n\tGroup.prototype.isGroup = true;\n\n\tconst _moveEvent = {\n\t\ttype: 'move'\n\t};\n\n\tclass WebXRController {\n\t\tconstructor() {\n\t\t\tthis._targetRay = null;\n\t\t\tthis._grip = null;\n\t\t\tthis._hand = null;\n\t\t}\n\n\t\tgetHandSpace() {\n\t\t\tif (this._hand === null) {\n\t\t\t\tthis._hand = new Group();\n\t\t\t\tthis._hand.matrixAutoUpdate = false;\n\t\t\t\tthis._hand.visible = false;\n\t\t\t\tthis._hand.joints = {};\n\t\t\t\tthis._hand.inputState = {\n\t\t\t\t\tpinching: false\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn this._hand;\n\t\t}\n\n\t\tgetTargetRaySpace() {\n\t\t\tif (this._targetRay === null) {\n\t\t\t\tthis._targetRay = new Group();\n\t\t\t\tthis._targetRay.matrixAutoUpdate = false;\n\t\t\t\tthis._targetRay.visible = false;\n\t\t\t\tthis._targetRay.hasLinearVelocity = false;\n\t\t\t\tthis._targetRay.linearVelocity = new Vector3();\n\t\t\t\tthis._targetRay.hasAngularVelocity = false;\n\t\t\t\tthis._targetRay.angularVelocity = new Vector3();\n\t\t\t}\n\n\t\t\treturn this._targetRay;\n\t\t}\n\n\t\tgetGripSpace() {\n\t\t\tif (this._grip === null) {\n\t\t\t\tthis._grip = new Group();\n\t\t\t\tthis._grip.matrixAutoUpdate = false;\n\t\t\t\tthis._grip.visible = false;\n\t\t\t\tthis._grip.hasLinearVelocity = false;\n\t\t\t\tthis._grip.linearVelocity = new Vector3();\n\t\t\t\tthis._grip.hasAngularVelocity = false;\n\t\t\t\tthis._grip.angularVelocity = new Vector3();\n\t\t\t}\n\n\t\t\treturn this._grip;\n\t\t}\n\n\t\tdispatchEvent(event) {\n\t\t\tif (this._targetRay !== null) {\n\t\t\t\tthis._targetRay.dispatchEvent(event);\n\t\t\t}\n\n\t\t\tif (this._grip !== null) {\n\t\t\t\tthis._grip.dispatchEvent(event);\n\t\t\t}\n\n\t\t\tif (this._hand !== null) {\n\t\t\t\tthis._hand.dispatchEvent(event);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tdisconnect(inputSource) {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'disconnected',\n\t\t\t\tdata: inputSource\n\t\t\t});\n\n\t\t\tif (this._targetRay !== null) {\n\t\t\t\tthis._targetRay.visible = false;\n\t\t\t}\n\n\t\t\tif (this._grip !== null) {\n\t\t\t\tthis._grip.visible = false;\n\t\t\t}\n\n\t\t\tif (this._hand !== null) {\n\t\t\t\tthis._hand.visible = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tupdate(inputSource, frame, referenceSpace) {\n\t\t\tlet inputPose = null;\n\t\t\tlet gripPose = null;\n\t\t\tlet handPose = null;\n\t\t\tconst targetRay = this._targetRay;\n\t\t\tconst grip = this._grip;\n\t\t\tconst hand = this._hand;\n\n\t\t\tif (inputSource && frame.session.visibilityState !== 'visible-blurred') {\n\t\t\t\tif (targetRay !== null) {\n\t\t\t\t\tinputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);\n\n\t\t\t\t\tif (inputPose !== null) {\n\t\t\t\t\t\ttargetRay.matrix.fromArray(inputPose.transform.matrix);\n\t\t\t\t\t\ttargetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);\n\n\t\t\t\t\t\tif (inputPose.linearVelocity) {\n\t\t\t\t\t\t\ttargetRay.hasLinearVelocity = true;\n\t\t\t\t\t\t\ttargetRay.linearVelocity.copy(inputPose.linearVelocity);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttargetRay.hasLinearVelocity = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (inputPose.angularVelocity) {\n\t\t\t\t\t\t\ttargetRay.hasAngularVelocity = true;\n\t\t\t\t\t\t\ttargetRay.angularVelocity.copy(inputPose.angularVelocity);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttargetRay.hasAngularVelocity = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.dispatchEvent(_moveEvent);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (hand && inputSource.hand) {\n\t\t\t\t\thandPose = true;\n\n\t\t\t\t\tfor (const inputjoint of inputSource.hand.values()) {\n\t\t\t\t\t\t// Update the joints groups with the XRJoint poses\n\t\t\t\t\t\tconst jointPose = frame.getJointPose(inputjoint, referenceSpace);\n\n\t\t\t\t\t\tif (hand.joints[inputjoint.jointName] === undefined) {\n\t\t\t\t\t\t\t// The transform of this joint will be updated with the joint pose on each frame\n\t\t\t\t\t\t\tconst joint = new Group();\n\t\t\t\t\t\t\tjoint.matrixAutoUpdate = false;\n\t\t\t\t\t\t\tjoint.visible = false;\n\t\t\t\t\t\t\thand.joints[inputjoint.jointName] = joint; // ??\n\n\t\t\t\t\t\t\thand.add(joint);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst joint = hand.joints[inputjoint.jointName];\n\n\t\t\t\t\t\tif (jointPose !== null) {\n\t\t\t\t\t\t\tjoint.matrix.fromArray(jointPose.transform.matrix);\n\t\t\t\t\t\t\tjoint.matrix.decompose(joint.position, joint.rotation, joint.scale);\n\t\t\t\t\t\t\tjoint.jointRadius = jointPose.radius;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tjoint.visible = jointPose !== null;\n\t\t\t\t\t} // Custom events\n\t\t\t\t\t// Check pinchz\n\n\n\t\t\t\t\tconst indexTip = hand.joints['index-finger-tip'];\n\t\t\t\t\tconst thumbTip = hand.joints['thumb-tip'];\n\t\t\t\t\tconst distance = indexTip.position.distanceTo(thumbTip.position);\n\t\t\t\t\tconst distanceToPinch = 0.02;\n\t\t\t\t\tconst threshold = 0.005;\n\n\t\t\t\t\tif (hand.inputState.pinching && distance > distanceToPinch + threshold) {\n\t\t\t\t\t\thand.inputState.pinching = false;\n\t\t\t\t\t\tthis.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'pinchend',\n\t\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\t\ttarget: this\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {\n\t\t\t\t\t\thand.inputState.pinching = true;\n\t\t\t\t\t\tthis.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'pinchstart',\n\t\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\t\ttarget: this\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (grip !== null && inputSource.gripSpace) {\n\t\t\t\t\t\tgripPose = frame.getPose(inputSource.gripSpace, referenceSpace);\n\n\t\t\t\t\t\tif (gripPose !== null) {\n\t\t\t\t\t\t\tgrip.matrix.fromArray(gripPose.transform.matrix);\n\t\t\t\t\t\t\tgrip.matrix.decompose(grip.position, grip.rotation, grip.scale);\n\n\t\t\t\t\t\t\tif (gripPose.linearVelocity) {\n\t\t\t\t\t\t\t\tgrip.hasLinearVelocity = true;\n\t\t\t\t\t\t\t\tgrip.linearVelocity.copy(gripPose.linearVelocity);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgrip.hasLinearVelocity = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (gripPose.angularVelocity) {\n\t\t\t\t\t\t\t\tgrip.hasAngularVelocity = true;\n\t\t\t\t\t\t\t\tgrip.angularVelocity.copy(gripPose.angularVelocity);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgrip.hasAngularVelocity = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (targetRay !== null) {\n\t\t\t\ttargetRay.visible = inputPose !== null;\n\t\t\t}\n\n\t\t\tif (grip !== null) {\n\t\t\t\tgrip.visible = gripPose !== null;\n\t\t\t}\n\n\t\t\tif (hand !== null) {\n\t\t\t\thand.visible = handPose !== null;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass WebXRManager extends EventDispatcher {\n\t\tconstructor(renderer, gl) {\n\t\t\tsuper();\n\t\t\tconst scope = this;\n\t\t\tconst state = renderer.state;\n\t\t\tlet session = null;\n\t\t\tlet framebufferScaleFactor = 1.0;\n\t\t\tlet referenceSpace = null;\n\t\t\tlet referenceSpaceType = 'local-floor';\n\t\t\tlet pose = null;\n\t\t\tconst controllers = [];\n\t\t\tconst inputSourcesMap = new Map(); //\n\n\t\t\tconst cameraL = new PerspectiveCamera();\n\t\t\tcameraL.layers.enable(1);\n\t\t\tcameraL.viewport = new Vector4();\n\t\t\tconst cameraR = new PerspectiveCamera();\n\t\t\tcameraR.layers.enable(2);\n\t\t\tcameraR.viewport = new Vector4();\n\t\t\tconst cameras = [cameraL, cameraR];\n\t\t\tconst cameraVR = new ArrayCamera();\n\t\t\tcameraVR.layers.enable(1);\n\t\t\tcameraVR.layers.enable(2);\n\t\t\tlet _currentDepthNear = null;\n\t\t\tlet _currentDepthFar = null; //\n\n\t\t\tthis.cameraAutoUpdate = true;\n\t\t\tthis.enabled = false;\n\t\t\tthis.isPresenting = false;\n\n\t\t\tthis.getController = function (index) {\n\t\t\t\tlet controller = controllers[index];\n\n\t\t\t\tif (controller === undefined) {\n\t\t\t\t\tcontroller = new WebXRController();\n\t\t\t\t\tcontrollers[index] = controller;\n\t\t\t\t}\n\n\t\t\t\treturn controller.getTargetRaySpace();\n\t\t\t};\n\n\t\t\tthis.getControllerGrip = function (index) {\n\t\t\t\tlet controller = controllers[index];\n\n\t\t\t\tif (controller === undefined) {\n\t\t\t\t\tcontroller = new WebXRController();\n\t\t\t\t\tcontrollers[index] = controller;\n\t\t\t\t}\n\n\t\t\t\treturn controller.getGripSpace();\n\t\t\t};\n\n\t\t\tthis.getHand = function (index) {\n\t\t\t\tlet controller = controllers[index];\n\n\t\t\t\tif (controller === undefined) {\n\t\t\t\t\tcontroller = new WebXRController();\n\t\t\t\t\tcontrollers[index] = controller;\n\t\t\t\t}\n\n\t\t\t\treturn controller.getHandSpace();\n\t\t\t}; //\n\n\n\t\t\tfunction onSessionEvent(event) {\n\t\t\t\tconst controller = inputSourcesMap.get(event.inputSource);\n\n\t\t\t\tif (controller) {\n\t\t\t\t\tcontroller.dispatchEvent({\n\t\t\t\t\t\ttype: event.type,\n\t\t\t\t\t\tdata: event.inputSource\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction onSessionEnd() {\n\t\t\t\tinputSourcesMap.forEach(function (controller, inputSource) {\n\t\t\t\t\tcontroller.disconnect(inputSource);\n\t\t\t\t});\n\t\t\t\tinputSourcesMap.clear();\n\t\t\t\t_currentDepthNear = null;\n\t\t\t\t_currentDepthFar = null; // restore framebuffer/rendering state\n\n\t\t\t\tstate.bindXRFramebuffer(null);\n\t\t\t\trenderer.setRenderTarget(renderer.getRenderTarget()); //\n\n\t\t\t\tanimation.stop();\n\t\t\t\tscope.isPresenting = false;\n\t\t\t\tscope.dispatchEvent({\n\t\t\t\t\ttype: 'sessionend'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.setFramebufferScaleFactor = function (value) {\n\t\t\t\tframebufferScaleFactor = value;\n\n\t\t\t\tif (scope.isPresenting === true) {\n\t\t\t\t\tconsole.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.setReferenceSpaceType = function (value) {\n\t\t\t\treferenceSpaceType = value;\n\n\t\t\t\tif (scope.isPresenting === true) {\n\t\t\t\t\tconsole.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.getReferenceSpace = function () {\n\t\t\t\treturn referenceSpace;\n\t\t\t};\n\n\t\t\tthis.getSession = function () {\n\t\t\t\treturn session;\n\t\t\t};\n\n\t\t\tthis.setSession = async function (value) {\n\t\t\t\tsession = value;\n\n\t\t\t\tif (session !== null) {\n\t\t\t\t\tsession.addEventListener('select', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('selectstart', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('selectend', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('squeeze', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('squeezestart', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('squeezeend', onSessionEvent);\n\t\t\t\t\tsession.addEventListener('end', onSessionEnd);\n\t\t\t\t\tsession.addEventListener('inputsourceschange', onInputSourcesChange);\n\t\t\t\t\tconst attributes = gl.getContextAttributes();\n\n\t\t\t\t\tif (attributes.xrCompatible !== true) {\n\t\t\t\t\t\tawait gl.makeXRCompatible();\n\t\t\t\t\t}\n\n\t\t\t\t\tconst layerInit = {\n\t\t\t\t\t\tantialias: attributes.antialias,\n\t\t\t\t\t\talpha: attributes.alpha,\n\t\t\t\t\t\tdepth: attributes.depth,\n\t\t\t\t\t\tstencil: attributes.stencil,\n\t\t\t\t\t\tframebufferScaleFactor: framebufferScaleFactor\n\t\t\t\t\t}; // eslint-disable-next-line no-undef\n\n\t\t\t\t\tconst baseLayer = new XRWebGLLayer(session, gl, layerInit);\n\t\t\t\t\tsession.updateRenderState({\n\t\t\t\t\t\tbaseLayer: baseLayer\n\t\t\t\t\t});\n\t\t\t\t\treferenceSpace = await session.requestReferenceSpace(referenceSpaceType);\n\t\t\t\t\tanimation.setContext(session);\n\t\t\t\t\tanimation.start();\n\t\t\t\t\tscope.isPresenting = true;\n\t\t\t\t\tscope.dispatchEvent({\n\t\t\t\t\t\ttype: 'sessionstart'\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfunction onInputSourcesChange(event) {\n\t\t\t\tconst inputSources = session.inputSources; // Assign inputSources to available controllers\n\n\t\t\t\tfor (let i = 0; i < controllers.length; i++) {\n\t\t\t\t\tinputSourcesMap.set(inputSources[i], controllers[i]);\n\t\t\t\t} // Notify disconnected\n\n\n\t\t\t\tfor (let i = 0; i < event.removed.length; i++) {\n\t\t\t\t\tconst inputSource = event.removed[i];\n\t\t\t\t\tconst controller = inputSourcesMap.get(inputSource);\n\n\t\t\t\t\tif (controller) {\n\t\t\t\t\t\tcontroller.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'disconnected',\n\t\t\t\t\t\t\tdata: inputSource\n\t\t\t\t\t\t});\n\t\t\t\t\t\tinputSourcesMap.delete(inputSource);\n\t\t\t\t\t}\n\t\t\t\t} // Notify connected\n\n\n\t\t\t\tfor (let i = 0; i < event.added.length; i++) {\n\t\t\t\t\tconst inputSource = event.added[i];\n\t\t\t\t\tconst controller = inputSourcesMap.get(inputSource);\n\n\t\t\t\t\tif (controller) {\n\t\t\t\t\t\tcontroller.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'connected',\n\t\t\t\t\t\t\tdata: inputSource\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} //\n\n\n\t\t\tconst cameraLPos = new Vector3();\n\t\t\tconst cameraRPos = new Vector3();\n\t\t\t/**\n\t\t\t * Assumes 2 cameras that are parallel and share an X-axis, and that\n\t\t\t * the cameras' projection and world matrices have already been set.\n\t\t\t * And that near and far planes are identical for both cameras.\n\t\t\t * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n\t\t\t */\n\n\t\t\tfunction setProjectionFromUnion(camera, cameraL, cameraR) {\n\t\t\t\tcameraLPos.setFromMatrixPosition(cameraL.matrixWorld);\n\t\t\t\tcameraRPos.setFromMatrixPosition(cameraR.matrixWorld);\n\t\t\t\tconst ipd = cameraLPos.distanceTo(cameraRPos);\n\t\t\t\tconst projL = cameraL.projectionMatrix.elements;\n\t\t\t\tconst projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and\n\t\t\t\t// most likely identical top and bottom frustum extents.\n\t\t\t\t// Use the left camera for these values.\n\n\t\t\t\tconst near = projL[14] / (projL[10] - 1);\n\t\t\t\tconst far = projL[14] / (projL[10] + 1);\n\t\t\t\tconst topFov = (projL[9] + 1) / projL[5];\n\t\t\t\tconst bottomFov = (projL[9] - 1) / projL[5];\n\t\t\t\tconst leftFov = (projL[8] - 1) / projL[0];\n\t\t\t\tconst rightFov = (projR[8] + 1) / projR[0];\n\t\t\t\tconst left = near * leftFov;\n\t\t\t\tconst right = near * rightFov; // Calculate the new camera's position offset from the\n\t\t\t\t// left camera. xOffset should be roughly half `ipd`.\n\n\t\t\t\tconst zOffset = ipd / (-leftFov + rightFov);\n\t\t\t\tconst xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?\n\n\t\t\t\tcameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);\n\t\t\t\tcamera.translateX(xOffset);\n\t\t\t\tcamera.translateZ(zOffset);\n\t\t\t\tcamera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);\n\t\t\t\tcamera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale\n\t\t\t\t// the values so that the near plane's position does not change in world space,\n\t\t\t\t// although must now be relative to the new union camera.\n\n\t\t\t\tconst near2 = near + zOffset;\n\t\t\t\tconst far2 = far + zOffset;\n\t\t\t\tconst left2 = left - xOffset;\n\t\t\t\tconst right2 = right + (ipd - xOffset);\n\t\t\t\tconst top2 = topFov * far / far2 * near2;\n\t\t\t\tconst bottom2 = bottomFov * far / far2 * near2;\n\t\t\t\tcamera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);\n\t\t\t}\n\n\t\t\tfunction updateCamera(camera, parent) {\n\t\t\t\tif (parent === null) {\n\t\t\t\t\tcamera.matrixWorld.copy(camera.matrix);\n\t\t\t\t} else {\n\t\t\t\t\tcamera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);\n\t\t\t\t}\n\n\t\t\t\tcamera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n\t\t\t}\n\n\t\t\tthis.updateCamera = function (camera) {\n\t\t\t\tif (session === null) return;\n\t\t\t\tcameraVR.near = cameraR.near = cameraL.near = camera.near;\n\t\t\t\tcameraVR.far = cameraR.far = cameraL.far = camera.far;\n\n\t\t\t\tif (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {\n\t\t\t\t\t// Note that the new renderState won't apply until the next frame. See #18320\n\t\t\t\t\tsession.updateRenderState({\n\t\t\t\t\t\tdepthNear: cameraVR.near,\n\t\t\t\t\t\tdepthFar: cameraVR.far\n\t\t\t\t\t});\n\t\t\t\t\t_currentDepthNear = cameraVR.near;\n\t\t\t\t\t_currentDepthFar = cameraVR.far;\n\t\t\t\t}\n\n\t\t\t\tconst parent = camera.parent;\n\t\t\t\tconst cameras = cameraVR.cameras;\n\t\t\t\tupdateCamera(cameraVR, parent);\n\n\t\t\t\tfor (let i = 0; i < cameras.length; i++) {\n\t\t\t\t\tupdateCamera(cameras[i], parent);\n\t\t\t\t} // update camera and its children\n\n\n\t\t\t\tcamera.matrixWorld.copy(cameraVR.matrixWorld);\n\t\t\t\tcamera.matrix.copy(cameraVR.matrix);\n\t\t\t\tcamera.matrix.decompose(camera.position, camera.quaternion, camera.scale);\n\t\t\t\tconst children = camera.children;\n\n\t\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\t\tchildren[i].updateMatrixWorld(true);\n\t\t\t\t} // update projection matrix for proper view frustum culling\n\n\n\t\t\t\tif (cameras.length === 2) {\n\t\t\t\t\tsetProjectionFromUnion(cameraVR, cameraL, cameraR);\n\t\t\t\t} else {\n\t\t\t\t\t// assume single camera setup (AR)\n\t\t\t\t\tcameraVR.projectionMatrix.copy(cameraL.projectionMatrix);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.getCamera = function () {\n\t\t\t\treturn cameraVR;\n\t\t\t}; // Animation Loop\n\n\n\t\t\tlet onAnimationFrameCallback = null;\n\n\t\t\tfunction onAnimationFrame(time, frame) {\n\t\t\t\tpose = frame.getViewerPose(referenceSpace);\n\n\t\t\t\tif (pose !== null) {\n\t\t\t\t\tconst views = pose.views;\n\t\t\t\t\tconst baseLayer = session.renderState.baseLayer;\n\t\t\t\t\tstate.bindXRFramebuffer(baseLayer.framebuffer);\n\t\t\t\t\tlet cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list\n\n\t\t\t\t\tif (views.length !== cameraVR.cameras.length) {\n\t\t\t\t\t\tcameraVR.cameras.length = 0;\n\t\t\t\t\t\tcameraVRNeedsUpdate = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < views.length; i++) {\n\t\t\t\t\t\tconst view = views[i];\n\t\t\t\t\t\tconst viewport = baseLayer.getViewport(view);\n\t\t\t\t\t\tconst camera = cameras[i];\n\t\t\t\t\t\tcamera.matrix.fromArray(view.transform.matrix);\n\t\t\t\t\t\tcamera.projectionMatrix.fromArray(view.projectionMatrix);\n\t\t\t\t\t\tcamera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);\n\n\t\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t\tcameraVR.matrix.copy(camera.matrix);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (cameraVRNeedsUpdate === true) {\n\t\t\t\t\t\t\tcameraVR.cameras.push(camera);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} //\n\n\n\t\t\t\tconst inputSources = session.inputSources;\n\n\t\t\t\tfor (let i = 0; i < controllers.length; i++) {\n\t\t\t\t\tconst controller = controllers[i];\n\t\t\t\t\tconst inputSource = inputSources[i];\n\t\t\t\t\tcontroller.update(inputSource, frame, referenceSpace);\n\t\t\t\t}\n\n\t\t\t\tif (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);\n\t\t\t}\n\n\t\t\tconst animation = new WebGLAnimation();\n\t\t\tanimation.setAnimationLoop(onAnimationFrame);\n\n\t\t\tthis.setAnimationLoop = function (callback) {\n\t\t\t\tonAnimationFrameCallback = callback;\n\t\t\t};\n\n\t\t\tthis.dispose = function () {};\n\t\t}\n\n\t}\n\n\tfunction WebGLMaterials(properties) {\n\t\tfunction refreshFogUniforms(uniforms, fog) {\n\t\t\tuniforms.fogColor.value.copy(fog.color);\n\n\t\t\tif (fog.isFog) {\n\t\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\t\tuniforms.fogFar.value = fog.far;\n\t\t\t} else if (fog.isFogExp2) {\n\t\t\t\tuniforms.fogDensity.value = fog.density;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {\n\t\t\tif (material.isMeshBasicMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t} else if (material.isMeshLambertMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsLambert(uniforms, material);\n\t\t\t} else if (material.isMeshToonMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsToon(uniforms, material);\n\t\t\t} else if (material.isMeshPhongMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsPhong(uniforms, material);\n\t\t\t} else if (material.isMeshStandardMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\n\t\t\t\tif (material.isMeshPhysicalMaterial) {\n\t\t\t\t\trefreshUniformsPhysical(uniforms, material, transmissionRenderTarget);\n\t\t\t\t} else {\n\t\t\t\t\trefreshUniformsStandard(uniforms, material);\n\t\t\t\t}\n\t\t\t} else if (material.isMeshMatcapMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsMatcap(uniforms, material);\n\t\t\t} else if (material.isMeshDepthMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsDepth(uniforms, material);\n\t\t\t} else if (material.isMeshDistanceMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsDistance(uniforms, material);\n\t\t\t} else if (material.isMeshNormalMaterial) {\n\t\t\t\trefreshUniformsCommon(uniforms, material);\n\t\t\t\trefreshUniformsNormal(uniforms, material);\n\t\t\t} else if (material.isLineBasicMaterial) {\n\t\t\t\trefreshUniformsLine(uniforms, material);\n\n\t\t\t\tif (material.isLineDashedMaterial) {\n\t\t\t\t\trefreshUniformsDash(uniforms, material);\n\t\t\t\t}\n\t\t\t} else if (material.isPointsMaterial) {\n\t\t\t\trefreshUniformsPoints(uniforms, material, pixelRatio, height);\n\t\t\t} else if (material.isSpriteMaterial) {\n\t\t\t\trefreshUniformsSprites(uniforms, material);\n\t\t\t} else if (material.isShadowMaterial) {\n\t\t\t\tuniforms.color.value.copy(material.color);\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\t} else if (material.isShaderMaterial) {\n\t\t\t\tmaterial.uniformsNeedUpdate = false; // #15581\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsCommon(uniforms, material) {\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t\tif (material.color) {\n\t\t\t\tuniforms.diffuse.value.copy(material.color);\n\t\t\t}\n\n\t\t\tif (material.emissive) {\n\t\t\t\tuniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n\t\t\t}\n\n\t\t\tif (material.map) {\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t}\n\n\t\t\tif (material.alphaMap) {\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\t\t\t}\n\n\t\t\tif (material.specularMap) {\n\t\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\t}\n\n\t\t\tconst envMap = properties.get(material).envMap;\n\n\t\t\tif (envMap) {\n\t\t\t\tuniforms.envMap.value = envMap;\n\t\t\t\tuniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;\n\t\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t\t\tconst maxMipLevel = properties.get(envMap).__maxMipLevel;\n\n\t\t\t\tif (maxMipLevel !== undefined) {\n\t\t\t\t\tuniforms.maxMipLevel.value = maxMipLevel;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (material.lightMap) {\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\t\t\t}\n\n\t\t\tif (material.aoMap) {\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\t\t\t} // uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. specular map\n\t\t\t// 3. displacementMap map\n\t\t\t// 4. normal map\n\t\t\t// 5. bump map\n\t\t\t// 6. roughnessMap map\n\t\t\t// 7. metalnessMap map\n\t\t\t// 8. alphaMap map\n\t\t\t// 9. emissiveMap map\n\t\t\t// 10. clearcoat map\n\t\t\t// 11. clearcoat normal map\n\t\t\t// 12. clearcoat roughnessMap map\n\n\n\t\t\tlet uvScaleMap;\n\n\t\t\tif (material.map) {\n\t\t\t\tuvScaleMap = material.map;\n\t\t\t} else if (material.specularMap) {\n\t\t\t\tuvScaleMap = material.specularMap;\n\t\t\t} else if (material.displacementMap) {\n\t\t\t\tuvScaleMap = material.displacementMap;\n\t\t\t} else if (material.normalMap) {\n\t\t\t\tuvScaleMap = material.normalMap;\n\t\t\t} else if (material.bumpMap) {\n\t\t\t\tuvScaleMap = material.bumpMap;\n\t\t\t} else if (material.roughnessMap) {\n\t\t\t\tuvScaleMap = material.roughnessMap;\n\t\t\t} else if (material.metalnessMap) {\n\t\t\t\tuvScaleMap = material.metalnessMap;\n\t\t\t} else if (material.alphaMap) {\n\t\t\t\tuvScaleMap = material.alphaMap;\n\t\t\t} else if (material.emissiveMap) {\n\t\t\t\tuvScaleMap = material.emissiveMap;\n\t\t\t} else if (material.clearcoatMap) {\n\t\t\t\tuvScaleMap = material.clearcoatMap;\n\t\t\t} else if (material.clearcoatNormalMap) {\n\t\t\t\tuvScaleMap = material.clearcoatNormalMap;\n\t\t\t} else if (material.clearcoatRoughnessMap) {\n\t\t\t\tuvScaleMap = material.clearcoatRoughnessMap;\n\t\t\t}\n\n\t\t\tif (uvScaleMap !== undefined) {\n\t\t\t\t// backwards compatibility\n\t\t\t\tif (uvScaleMap.isWebGLRenderTarget) {\n\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\t\t\t\t}\n\n\t\t\t\tif (uvScaleMap.matrixAutoUpdate === true) {\n\t\t\t\t\tuvScaleMap.updateMatrix();\n\t\t\t\t}\n\n\t\t\t\tuniforms.uvTransform.value.copy(uvScaleMap.matrix);\n\t\t\t} // uv repeat and offset setting priorities for uv2\n\t\t\t// 1. ao map\n\t\t\t// 2. light map\n\n\n\t\t\tlet uv2ScaleMap;\n\n\t\t\tif (material.aoMap) {\n\t\t\t\tuv2ScaleMap = material.aoMap;\n\t\t\t} else if (material.lightMap) {\n\t\t\t\tuv2ScaleMap = material.lightMap;\n\t\t\t}\n\n\t\t\tif (uv2ScaleMap !== undefined) {\n\t\t\t\t// backwards compatibility\n\t\t\t\tif (uv2ScaleMap.isWebGLRenderTarget) {\n\t\t\t\t\tuv2ScaleMap = uv2ScaleMap.texture;\n\t\t\t\t}\n\n\t\t\t\tif (uv2ScaleMap.matrixAutoUpdate === true) {\n\t\t\t\t\tuv2ScaleMap.updateMatrix();\n\t\t\t\t}\n\n\t\t\t\tuniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsLine(uniforms, material) {\n\t\t\tuniforms.diffuse.value.copy(material.color);\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t}\n\n\t\tfunction refreshUniformsDash(uniforms, material) {\n\t\t\tuniforms.dashSize.value = material.dashSize;\n\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\t\tuniforms.scale.value = material.scale;\n\t\t}\n\n\t\tfunction refreshUniformsPoints(uniforms, material, pixelRatio, height) {\n\t\t\tuniforms.diffuse.value.copy(material.color);\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\tuniforms.size.value = material.size * pixelRatio;\n\t\t\tuniforms.scale.value = height * 0.5;\n\n\t\t\tif (material.map) {\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t}\n\n\t\t\tif (material.alphaMap) {\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\t\t\t} // uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. alpha map\n\n\n\t\t\tlet uvScaleMap;\n\n\t\t\tif (material.map) {\n\t\t\t\tuvScaleMap = material.map;\n\t\t\t} else if (material.alphaMap) {\n\t\t\t\tuvScaleMap = material.alphaMap;\n\t\t\t}\n\n\t\t\tif (uvScaleMap !== undefined) {\n\t\t\t\tif (uvScaleMap.matrixAutoUpdate === true) {\n\t\t\t\t\tuvScaleMap.updateMatrix();\n\t\t\t\t}\n\n\t\t\t\tuniforms.uvTransform.value.copy(uvScaleMap.matrix);\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsSprites(uniforms, material) {\n\t\t\tuniforms.diffuse.value.copy(material.color);\n\t\t\tuniforms.opacity.value = material.opacity;\n\t\t\tuniforms.rotation.value = material.rotation;\n\n\t\t\tif (material.map) {\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t}\n\n\t\t\tif (material.alphaMap) {\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\t\t\t} // uv repeat and offset setting priorities\n\t\t\t// 1. color map\n\t\t\t// 2. alpha map\n\n\n\t\t\tlet uvScaleMap;\n\n\t\t\tif (material.map) {\n\t\t\t\tuvScaleMap = material.map;\n\t\t\t} else if (material.alphaMap) {\n\t\t\t\tuvScaleMap = material.alphaMap;\n\t\t\t}\n\n\t\t\tif (uvScaleMap !== undefined) {\n\t\t\t\tif (uvScaleMap.matrixAutoUpdate === true) {\n\t\t\t\t\tuvScaleMap.updateMatrix();\n\t\t\t\t}\n\n\t\t\t\tuniforms.uvTransform.value.copy(uvScaleMap.matrix);\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsLambert(uniforms, material) {\n\t\t\tif (material.emissiveMap) {\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsPhong(uniforms, material) {\n\t\t\tuniforms.specular.value.copy(material.specular);\n\t\t\tuniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )\n\n\t\t\tif (material.emissiveMap) {\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t}\n\n\t\t\tif (material.bumpMap) {\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\t\tif (material.side === BackSide) uniforms.bumpScale.value *= -1;\n\t\t\t}\n\n\t\t\tif (material.normalMap) {\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy(material.normalScale);\n\t\t\t\tif (material.side === BackSide) uniforms.normalScale.value.negate();\n\t\t\t}\n\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsToon(uniforms, material) {\n\t\t\tif (material.gradientMap) {\n\t\t\t\tuniforms.gradientMap.value = material.gradientMap;\n\t\t\t}\n\n\t\t\tif (material.emissiveMap) {\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t}\n\n\t\t\tif (material.bumpMap) {\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\t\tif (material.side === BackSide) uniforms.bumpScale.value *= -1;\n\t\t\t}\n\n\t\t\tif (material.normalMap) {\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy(material.normalScale);\n\t\t\t\tif (material.side === BackSide) uniforms.normalScale.value.negate();\n\t\t\t}\n\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsStandard(uniforms, material) {\n\t\t\tuniforms.roughness.value = material.roughness;\n\t\t\tuniforms.metalness.value = material.metalness;\n\n\t\t\tif (material.roughnessMap) {\n\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\t\t\t}\n\n\t\t\tif (material.metalnessMap) {\n\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\t\t\t}\n\n\t\t\tif (material.emissiveMap) {\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t}\n\n\t\t\tif (material.bumpMap) {\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\t\tif (material.side === BackSide) uniforms.bumpScale.value *= -1;\n\t\t\t}\n\n\t\t\tif (material.normalMap) {\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy(material.normalScale);\n\t\t\t\tif (material.side === BackSide) uniforms.normalScale.value.negate();\n\t\t\t}\n\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\n\t\t\tconst envMap = properties.get(material).envMap;\n\n\t\t\tif (envMap) {\n\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {\n\t\t\trefreshUniformsStandard(uniforms, material);\n\t\t\tuniforms.reflectivity.value = material.reflectivity; // also part of uniforms common\n\n\t\t\tuniforms.clearcoat.value = material.clearcoat;\n\t\t\tuniforms.clearcoatRoughness.value = material.clearcoatRoughness;\n\t\t\tif (material.sheen) uniforms.sheen.value.copy(material.sheen);\n\n\t\t\tif (material.clearcoatMap) {\n\t\t\t\tuniforms.clearcoatMap.value = material.clearcoatMap;\n\t\t\t}\n\n\t\t\tif (material.clearcoatRoughnessMap) {\n\t\t\t\tuniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;\n\t\t\t}\n\n\t\t\tif (material.clearcoatNormalMap) {\n\t\t\t\tuniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);\n\t\t\t\tuniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;\n\n\t\t\t\tif (material.side === BackSide) {\n\t\t\t\t\tuniforms.clearcoatNormalScale.value.negate();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tuniforms.transmission.value = material.transmission;\n\n\t\t\tif (material.transmissionMap) {\n\t\t\t\tuniforms.transmissionMap.value = material.transmissionMap;\n\t\t\t}\n\n\t\t\tif (material.transmission > 0.0) {\n\t\t\t\tuniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;\n\t\t\t\tuniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);\n\t\t\t}\n\n\t\t\tuniforms.thickness.value = material.thickness;\n\n\t\t\tif (material.thicknessMap) {\n\t\t\t\tuniforms.thicknessMap.value = material.thicknessMap;\n\t\t\t}\n\n\t\t\tuniforms.attenuationDistance.value = material.attenuationDistance;\n\t\t\tuniforms.attenuationColor.value.copy(material.attenuationColor);\n\t\t}\n\n\t\tfunction refreshUniformsMatcap(uniforms, material) {\n\t\t\tif (material.matcap) {\n\t\t\t\tuniforms.matcap.value = material.matcap;\n\t\t\t}\n\n\t\t\tif (material.bumpMap) {\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\t\tif (material.side === BackSide) uniforms.bumpScale.value *= -1;\n\t\t\t}\n\n\t\t\tif (material.normalMap) {\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy(material.normalScale);\n\t\t\t\tif (material.side === BackSide) uniforms.normalScale.value.negate();\n\t\t\t}\n\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsDepth(uniforms, material) {\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\t\t}\n\n\t\tfunction refreshUniformsDistance(uniforms, material) {\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\n\t\t\tuniforms.referencePosition.value.copy(material.referencePosition);\n\t\t\tuniforms.nearDistance.value = material.nearDistance;\n\t\t\tuniforms.farDistance.value = material.farDistance;\n\t\t}\n\n\t\tfunction refreshUniformsNormal(uniforms, material) {\n\t\t\tif (material.bumpMap) {\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\t\t\t\tif (material.side === BackSide) uniforms.bumpScale.value *= -1;\n\t\t\t}\n\n\t\t\tif (material.normalMap) {\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\t\tuniforms.normalScale.value.copy(material.normalScale);\n\t\t\t\tif (material.side === BackSide) uniforms.normalScale.value.negate();\n\t\t\t}\n\n\t\t\tif (material.displacementMap) {\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\trefreshFogUniforms: refreshFogUniforms,\n\t\t\trefreshMaterialUniforms: refreshMaterialUniforms\n\t\t};\n\t}\n\n\tfunction createCanvasElement() {\n\t\tconst canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');\n\t\tcanvas.style.display = 'block';\n\t\treturn canvas;\n\t}\n\n\tfunction WebGLRenderer(parameters) {\n\t\tparameters = parameters || {};\n\n\t\tconst _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),\n\t\t\t\t\t_context = parameters.context !== undefined ? parameters.context : null,\n\t\t\t\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t\t\t\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\n\t\t\t\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t\t\t\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t\t\t\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t\t\t\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n\t\t\t\t\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',\n\t\t\t\t\t_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;\n\n\t\tlet currentRenderList = null;\n\t\tlet currentRenderState = null; // render() can be called from within a callback triggered by another render.\n\t\t// We track this so that the nested render call gets its list and state isolated from the parent render call.\n\n\t\tconst renderListStack = [];\n\t\tconst renderStateStack = []; // public properties\n\n\t\tthis.domElement = _canvas; // Debug configuration container\n\n\t\tthis.debug = {\n\t\t\t/**\n\t\t\t * Enables error checking and reporting when shader programs are being compiled\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tcheckShaderErrors: true\n\t\t}; // clearing\n\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true; // scene graph\n\n\t\tthis.sortObjects = true; // user-defined clipping\n\n\t\tthis.clippingPlanes = [];\n\t\tthis.localClippingEnabled = false; // physically based shading\n\n\t\tthis.gammaFactor = 2.0; // for backwards compatibility\n\n\t\tthis.outputEncoding = LinearEncoding; // physical lights\n\n\t\tthis.physicallyCorrectLights = false; // tone mapping\n\n\t\tthis.toneMapping = NoToneMapping;\n\t\tthis.toneMappingExposure = 1.0; // internal properties\n\n\t\tconst _this = this;\n\n\t\tlet _isContextLost = false; // internal state cache\n\n\t\tlet _currentActiveCubeFace = 0;\n\t\tlet _currentActiveMipmapLevel = 0;\n\t\tlet _currentRenderTarget = null;\n\n\t\tlet _currentMaterialId = -1;\n\n\t\tlet _currentCamera = null;\n\n\t\tconst _currentViewport = new Vector4();\n\n\t\tconst _currentScissor = new Vector4();\n\n\t\tlet _currentScissorTest = null; //\n\n\t\tlet _width = _canvas.width;\n\t\tlet _height = _canvas.height;\n\t\tlet _pixelRatio = 1;\n\t\tlet _opaqueSort = null;\n\t\tlet _transparentSort = null;\n\n\t\tconst _viewport = new Vector4(0, 0, _width, _height);\n\n\t\tconst _scissor = new Vector4(0, 0, _width, _height);\n\n\t\tlet _scissorTest = false; //\n\n\t\tconst _currentDrawBuffers = []; // frustum\n\n\t\tconst _frustum = new Frustum(); // clipping\n\n\n\t\tlet _clippingEnabled = false;\n\t\tlet _localClippingEnabled = false; // transmission\n\n\t\tlet _transmissionRenderTarget = null; // camera matrices cache\n\n\t\tconst _projScreenMatrix = new Matrix4();\n\n\t\tconst _vector3 = new Vector3();\n\n\t\tconst _emptyScene = {\n\t\t\tbackground: null,\n\t\t\tfog: null,\n\t\t\tenvironment: null,\n\t\t\toverrideMaterial: null,\n\t\t\tisScene: true\n\t\t};\n\n\t\tfunction getTargetPixelRatio() {\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\t\t} // initialize\n\n\n\t\tlet _gl = _context;\n\n\t\tfunction getContext(contextNames, contextAttributes) {\n\t\t\tfor (let i = 0; i < contextNames.length; i++) {\n\t\t\t\tconst contextName = contextNames[i];\n\n\t\t\t\tconst context = _canvas.getContext(contextName, contextAttributes);\n\n\t\t\t\tif (context !== null) return context;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tconst contextAttributes = {\n\t\t\t\talpha: _alpha,\n\t\t\t\tdepth: _depth,\n\t\t\t\tstencil: _stencil,\n\t\t\t\tantialias: _antialias,\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer,\n\t\t\t\tpowerPreference: _powerPreference,\n\t\t\t\tfailIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat\n\t\t\t}; // event listeners must be registered before WebGL context is created, see #12753\n\n\t\t\t_canvas.addEventListener('webglcontextlost', onContextLost, false);\n\n\t\t\t_canvas.addEventListener('webglcontextrestored', onContextRestore, false);\n\n\t\t\tif (_gl === null) {\n\t\t\t\tconst contextNames = ['webgl2', 'webgl', 'experimental-webgl'];\n\n\t\t\t\tif (_this.isWebGL1Renderer === true) {\n\t\t\t\t\tcontextNames.shift();\n\t\t\t\t}\n\n\t\t\t\t_gl = getContext(contextNames, contextAttributes);\n\n\t\t\t\tif (_gl === null) {\n\t\t\t\t\tif (getContext(contextNames)) {\n\t\t\t\t\t\tthrow new Error('Error creating WebGL context with your selected attributes.');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Error creating WebGL context.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\n\t\t\tif (_gl.getShaderPrecisionFormat === undefined) {\n\t\t\t\t_gl.getShaderPrecisionFormat = function () {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t'rangeMin': 1,\n\t\t\t\t\t\t'rangeMax': 1,\n\t\t\t\t\t\t'precision': 1\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error('THREE.WebGLRenderer: ' + error.message);\n\t\t\tthrow error;\n\t\t}\n\n\t\tlet extensions, capabilities, state, info;\n\t\tlet properties, textures, cubemaps, attributes, geometries, objects;\n\t\tlet programCache, materials, renderLists, renderStates, clipping, shadowMap;\n\t\tlet background, morphtargets, bufferRenderer, indexedBufferRenderer;\n\t\tlet utils, bindingStates;\n\n\t\tfunction initGLContext() {\n\t\t\textensions = new WebGLExtensions(_gl);\n\t\t\tcapabilities = new WebGLCapabilities(_gl, extensions, parameters);\n\t\t\textensions.init(capabilities);\n\t\t\tutils = new WebGLUtils(_gl, extensions, capabilities);\n\t\t\tstate = new WebGLState(_gl, extensions, capabilities);\n\t\t\t_currentDrawBuffers[0] = _gl.BACK;\n\t\t\tinfo = new WebGLInfo(_gl);\n\t\t\tproperties = new WebGLProperties();\n\t\t\ttextures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);\n\t\t\tcubemaps = new WebGLCubeMaps(_this);\n\t\t\tattributes = new WebGLAttributes(_gl, capabilities);\n\t\t\tbindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);\n\t\t\tgeometries = new WebGLGeometries(_gl, attributes, info, bindingStates);\n\t\t\tobjects = new WebGLObjects(_gl, geometries, attributes, info);\n\t\t\tmorphtargets = new WebGLMorphtargets(_gl);\n\t\t\tclipping = new WebGLClipping(properties);\n\t\t\tprogramCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);\n\t\t\tmaterials = new WebGLMaterials(properties);\n\t\t\trenderLists = new WebGLRenderLists(properties);\n\t\t\trenderStates = new WebGLRenderStates(extensions, capabilities);\n\t\t\tbackground = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);\n\t\t\tshadowMap = new WebGLShadowMap(_this, objects, capabilities);\n\t\t\tbufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);\n\t\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);\n\t\t\tinfo.programs = programCache.programs;\n\t\t\t_this.capabilities = capabilities;\n\t\t\t_this.extensions = extensions;\n\t\t\t_this.properties = properties;\n\t\t\t_this.renderLists = renderLists;\n\t\t\t_this.shadowMap = shadowMap;\n\t\t\t_this.state = state;\n\t\t\t_this.info = info;\n\t\t}\n\n\t\tinitGLContext(); // xr\n\n\t\tconst xr = new WebXRManager(_this, _gl);\n\t\tthis.xr = xr; // API\n\n\t\tthis.getContext = function () {\n\t\t\treturn _gl;\n\t\t};\n\n\t\tthis.getContextAttributes = function () {\n\t\t\treturn _gl.getContextAttributes();\n\t\t};\n\n\t\tthis.forceContextLoss = function () {\n\t\t\tconst extension = extensions.get('WEBGL_lose_context');\n\t\t\tif (extension) extension.loseContext();\n\t\t};\n\n\t\tthis.forceContextRestore = function () {\n\t\t\tconst extension = extensions.get('WEBGL_lose_context');\n\t\t\tif (extension) extension.restoreContext();\n\t\t};\n\n\t\tthis.getPixelRatio = function () {\n\t\t\treturn _pixelRatio;\n\t\t};\n\n\t\tthis.setPixelRatio = function (value) {\n\t\t\tif (value === undefined) return;\n\t\t\t_pixelRatio = value;\n\t\t\tthis.setSize(_width, _height, false);\n\t\t};\n\n\t\tthis.getSize = function (target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn target.set(_width, _height);\n\t\t};\n\n\t\tthis.setSize = function (width, height, updateStyle) {\n\t\t\tif (xr.isPresenting) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\t\t\t_canvas.width = Math.floor(width * _pixelRatio);\n\t\t\t_canvas.height = Math.floor(height * _pixelRatio);\n\n\t\t\tif (updateStyle !== false) {\n\t\t\t\t_canvas.style.width = width + 'px';\n\t\t\t\t_canvas.style.height = height + 'px';\n\t\t\t}\n\n\t\t\tthis.setViewport(0, 0, width, height);\n\t\t};\n\n\t\tthis.getDrawingBufferSize = function (target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn target.set(_width * _pixelRatio, _height * _pixelRatio).floor();\n\t\t};\n\n\t\tthis.setDrawingBufferSize = function (width, height, pixelRatio) {\n\t\t\t_width = width;\n\t\t\t_height = height;\n\t\t\t_pixelRatio = pixelRatio;\n\t\t\t_canvas.width = Math.floor(width * pixelRatio);\n\t\t\t_canvas.height = Math.floor(height * pixelRatio);\n\t\t\tthis.setViewport(0, 0, width, height);\n\t\t};\n\n\t\tthis.getCurrentViewport = function (target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');\n\t\t\t\ttarget = new Vector4();\n\t\t\t}\n\n\t\t\treturn target.copy(_currentViewport);\n\t\t};\n\n\t\tthis.getViewport = function (target) {\n\t\t\treturn target.copy(_viewport);\n\t\t};\n\n\t\tthis.setViewport = function (x, y, width, height) {\n\t\t\tif (x.isVector4) {\n\t\t\t\t_viewport.set(x.x, x.y, x.z, x.w);\n\t\t\t} else {\n\t\t\t\t_viewport.set(x, y, width, height);\n\t\t\t}\n\n\t\t\tstate.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());\n\t\t};\n\n\t\tthis.getScissor = function (target) {\n\t\t\treturn target.copy(_scissor);\n\t\t};\n\n\t\tthis.setScissor = function (x, y, width, height) {\n\t\t\tif (x.isVector4) {\n\t\t\t\t_scissor.set(x.x, x.y, x.z, x.w);\n\t\t\t} else {\n\t\t\t\t_scissor.set(x, y, width, height);\n\t\t\t}\n\n\t\t\tstate.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());\n\t\t};\n\n\t\tthis.getScissorTest = function () {\n\t\t\treturn _scissorTest;\n\t\t};\n\n\t\tthis.setScissorTest = function (boolean) {\n\t\t\tstate.setScissorTest(_scissorTest = boolean);\n\t\t};\n\n\t\tthis.setOpaqueSort = function (method) {\n\t\t\t_opaqueSort = method;\n\t\t};\n\n\t\tthis.setTransparentSort = function (method) {\n\t\t\t_transparentSort = method;\n\t\t}; // Clearing\n\n\n\t\tthis.getClearColor = function (target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('WebGLRenderer: .getClearColor() now requires a Color as an argument');\n\t\t\t\ttarget = new Color();\n\t\t\t}\n\n\t\t\treturn target.copy(background.getClearColor());\n\t\t};\n\n\t\tthis.setClearColor = function () {\n\t\t\tbackground.setClearColor.apply(background, arguments);\n\t\t};\n\n\t\tthis.getClearAlpha = function () {\n\t\t\treturn background.getClearAlpha();\n\t\t};\n\n\t\tthis.setClearAlpha = function () {\n\t\t\tbackground.setClearAlpha.apply(background, arguments);\n\t\t};\n\n\t\tthis.clear = function (color, depth, stencil) {\n\t\t\tlet bits = 0;\n\t\t\tif (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;\n\t\t\tif (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\tif (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t\t_gl.clear(bits);\n\t\t};\n\n\t\tthis.clearColor = function () {\n\t\t\tthis.clear(true, false, false);\n\t\t};\n\n\t\tthis.clearDepth = function () {\n\t\t\tthis.clear(false, true, false);\n\t\t};\n\n\t\tthis.clearStencil = function () {\n\t\t\tthis.clear(false, false, true);\n\t\t}; //\n\n\n\t\tthis.dispose = function () {\n\t\t\t_canvas.removeEventListener('webglcontextlost', onContextLost, false);\n\n\t\t\t_canvas.removeEventListener('webglcontextrestored', onContextRestore, false);\n\n\t\t\trenderLists.dispose();\n\t\t\trenderStates.dispose();\n\t\t\tproperties.dispose();\n\t\t\tcubemaps.dispose();\n\t\t\tobjects.dispose();\n\t\t\tbindingStates.dispose();\n\t\t\txr.dispose();\n\t\t\txr.removeEventListener('sessionstart', onXRSessionStart);\n\t\t\txr.removeEventListener('sessionend', onXRSessionEnd);\n\n\t\t\tif (_transmissionRenderTarget) {\n\t\t\t\t_transmissionRenderTarget.dispose();\n\n\t\t\t\t_transmissionRenderTarget = null;\n\t\t\t}\n\n\t\t\tanimation.stop();\n\t\t}; // Events\n\n\n\t\tfunction onContextLost(event) {\n\t\t\tevent.preventDefault();\n\t\t\tconsole.log('THREE.WebGLRenderer: Context Lost.');\n\t\t\t_isContextLost = true;\n\t\t}\n\n\t\tfunction onContextRestore()\n\t\t/* event */\n\t\t{\n\t\t\tconsole.log('THREE.WebGLRenderer: Context Restored.');\n\t\t\t_isContextLost = false;\n\t\t\tconst infoAutoReset = info.autoReset;\n\t\t\tconst shadowMapEnabled = shadowMap.enabled;\n\t\t\tconst shadowMapAutoUpdate = shadowMap.autoUpdate;\n\t\t\tconst shadowMapNeedsUpdate = shadowMap.needsUpdate;\n\t\t\tconst shadowMapType = shadowMap.type;\n\t\t\tinitGLContext();\n\t\t\tinfo.autoReset = infoAutoReset;\n\t\t\tshadowMap.enabled = shadowMapEnabled;\n\t\t\tshadowMap.autoUpdate = shadowMapAutoUpdate;\n\t\t\tshadowMap.needsUpdate = shadowMapNeedsUpdate;\n\t\t\tshadowMap.type = shadowMapType;\n\t\t}\n\n\t\tfunction onMaterialDispose(event) {\n\t\t\tconst material = event.target;\n\t\t\tmaterial.removeEventListener('dispose', onMaterialDispose);\n\t\t\tdeallocateMaterial(material);\n\t\t} // Buffer deallocation\n\n\n\t\tfunction deallocateMaterial(material) {\n\t\t\treleaseMaterialProgramReferences(material);\n\t\t\tproperties.remove(material);\n\t\t}\n\n\t\tfunction releaseMaterialProgramReferences(material) {\n\t\t\tconst programs = properties.get(material).programs;\n\n\t\t\tif (programs !== undefined) {\n\t\t\t\tprograms.forEach(function (program) {\n\t\t\t\t\tprogramCache.releaseProgram(program);\n\t\t\t\t});\n\t\t\t}\n\t\t} // Buffer rendering\n\n\n\t\tfunction renderObjectImmediate(object, program) {\n\t\t\tobject.render(function (object) {\n\t\t\t\t_this.renderBufferImmediate(object, program);\n\t\t\t});\n\t\t}\n\n\t\tthis.renderBufferImmediate = function (object, program) {\n\t\t\tbindingStates.initAttributes();\n\t\t\tconst buffers = properties.get(object);\n\t\t\tif (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();\n\t\t\tif (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();\n\t\t\tif (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();\n\t\t\tif (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();\n\t\t\tconst programAttributes = program.getAttributes();\n\n\t\t\tif (object.hasPositions) {\n\t\t\t\t_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);\n\n\t\t\t\t_gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);\n\n\t\t\t\tbindingStates.enableAttribute(programAttributes.position);\n\n\t\t\t\t_gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);\n\t\t\t}\n\n\t\t\tif (object.hasNormals) {\n\t\t\t\t_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);\n\n\t\t\t\t_gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);\n\n\t\t\t\tbindingStates.enableAttribute(programAttributes.normal);\n\n\t\t\t\t_gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);\n\t\t\t}\n\n\t\t\tif (object.hasUvs) {\n\t\t\t\t_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);\n\n\t\t\t\t_gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);\n\n\t\t\t\tbindingStates.enableAttribute(programAttributes.uv);\n\n\t\t\t\t_gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);\n\t\t\t}\n\n\t\t\tif (object.hasColors) {\n\t\t\t\t_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);\n\n\t\t\t\t_gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);\n\n\t\t\t\tbindingStates.enableAttribute(programAttributes.color);\n\n\t\t\t\t_gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);\n\t\t\t}\n\n\t\t\tbindingStates.disableUnusedAttributes();\n\n\t\t\t_gl.drawArrays(_gl.TRIANGLES, 0, object.count);\n\n\t\t\tobject.count = 0;\n\t\t};\n\n\t\tthis.renderBufferDirect = function (camera, scene, geometry, material, object, group) {\n\t\t\tif (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\n\n\t\t\tconst frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;\n\t\t\tconst program = setProgram(camera, scene, material, object);\n\t\t\tstate.setMaterial(material, frontFaceCW); //\n\n\t\t\tlet index = geometry.index;\n\t\t\tconst position = geometry.attributes.position; //\n\n\t\t\tif (index === null) {\n\t\t\t\tif (position === undefined || position.count === 0) return;\n\t\t\t} else if (index.count === 0) {\n\t\t\t\treturn;\n\t\t\t} //\n\n\n\t\t\tlet rangeFactor = 1;\n\n\t\t\tif (material.wireframe === true) {\n\t\t\t\tindex = geometries.getWireframeAttribute(geometry);\n\t\t\t\trangeFactor = 2;\n\t\t\t}\n\n\t\t\tif (material.morphTargets || material.morphNormals) {\n\t\t\t\tmorphtargets.update(object, geometry, material, program);\n\t\t\t}\n\n\t\t\tbindingStates.setup(object, material, program, geometry, index);\n\t\t\tlet attribute;\n\t\t\tlet renderer = bufferRenderer;\n\n\t\t\tif (index !== null) {\n\t\t\t\tattribute = attributes.get(index);\n\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\trenderer.setIndex(attribute);\n\t\t\t} //\n\n\n\t\t\tconst dataCount = index !== null ? index.count : position.count;\n\t\t\tconst rangeStart = geometry.drawRange.start * rangeFactor;\n\t\t\tconst rangeCount = geometry.drawRange.count * rangeFactor;\n\t\t\tconst groupStart = group !== null ? group.start * rangeFactor : 0;\n\t\t\tconst groupCount = group !== null ? group.count * rangeFactor : Infinity;\n\t\t\tconst drawStart = Math.max(rangeStart, groupStart);\n\t\t\tconst drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;\n\t\t\tconst drawCount = Math.max(0, drawEnd - drawStart + 1);\n\t\t\tif (drawCount === 0) return; //\n\n\t\t\tif (object.isMesh) {\n\t\t\t\tif (material.wireframe === true) {\n\t\t\t\t\tstate.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());\n\t\t\t\t\trenderer.setMode(_gl.LINES);\n\t\t\t\t} else {\n\t\t\t\t\trenderer.setMode(_gl.TRIANGLES);\n\t\t\t\t}\n\t\t\t} else if (object.isLine) {\n\t\t\t\tlet lineWidth = material.linewidth;\n\t\t\t\tif (lineWidth === undefined) lineWidth = 1; // Not using Line*Material\n\n\t\t\t\tstate.setLineWidth(lineWidth * getTargetPixelRatio());\n\n\t\t\t\tif (object.isLineSegments) {\n\t\t\t\t\trenderer.setMode(_gl.LINES);\n\t\t\t\t} else if (object.isLineLoop) {\n\t\t\t\t\trenderer.setMode(_gl.LINE_LOOP);\n\t\t\t\t} else {\n\t\t\t\t\trenderer.setMode(_gl.LINE_STRIP);\n\t\t\t\t}\n\t\t\t} else if (object.isPoints) {\n\t\t\t\trenderer.setMode(_gl.POINTS);\n\t\t\t} else if (object.isSprite) {\n\t\t\t\trenderer.setMode(_gl.TRIANGLES);\n\t\t\t}\n\n\t\t\tif (object.isInstancedMesh) {\n\t\t\t\trenderer.renderInstances(drawStart, drawCount, object.count);\n\t\t\t} else if (geometry.isInstancedBufferGeometry) {\n\t\t\t\tconst instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);\n\t\t\t\trenderer.renderInstances(drawStart, drawCount, instanceCount);\n\t\t\t} else {\n\t\t\t\trenderer.render(drawStart, drawCount);\n\t\t\t}\n\t\t}; // Compile\n\n\n\t\tthis.compile = function (scene, camera) {\n\t\t\tcurrentRenderState = renderStates.get(scene);\n\t\t\tcurrentRenderState.init();\n\t\t\tscene.traverseVisible(function (object) {\n\t\t\t\tif (object.isLight && object.layers.test(camera.layers)) {\n\t\t\t\t\tcurrentRenderState.pushLight(object);\n\n\t\t\t\t\tif (object.castShadow) {\n\t\t\t\t\t\tcurrentRenderState.pushShadow(object);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tcurrentRenderState.setupLights();\n\t\t\tscene.traverse(function (object) {\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif (material) {\n\t\t\t\t\tif (Array.isArray(material)) {\n\t\t\t\t\t\tfor (let i = 0; i < material.length; i++) {\n\t\t\t\t\t\t\tconst material2 = material[i];\n\t\t\t\t\t\t\tgetProgram(material2, scene, object);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgetProgram(material, scene, object);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}; // Animation Loop\n\n\n\t\tlet onAnimationFrameCallback = null;\n\n\t\tfunction onAnimationFrame(time) {\n\t\t\tif (onAnimationFrameCallback) onAnimationFrameCallback(time);\n\t\t}\n\n\t\tfunction onXRSessionStart() {\n\t\t\tanimation.stop();\n\t\t}\n\n\t\tfunction onXRSessionEnd() {\n\t\t\tanimation.start();\n\t\t}\n\n\t\tconst animation = new WebGLAnimation();\n\t\tanimation.setAnimationLoop(onAnimationFrame);\n\t\tif (typeof window !== 'undefined') animation.setContext(window);\n\n\t\tthis.setAnimationLoop = function (callback) {\n\t\t\tonAnimationFrameCallback = callback;\n\t\t\txr.setAnimationLoop(callback);\n\t\t\tcallback === null ? animation.stop() : animation.start();\n\t\t};\n\n\t\txr.addEventListener('sessionstart', onXRSessionStart);\n\t\txr.addEventListener('sessionend', onXRSessionEnd); // Rendering\n\n\t\tthis.render = function (scene, camera) {\n\t\t\tif (camera !== undefined && camera.isCamera !== true) {\n\t\t\t\tconsole.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_isContextLost === true) return; // update scene graph\n\n\t\t\tif (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum\n\n\t\t\tif (camera.parent === null) camera.updateMatrixWorld();\n\n\t\t\tif (xr.enabled === true && xr.isPresenting === true) {\n\t\t\t\tif (xr.cameraAutoUpdate === true) xr.updateCamera(camera);\n\t\t\t\tcamera = xr.getCamera(); // use XR camera for rendering\n\t\t\t} //\n\n\n\t\t\tif (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);\n\t\t\tcurrentRenderState = renderStates.get(scene, renderStateStack.length);\n\t\t\tcurrentRenderState.init();\n\t\t\trenderStateStack.push(currentRenderState);\n\n\t\t\t_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n\n\t\t\t_frustum.setFromProjectionMatrix(_projScreenMatrix);\n\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t_clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);\n\t\t\tcurrentRenderList = renderLists.get(scene, renderListStack.length);\n\t\t\tcurrentRenderList.init();\n\t\t\trenderListStack.push(currentRenderList);\n\t\t\tprojectObject(scene, camera, 0, _this.sortObjects);\n\t\t\tcurrentRenderList.finish();\n\n\t\t\tif (_this.sortObjects === true) {\n\t\t\t\tcurrentRenderList.sort(_opaqueSort, _transparentSort);\n\t\t\t} //\n\n\n\t\t\tif (_clippingEnabled === true) clipping.beginShadows();\n\t\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\t\t\tshadowMap.render(shadowsArray, scene, camera);\n\t\t\tcurrentRenderState.setupLights();\n\t\t\tcurrentRenderState.setupLightsView(camera);\n\t\t\tif (_clippingEnabled === true) clipping.endShadows(); //\n\n\t\t\tif (this.info.autoReset === true) this.info.reset(); //\n\n\t\t\tbackground.render(currentRenderList, scene); // render scene\n\n\t\t\tconst opaqueObjects = currentRenderList.opaque;\n\t\t\tconst transmissiveObjects = currentRenderList.transmissive;\n\t\t\tconst transparentObjects = currentRenderList.transparent;\n\t\t\tif (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);\n\t\t\tif (transmissiveObjects.length > 0) renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera);\n\t\t\tif (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera); //\n\n\t\t\tif (_currentRenderTarget !== null) {\n\t\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\t\t\t\ttextures.updateRenderTargetMipmap(_currentRenderTarget); // resolve multisample renderbuffers to a single-sample texture if necessary\n\n\t\t\t\ttextures.updateMultisampleRenderTarget(_currentRenderTarget);\n\t\t\t} //\n\n\n\t\t\tif (scene.isScene === true) scene.onAfterRender(_this, scene, camera); // Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\t\tstate.buffers.depth.setTest(true);\n\t\t\tstate.buffers.depth.setMask(true);\n\t\t\tstate.buffers.color.setMask(true);\n\t\t\tstate.setPolygonOffset(false); // _gl.finish();\n\n\t\t\tbindingStates.resetDefaultState();\n\t\t\t_currentMaterialId = -1;\n\t\t\t_currentCamera = null;\n\t\t\trenderStateStack.pop();\n\n\t\t\tif (renderStateStack.length > 0) {\n\t\t\t\tcurrentRenderState = renderStateStack[renderStateStack.length - 1];\n\t\t\t} else {\n\t\t\t\tcurrentRenderState = null;\n\t\t\t}\n\n\t\t\trenderListStack.pop();\n\n\t\t\tif (renderListStack.length > 0) {\n\t\t\t\tcurrentRenderList = renderListStack[renderListStack.length - 1];\n\t\t\t} else {\n\t\t\t\tcurrentRenderList = null;\n\t\t\t}\n\t\t};\n\n\t\tfunction projectObject(object, camera, groupOrder, sortObjects) {\n\t\t\tif (object.visible === false) return;\n\t\t\tconst visible = object.layers.test(camera.layers);\n\n\t\t\tif (visible) {\n\t\t\t\tif (object.isGroup) {\n\t\t\t\t\tgroupOrder = object.renderOrder;\n\t\t\t\t} else if (object.isLOD) {\n\t\t\t\t\tif (object.autoUpdate === true) object.update(camera);\n\t\t\t\t} else if (object.isLight) {\n\t\t\t\t\tcurrentRenderState.pushLight(object);\n\n\t\t\t\t\tif (object.castShadow) {\n\t\t\t\t\t\tcurrentRenderState.pushShadow(object);\n\t\t\t\t\t}\n\t\t\t\t} else if (object.isSprite) {\n\t\t\t\t\tif (!object.frustumCulled || _frustum.intersectsSprite(object)) {\n\t\t\t\t\t\tif (sortObjects) {\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst geometry = objects.update(object);\n\t\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\t\tif (material.visible) {\n\t\t\t\t\t\t\tcurrentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (object.isImmediateRenderObject) {\n\t\t\t\t\tif (sortObjects) {\n\t\t\t\t\t\t_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);\n\t\t\t\t} else if (object.isMesh || object.isLine || object.isPoints) {\n\t\t\t\t\tif (object.isSkinnedMesh) {\n\t\t\t\t\t\t// update skeleton only once in a frame\n\t\t\t\t\t\tif (object.skeleton.frame !== info.render.frame) {\n\t\t\t\t\t\t\tobject.skeleton.update();\n\t\t\t\t\t\t\tobject.skeleton.frame = info.render.frame;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!object.frustumCulled || _frustum.intersectsObject(object)) {\n\t\t\t\t\t\tif (sortObjects) {\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst geometry = objects.update(object);\n\t\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\t\tif (Array.isArray(material)) {\n\t\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\t\tfor (let i = 0, l = groups.length; i < l; i++) {\n\t\t\t\t\t\t\t\tconst group = groups[i];\n\t\t\t\t\t\t\t\tconst groupMaterial = material[group.materialIndex];\n\n\t\t\t\t\t\t\t\tif (groupMaterial && groupMaterial.visible) {\n\t\t\t\t\t\t\t\t\tcurrentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (material.visible) {\n\t\t\t\t\t\t\tcurrentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst children = object.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tprojectObject(children[i], camera, groupOrder, sortObjects);\n\t\t\t}\n\t\t}\n\n\t\tfunction renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera) {\n\t\t\tif (_transmissionRenderTarget === null) {\n\t\t\t\t_transmissionRenderTarget = new WebGLRenderTarget(1024, 1024, {\n\t\t\t\t\tgenerateMipmaps: true,\n\t\t\t\t\tminFilter: LinearMipmapLinearFilter,\n\t\t\t\t\tmagFilter: NearestFilter,\n\t\t\t\t\twrapS: ClampToEdgeWrapping,\n\t\t\t\t\twrapT: ClampToEdgeWrapping\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst currentRenderTarget = _this.getRenderTarget();\n\n\t\t\t_this.setRenderTarget(_transmissionRenderTarget);\n\n\t\t\t_this.clear();\n\n\t\t\trenderObjects(opaqueObjects, scene, camera);\n\t\t\ttextures.updateRenderTargetMipmap(_transmissionRenderTarget);\n\n\t\t\t_this.setRenderTarget(currentRenderTarget);\n\n\t\t\trenderObjects(transmissiveObjects, scene, camera);\n\t\t}\n\n\t\tfunction renderObjects(renderList, scene, camera) {\n\t\t\tconst overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n\t\t\tfor (let i = 0, l = renderList.length; i < l; i++) {\n\t\t\t\tconst renderItem = renderList[i];\n\t\t\t\tconst object = renderItem.object;\n\t\t\t\tconst geometry = renderItem.geometry;\n\t\t\t\tconst material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n\t\t\t\tconst group = renderItem.group;\n\n\t\t\t\tif (camera.isArrayCamera) {\n\t\t\t\t\tconst cameras = camera.cameras;\n\n\t\t\t\t\tfor (let j = 0, jl = cameras.length; j < jl; j++) {\n\t\t\t\t\t\tconst camera2 = cameras[j];\n\n\t\t\t\t\t\tif (object.layers.test(camera2.layers)) {\n\t\t\t\t\t\t\tstate.viewport(_currentViewport.copy(camera2.viewport));\n\t\t\t\t\t\t\tcurrentRenderState.setupLightsView(camera2);\n\t\t\t\t\t\t\trenderObject(object, scene, camera2, geometry, material, group);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trenderObject(object, scene, camera, geometry, material, group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction renderObject(object, scene, camera, geometry, material, group) {\n\t\t\tobject.onBeforeRender(_this, scene, camera, geometry, material, group);\n\t\t\tobject.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n\t\t\tobject.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n\n\t\t\tif (object.isImmediateRenderObject) {\n\t\t\t\tconst program = setProgram(camera, scene, material, object);\n\t\t\t\tstate.setMaterial(material);\n\t\t\t\tbindingStates.reset();\n\t\t\t\trenderObjectImmediate(object, program);\n\t\t\t} else {\n\t\t\t\t_this.renderBufferDirect(camera, scene, geometry, material, object, group);\n\t\t\t}\n\n\t\t\tobject.onAfterRender(_this, scene, camera, geometry, material, group);\n\t\t}\n\n\t\tfunction getProgram(material, scene, object) {\n\t\t\tif (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\t\tconst materialProperties = properties.get(material);\n\t\t\tconst lights = currentRenderState.state.lights;\n\t\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\t\t\tconst lightsStateVersion = lights.state.version;\n\t\t\tconst parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);\n\t\t\tconst programCacheKey = programCache.getProgramCacheKey(parameters);\n\t\t\tlet programs = materialProperties.programs; // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change\n\n\t\t\tmaterialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tmaterialProperties.fog = scene.fog;\n\t\t\tmaterialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);\n\n\t\t\tif (programs === undefined) {\n\t\t\t\t// new material\n\t\t\t\tmaterial.addEventListener('dispose', onMaterialDispose);\n\t\t\t\tprograms = new Map();\n\t\t\t\tmaterialProperties.programs = programs;\n\t\t\t}\n\n\t\t\tlet program = programs.get(programCacheKey);\n\n\t\t\tif (program !== undefined) {\n\t\t\t\t// early out if program and light state is identical\n\t\t\t\tif (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {\n\t\t\t\t\tupdateCommonMaterialProperties(material, parameters);\n\t\t\t\t\treturn program;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tparameters.uniforms = programCache.getUniforms(material);\n\t\t\t\tmaterial.onBuild(parameters, _this);\n\t\t\t\tmaterial.onBeforeCompile(parameters, _this);\n\t\t\t\tprogram = programCache.acquireProgram(parameters, programCacheKey);\n\t\t\t\tprograms.set(programCacheKey, program);\n\t\t\t\tmaterialProperties.uniforms = parameters.uniforms;\n\t\t\t}\n\n\t\t\tconst uniforms = materialProperties.uniforms;\n\n\t\t\tif (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {\n\t\t\t\tuniforms.clippingPlanes = clipping.uniform;\n\t\t\t}\n\n\t\t\tupdateCommonMaterialProperties(material, parameters); // store the light setup it was created for\n\n\t\t\tmaterialProperties.needsLights = materialNeedsLights(material);\n\t\t\tmaterialProperties.lightsStateVersion = lightsStateVersion;\n\n\t\t\tif (materialProperties.needsLights) {\n\t\t\t\t// wire up the material to this renderer's lighting state\n\t\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\n\t\t\t\tuniforms.lightProbe.value = lights.state.probe;\n\t\t\t\tuniforms.directionalLights.value = lights.state.directional;\n\t\t\t\tuniforms.directionalLightShadows.value = lights.state.directionalShadow;\n\t\t\t\tuniforms.spotLights.value = lights.state.spot;\n\t\t\t\tuniforms.spotLightShadows.value = lights.state.spotShadow;\n\t\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\n\t\t\t\tuniforms.ltc_1.value = lights.state.rectAreaLTC1;\n\t\t\t\tuniforms.ltc_2.value = lights.state.rectAreaLTC2;\n\t\t\t\tuniforms.pointLights.value = lights.state.point;\n\t\t\t\tuniforms.pointLightShadows.value = lights.state.pointShadow;\n\t\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\n\t\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n\t\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n\t\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\n\t\t\t\tuniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\n\t\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\n\t\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms\n\t\t\t}\n\n\t\t\tconst progUniforms = program.getUniforms();\n\t\t\tconst uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);\n\t\t\tmaterialProperties.currentProgram = program;\n\t\t\tmaterialProperties.uniformsList = uniformsList;\n\t\t\treturn program;\n\t\t}\n\n\t\tfunction updateCommonMaterialProperties(material, parameters) {\n\t\t\tconst materialProperties = properties.get(material);\n\t\t\tmaterialProperties.outputEncoding = parameters.outputEncoding;\n\t\t\tmaterialProperties.instancing = parameters.instancing;\n\t\t\tmaterialProperties.skinning = parameters.skinning;\n\t\t\tmaterialProperties.numClippingPlanes = parameters.numClippingPlanes;\n\t\t\tmaterialProperties.numIntersection = parameters.numClipIntersection;\n\t\t\tmaterialProperties.vertexAlphas = parameters.vertexAlphas;\n\t\t}\n\n\t\tfunction setProgram(camera, scene, material, object) {\n\t\t\tif (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\t\ttextures.resetTextureUnits();\n\t\t\tconst fog = scene.fog;\n\t\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tconst encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;\n\t\t\tconst envMap = cubemaps.get(material.envMap || environment);\n\t\t\tconst vertexAlphas = material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;\n\t\t\tconst materialProperties = properties.get(material);\n\t\t\tconst lights = currentRenderState.state.lights;\n\n\t\t\tif (_clippingEnabled === true) {\n\t\t\t\tif (_localClippingEnabled === true || camera !== _currentCamera) {\n\t\t\t\t\tconst useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup\n\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t// (#8465, #8379)\n\n\t\t\t\t\tclipping.setState(material, camera, useCache);\n\t\t\t\t}\n\t\t\t} //\n\n\n\t\t\tlet needsProgramChange = false;\n\n\t\t\tif (material.version === materialProperties.__version) {\n\t\t\t\tif (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (materialProperties.outputEncoding !== encoding) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (object.isInstancedMesh && materialProperties.instancing === false) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (!object.isInstancedMesh && materialProperties.instancing === true) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (object.isSkinnedMesh && materialProperties.skinning === false) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (!object.isSkinnedMesh && materialProperties.skinning === true) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (materialProperties.envMap !== envMap) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (material.fog && materialProperties.fog !== fog) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t} else if (materialProperties.vertexAlphas !== vertexAlphas) {\n\t\t\t\t\tneedsProgramChange = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tneedsProgramChange = true;\n\t\t\t\tmaterialProperties.__version = material.version;\n\t\t\t} //\n\n\n\t\t\tlet program = materialProperties.currentProgram;\n\n\t\t\tif (needsProgramChange === true) {\n\t\t\t\tprogram = getProgram(material, scene, object);\n\t\t\t}\n\n\t\t\tlet refreshProgram = false;\n\t\t\tlet refreshMaterial = false;\n\t\t\tlet refreshLights = false;\n\t\t\tconst p_uniforms = program.getUniforms(),\n\t\t\t\t\t\tm_uniforms = materialProperties.uniforms;\n\n\t\t\tif (state.useProgram(program.program)) {\n\t\t\t\trefreshProgram = true;\n\t\t\t\trefreshMaterial = true;\n\t\t\t\trefreshLights = true;\n\t\t\t}\n\n\t\t\tif (material.id !== _currentMaterialId) {\n\t\t\t\t_currentMaterialId = material.id;\n\t\t\t\trefreshMaterial = true;\n\t\t\t}\n\n\t\t\tif (refreshProgram || _currentCamera !== camera) {\n\t\t\t\tp_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);\n\n\t\t\t\tif (capabilities.logarithmicDepthBuffer) {\n\t\t\t\t\tp_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));\n\t\t\t\t}\n\n\t\t\t\tif (_currentCamera !== camera) {\n\t\t\t\t\t_currentCamera = camera; // lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\t\trefreshMaterial = true; // set to true on material change\n\n\t\t\t\t\trefreshLights = true; // remains set until update done\n\t\t\t\t} // load material specific uniforms\n\t\t\t\t// (shader material also gets them for the sake of genericity)\n\n\n\t\t\t\tif (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {\n\t\t\t\t\tconst uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\t\tif (uCamPos !== undefined) {\n\t\t\t\t\t\tuCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {\n\t\t\t\t\tp_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);\n\t\t\t\t}\n\n\t\t\t\tif (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {\n\t\t\t\t\tp_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);\n\t\t\t\t}\n\t\t\t} // skinning uniforms must be set even if material didn't change\n\t\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t\t// otherwise textures used for skinning can take over texture units reserved for other material textures\n\n\n\t\t\tif (object.isSkinnedMesh) {\n\t\t\t\tp_uniforms.setOptional(_gl, object, 'bindMatrix');\n\t\t\t\tp_uniforms.setOptional(_gl, object, 'bindMatrixInverse');\n\t\t\t\tconst skeleton = object.skeleton;\n\n\t\t\t\tif (skeleton) {\n\t\t\t\t\tif (capabilities.floatVertexTextures) {\n\t\t\t\t\t\tif (skeleton.boneTexture === null) skeleton.computeBoneTexture();\n\t\t\t\t\t\tp_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);\n\t\t\t\t\t\tp_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp_uniforms.setOptional(_gl, skeleton, 'boneMatrices');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {\n\t\t\t\tmaterialProperties.receiveShadow = object.receiveShadow;\n\t\t\t\tp_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);\n\t\t\t}\n\n\t\t\tif (refreshMaterial) {\n\t\t\t\tp_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);\n\n\t\t\t\tif (materialProperties.needsLights) {\n\t\t\t\t\t// the current material requires lighting info\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t// values\n\t\t\t\t\t//\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t// the GL state when required\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate(m_uniforms, refreshLights);\n\t\t\t\t} // refresh uniforms common to several materials\n\n\n\t\t\t\tif (fog && material.fog) {\n\t\t\t\t\tmaterials.refreshFogUniforms(m_uniforms, fog);\n\t\t\t\t}\n\n\t\t\t\tmaterials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);\n\t\t\t\tWebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\n\t\t\t}\n\n\t\t\tif (material.isShaderMaterial && material.uniformsNeedUpdate === true) {\n\t\t\t\tWebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\n\t\t\t\tmaterial.uniformsNeedUpdate = false;\n\t\t\t}\n\n\t\t\tif (material.isSpriteMaterial) {\n\t\t\t\tp_uniforms.setValue(_gl, 'center', object.center);\n\t\t\t} // common matrices\n\n\n\t\t\tp_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);\n\t\t\tp_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);\n\t\t\tp_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);\n\t\t\treturn program;\n\t\t} // If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\n\t\tfunction markUniformsLightsNeedsUpdate(uniforms, value) {\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\t\tuniforms.lightProbe.needsUpdate = value;\n\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\tuniforms.directionalLightShadows.needsUpdate = value;\n\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\tuniforms.pointLightShadows.needsUpdate = value;\n\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\tuniforms.spotLightShadows.needsUpdate = value;\n\t\t\tuniforms.rectAreaLights.needsUpdate = value;\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\t\t}\n\n\t\tfunction materialNeedsLights(material) {\n\t\t\treturn material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;\n\t\t}\n\n\t\tthis.getActiveCubeFace = function () {\n\t\t\treturn _currentActiveCubeFace;\n\t\t};\n\n\t\tthis.getActiveMipmapLevel = function () {\n\t\t\treturn _currentActiveMipmapLevel;\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\t\t\treturn _currentRenderTarget;\n\t\t};\n\n\t\tthis.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {\n\t\t\t_currentRenderTarget = renderTarget;\n\t\t\t_currentActiveCubeFace = activeCubeFace;\n\t\t\t_currentActiveMipmapLevel = activeMipmapLevel;\n\n\t\t\tif (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {\n\t\t\t\ttextures.setupRenderTarget(renderTarget);\n\t\t\t}\n\n\t\t\tlet framebuffer = null;\n\t\t\tlet isCube = false;\n\t\t\tlet isRenderTarget3D = false;\n\n\t\t\tif (renderTarget) {\n\t\t\t\tconst texture = renderTarget.texture;\n\n\t\t\t\tif (texture.isDataTexture3D || texture.isDataTexture2DArray) {\n\t\t\t\t\tisRenderTarget3D = true;\n\t\t\t\t}\n\n\t\t\t\tconst __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;\n\n\t\t\t\tif (renderTarget.isWebGLCubeRenderTarget) {\n\t\t\t\t\tframebuffer = __webglFramebuffer[activeCubeFace];\n\t\t\t\t\tisCube = true;\n\t\t\t\t} else if (renderTarget.isWebGLMultisampleRenderTarget) {\n\t\t\t\t\tframebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;\n\t\t\t\t} else {\n\t\t\t\t\tframebuffer = __webglFramebuffer;\n\t\t\t\t}\n\n\t\t\t\t_currentViewport.copy(renderTarget.viewport);\n\n\t\t\t\t_currentScissor.copy(renderTarget.scissor);\n\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\t\t\t} else {\n\t\t\t\t_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();\n\n\t\t\t\t_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();\n\n\t\t\t\t_currentScissorTest = _scissorTest;\n\t\t\t}\n\n\t\t\tconst framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n\t\t\tif (framebufferBound && capabilities.drawBuffers) {\n\t\t\t\tlet needsUpdate = false;\n\n\t\t\t\tif (renderTarget) {\n\t\t\t\t\tif (renderTarget.isWebGLMultipleRenderTargets) {\n\t\t\t\t\t\tconst textures = renderTarget.texture;\n\n\t\t\t\t\t\tif (_currentDrawBuffers.length !== textures.length || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {\n\t\t\t\t\t\t\tfor (let i = 0, il = textures.length; i < il; i++) {\n\t\t\t\t\t\t\t\t_currentDrawBuffers[i] = _gl.COLOR_ATTACHMENT0 + i;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_currentDrawBuffers.length = textures.length;\n\t\t\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {\n\t\t\t\t\t\t\t_currentDrawBuffers[0] = _gl.COLOR_ATTACHMENT0;\n\t\t\t\t\t\t\t_currentDrawBuffers.length = 1;\n\t\t\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.BACK) {\n\t\t\t\t\t\t_currentDrawBuffers[0] = _gl.BACK;\n\t\t\t\t\t\t_currentDrawBuffers.length = 1;\n\t\t\t\t\t\tneedsUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (needsUpdate) {\n\t\t\t\t\tif (capabilities.isWebGL2) {\n\t\t\t\t\t\t_gl.drawBuffers(_currentDrawBuffers);\n\t\t\t\t\t} else {\n\t\t\t\t\t\textensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(_currentDrawBuffers);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.viewport(_currentViewport);\n\t\t\tstate.scissor(_currentScissor);\n\t\t\tstate.setScissorTest(_currentScissorTest);\n\n\t\t\tif (isCube) {\n\t\t\t\tconst textureProperties = properties.get(renderTarget.texture);\n\n\t\t\t\t_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);\n\t\t\t} else if (isRenderTarget3D) {\n\t\t\t\tconst textureProperties = properties.get(renderTarget.texture);\n\t\t\t\tconst layer = activeCubeFace || 0;\n\n\t\t\t\t_gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);\n\t\t\t}\n\t\t};\n\n\t\tthis.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {\n\t\t\tif (!(renderTarget && renderTarget.isWebGLRenderTarget)) {\n\t\t\t\tconsole.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet framebuffer = properties.get(renderTarget).__webglFramebuffer;\n\n\t\t\tif (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {\n\t\t\t\tframebuffer = framebuffer[activeCubeFaceIndex];\n\t\t\t}\n\n\t\t\tif (framebuffer) {\n\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n\t\t\t\ttry {\n\t\t\t\t\tconst texture = renderTarget.texture;\n\t\t\t\t\tconst textureFormat = texture.format;\n\t\t\t\t\tconst textureType = texture.type;\n\n\t\t\t\t\tif (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {\n\t\t\t\t\t\tconsole.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));\n\n\t\t\t\t\tif (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t!(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t!halfFloatSupportedByExt) {\n\t\t\t\t\t\tconsole.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {\n\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\t\t\t\t\t\tif (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {\n\t\t\t\t\t\t\t_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\t// restore framebuffer of current render target if necessary\n\t\t\t\t\tconst framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;\n\t\t\t\t\tstate.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthis.copyFramebufferToTexture = function (position, texture, level = 0) {\n\t\t\tconst levelScale = Math.pow(2, -level);\n\t\t\tconst width = Math.floor(texture.image.width * levelScale);\n\t\t\tconst height = Math.floor(texture.image.height * levelScale);\n\t\t\tlet glFormat = utils.convert(texture.format);\n\n\t\t\tif (capabilities.isWebGL2) {\n\t\t\t\t// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100\n\t\t\t\tif (glFormat === _gl.RGB) glFormat = _gl.RGB8;\n\t\t\t\tif (glFormat === _gl.RGBA) glFormat = _gl.RGBA8;\n\t\t\t}\n\n\t\t\ttextures.setTexture2D(texture, 0);\n\n\t\t\t_gl.copyTexImage2D(_gl.TEXTURE_2D, level, glFormat, position.x, position.y, width, height, 0);\n\n\t\t\tstate.unbindTexture();\n\t\t};\n\n\t\tthis.copyTextureToTexture = function (position, srcTexture, dstTexture, level = 0) {\n\t\t\tconst width = srcTexture.image.width;\n\t\t\tconst height = srcTexture.image.height;\n\t\t\tconst glFormat = utils.convert(dstTexture.format);\n\t\t\tconst glType = utils.convert(dstTexture.type);\n\t\t\ttextures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei\n\t\t\t// parameters, make sure they are correct for the dstTexture\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n\n\t\t\tif (srcTexture.isDataTexture) {\n\t\t\t\t_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);\n\t\t\t} else {\n\t\t\t\tif (srcTexture.isCompressedTexture) {\n\t\t\t\t\t_gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);\n\t\t\t\t} else {\n\t\t\t\t\t_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);\n\t\t\t\t}\n\t\t\t} // Generate mipmaps only when copying level 0\n\n\n\t\t\tif (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);\n\t\t\tstate.unbindTexture();\n\t\t};\n\n\t\tthis.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture, level = 0) {\n\t\t\tif (_this.isWebGL1Renderer) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst {\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tdata\n\t\t\t} = srcTexture.image;\n\t\t\tconst glFormat = utils.convert(dstTexture.format);\n\t\t\tconst glType = utils.convert(dstTexture.type);\n\t\t\tlet glTarget;\n\n\t\t\tif (dstTexture.isDataTexture3D) {\n\t\t\t\ttextures.setTexture3D(dstTexture, 0);\n\t\t\t\tglTarget = _gl.TEXTURE_3D;\n\t\t\t} else if (dstTexture.isDataTexture2DArray) {\n\t\t\t\ttextures.setTexture2DArray(dstTexture, 0);\n\t\t\t\tglTarget = _gl.TEXTURE_2D_ARRAY;\n\t\t\t} else {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n\n\t\t\tconst unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);\n\n\t\t\tconst unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);\n\n\t\t\tconst unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);\n\n\t\t\tconst unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);\n\n\t\t\tconst unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, width);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, height);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);\n\n\t\t\t_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, sourceBox.max.x - sourceBox.min.x + 1, sourceBox.max.y - sourceBox.min.y + 1, sourceBox.max.z - sourceBox.min.z + 1, glFormat, glType, data);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);\n\n\t\t\t_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages); // Generate mipmaps only when copying level 0\n\n\n\t\t\tif (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);\n\t\t\tstate.unbindTexture();\n\t\t};\n\n\t\tthis.initTexture = function (texture) {\n\t\t\ttextures.setTexture2D(texture, 0);\n\t\t\tstate.unbindTexture();\n\t\t};\n\n\t\tthis.resetState = function () {\n\t\t\t_currentActiveCubeFace = 0;\n\t\t\t_currentActiveMipmapLevel = 0;\n\t\t\t_currentRenderTarget = null;\n\t\t\tstate.reset();\n\t\t\tbindingStates.reset();\n\t\t};\n\n\t\tif (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {\n\t\t\t\tdetail: this\n\t\t\t})); // eslint-disable-line no-undef\n\n\t\t}\n\t}\n\n\tclass WebGL1Renderer extends WebGLRenderer {}\n\n\tWebGL1Renderer.prototype.isWebGL1Renderer = true;\n\n\tclass FogExp2 {\n\t\tconstructor(color, density = 0.00025) {\n\t\t\tthis.name = '';\n\t\t\tthis.color = new Color(color);\n\t\t\tthis.density = density;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new FogExp2(this.color, this.density);\n\t\t}\n\n\t\ttoJSON()\n\t\t/* meta */\n\t\t{\n\t\t\treturn {\n\t\t\t\ttype: 'FogExp2',\n\t\t\t\tcolor: this.color.getHex(),\n\t\t\t\tdensity: this.density\n\t\t\t};\n\t\t}\n\n\t}\n\n\tFogExp2.prototype.isFogExp2 = true;\n\n\tclass Fog {\n\t\tconstructor(color, near = 1, far = 1000) {\n\t\t\tthis.name = '';\n\t\t\tthis.color = new Color(color);\n\t\t\tthis.near = near;\n\t\t\tthis.far = far;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new Fog(this.color, this.near, this.far);\n\t\t}\n\n\t\ttoJSON()\n\t\t/* meta */\n\t\t{\n\t\t\treturn {\n\t\t\t\ttype: 'Fog',\n\t\t\t\tcolor: this.color.getHex(),\n\t\t\t\tnear: this.near,\n\t\t\t\tfar: this.far\n\t\t\t};\n\t\t}\n\n\t}\n\n\tFog.prototype.isFog = true;\n\n\tclass Scene extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'Scene';\n\t\t\tthis.background = null;\n\t\t\tthis.environment = null;\n\t\t\tthis.fog = null;\n\t\t\tthis.overrideMaterial = null;\n\t\t\tthis.autoUpdate = true; // checked by the renderer\n\n\t\t\tif (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n\t\t\t\t__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {\n\t\t\t\t\tdetail: this\n\t\t\t\t})); // eslint-disable-line no-undef\n\n\t\t\t}\n\t\t}\n\n\t\tcopy(source, recursive) {\n\t\t\tsuper.copy(source, recursive);\n\t\t\tif (source.background !== null) this.background = source.background.clone();\n\t\t\tif (source.environment !== null) this.environment = source.environment.clone();\n\t\t\tif (source.fog !== null) this.fog = source.fog.clone();\n\t\t\tif (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();\n\t\t\tthis.autoUpdate = source.autoUpdate;\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tif (this.background !== null) data.object.background = this.background.toJSON(meta);\n\t\t\tif (this.environment !== null) data.object.environment = this.environment.toJSON(meta);\n\t\t\tif (this.fog !== null) data.object.fog = this.fog.toJSON();\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tScene.prototype.isScene = true;\n\n\tclass InterleavedBuffer {\n\t\tconstructor(array, stride) {\n\t\t\tthis.array = array;\n\t\t\tthis.stride = stride;\n\t\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\t\t\tthis.usage = StaticDrawUsage;\n\t\t\tthis.updateRange = {\n\t\t\t\toffset: 0,\n\t\t\t\tcount: -1\n\t\t\t};\n\t\t\tthis.version = 0;\n\t\t\tthis.uuid = generateUUID();\n\t\t}\n\n\t\tonUploadCallback() {}\n\n\t\tset needsUpdate(value) {\n\t\t\tif (value === true) this.version++;\n\t\t}\n\n\t\tsetUsage(value) {\n\t\t\tthis.usage = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.array = new source.array.constructor(source.array);\n\t\t\tthis.count = source.count;\n\t\t\tthis.stride = source.stride;\n\t\t\tthis.usage = source.usage;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopyAt(index1, attribute, index2) {\n\t\t\tindex1 *= this.stride;\n\t\t\tindex2 *= attribute.stride;\n\n\t\t\tfor (let i = 0, l = this.stride; i < l; i++) {\n\t\t\t\tthis.array[index1 + i] = attribute.array[index2 + i];\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tset(value, offset = 0) {\n\t\t\tthis.array.set(value, offset);\n\t\t\treturn this;\n\t\t}\n\n\t\tclone(data) {\n\t\t\tif (data.arrayBuffers === undefined) {\n\t\t\t\tdata.arrayBuffers = {};\n\t\t\t}\n\n\t\t\tif (this.array.buffer._uuid === undefined) {\n\t\t\t\tthis.array.buffer._uuid = generateUUID();\n\t\t\t}\n\n\t\t\tif (data.arrayBuffers[this.array.buffer._uuid] === undefined) {\n\t\t\t\tdata.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;\n\t\t\t}\n\n\t\t\tconst array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);\n\t\t\tconst ib = new this.constructor(array, this.stride);\n\t\t\tib.setUsage(this.usage);\n\t\t\treturn ib;\n\t\t}\n\n\t\tonUpload(callback) {\n\t\t\tthis.onUploadCallback = callback;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(data) {\n\t\t\tif (data.arrayBuffers === undefined) {\n\t\t\t\tdata.arrayBuffers = {};\n\t\t\t} // generate UUID for array buffer if necessary\n\n\n\t\t\tif (this.array.buffer._uuid === undefined) {\n\t\t\t\tthis.array.buffer._uuid = generateUUID();\n\t\t\t}\n\n\t\t\tif (data.arrayBuffers[this.array.buffer._uuid] === undefined) {\n\t\t\t\tdata.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));\n\t\t\t} //\n\n\n\t\t\treturn {\n\t\t\t\tuuid: this.uuid,\n\t\t\t\tbuffer: this.array.buffer._uuid,\n\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\tstride: this.stride\n\t\t\t};\n\t\t}\n\n\t}\n\n\tInterleavedBuffer.prototype.isInterleavedBuffer = true;\n\n\tconst _vector$6 = /*@__PURE__*/new Vector3();\n\n\tclass InterleavedBufferAttribute {\n\t\tconstructor(interleavedBuffer, itemSize, offset, normalized) {\n\t\t\tthis.name = '';\n\t\t\tthis.data = interleavedBuffer;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.offset = offset;\n\t\t\tthis.normalized = normalized === true;\n\t\t}\n\n\t\tget count() {\n\t\t\treturn this.data.count;\n\t\t}\n\n\t\tget array() {\n\t\t\treturn this.data.array;\n\t\t}\n\n\t\tset needsUpdate(value) {\n\t\t\tthis.data.needsUpdate = value;\n\t\t}\n\n\t\tapplyMatrix4(m) {\n\t\t\tfor (let i = 0, l = this.data.count; i < l; i++) {\n\t\t\t\t_vector$6.x = this.getX(i);\n\t\t\t\t_vector$6.y = this.getY(i);\n\t\t\t\t_vector$6.z = this.getZ(i);\n\n\t\t\t\t_vector$6.applyMatrix4(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tapplyNormalMatrix(m) {\n\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t_vector$6.x = this.getX(i);\n\t\t\t\t_vector$6.y = this.getY(i);\n\t\t\t\t_vector$6.z = this.getZ(i);\n\n\t\t\t\t_vector$6.applyNormalMatrix(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttransformDirection(m) {\n\t\t\tfor (let i = 0, l = this.count; i < l; i++) {\n\t\t\t\t_vector$6.x = this.getX(i);\n\t\t\t\t_vector$6.y = this.getY(i);\n\t\t\t\t_vector$6.z = this.getZ(i);\n\n\t\t\t\t_vector$6.transformDirection(m);\n\n\t\t\t\tthis.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetX(index, x) {\n\t\t\tthis.data.array[index * this.data.stride + this.offset] = x;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetY(index, y) {\n\t\t\tthis.data.array[index * this.data.stride + this.offset + 1] = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetZ(index, z) {\n\t\t\tthis.data.array[index * this.data.stride + this.offset + 2] = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetW(index, w) {\n\t\t\tthis.data.array[index * this.data.stride + this.offset + 3] = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetX(index) {\n\t\t\treturn this.data.array[index * this.data.stride + this.offset];\n\t\t}\n\n\t\tgetY(index) {\n\t\t\treturn this.data.array[index * this.data.stride + this.offset + 1];\n\t\t}\n\n\t\tgetZ(index) {\n\t\t\treturn this.data.array[index * this.data.stride + this.offset + 2];\n\t\t}\n\n\t\tgetW(index) {\n\t\t\treturn this.data.array[index * this.data.stride + this.offset + 3];\n\t\t}\n\n\t\tsetXY(index, x, y) {\n\t\t\tindex = index * this.data.stride + this.offset;\n\t\t\tthis.data.array[index + 0] = x;\n\t\t\tthis.data.array[index + 1] = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetXYZ(index, x, y, z) {\n\t\t\tindex = index * this.data.stride + this.offset;\n\t\t\tthis.data.array[index + 0] = x;\n\t\t\tthis.data.array[index + 1] = y;\n\t\t\tthis.data.array[index + 2] = z;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetXYZW(index, x, y, z, w) {\n\t\t\tindex = index * this.data.stride + this.offset;\n\t\t\tthis.data.array[index + 0] = x;\n\t\t\tthis.data.array[index + 1] = y;\n\t\t\tthis.data.array[index + 2] = z;\n\t\t\tthis.data.array[index + 3] = w;\n\t\t\treturn this;\n\t\t}\n\n\t\tclone(data) {\n\t\t\tif (data === undefined) {\n\t\t\t\tconsole.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor (let i = 0; i < this.count; i++) {\n\t\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\t\tfor (let j = 0; j < this.itemSize; j++) {\n\t\t\t\t\t\tarray.push(this.data.array[index + j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);\n\t\t\t} else {\n\t\t\t\tif (data.interleavedBuffers === undefined) {\n\t\t\t\t\tdata.interleavedBuffers = {};\n\t\t\t\t}\n\n\t\t\t\tif (data.interleavedBuffers[this.data.uuid] === undefined) {\n\t\t\t\t\tdata.interleavedBuffers[this.data.uuid] = this.data.clone(data);\n\t\t\t\t}\n\n\t\t\t\treturn new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);\n\t\t\t}\n\t\t}\n\n\t\ttoJSON(data) {\n\t\t\tif (data === undefined) {\n\t\t\t\tconsole.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor (let i = 0; i < this.count; i++) {\n\t\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\t\tfor (let j = 0; j < this.itemSize; j++) {\n\t\t\t\t\t\tarray.push(this.data.array[index + j]);\n\t\t\t\t\t}\n\t\t\t\t} // deinterleave data and save it as an ordinary buffer attribute for now\n\n\n\t\t\t\treturn {\n\t\t\t\t\titemSize: this.itemSize,\n\t\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\t\tarray: array,\n\t\t\t\t\tnormalized: this.normalized\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// save as true interlaved attribtue\n\t\t\t\tif (data.interleavedBuffers === undefined) {\n\t\t\t\t\tdata.interleavedBuffers = {};\n\t\t\t\t}\n\n\t\t\t\tif (data.interleavedBuffers[this.data.uuid] === undefined) {\n\t\t\t\t\tdata.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tisInterleavedBufferAttribute: true,\n\t\t\t\t\titemSize: this.itemSize,\n\t\t\t\t\tdata: this.data.uuid,\n\t\t\t\t\toffset: this.offset,\n\t\t\t\t\tnormalized: this.normalized\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t}\n\n\tInterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\trotation: <float>,\n\t *\tsizeAttenuation: <bool>\n\t * }\n\t */\n\n\tclass SpriteMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'SpriteMaterial';\n\t\t\tthis.color = new Color(0xffffff);\n\t\t\tthis.map = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.rotation = 0;\n\t\t\tthis.sizeAttenuation = true;\n\t\t\tthis.transparent = true;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.map = source.map;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.rotation = source.rotation;\n\t\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tSpriteMaterial.prototype.isSpriteMaterial = true;\n\n\tlet _geometry;\n\n\tconst _intersectPoint = /*@__PURE__*/new Vector3();\n\n\tconst _worldScale = /*@__PURE__*/new Vector3();\n\n\tconst _mvPosition = /*@__PURE__*/new Vector3();\n\n\tconst _alignedPosition = /*@__PURE__*/new Vector2();\n\n\tconst _rotatedPosition = /*@__PURE__*/new Vector2();\n\n\tconst _viewWorldMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _vA = /*@__PURE__*/new Vector3();\n\n\tconst _vB = /*@__PURE__*/new Vector3();\n\n\tconst _vC = /*@__PURE__*/new Vector3();\n\n\tconst _uvA = /*@__PURE__*/new Vector2();\n\n\tconst _uvB = /*@__PURE__*/new Vector2();\n\n\tconst _uvC = /*@__PURE__*/new Vector2();\n\n\tclass Sprite extends Object3D {\n\t\tconstructor(material) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Sprite';\n\n\t\t\tif (_geometry === undefined) {\n\t\t\t\t_geometry = new BufferGeometry();\n\t\t\t\tconst float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);\n\t\t\t\tconst interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n\n\t\t\t\t_geometry.setIndex([0, 1, 2, 0, 2, 3]);\n\n\t\t\t\t_geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n\n\t\t\t\t_geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n\t\t\t}\n\n\t\t\tthis.geometry = _geometry;\n\t\t\tthis.material = material !== undefined ? material : new SpriteMaterial();\n\t\t\tthis.center = new Vector2(0.5, 0.5);\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tif (raycaster.camera === null) {\n\t\t\t\tconsole.error('THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.');\n\t\t\t}\n\n\t\t\t_worldScale.setFromMatrixScale(this.matrixWorld);\n\n\t\t\t_viewWorldMatrix.copy(raycaster.camera.matrixWorld);\n\n\t\t\tthis.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);\n\n\t\t\t_mvPosition.setFromMatrixPosition(this.modelViewMatrix);\n\n\t\t\tif (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {\n\t\t\t\t_worldScale.multiplyScalar(-_mvPosition.z);\n\t\t\t}\n\n\t\t\tconst rotation = this.material.rotation;\n\t\t\tlet sin, cos;\n\n\t\t\tif (rotation !== 0) {\n\t\t\t\tcos = Math.cos(rotation);\n\t\t\t\tsin = Math.sin(rotation);\n\t\t\t}\n\n\t\t\tconst center = this.center;\n\t\t\ttransformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\t\t\ttransformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\t\t\ttransformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\n\t\t\t_uvA.set(0, 0);\n\n\t\t\t_uvB.set(1, 0);\n\n\t\t\t_uvC.set(1, 1); // check first triangle\n\n\n\t\t\tlet intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);\n\n\t\t\tif (intersect === null) {\n\t\t\t\t// check second triangle\n\t\t\t\ttransformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n\n\t\t\t\t_uvB.set(0, 1);\n\n\t\t\t\tintersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);\n\n\t\t\t\tif (intersect === null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst distance = raycaster.ray.origin.distanceTo(_intersectPoint);\n\t\t\tif (distance < raycaster.near || distance > raycaster.far) return;\n\t\t\tintersects.push({\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: _intersectPoint.clone(),\n\t\t\t\tuv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),\n\t\t\t\tface: null,\n\t\t\t\tobject: this\n\t\t\t});\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tif (source.center !== undefined) this.center.copy(source.center);\n\t\t\tthis.material = source.material;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tSprite.prototype.isSprite = true;\n\n\tfunction transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {\n\t\t// compute position in camera space\n\t\t_alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero\n\n\n\t\tif (sin !== undefined) {\n\t\t\t_rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;\n\t\t\t_rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;\n\t\t} else {\n\t\t\t_rotatedPosition.copy(_alignedPosition);\n\t\t}\n\n\t\tvertexPosition.copy(mvPosition);\n\t\tvertexPosition.x += _rotatedPosition.x;\n\t\tvertexPosition.y += _rotatedPosition.y; // transform to world space\n\n\t\tvertexPosition.applyMatrix4(_viewWorldMatrix);\n\t}\n\n\tconst _v1$2 = /*@__PURE__*/new Vector3();\n\n\tconst _v2$1 = /*@__PURE__*/new Vector3();\n\n\tclass LOD extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis._currentLevel = 0;\n\t\t\tthis.type = 'LOD';\n\t\t\tObject.defineProperties(this, {\n\t\t\t\tlevels: {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tvalue: []\n\t\t\t\t},\n\t\t\t\tisLOD: {\n\t\t\t\t\tvalue: true\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.autoUpdate = true;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source, false);\n\t\t\tconst levels = source.levels;\n\n\t\t\tfor (let i = 0, l = levels.length; i < l; i++) {\n\t\t\t\tconst level = levels[i];\n\t\t\t\tthis.addLevel(level.object.clone(), level.distance);\n\t\t\t}\n\n\t\t\tthis.autoUpdate = source.autoUpdate;\n\t\t\treturn this;\n\t\t}\n\n\t\taddLevel(object, distance = 0) {\n\t\t\tdistance = Math.abs(distance);\n\t\t\tconst levels = this.levels;\n\t\t\tlet l;\n\n\t\t\tfor (l = 0; l < levels.length; l++) {\n\t\t\t\tif (distance < levels[l].distance) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlevels.splice(l, 0, {\n\t\t\t\tdistance: distance,\n\t\t\t\tobject: object\n\t\t\t});\n\t\t\tthis.add(object);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetCurrentLevel() {\n\t\t\treturn this._currentLevel;\n\t\t}\n\n\t\tgetObjectForDistance(distance) {\n\t\t\tconst levels = this.levels;\n\n\t\t\tif (levels.length > 0) {\n\t\t\t\tlet i, l;\n\n\t\t\t\tfor (i = 1, l = levels.length; i < l; i++) {\n\t\t\t\t\tif (distance < levels[i].distance) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn levels[i - 1].object;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tconst levels = this.levels;\n\n\t\t\tif (levels.length > 0) {\n\t\t\t\t_v1$2.setFromMatrixPosition(this.matrixWorld);\n\n\t\t\t\tconst distance = raycaster.ray.origin.distanceTo(_v1$2);\n\t\t\t\tthis.getObjectForDistance(distance).raycast(raycaster, intersects);\n\t\t\t}\n\t\t}\n\n\t\tupdate(camera) {\n\t\t\tconst levels = this.levels;\n\n\t\t\tif (levels.length > 1) {\n\t\t\t\t_v1$2.setFromMatrixPosition(camera.matrixWorld);\n\n\t\t\t\t_v2$1.setFromMatrixPosition(this.matrixWorld);\n\n\t\t\t\tconst distance = _v1$2.distanceTo(_v2$1) / camera.zoom;\n\t\t\t\tlevels[0].object.visible = true;\n\t\t\t\tlet i, l;\n\n\t\t\t\tfor (i = 1, l = levels.length; i < l; i++) {\n\t\t\t\t\tif (distance >= levels[i].distance) {\n\t\t\t\t\t\tlevels[i - 1].object.visible = false;\n\t\t\t\t\t\tlevels[i].object.visible = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._currentLevel = i - 1;\n\n\t\t\t\tfor (; i < l; i++) {\n\t\t\t\t\tlevels[i].object.visible = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tif (this.autoUpdate === false) data.object.autoUpdate = false;\n\t\t\tdata.object.levels = [];\n\t\t\tconst levels = this.levels;\n\n\t\t\tfor (let i = 0, l = levels.length; i < l; i++) {\n\t\t\t\tconst level = levels[i];\n\t\t\t\tdata.object.levels.push({\n\t\t\t\t\tobject: level.object.uuid,\n\t\t\t\t\tdistance: level.distance\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tconst _basePosition = /*@__PURE__*/new Vector3();\n\n\tconst _skinIndex = /*@__PURE__*/new Vector4();\n\n\tconst _skinWeight = /*@__PURE__*/new Vector4();\n\n\tconst _vector$5 = /*@__PURE__*/new Vector3();\n\n\tconst _matrix = /*@__PURE__*/new Matrix4();\n\n\tclass SkinnedMesh extends Mesh {\n\t\tconstructor(geometry, material) {\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'SkinnedMesh';\n\t\t\tthis.bindMode = 'attached';\n\t\t\tthis.bindMatrix = new Matrix4();\n\t\t\tthis.bindMatrixInverse = new Matrix4();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.bindMode = source.bindMode;\n\t\t\tthis.bindMatrix.copy(source.bindMatrix);\n\t\t\tthis.bindMatrixInverse.copy(source.bindMatrixInverse);\n\t\t\tthis.skeleton = source.skeleton;\n\t\t\treturn this;\n\t\t}\n\n\t\tbind(skeleton, bindMatrix) {\n\t\t\tthis.skeleton = skeleton;\n\n\t\t\tif (bindMatrix === undefined) {\n\t\t\t\tthis.updateMatrixWorld(true);\n\t\t\t\tthis.skeleton.calculateInverses();\n\t\t\t\tbindMatrix = this.matrixWorld;\n\t\t\t}\n\n\t\t\tthis.bindMatrix.copy(bindMatrix);\n\t\t\tthis.bindMatrixInverse.copy(bindMatrix).invert();\n\t\t}\n\n\t\tpose() {\n\t\t\tthis.skeleton.pose();\n\t\t}\n\n\t\tnormalizeSkinWeights() {\n\t\t\tconst vector = new Vector4();\n\t\t\tconst skinWeight = this.geometry.attributes.skinWeight;\n\n\t\t\tfor (let i = 0, l = skinWeight.count; i < l; i++) {\n\t\t\t\tvector.x = skinWeight.getX(i);\n\t\t\t\tvector.y = skinWeight.getY(i);\n\t\t\t\tvector.z = skinWeight.getZ(i);\n\t\t\t\tvector.w = skinWeight.getW(i);\n\t\t\t\tconst scale = 1.0 / vector.manhattanLength();\n\n\t\t\t\tif (scale !== Infinity) {\n\t\t\t\t\tvector.multiplyScalar(scale);\n\t\t\t\t} else {\n\t\t\t\t\tvector.set(1, 0, 0, 0); // do something reasonable\n\t\t\t\t}\n\n\t\t\t\tskinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);\n\t\t\t}\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tsuper.updateMatrixWorld(force);\n\n\t\t\tif (this.bindMode === 'attached') {\n\t\t\t\tthis.bindMatrixInverse.copy(this.matrixWorld).invert();\n\t\t\t} else if (this.bindMode === 'detached') {\n\t\t\t\tthis.bindMatrixInverse.copy(this.bindMatrix).invert();\n\t\t\t} else {\n\t\t\t\tconsole.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);\n\t\t\t}\n\t\t}\n\n\t\tboneTransform(index, target) {\n\t\t\tconst skeleton = this.skeleton;\n\t\t\tconst geometry = this.geometry;\n\n\t\t\t_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n\n\t\t\t_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n\n\t\t\t_basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);\n\n\t\t\ttarget.set(0, 0, 0);\n\n\t\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\tconst weight = _skinWeight.getComponent(i);\n\n\t\t\t\tif (weight !== 0) {\n\t\t\t\t\tconst boneIndex = _skinIndex.getComponent(i);\n\n\t\t\t\t\t_matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);\n\n\t\t\t\t\ttarget.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn target.applyMatrix4(this.bindMatrixInverse);\n\t\t}\n\n\t}\n\n\tSkinnedMesh.prototype.isSkinnedMesh = true;\n\n\tclass Bone extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'Bone';\n\t\t}\n\n\t}\n\n\tBone.prototype.isBone = true;\n\n\tclass DataTexture extends Texture {\n\t\tconstructor(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {\n\t\t\tsuper(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\n\t\t\tthis.image = {\n\t\t\t\tdata: data || null,\n\t\t\t\twidth: width || 1,\n\t\t\t\theight: height || 1\n\t\t\t};\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\t\t\tthis.generateMipmaps = false;\n\t\t\tthis.flipY = false;\n\t\t\tthis.unpackAlignment = 1;\n\t\t\tthis.needsUpdate = true;\n\t\t}\n\n\t}\n\n\tDataTexture.prototype.isDataTexture = true;\n\n\tconst _offsetMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _identityMatrix = /*@__PURE__*/new Matrix4();\n\n\tclass Skeleton {\n\t\tconstructor(bones = [], boneInverses = []) {\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.bones = bones.slice(0);\n\t\t\tthis.boneInverses = boneInverses;\n\t\t\tthis.boneMatrices = null;\n\t\t\tthis.boneTexture = null;\n\t\t\tthis.boneTextureSize = 0;\n\t\t\tthis.frame = -1;\n\t\t\tthis.init();\n\t\t}\n\n\t\tinit() {\n\t\t\tconst bones = this.bones;\n\t\t\tconst boneInverses = this.boneInverses;\n\t\t\tthis.boneMatrices = new Float32Array(bones.length * 16); // calculate inverse bone matrices if necessary\n\n\t\t\tif (boneInverses.length === 0) {\n\t\t\t\tthis.calculateInverses();\n\t\t\t} else {\n\t\t\t\t// handle special case\n\t\t\t\tif (bones.length !== boneInverses.length) {\n\t\t\t\t\tconsole.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');\n\t\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\t\tfor (let i = 0, il = this.bones.length; i < il; i++) {\n\t\t\t\t\t\tthis.boneInverses.push(new Matrix4());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcalculateInverses() {\n\t\t\tthis.boneInverses.length = 0;\n\n\t\t\tfor (let i = 0, il = this.bones.length; i < il; i++) {\n\t\t\t\tconst inverse = new Matrix4();\n\n\t\t\t\tif (this.bones[i]) {\n\t\t\t\t\tinverse.copy(this.bones[i].matrixWorld).invert();\n\t\t\t\t}\n\n\t\t\t\tthis.boneInverses.push(inverse);\n\t\t\t}\n\t\t}\n\n\t\tpose() {\n\t\t\t// recover the bind-time world matrices\n\t\t\tfor (let i = 0, il = this.bones.length; i < il; i++) {\n\t\t\t\tconst bone = this.bones[i];\n\n\t\t\t\tif (bone) {\n\t\t\t\t\tbone.matrixWorld.copy(this.boneInverses[i]).invert();\n\t\t\t\t}\n\t\t\t} // compute the local matrices, positions, rotations and scales\n\n\n\t\t\tfor (let i = 0, il = this.bones.length; i < il; i++) {\n\t\t\t\tconst bone = this.bones[i];\n\n\t\t\t\tif (bone) {\n\t\t\t\t\tif (bone.parent && bone.parent.isBone) {\n\t\t\t\t\t\tbone.matrix.copy(bone.parent.matrixWorld).invert();\n\t\t\t\t\t\tbone.matrix.multiply(bone.matrixWorld);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbone.matrix.copy(bone.matrixWorld);\n\t\t\t\t\t}\n\n\t\t\t\t\tbone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tupdate() {\n\t\t\tconst bones = this.bones;\n\t\t\tconst boneInverses = this.boneInverses;\n\t\t\tconst boneMatrices = this.boneMatrices;\n\t\t\tconst boneTexture = this.boneTexture; // flatten bone matrices to array\n\n\t\t\tfor (let i = 0, il = bones.length; i < il; i++) {\n\t\t\t\t// compute the offset between the current and the original transform\n\t\t\t\tconst matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;\n\n\t\t\t\t_offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);\n\n\t\t\t\t_offsetMatrix.toArray(boneMatrices, i * 16);\n\t\t\t}\n\n\t\t\tif (boneTexture !== null) {\n\t\t\t\tboneTexture.needsUpdate = true;\n\t\t\t}\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new Skeleton(this.bones, this.boneInverses);\n\t\t}\n\n\t\tcomputeBoneTexture() {\n\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t//\t\t\tRGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t//\twith\t8x8\tpixel texture max\t 16 bones * 4 pixels =\t(8 * 8)\n\t\t\t//\t\t\t 16x16 pixel texture max\t 64 bones * 4 pixels = (16 * 16)\n\t\t\t//\t\t\t 32x32 pixel texture max\t256 bones * 4 pixels = (32 * 32)\n\t\t\t//\t\t\t 64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\t\t\tlet size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix\n\n\t\t\tsize = ceilPowerOfTwo(size);\n\t\t\tsize = Math.max(size, 4);\n\t\t\tconst boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel\n\n\t\t\tboneMatrices.set(this.boneMatrices); // copy current values\n\n\t\t\tconst boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);\n\t\t\tthis.boneMatrices = boneMatrices;\n\t\t\tthis.boneTexture = boneTexture;\n\t\t\tthis.boneTextureSize = size;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetBoneByName(name) {\n\t\t\tfor (let i = 0, il = this.bones.length; i < il; i++) {\n\t\t\t\tconst bone = this.bones[i];\n\n\t\t\t\tif (bone.name === name) {\n\t\t\t\t\treturn bone;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\tdispose() {\n\t\t\tif (this.boneTexture !== null) {\n\t\t\t\tthis.boneTexture.dispose();\n\t\t\t\tthis.boneTexture = null;\n\t\t\t}\n\t\t}\n\n\t\tfromJSON(json, bones) {\n\t\t\tthis.uuid = json.uuid;\n\n\t\t\tfor (let i = 0, l = json.bones.length; i < l; i++) {\n\t\t\t\tconst uuid = json.bones[i];\n\t\t\t\tlet bone = bones[uuid];\n\n\t\t\t\tif (bone === undefined) {\n\t\t\t\t\tconsole.warn('THREE.Skeleton: No bone found with UUID:', uuid);\n\t\t\t\t\tbone = new Bone();\n\t\t\t\t}\n\n\t\t\t\tthis.bones.push(bone);\n\t\t\t\tthis.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));\n\t\t\t}\n\n\t\t\tthis.init();\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Skeleton',\n\t\t\t\t\tgenerator: 'Skeleton.toJSON'\n\t\t\t\t},\n\t\t\t\tbones: [],\n\t\t\t\tboneInverses: []\n\t\t\t};\n\t\t\tdata.uuid = this.uuid;\n\t\t\tconst bones = this.bones;\n\t\t\tconst boneInverses = this.boneInverses;\n\n\t\t\tfor (let i = 0, l = bones.length; i < l; i++) {\n\t\t\t\tconst bone = bones[i];\n\t\t\t\tdata.bones.push(bone.uuid);\n\t\t\t\tconst boneInverse = boneInverses[i];\n\t\t\t\tdata.boneInverses.push(boneInverse.toArray());\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tconst _instanceLocalMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _instanceWorldMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _instanceIntersects = [];\n\n\tconst _mesh = /*@__PURE__*/new Mesh();\n\n\tclass InstancedMesh extends Mesh {\n\t\tconstructor(geometry, material, count) {\n\t\t\tsuper(geometry, material);\n\t\t\tthis.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);\n\t\t\tthis.instanceColor = null;\n\t\t\tthis.count = count;\n\t\t\tthis.frustumCulled = false;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.instanceMatrix.copy(source.instanceMatrix);\n\t\t\tif (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();\n\t\t\tthis.count = source.count;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetColorAt(index, color) {\n\t\t\tcolor.fromArray(this.instanceColor.array, index * 3);\n\t\t}\n\n\t\tgetMatrixAt(index, matrix) {\n\t\t\tmatrix.fromArray(this.instanceMatrix.array, index * 16);\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tconst matrixWorld = this.matrixWorld;\n\t\t\tconst raycastTimes = this.count;\n\t\t\t_mesh.geometry = this.geometry;\n\t\t\t_mesh.material = this.material;\n\t\t\tif (_mesh.material === undefined) return;\n\n\t\t\tfor (let instanceId = 0; instanceId < raycastTimes; instanceId++) {\n\t\t\t\t// calculate the world matrix for each instance\n\t\t\t\tthis.getMatrixAt(instanceId, _instanceLocalMatrix);\n\n\t\t\t\t_instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance\n\n\n\t\t\t\t_mesh.matrixWorld = _instanceWorldMatrix;\n\n\t\t\t\t_mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast\n\n\n\t\t\t\tfor (let i = 0, l = _instanceIntersects.length; i < l; i++) {\n\t\t\t\t\tconst intersect = _instanceIntersects[i];\n\t\t\t\t\tintersect.instanceId = instanceId;\n\t\t\t\t\tintersect.object = this;\n\t\t\t\t\tintersects.push(intersect);\n\t\t\t\t}\n\n\t\t\t\t_instanceIntersects.length = 0;\n\t\t\t}\n\t\t}\n\n\t\tsetColorAt(index, color) {\n\t\t\tif (this.instanceColor === null) {\n\t\t\t\tthis.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);\n\t\t\t}\n\n\t\t\tcolor.toArray(this.instanceColor.array, index * 3);\n\t\t}\n\n\t\tsetMatrixAt(index, matrix) {\n\t\t\tmatrix.toArray(this.instanceMatrix.array, index * 16);\n\t\t}\n\n\t\tupdateMorphTargets() {}\n\n\t\tdispose() {\n\t\t\tthis.dispatchEvent({\n\t\t\t\ttype: 'dispose'\n\t\t\t});\n\t\t}\n\n\t}\n\n\tInstancedMesh.prototype.isInstancedMesh = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\n\t *\tlinewidth: <float>,\n\t *\tlinecap: \"round\",\n\t *\tlinejoin: \"round\"\n\t * }\n\t */\n\n\tclass LineBasicMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'LineBasicMaterial';\n\t\t\tthis.color = new Color(0xffffff);\n\t\t\tthis.linewidth = 1;\n\t\t\tthis.linecap = 'round';\n\t\t\tthis.linejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.linewidth = source.linewidth;\n\t\t\tthis.linecap = source.linecap;\n\t\t\tthis.linejoin = source.linejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\n\n\tconst _start$1 = /*@__PURE__*/new Vector3();\n\n\tconst _end$1 = /*@__PURE__*/new Vector3();\n\n\tconst _inverseMatrix$1 = /*@__PURE__*/new Matrix4();\n\n\tconst _ray$1 = /*@__PURE__*/new Ray();\n\n\tconst _sphere$1 = /*@__PURE__*/new Sphere();\n\n\tclass Line extends Object3D {\n\t\tconstructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Line';\n\t\t\tthis.geometry = geometry;\n\t\t\tthis.material = material;\n\t\t\tthis.updateMorphTargets();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.material = source.material;\n\t\t\tthis.geometry = source.geometry;\n\t\t\treturn this;\n\t\t}\n\n\t\tcomputeLineDistances() {\n\t\t\tconst geometry = this.geometry;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\t// we assume non-indexed geometry\n\t\t\t\tif (geometry.index === null) {\n\t\t\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\t\t\tconst lineDistances = [0];\n\n\t\t\t\t\tfor (let i = 1, l = positionAttribute.count; i < l; i++) {\n\t\t\t\t\t\t_start$1.fromBufferAttribute(positionAttribute, i - 1);\n\n\t\t\t\t\t\t_end$1.fromBufferAttribute(positionAttribute, i);\n\n\t\t\t\t\t\tlineDistances[i] = lineDistances[i - 1];\n\t\t\t\t\t\tlineDistances[i] += _start$1.distanceTo(_end$1);\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\n\t\t\t\t}\n\t\t\t} else if (geometry.isGeometry) {\n\t\t\t\tconsole.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst matrixWorld = this.matrixWorld;\n\t\t\tconst threshold = raycaster.params.Line.threshold;\n\t\t\tconst drawRange = geometry.drawRange; // Checking boundingSphere distance to ray\n\n\t\t\tif (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n\t\t\t_sphere$1.copy(geometry.boundingSphere);\n\n\t\t\t_sphere$1.applyMatrix4(matrixWorld);\n\n\t\t\t_sphere$1.radius += threshold;\n\t\t\tif (raycaster.ray.intersectsSphere(_sphere$1) === false) return; //\n\n\t\t\t_inverseMatrix$1.copy(matrixWorld).invert();\n\n\t\t\t_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);\n\n\t\t\tconst localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n\t\t\tconst localThresholdSq = localThreshold * localThreshold;\n\t\t\tconst vStart = new Vector3();\n\t\t\tconst vEnd = new Vector3();\n\t\t\tconst interSegment = new Vector3();\n\t\t\tconst interRay = new Vector3();\n\t\t\tconst step = this.isLineSegments ? 2 : 1;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tconst attributes = geometry.attributes;\n\t\t\t\tconst positionAttribute = attributes.position;\n\n\t\t\t\tif (index !== null) {\n\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\tconst end = Math.min(index.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\tfor (let i = start, l = end - 1; i < l; i += step) {\n\t\t\t\t\t\tconst a = index.getX(i);\n\t\t\t\t\t\tconst b = index.getX(i + 1);\n\t\t\t\t\t\tvStart.fromBufferAttribute(positionAttribute, a);\n\t\t\t\t\t\tvEnd.fromBufferAttribute(positionAttribute, b);\n\n\t\t\t\t\t\tconst distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n\n\t\t\t\t\t\tif (distSq > localThresholdSq) continue;\n\t\t\t\t\t\tinterRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tconst distance = raycaster.ray.origin.distanceTo(interRay);\n\t\t\t\t\t\tif (distance < raycaster.near || distance > raycaster.far) continue;\n\t\t\t\t\t\tintersects.push({\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4(this.matrixWorld),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\tconst end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\tfor (let i = start, l = end - 1; i < l; i += step) {\n\t\t\t\t\t\tvStart.fromBufferAttribute(positionAttribute, i);\n\t\t\t\t\t\tvEnd.fromBufferAttribute(positionAttribute, i + 1);\n\n\t\t\t\t\t\tconst distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n\n\t\t\t\t\t\tif (distSq > localThresholdSq) continue;\n\t\t\t\t\t\tinterRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation\n\n\t\t\t\t\t\tconst distance = raycaster.ray.origin.distanceTo(interRay);\n\t\t\t\t\t\tif (distance < raycaster.near || distance > raycaster.far) continue;\n\t\t\t\t\t\tintersects.push({\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4(this.matrixWorld),\n\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: this\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (geometry.isGeometry) {\n\t\t\t\tconsole.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t}\n\t\t}\n\n\t\tupdateMorphTargets() {\n\t\t\tconst geometry = this.geometry;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\t\tconst keys = Object.keys(morphAttributes);\n\n\t\t\t\tif (keys.length > 0) {\n\t\t\t\t\tconst morphAttribute = morphAttributes[keys[0]];\n\n\t\t\t\t\tif (morphAttribute !== undefined) {\n\t\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\t\tfor (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n\t\t\t\t\t\t\tconst name = morphAttribute[m].name || String(m);\n\t\t\t\t\t\t\tthis.morphTargetInfluences.push(0);\n\t\t\t\t\t\t\tthis.morphTargetDictionary[name] = m;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\t\tif (morphTargets !== undefined && morphTargets.length > 0) {\n\t\t\t\t\tconsole.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tLine.prototype.isLine = true;\n\n\tconst _start = /*@__PURE__*/new Vector3();\n\n\tconst _end = /*@__PURE__*/new Vector3();\n\n\tclass LineSegments extends Line {\n\t\tconstructor(geometry, material) {\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'LineSegments';\n\t\t}\n\n\t\tcomputeLineDistances() {\n\t\t\tconst geometry = this.geometry;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\t// we assume non-indexed geometry\n\t\t\t\tif (geometry.index === null) {\n\t\t\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\t\t\tconst lineDistances = [];\n\n\t\t\t\t\tfor (let i = 0, l = positionAttribute.count; i < l; i += 2) {\n\t\t\t\t\t\t_start.fromBufferAttribute(positionAttribute, i);\n\n\t\t\t\t\t\t_end.fromBufferAttribute(positionAttribute, i + 1);\n\n\t\t\t\t\t\tlineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];\n\t\t\t\t\t\tlineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');\n\t\t\t\t}\n\t\t\t} else if (geometry.isGeometry) {\n\t\t\t\tconsole.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tLineSegments.prototype.isLineSegments = true;\n\n\tclass LineLoop extends Line {\n\t\tconstructor(geometry, material) {\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'LineLoop';\n\t\t}\n\n\t}\n\n\tLineLoop.prototype.isLineLoop = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tsize: <float>,\n\t *\tsizeAttenuation: <bool>\n\t *\n\t *\tmorphTargets: <bool>\n\t * }\n\t */\n\n\tclass PointsMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'PointsMaterial';\n\t\t\tthis.color = new Color(0xffffff);\n\t\t\tthis.map = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.size = 1;\n\t\t\tthis.sizeAttenuation = true;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.map = source.map;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.size = source.size;\n\t\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tPointsMaterial.prototype.isPointsMaterial = true;\n\n\tconst _inverseMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _ray = /*@__PURE__*/new Ray();\n\n\tconst _sphere = /*@__PURE__*/new Sphere();\n\n\tconst _position$2 = /*@__PURE__*/new Vector3();\n\n\tclass Points extends Object3D {\n\t\tconstructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Points';\n\t\t\tthis.geometry = geometry;\n\t\t\tthis.material = material;\n\t\t\tthis.updateMorphTargets();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.material = source.material;\n\t\t\tthis.geometry = source.geometry;\n\t\t\treturn this;\n\t\t}\n\n\t\traycast(raycaster, intersects) {\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst matrixWorld = this.matrixWorld;\n\t\t\tconst threshold = raycaster.params.Points.threshold;\n\t\t\tconst drawRange = geometry.drawRange; // Checking boundingSphere distance to ray\n\n\t\t\tif (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n\n\t\t\t_sphere.copy(geometry.boundingSphere);\n\n\t\t\t_sphere.applyMatrix4(matrixWorld);\n\n\t\t\t_sphere.radius += threshold;\n\t\t\tif (raycaster.ray.intersectsSphere(_sphere) === false) return; //\n\n\t\t\t_inverseMatrix.copy(matrixWorld).invert();\n\n\t\t\t_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n\n\t\t\tconst localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n\t\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tconst attributes = geometry.attributes;\n\t\t\t\tconst positionAttribute = attributes.position;\n\n\t\t\t\tif (index !== null) {\n\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\tconst end = Math.min(index.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\tfor (let i = start, il = end; i < il; i++) {\n\t\t\t\t\t\tconst a = index.getX(i);\n\n\t\t\t\t\t\t_position$2.fromBufferAttribute(positionAttribute, a);\n\n\t\t\t\t\t\ttestPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst start = Math.max(0, drawRange.start);\n\t\t\t\t\tconst end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n\t\t\t\t\tfor (let i = start, l = end; i < l; i++) {\n\t\t\t\t\t\t_position$2.fromBufferAttribute(positionAttribute, i);\n\n\t\t\t\t\t\ttestPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t}\n\t\t}\n\n\t\tupdateMorphTargets() {\n\t\t\tconst geometry = this.geometry;\n\n\t\t\tif (geometry.isBufferGeometry) {\n\t\t\t\tconst morphAttributes = geometry.morphAttributes;\n\t\t\t\tconst keys = Object.keys(morphAttributes);\n\n\t\t\t\tif (keys.length > 0) {\n\t\t\t\t\tconst morphAttribute = morphAttributes[keys[0]];\n\n\t\t\t\t\tif (morphAttribute !== undefined) {\n\t\t\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\t\t\tfor (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n\t\t\t\t\t\t\tconst name = morphAttribute[m].name || String(m);\n\t\t\t\t\t\t\tthis.morphTargetInfluences.push(0);\n\t\t\t\t\t\t\tthis.morphTargetDictionary[name] = m;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst morphTargets = geometry.morphTargets;\n\n\t\t\t\tif (morphTargets !== undefined && morphTargets.length > 0) {\n\t\t\t\t\tconsole.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tPoints.prototype.isPoints = true;\n\n\tfunction testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {\n\t\tconst rayPointDistanceSq = _ray.distanceSqToPoint(point);\n\n\t\tif (rayPointDistanceSq < localThresholdSq) {\n\t\t\tconst intersectPoint = new Vector3();\n\n\t\t\t_ray.closestPointToPoint(point, intersectPoint);\n\n\t\t\tintersectPoint.applyMatrix4(matrixWorld);\n\t\t\tconst distance = raycaster.ray.origin.distanceTo(intersectPoint);\n\t\t\tif (distance < raycaster.near || distance > raycaster.far) return;\n\t\t\tintersects.push({\n\t\t\t\tdistance: distance,\n\t\t\t\tdistanceToRay: Math.sqrt(rayPointDistanceSq),\n\t\t\t\tpoint: intersectPoint,\n\t\t\t\tindex: index,\n\t\t\t\tface: null,\n\t\t\t\tobject: object\n\t\t\t});\n\t\t}\n\t}\n\n\tclass VideoTexture extends Texture {\n\t\tconstructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n\t\t\tsuper(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n\t\t\tthis.format = format !== undefined ? format : RGBFormat;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\t\t\tthis.generateMipmaps = false;\n\t\t\tconst scope = this;\n\n\t\t\tfunction updateVideo() {\n\t\t\t\tscope.needsUpdate = true;\n\t\t\t\tvideo.requestVideoFrameCallback(updateVideo);\n\t\t\t}\n\n\t\t\tif ('requestVideoFrameCallback' in video) {\n\t\t\t\tvideo.requestVideoFrameCallback(updateVideo);\n\t\t\t}\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor(this.image).copy(this);\n\t\t}\n\n\t\tupdate() {\n\t\t\tconst video = this.image;\n\t\t\tconst hasVideoFrameCallback = ('requestVideoFrameCallback' in video);\n\n\t\t\tif (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {\n\t\t\t\tthis.needsUpdate = true;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tVideoTexture.prototype.isVideoTexture = true;\n\n\tclass CompressedTexture extends Texture {\n\t\tconstructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {\n\t\t\tsuper(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\n\t\t\tthis.image = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\t\t\tthis.mipmaps = mipmaps; // no flipping for cube textures\n\t\t\t// (also flipping doesn't work for compressed textures )\n\n\t\t\tthis.flipY = false; // can't generate mipmaps for compressed textures\n\t\t\t// mips must be embedded in DDS files\n\n\t\t\tthis.generateMipmaps = false;\n\t\t}\n\n\t}\n\n\tCompressedTexture.prototype.isCompressedTexture = true;\n\n\tclass CanvasTexture extends Texture {\n\t\tconstructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n\t\t\tsuper(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n\t\t\tthis.needsUpdate = true;\n\t\t}\n\n\t}\n\n\tCanvasTexture.prototype.isCanvasTexture = true;\n\n\tclass DepthTexture extends Texture {\n\t\tconstructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {\n\t\t\tformat = format !== undefined ? format : DepthFormat;\n\n\t\t\tif (format !== DepthFormat && format !== DepthStencilFormat) {\n\t\t\t\tthrow new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');\n\t\t\t}\n\n\t\t\tif (type === undefined && format === DepthFormat) type = UnsignedShortType;\n\t\t\tif (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;\n\t\t\tsuper(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n\t\t\tthis.image = {\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t};\n\t\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\t\t\tthis.flipY = false;\n\t\t\tthis.generateMipmaps = false;\n\t\t}\n\n\t}\n\n\tDepthTexture.prototype.isDepthTexture = true;\n\n\tclass CircleGeometry extends BufferGeometry {\n\t\tconstructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CircleGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tsegments: segments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\t\tsegments = Math.max(3, segments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst uv = new Vector2(); // center point\n\n\t\t\tvertices.push(0, 0, 0);\n\t\t\tnormals.push(0, 0, 1);\n\t\t\tuvs.push(0.5, 0.5);\n\n\t\t\tfor (let s = 0, i = 3; s <= segments; s++, i += 3) {\n\t\t\t\tconst segment = thetaStart + s / segments * thetaLength; // vertex\n\n\t\t\t\tvertex.x = radius * Math.cos(segment);\n\t\t\t\tvertex.y = radius * Math.sin(segment);\n\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\tnormals.push(0, 0, 1); // uvs\n\n\t\t\t\tuv.x = (vertices[i] / radius + 1) / 2;\n\t\t\t\tuv.y = (vertices[i + 1] / radius + 1) / 2;\n\t\t\t\tuvs.push(uv.x, uv.y);\n\t\t\t} // indices\n\n\n\t\t\tfor (let i = 1; i <= segments; i++) {\n\t\t\t\tindices.push(i, i + 1, 0);\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tclass CylinderGeometry extends BufferGeometry {\n\t\tconstructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CylinderGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradiusTop: radiusTop,\n\t\t\t\tradiusBottom: radiusBottom,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\t\tconst scope = this;\n\t\t\tradialSegments = Math.floor(radialSegments);\n\t\t\theightSegments = Math.floor(heightSegments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tlet index = 0;\n\t\t\tconst indexArray = [];\n\t\t\tconst halfHeight = height / 2;\n\t\t\tlet groupStart = 0; // generate geometry\n\n\t\t\tgenerateTorso();\n\n\t\t\tif (openEnded === false) {\n\t\t\t\tif (radiusTop > 0) generateCap(true);\n\t\t\t\tif (radiusBottom > 0) generateCap(false);\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\n\t\t\tfunction generateTorso() {\n\t\t\t\tconst normal = new Vector3();\n\t\t\t\tconst vertex = new Vector3();\n\t\t\t\tlet groupCount = 0; // this will be used to calculate the normal\n\n\t\t\t\tconst slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs\n\n\t\t\t\tfor (let y = 0; y <= heightSegments; y++) {\n\t\t\t\t\tconst indexRow = [];\n\t\t\t\t\tconst v = y / heightSegments; // calculate the radius of the current row\n\n\t\t\t\t\tconst radius = v * (radiusBottom - radiusTop) + radiusTop;\n\n\t\t\t\t\tfor (let x = 0; x <= radialSegments; x++) {\n\t\t\t\t\t\tconst u = x / radialSegments;\n\t\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\t\t\t\t\t\tconst sinTheta = Math.sin(theta);\n\t\t\t\t\t\tconst cosTheta = Math.cos(theta); // vertex\n\n\t\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\t\tvertex.y = -v * height + halfHeight;\n\t\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\t\t\tnormal.set(sinTheta, slope, cosTheta).normalize();\n\t\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // uv\n\n\t\t\t\t\t\tuvs.push(u, 1 - v); // save index of vertex in respective row\n\n\t\t\t\t\t\tindexRow.push(index++);\n\t\t\t\t\t} // now save vertices of the row in our index array\n\n\n\t\t\t\t\tindexArray.push(indexRow);\n\t\t\t\t} // generate indices\n\n\n\t\t\t\tfor (let x = 0; x < radialSegments; x++) {\n\t\t\t\t\tfor (let y = 0; y < heightSegments; y++) {\n\t\t\t\t\t\t// we use the index array to access the correct indices\n\t\t\t\t\t\tconst a = indexArray[y][x];\n\t\t\t\t\t\tconst b = indexArray[y + 1][x];\n\t\t\t\t\t\tconst c = indexArray[y + 1][x + 1];\n\t\t\t\t\t\tconst d = indexArray[y][x + 1]; // faces\n\n\t\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\t\tindices.push(b, c, d); // update group counter\n\n\t\t\t\t\t\tgroupCount += 6;\n\t\t\t\t\t}\n\t\t\t\t} // add a group to the geometry. this will ensure multi material support\n\n\n\t\t\t\tscope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t}\n\n\t\t\tfunction generateCap(top) {\n\t\t\t\t// save the index of the first center vertex\n\t\t\t\tconst centerIndexStart = index;\n\t\t\t\tconst uv = new Vector2();\n\t\t\t\tconst vertex = new Vector3();\n\t\t\t\tlet groupCount = 0;\n\t\t\t\tconst radius = top === true ? radiusTop : radiusBottom;\n\t\t\t\tconst sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.\n\t\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\t\tfor (let x = 1; x <= radialSegments; x++) {\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertices.push(0, halfHeight * sign, 0); // normal\n\n\t\t\t\t\tnormals.push(0, sign, 0); // uv\n\n\t\t\t\t\tuvs.push(0.5, 0.5); // increase index\n\n\t\t\t\t\tindex++;\n\t\t\t\t} // save the index of the last center vertex\n\n\n\t\t\t\tconst centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs\n\n\t\t\t\tfor (let x = 0; x <= radialSegments; x++) {\n\t\t\t\t\tconst u = x / radialSegments;\n\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\t\t\t\t\tconst cosTheta = Math.cos(theta);\n\t\t\t\t\tconst sinTheta = Math.sin(theta); // vertex\n\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\t\tnormals.push(0, sign, 0); // uv\n\n\t\t\t\t\tuv.x = cosTheta * 0.5 + 0.5;\n\t\t\t\t\tuv.y = sinTheta * 0.5 * sign + 0.5;\n\t\t\t\t\tuvs.push(uv.x, uv.y); // increase index\n\n\t\t\t\t\tindex++;\n\t\t\t\t} // generate indices\n\n\n\t\t\t\tfor (let x = 0; x < radialSegments; x++) {\n\t\t\t\t\tconst c = centerIndexStart + x;\n\t\t\t\t\tconst i = centerIndexEnd + x;\n\n\t\t\t\t\tif (top === true) {\n\t\t\t\t\t\t// face top\n\t\t\t\t\t\tindices.push(i, i + 1, c);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// face bottom\n\t\t\t\t\t\tindices.push(i + 1, i, c);\n\t\t\t\t\t}\n\n\t\t\t\t\tgroupCount += 3;\n\t\t\t\t} // add a group to the geometry. this will ensure multi material support\n\n\n\t\t\t\tscope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass ConeGeometry extends CylinderGeometry {\n\t\tconstructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {\n\t\t\tsuper(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);\n\t\t\tthis.type = 'ConeGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\theight: height,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\topenEnded: openEnded,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\t}\n\n\t}\n\n\tclass PolyhedronGeometry extends BufferGeometry {\n\t\tconstructor(vertices, indices, radius = 1, detail = 0) {\n\t\t\tsuper();\n\t\t\tthis.type = 'PolyhedronGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tvertices: vertices,\n\t\t\t\tindices: indices,\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t}; // default buffer data\n\n\t\t\tconst vertexBuffer = [];\n\t\t\tconst uvBuffer = []; // the subdivision creates the vertex buffer data\n\n\t\t\tsubdivide(detail); // all vertices should lie on a conceptual sphere with a given radius\n\n\t\t\tapplyRadius(radius); // finally, create the uv data\n\n\t\t\tgenerateUVs(); // build non-indexed geometry\n\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));\n\n\t\t\tif (detail === 0) {\n\t\t\t\tthis.computeVertexNormals(); // flat normals\n\t\t\t} else {\n\t\t\t\tthis.normalizeNormals(); // smooth normals\n\t\t\t} // helper functions\n\n\n\t\t\tfunction subdivide(detail) {\n\t\t\t\tconst a = new Vector3();\n\t\t\t\tconst b = new Vector3();\n\t\t\t\tconst c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value\n\n\t\t\t\tfor (let i = 0; i < indices.length; i += 3) {\n\t\t\t\t\t// get the vertices of the face\n\t\t\t\t\tgetVertexByIndex(indices[i + 0], a);\n\t\t\t\t\tgetVertexByIndex(indices[i + 1], b);\n\t\t\t\t\tgetVertexByIndex(indices[i + 2], c); // perform subdivision\n\n\t\t\t\t\tsubdivideFace(a, b, c, detail);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction subdivideFace(a, b, c, detail) {\n\t\t\t\tconst cols = detail + 1; // we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\t\tconst v = []; // construct all of the vertices for this subdivision\n\n\t\t\t\tfor (let i = 0; i <= cols; i++) {\n\t\t\t\t\tv[i] = [];\n\t\t\t\t\tconst aj = a.clone().lerp(c, i / cols);\n\t\t\t\t\tconst bj = b.clone().lerp(c, i / cols);\n\t\t\t\t\tconst rows = cols - i;\n\n\t\t\t\t\tfor (let j = 0; j <= rows; j++) {\n\t\t\t\t\t\tif (j === 0 && i === cols) {\n\t\t\t\t\t\t\tv[i][j] = aj;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tv[i][j] = aj.clone().lerp(bj, j / rows);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // construct all of the faces\n\n\n\t\t\t\tfor (let i = 0; i < cols; i++) {\n\t\t\t\t\tfor (let j = 0; j < 2 * (cols - i) - 1; j++) {\n\t\t\t\t\t\tconst k = Math.floor(j / 2);\n\n\t\t\t\t\t\tif (j % 2 === 0) {\n\t\t\t\t\t\t\tpushVertex(v[i][k + 1]);\n\t\t\t\t\t\t\tpushVertex(v[i + 1][k]);\n\t\t\t\t\t\t\tpushVertex(v[i][k]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tpushVertex(v[i][k + 1]);\n\t\t\t\t\t\t\tpushVertex(v[i + 1][k + 1]);\n\t\t\t\t\t\t\tpushVertex(v[i + 1][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction applyRadius(radius) {\n\t\t\t\tconst vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\t\tfor (let i = 0; i < vertexBuffer.length; i += 3) {\n\t\t\t\t\tvertex.x = vertexBuffer[i + 0];\n\t\t\t\t\tvertex.y = vertexBuffer[i + 1];\n\t\t\t\t\tvertex.z = vertexBuffer[i + 2];\n\t\t\t\t\tvertex.normalize().multiplyScalar(radius);\n\t\t\t\t\tvertexBuffer[i + 0] = vertex.x;\n\t\t\t\t\tvertexBuffer[i + 1] = vertex.y;\n\t\t\t\t\tvertexBuffer[i + 2] = vertex.z;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction generateUVs() {\n\t\t\t\tconst vertex = new Vector3();\n\n\t\t\t\tfor (let i = 0; i < vertexBuffer.length; i += 3) {\n\t\t\t\t\tvertex.x = vertexBuffer[i + 0];\n\t\t\t\t\tvertex.y = vertexBuffer[i + 1];\n\t\t\t\t\tvertex.z = vertexBuffer[i + 2];\n\t\t\t\t\tconst u = azimuth(vertex) / 2 / Math.PI + 0.5;\n\t\t\t\t\tconst v = inclination(vertex) / Math.PI + 0.5;\n\t\t\t\t\tuvBuffer.push(u, 1 - v);\n\t\t\t\t}\n\n\t\t\t\tcorrectUVs();\n\t\t\t\tcorrectSeam();\n\t\t\t}\n\n\t\t\tfunction correctSeam() {\n\t\t\t\t// handle case when face straddles the seam, see #3269\n\t\t\t\tfor (let i = 0; i < uvBuffer.length; i += 6) {\n\t\t\t\t\t// uv data of a single face\n\t\t\t\t\tconst x0 = uvBuffer[i + 0];\n\t\t\t\t\tconst x1 = uvBuffer[i + 2];\n\t\t\t\t\tconst x2 = uvBuffer[i + 4];\n\t\t\t\t\tconst max = Math.max(x0, x1, x2);\n\t\t\t\t\tconst min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary\n\n\t\t\t\t\tif (max > 0.9 && min < 0.1) {\n\t\t\t\t\t\tif (x0 < 0.2) uvBuffer[i + 0] += 1;\n\t\t\t\t\t\tif (x1 < 0.2) uvBuffer[i + 2] += 1;\n\t\t\t\t\t\tif (x2 < 0.2) uvBuffer[i + 4] += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction pushVertex(vertex) {\n\t\t\t\tvertexBuffer.push(vertex.x, vertex.y, vertex.z);\n\t\t\t}\n\n\t\t\tfunction getVertexByIndex(index, vertex) {\n\t\t\t\tconst stride = index * 3;\n\t\t\t\tvertex.x = vertices[stride + 0];\n\t\t\t\tvertex.y = vertices[stride + 1];\n\t\t\t\tvertex.z = vertices[stride + 2];\n\t\t\t}\n\n\t\t\tfunction correctUVs() {\n\t\t\t\tconst a = new Vector3();\n\t\t\t\tconst b = new Vector3();\n\t\t\t\tconst c = new Vector3();\n\t\t\t\tconst centroid = new Vector3();\n\t\t\t\tconst uvA = new Vector2();\n\t\t\t\tconst uvB = new Vector2();\n\t\t\t\tconst uvC = new Vector2();\n\n\t\t\t\tfor (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {\n\t\t\t\t\ta.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);\n\t\t\t\t\tb.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);\n\t\t\t\t\tc.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);\n\t\t\t\t\tuvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);\n\t\t\t\t\tuvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);\n\t\t\t\t\tuvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);\n\t\t\t\t\tcentroid.copy(a).add(b).add(c).divideScalar(3);\n\t\t\t\t\tconst azi = azimuth(centroid);\n\t\t\t\t\tcorrectUV(uvA, j + 0, a, azi);\n\t\t\t\t\tcorrectUV(uvB, j + 2, b, azi);\n\t\t\t\t\tcorrectUV(uvC, j + 4, c, azi);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction correctUV(uv, stride, vector, azimuth) {\n\t\t\t\tif (azimuth < 0 && uv.x === 1) {\n\t\t\t\t\tuvBuffer[stride] = uv.x - 1;\n\t\t\t\t}\n\n\t\t\t\tif (vector.x === 0 && vector.z === 0) {\n\t\t\t\t\tuvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;\n\t\t\t\t}\n\t\t\t} // Angle around the Y axis, counter-clockwise when looking from above.\n\n\n\t\t\tfunction azimuth(vector) {\n\t\t\t\treturn Math.atan2(vector.z, -vector.x);\n\t\t\t} // Angle above the XZ plane.\n\n\n\t\t\tfunction inclination(vector) {\n\t\t\t\treturn Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass DodecahedronGeometry extends PolyhedronGeometry {\n\t\tconstructor(radius = 1, detail = 0) {\n\t\t\tconst t = (1 + Math.sqrt(5)) / 2;\n\t\t\tconst r = 1 / t;\n\t\t\tconst vertices = [// (±1, ±1, ±1)\n\t\t\t-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, ±1/φ, ±φ)\n\t\t\t0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (±1/φ, ±φ, 0)\n\t\t\t-r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (±φ, 0, ±1/φ)\n\t\t\t-t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];\n\t\t\tconst indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];\n\t\t\tsuper(vertices, indices, radius, detail);\n\t\t\tthis.type = 'DodecahedronGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\t}\n\n\t}\n\n\tconst _v0 = new Vector3();\n\n\tconst _v1$1 = new Vector3();\n\n\tconst _normal = new Vector3();\n\n\tconst _triangle = new Triangle();\n\n\tclass EdgesGeometry extends BufferGeometry {\n\t\tconstructor(geometry, thresholdAngle) {\n\t\t\tsuper();\n\t\t\tthis.type = 'EdgesGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tthresholdAngle: thresholdAngle\n\t\t\t};\n\t\t\tthresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;\n\n\t\t\tif (geometry.isGeometry === true) {\n\t\t\t\tconsole.error('THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst precisionPoints = 4;\n\t\t\tconst precision = Math.pow(10, precisionPoints);\n\t\t\tconst thresholdDot = Math.cos(DEG2RAD * thresholdAngle);\n\t\t\tconst indexAttr = geometry.getIndex();\n\t\t\tconst positionAttr = geometry.getAttribute('position');\n\t\t\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\t\t\tconst indexArr = [0, 0, 0];\n\t\t\tconst vertKeys = ['a', 'b', 'c'];\n\t\t\tconst hashes = new Array(3);\n\t\t\tconst edgeData = {};\n\t\t\tconst vertices = [];\n\n\t\t\tfor (let i = 0; i < indexCount; i += 3) {\n\t\t\t\tif (indexAttr) {\n\t\t\t\t\tindexArr[0] = indexAttr.getX(i);\n\t\t\t\t\tindexArr[1] = indexAttr.getX(i + 1);\n\t\t\t\t\tindexArr[2] = indexAttr.getX(i + 2);\n\t\t\t\t} else {\n\t\t\t\t\tindexArr[0] = i;\n\t\t\t\t\tindexArr[1] = i + 1;\n\t\t\t\t\tindexArr[2] = i + 2;\n\t\t\t\t}\n\n\t\t\t\tconst {\n\t\t\t\t\ta,\n\t\t\t\t\tb,\n\t\t\t\t\tc\n\t\t\t\t} = _triangle;\n\t\t\t\ta.fromBufferAttribute(positionAttr, indexArr[0]);\n\t\t\t\tb.fromBufferAttribute(positionAttr, indexArr[1]);\n\t\t\t\tc.fromBufferAttribute(positionAttr, indexArr[2]);\n\n\t\t\t\t_triangle.getNormal(_normal); // create hashes for the edge from the vertices\n\n\n\t\t\t\thashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;\n\t\t\t\thashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;\n\t\t\t\thashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`; // skip degenerate triangles\n\n\t\t\t\tif (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} // iterate over every edge\n\n\n\t\t\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t\t\t// get the first and next vertex making up the edge\n\t\t\t\t\tconst jNext = (j + 1) % 3;\n\t\t\t\t\tconst vecHash0 = hashes[j];\n\t\t\t\t\tconst vecHash1 = hashes[jNext];\n\t\t\t\t\tconst v0 = _triangle[vertKeys[j]];\n\t\t\t\t\tconst v1 = _triangle[vertKeys[jNext]];\n\t\t\t\t\tconst hash = `${vecHash0}_${vecHash1}`;\n\t\t\t\t\tconst reverseHash = `${vecHash1}_${vecHash0}`;\n\n\t\t\t\t\tif (reverseHash in edgeData && edgeData[reverseHash]) {\n\t\t\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\t\t\tif (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {\n\t\t\t\t\t\t\tvertices.push(v0.x, v0.y, v0.z);\n\t\t\t\t\t\t\tvertices.push(v1.x, v1.y, v1.z);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedgeData[reverseHash] = null;\n\t\t\t\t\t} else if (!(hash in edgeData)) {\n\t\t\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\t\t\tedgeData[hash] = {\n\t\t\t\t\t\t\tindex0: indexArr[j],\n\t\t\t\t\t\t\tindex1: indexArr[jNext],\n\t\t\t\t\t\t\tnormal: _normal.clone()\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // iterate over all remaining, unmatched edges and add them to the vertex array\n\n\n\t\t\tfor (const key in edgeData) {\n\t\t\t\tif (edgeData[key]) {\n\t\t\t\t\tconst {\n\t\t\t\t\t\tindex0,\n\t\t\t\t\t\tindex1\n\t\t\t\t\t} = edgeData[key];\n\n\t\t\t\t\t_v0.fromBufferAttribute(positionAttr, index0);\n\n\t\t\t\t\t_v1$1.fromBufferAttribute(positionAttr, index1);\n\n\t\t\t\t\tvertices.push(_v0.x, _v0.y, _v0.z);\n\t\t\t\t\tvertices.push(_v1$1.x, _v1$1.y, _v1$1.z);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t}\n\n\t}\n\n\t/**\n\t * Port from https://github.com/mapbox/earcut (v2.2.2)\n\t */\n\tconst Earcut = {\n\t\ttriangulate: function (data, holeIndices, dim) {\n\t\t\tdim = dim || 2;\n\t\t\tconst hasHoles = holeIndices && holeIndices.length;\n\t\t\tconst outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\t\t\tlet outerNode = linkedList(data, 0, outerLen, dim, true);\n\t\t\tconst triangles = [];\n\t\t\tif (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\t\t\tlet minX, minY, maxX, maxY, x, y, invSize;\n\t\t\tif (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\n\t\t\tif (data.length > 80 * dim) {\n\t\t\t\tminX = maxX = data[0];\n\t\t\t\tminY = maxY = data[1];\n\n\t\t\t\tfor (let i = dim; i < outerLen; i += dim) {\n\t\t\t\t\tx = data[i];\n\t\t\t\t\ty = data[i + 1];\n\t\t\t\t\tif (x < minX) minX = x;\n\t\t\t\t\tif (y < minY) minY = y;\n\t\t\t\t\tif (x > maxX) maxX = x;\n\t\t\t\t\tif (y > maxY) maxY = y;\n\t\t\t\t} // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\n\n\t\t\t\tinvSize = Math.max(maxX - minX, maxY - minY);\n\t\t\t\tinvSize = invSize !== 0 ? 1 / invSize : 0;\n\t\t\t}\n\n\t\t\tearcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\t\t\treturn triangles;\n\t\t}\n\t}; // create a circular doubly linked list from polygon points in the specified winding order\n\n\tfunction linkedList(data, start, end, dim, clockwise) {\n\t\tlet i, last;\n\n\t\tif (clockwise === signedArea(data, start, end, dim) > 0) {\n\t\t\tfor (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n\t\t} else {\n\t\t\tfor (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n\t\t}\n\n\t\tif (last && equals(last, last.next)) {\n\t\t\tremoveNode(last);\n\t\t\tlast = last.next;\n\t\t}\n\n\t\treturn last;\n\t} // eliminate colinear or duplicate points\n\n\n\tfunction filterPoints(start, end) {\n\t\tif (!start) return start;\n\t\tif (!end) end = start;\n\t\tlet p = start,\n\t\t\t\tagain;\n\n\t\tdo {\n\t\t\tagain = false;\n\n\t\t\tif (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n\t\t\t\tremoveNode(p);\n\t\t\t\tp = end = p.prev;\n\t\t\t\tif (p === p.next) break;\n\t\t\t\tagain = true;\n\t\t\t} else {\n\t\t\t\tp = p.next;\n\t\t\t}\n\t\t} while (again || p !== end);\n\n\t\treturn end;\n\t} // main ear slicing loop which triangulates a polygon (given as a linked list)\n\n\n\tfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n\t\tif (!ear) return; // interlink polygon nodes in z-order\n\n\t\tif (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\t\tlet stop = ear,\n\t\t\t\tprev,\n\t\t\t\tnext; // iterate through ears, slicing them one by one\n\n\t\twhile (ear.prev !== ear.next) {\n\t\t\tprev = ear.prev;\n\t\t\tnext = ear.next;\n\n\t\t\tif (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n\t\t\t\t// cut off the triangle\n\t\t\t\ttriangles.push(prev.i / dim);\n\t\t\t\ttriangles.push(ear.i / dim);\n\t\t\t\ttriangles.push(next.i / dim);\n\t\t\t\tremoveNode(ear); // skipping the next vertex leads to less sliver triangles\n\n\t\t\t\tear = next.next;\n\t\t\t\tstop = next.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tear = next; // if we looped through the whole remaining polygon and can't find any more ears\n\n\t\t\tif (ear === stop) {\n\t\t\t\t// try filtering points and slicing again\n\t\t\t\tif (!pass) {\n\t\t\t\t\tearcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally\n\t\t\t\t} else if (pass === 1) {\n\t\t\t\t\tear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n\t\t\t\t\tearcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two\n\t\t\t\t} else if (pass === 2) {\n\t\t\t\t\tsplitEarcut(ear, triangles, dim, minX, minY, invSize);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} // check whether a polygon node forms a valid ear with adjacent nodes\n\n\n\tfunction isEar(ear) {\n\t\tconst a = ear.prev,\n\t\t\t\t\tb = ear,\n\t\t\t\t\tc = ear.next;\n\t\tif (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\t\t// now make sure we don't have other points inside the potential ear\n\n\t\tlet p = ear.next.next;\n\n\t\twhile (p !== ear.prev) {\n\t\t\tif (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n\t\t\tp = p.next;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction isEarHashed(ear, minX, minY, invSize) {\n\t\tconst a = ear.prev,\n\t\t\t\t\tb = ear,\n\t\t\t\t\tc = ear.next;\n\t\tif (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\t\t// triangle bbox; min & max are calculated like this for speed\n\n\t\tconst minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,\n\t\t\t\t\tminTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,\n\t\t\t\t\tmaxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,\n\t\t\t\t\tmaxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;\n\n\t\tconst minZ = zOrder(minTX, minTY, minX, minY, invSize),\n\t\t\t\t\tmaxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\t\tlet p = ear.prevZ,\n\t\t\t\tn = ear.nextZ; // look for points inside the triangle in both directions\n\n\t\twhile (p && p.z >= minZ && n && n.z <= maxZ) {\n\t\t\tif (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n\t\t\tp = p.prevZ;\n\t\t\tif (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n\t\t\tn = n.nextZ;\n\t\t} // look for remaining points in decreasing z-order\n\n\n\t\twhile (p && p.z >= minZ) {\n\t\t\tif (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n\t\t\tp = p.prevZ;\n\t\t} // look for remaining points in increasing z-order\n\n\n\t\twhile (n && n.z <= maxZ) {\n\t\t\tif (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n\t\t\tn = n.nextZ;\n\t\t}\n\n\t\treturn true;\n\t} // go through all polygon nodes and cure small local self-intersections\n\n\n\tfunction cureLocalIntersections(start, triangles, dim) {\n\t\tlet p = start;\n\n\t\tdo {\n\t\t\tconst a = p.prev,\n\t\t\t\t\t\tb = p.next.next;\n\n\t\t\tif (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\t\t\t\ttriangles.push(a.i / dim);\n\t\t\t\ttriangles.push(p.i / dim);\n\t\t\t\ttriangles.push(b.i / dim); // remove two nodes involved\n\n\t\t\t\tremoveNode(p);\n\t\t\t\tremoveNode(p.next);\n\t\t\t\tp = start = b;\n\t\t\t}\n\n\t\t\tp = p.next;\n\t\t} while (p !== start);\n\n\t\treturn filterPoints(p);\n\t} // try splitting polygon into two and triangulate them independently\n\n\n\tfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n\t\t// look for a valid diagonal that divides the polygon into two\n\t\tlet a = start;\n\n\t\tdo {\n\t\t\tlet b = a.next.next;\n\n\t\t\twhile (b !== a.prev) {\n\t\t\t\tif (a.i !== b.i && isValidDiagonal(a, b)) {\n\t\t\t\t\t// split the polygon in two by the diagonal\n\t\t\t\t\tlet c = splitPolygon(a, b); // filter colinear points around the cuts\n\n\t\t\t\t\ta = filterPoints(a, a.next);\n\t\t\t\t\tc = filterPoints(c, c.next); // run earcut on each half\n\n\t\t\t\t\tearcutLinked(a, triangles, dim, minX, minY, invSize);\n\t\t\t\t\tearcutLinked(c, triangles, dim, minX, minY, invSize);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tb = b.next;\n\t\t\t}\n\n\t\t\ta = a.next;\n\t\t} while (a !== start);\n\t} // link every hole into the outer loop, producing a single-ring polygon without holes\n\n\n\tfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n\t\tconst queue = [];\n\t\tlet i, len, start, end, list;\n\n\t\tfor (i = 0, len = holeIndices.length; i < len; i++) {\n\t\t\tstart = holeIndices[i] * dim;\n\t\t\tend = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n\t\t\tlist = linkedList(data, start, end, dim, false);\n\t\t\tif (list === list.next) list.steiner = true;\n\t\t\tqueue.push(getLeftmost(list));\n\t\t}\n\n\t\tqueue.sort(compareX); // process holes from left to right\n\n\t\tfor (i = 0; i < queue.length; i++) {\n\t\t\teliminateHole(queue[i], outerNode);\n\t\t\touterNode = filterPoints(outerNode, outerNode.next);\n\t\t}\n\n\t\treturn outerNode;\n\t}\n\n\tfunction compareX(a, b) {\n\t\treturn a.x - b.x;\n\t} // find a bridge between vertices that connects hole with an outer ring and and link it\n\n\n\tfunction eliminateHole(hole, outerNode) {\n\t\touterNode = findHoleBridge(hole, outerNode);\n\n\t\tif (outerNode) {\n\t\t\tconst b = splitPolygon(outerNode, hole); // filter collinear points around the cuts\n\n\t\t\tfilterPoints(outerNode, outerNode.next);\n\t\t\tfilterPoints(b, b.next);\n\t\t}\n\t} // David Eberly's algorithm for finding a bridge between hole and outer polygon\n\n\n\tfunction findHoleBridge(hole, outerNode) {\n\t\tlet p = outerNode;\n\t\tconst hx = hole.x;\n\t\tconst hy = hole.y;\n\t\tlet qx = -Infinity,\n\t\t\t\tm; // find a segment intersected by a ray from the hole's leftmost point to the left;\n\t\t// segment's endpoint with lesser x will be potential connection point\n\n\t\tdo {\n\t\t\tif (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n\t\t\t\tconst x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n\n\t\t\t\tif (x <= hx && x > qx) {\n\t\t\t\t\tqx = x;\n\n\t\t\t\t\tif (x === hx) {\n\t\t\t\t\t\tif (hy === p.y) return p;\n\t\t\t\t\t\tif (hy === p.next.y) return p.next;\n\t\t\t\t\t}\n\n\t\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = p.next;\n\t\t} while (p !== outerNode);\n\n\t\tif (!m) return null;\n\t\tif (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\t\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t\t// if there are no points found, we have a valid connection;\n\t\t// otherwise choose the point of the minimum angle with the ray as connection point\n\n\t\tconst stop = m,\n\t\t\t\t\tmx = m.x,\n\t\t\t\t\tmy = m.y;\n\t\tlet tanMin = Infinity,\n\t\t\t\ttan;\n\t\tp = m;\n\n\t\tdo {\n\t\t\tif (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\t\t\t\ttan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n\t\t\t\tif (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n\t\t\t\t\tm = p;\n\t\t\t\t\ttanMin = tan;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp = p.next;\n\t\t} while (p !== stop);\n\n\t\treturn m;\n\t} // whether sector in vertex m contains sector in vertex p in the same coordinates\n\n\n\tfunction sectorContainsSector(m, p) {\n\t\treturn area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n\t} // interlink polygon nodes in z-order\n\n\n\tfunction indexCurve(start, minX, minY, invSize) {\n\t\tlet p = start;\n\n\t\tdo {\n\t\t\tif (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n\t\t\tp.prevZ = p.prev;\n\t\t\tp.nextZ = p.next;\n\t\t\tp = p.next;\n\t\t} while (p !== start);\n\n\t\tp.prevZ.nextZ = null;\n\t\tp.prevZ = null;\n\t\tsortLinked(p);\n\t} // Simon Tatham's linked list merge sort algorithm\n\t// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n\n\n\tfunction sortLinked(list) {\n\t\tlet i,\n\t\t\t\tp,\n\t\t\t\tq,\n\t\t\t\te,\n\t\t\t\ttail,\n\t\t\t\tnumMerges,\n\t\t\t\tpSize,\n\t\t\t\tqSize,\n\t\t\t\tinSize = 1;\n\n\t\tdo {\n\t\t\tp = list;\n\t\t\tlist = null;\n\t\t\ttail = null;\n\t\t\tnumMerges = 0;\n\n\t\t\twhile (p) {\n\t\t\t\tnumMerges++;\n\t\t\t\tq = p;\n\t\t\t\tpSize = 0;\n\n\t\t\t\tfor (i = 0; i < inSize; i++) {\n\t\t\t\t\tpSize++;\n\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\tif (!q) break;\n\t\t\t\t}\n\n\t\t\t\tqSize = inSize;\n\n\t\t\t\twhile (pSize > 0 || qSize > 0 && q) {\n\t\t\t\t\tif (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n\t\t\t\t\t\te = p;\n\t\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\t\tpSize--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = q;\n\t\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\t\tqSize--;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (tail) tail.nextZ = e;else list = e;\n\t\t\t\t\te.prevZ = tail;\n\t\t\t\t\ttail = e;\n\t\t\t\t}\n\n\t\t\t\tp = q;\n\t\t\t}\n\n\t\t\ttail.nextZ = null;\n\t\t\tinSize *= 2;\n\t\t} while (numMerges > 1);\n\n\t\treturn list;\n\t} // z-order of a point given coords and inverse of the longer side of data bbox\n\n\n\tfunction zOrder(x, y, minX, minY, invSize) {\n\t\t// coords are transformed into non-negative 15-bit integer range\n\t\tx = 32767 * (x - minX) * invSize;\n\t\ty = 32767 * (y - minY) * invSize;\n\t\tx = (x | x << 8) & 0x00FF00FF;\n\t\tx = (x | x << 4) & 0x0F0F0F0F;\n\t\tx = (x | x << 2) & 0x33333333;\n\t\tx = (x | x << 1) & 0x55555555;\n\t\ty = (y | y << 8) & 0x00FF00FF;\n\t\ty = (y | y << 4) & 0x0F0F0F0F;\n\t\ty = (y | y << 2) & 0x33333333;\n\t\ty = (y | y << 1) & 0x55555555;\n\t\treturn x | y << 1;\n\t} // find the leftmost node of a polygon ring\n\n\n\tfunction getLeftmost(start) {\n\t\tlet p = start,\n\t\t\t\tleftmost = start;\n\n\t\tdo {\n\t\t\tif (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n\t\t\tp = p.next;\n\t\t} while (p !== start);\n\n\t\treturn leftmost;\n\t} // check if a point lies within a convex triangle\n\n\n\tfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n\t\treturn (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n\t} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n\n\n\tfunction isValidDiagonal(a, b) {\n\t\treturn a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges\n\t\tlocallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible\n\t\tarea(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n\t\tequals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n\t} // signed area of a triangle\n\n\n\tfunction area(p, q, r) {\n\t\treturn (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n\t} // check if two points are equal\n\n\n\tfunction equals(p1, p2) {\n\t\treturn p1.x === p2.x && p1.y === p2.y;\n\t} // check if two segments intersect\n\n\n\tfunction intersects(p1, q1, p2, q2) {\n\t\tconst o1 = sign(area(p1, q1, p2));\n\t\tconst o2 = sign(area(p1, q1, q2));\n\t\tconst o3 = sign(area(p2, q2, p1));\n\t\tconst o4 = sign(area(p2, q2, q1));\n\t\tif (o1 !== o2 && o3 !== o4) return true; // general case\n\n\t\tif (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n\n\t\tif (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n\n\t\tif (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n\n\t\tif (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n\t\treturn false;\n\t} // for collinear points p, q, r, check if point q lies on segment pr\n\n\n\tfunction onSegment(p, q, r) {\n\t\treturn q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n\t}\n\n\tfunction sign(num) {\n\t\treturn num > 0 ? 1 : num < 0 ? -1 : 0;\n\t} // check if a polygon diagonal intersects any polygon segments\n\n\n\tfunction intersectsPolygon(a, b) {\n\t\tlet p = a;\n\n\t\tdo {\n\t\t\tif (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n\t\t\tp = p.next;\n\t\t} while (p !== a);\n\n\t\treturn false;\n\t} // check if a polygon diagonal is locally inside the polygon\n\n\n\tfunction locallyInside(a, b) {\n\t\treturn area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n\t} // check if the middle point of a polygon diagonal is inside the polygon\n\n\n\tfunction middleInside(a, b) {\n\t\tlet p = a,\n\t\t\t\tinside = false;\n\t\tconst px = (a.x + b.x) / 2,\n\t\t\t\t\tpy = (a.y + b.y) / 2;\n\n\t\tdo {\n\t\t\tif (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n\t\t\tp = p.next;\n\t\t} while (p !== a);\n\n\t\treturn inside;\n\t} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n\t// if one belongs to the outer ring and another to a hole, it merges it into a single ring\n\n\n\tfunction splitPolygon(a, b) {\n\t\tconst a2 = new Node(a.i, a.x, a.y),\n\t\t\t\t\tb2 = new Node(b.i, b.x, b.y),\n\t\t\t\t\tan = a.next,\n\t\t\t\t\tbp = b.prev;\n\t\ta.next = b;\n\t\tb.prev = a;\n\t\ta2.next = an;\n\t\tan.prev = a2;\n\t\tb2.next = a2;\n\t\ta2.prev = b2;\n\t\tbp.next = b2;\n\t\tb2.prev = bp;\n\t\treturn b2;\n\t} // create a node and optionally link it with previous one (in a circular doubly linked list)\n\n\n\tfunction insertNode(i, x, y, last) {\n\t\tconst p = new Node(i, x, y);\n\n\t\tif (!last) {\n\t\t\tp.prev = p;\n\t\t\tp.next = p;\n\t\t} else {\n\t\t\tp.next = last.next;\n\t\t\tp.prev = last;\n\t\t\tlast.next.prev = p;\n\t\t\tlast.next = p;\n\t\t}\n\n\t\treturn p;\n\t}\n\n\tfunction removeNode(p) {\n\t\tp.next.prev = p.prev;\n\t\tp.prev.next = p.next;\n\t\tif (p.prevZ) p.prevZ.nextZ = p.nextZ;\n\t\tif (p.nextZ) p.nextZ.prevZ = p.prevZ;\n\t}\n\n\tfunction Node(i, x, y) {\n\t\t// vertex index in coordinates array\n\t\tthis.i = i; // vertex coordinates\n\n\t\tthis.x = x;\n\t\tthis.y = y; // previous and next vertex nodes in a polygon ring\n\n\t\tthis.prev = null;\n\t\tthis.next = null; // z-order curve value\n\n\t\tthis.z = null; // previous and next nodes in z-order\n\n\t\tthis.prevZ = null;\n\t\tthis.nextZ = null; // indicates whether this is a steiner point\n\n\t\tthis.steiner = false;\n\t}\n\n\tfunction signedArea(data, start, end, dim) {\n\t\tlet sum = 0;\n\n\t\tfor (let i = start, j = end - dim; i < end; i += dim) {\n\t\t\tsum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n\t\t\tj = i;\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\tclass ShapeUtils {\n\t\t// calculate area of the contour polygon\n\t\tstatic area(contour) {\n\t\t\tconst n = contour.length;\n\t\t\tlet a = 0.0;\n\n\t\t\tfor (let p = n - 1, q = 0; q < n; p = q++) {\n\t\t\t\ta += contour[p].x * contour[q].y - contour[q].x * contour[p].y;\n\t\t\t}\n\n\t\t\treturn a * 0.5;\n\t\t}\n\n\t\tstatic isClockWise(pts) {\n\t\t\treturn ShapeUtils.area(pts) < 0;\n\t\t}\n\n\t\tstatic triangulateShape(contour, holes) {\n\t\t\tconst vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\n\t\t\tconst holeIndices = []; // array of hole indices\n\n\t\t\tconst faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n\t\t\tremoveDupEndPts(contour);\n\t\t\taddContour(vertices, contour); //\n\n\t\t\tlet holeIndex = contour.length;\n\t\t\tholes.forEach(removeDupEndPts);\n\n\t\t\tfor (let i = 0; i < holes.length; i++) {\n\t\t\t\tholeIndices.push(holeIndex);\n\t\t\t\tholeIndex += holes[i].length;\n\t\t\t\taddContour(vertices, holes[i]);\n\t\t\t} //\n\n\n\t\t\tconst triangles = Earcut.triangulate(vertices, holeIndices); //\n\n\t\t\tfor (let i = 0; i < triangles.length; i += 3) {\n\t\t\t\tfaces.push(triangles.slice(i, i + 3));\n\t\t\t}\n\n\t\t\treturn faces;\n\t\t}\n\n\t}\n\n\tfunction removeDupEndPts(points) {\n\t\tconst l = points.length;\n\n\t\tif (l > 2 && points[l - 1].equals(points[0])) {\n\t\t\tpoints.pop();\n\t\t}\n\t}\n\n\tfunction addContour(vertices, contour) {\n\t\tfor (let i = 0; i < contour.length; i++) {\n\t\t\tvertices.push(contour[i].x);\n\t\t\tvertices.push(contour[i].y);\n\t\t}\n\t}\n\n\t/**\n\t * Creates extruded geometry from a path shape.\n\t *\n\t * parameters = {\n\t *\n\t *\tcurveSegments: <int>, // number of points on the curves\n\t *\tsteps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n\t *\tdepth: <float>, // Depth to extrude the shape\n\t *\n\t *\tbevelEnabled: <bool>, // turn on bevel\n\t *\tbevelThickness: <float>, // how deep into the original shape bevel goes\n\t *\tbevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n\t *\tbevelOffset: <float>, // how far from shape outline does bevel start\n\t *\tbevelSegments: <int>, // number of bevel layers\n\t *\n\t *\textrudePath: <THREE.Curve> // curve to extrude shape along\n\t *\n\t *\tUVGenerator: <Object> // object that provides UV generator functions\n\t *\n\t * }\n\t */\n\n\tclass ExtrudeGeometry extends BufferGeometry {\n\t\tconstructor(shapes, options) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ExtrudeGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tshapes: shapes,\n\t\t\t\toptions: options\n\t\t\t};\n\t\t\tshapes = Array.isArray(shapes) ? shapes : [shapes];\n\t\t\tconst scope = this;\n\t\t\tconst verticesArray = [];\n\t\t\tconst uvArray = [];\n\n\t\t\tfor (let i = 0, l = shapes.length; i < l; i++) {\n\t\t\t\tconst shape = shapes[i];\n\t\t\t\taddShape(shape);\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));\n\t\t\tthis.computeVertexNormals(); // functions\n\n\t\t\tfunction addShape(shape) {\n\t\t\t\tconst placeholder = []; // options\n\n\t\t\t\tconst curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\t\t\tconst steps = options.steps !== undefined ? options.steps : 1;\n\t\t\t\tlet depth = options.depth !== undefined ? options.depth : 100;\n\t\t\t\tlet bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\t\t\tlet bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;\n\t\t\t\tlet bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;\n\t\t\t\tlet bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n\t\t\t\tlet bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\t\t\t\tconst extrudePath = options.extrudePath;\n\t\t\t\tconst uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options\n\n\t\t\t\tif (options.amount !== undefined) {\n\t\t\t\t\tconsole.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');\n\t\t\t\t\tdepth = options.amount;\n\t\t\t\t} //\n\n\n\t\t\t\tlet extrudePts,\n\t\t\t\t\t\textrudeByPath = false;\n\t\t\t\tlet splineTube, binormal, normal, position2;\n\n\t\t\t\tif (extrudePath) {\n\t\t\t\t\textrudePts = extrudePath.getSpacedPoints(steps);\n\t\t\t\t\textrudeByPath = true;\n\t\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\t\t\t\t\t// SETUP TNB variables\n\t\t\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\t\t\tsplineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\t\t\tbinormal = new Vector3();\n\t\t\t\t\tnormal = new Vector3();\n\t\t\t\t\tposition2 = new Vector3();\n\t\t\t\t} // Safeguards if bevels are not enabled\n\n\n\t\t\t\tif (!bevelEnabled) {\n\t\t\t\t\tbevelSegments = 0;\n\t\t\t\t\tbevelThickness = 0;\n\t\t\t\t\tbevelSize = 0;\n\t\t\t\t\tbevelOffset = 0;\n\t\t\t\t} // Variables initialization\n\n\n\t\t\t\tconst shapePoints = shape.extractPoints(curveSegments);\n\t\t\t\tlet vertices = shapePoints.shape;\n\t\t\t\tconst holes = shapePoints.holes;\n\t\t\t\tconst reverse = !ShapeUtils.isClockWise(vertices);\n\n\t\t\t\tif (reverse) {\n\t\t\t\t\tvertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\t\tconst ahole = holes[h];\n\n\t\t\t\t\t\tif (ShapeUtils.isClockWise(ahole)) {\n\t\t\t\t\t\t\tholes[h] = ahole.reverse();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst faces = ShapeUtils.triangulateShape(vertices, holes);\n\t\t\t\t/* Vertices */\n\n\t\t\t\tconst contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\tconst ahole = holes[h];\n\t\t\t\t\tvertices = vertices.concat(ahole);\n\t\t\t\t}\n\n\t\t\t\tfunction scalePt2(pt, vec, size) {\n\t\t\t\t\tif (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');\n\t\t\t\t\treturn vec.clone().multiplyScalar(size).add(pt);\n\t\t\t\t}\n\n\t\t\t\tconst vlen = vertices.length,\n\t\t\t\t\t\t\tflen = faces.length; // Find directions for point movement\n\n\t\t\t\tfunction getBevelVec(inPt, inPrev, inNext) {\n\t\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t\t//\t shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t\t//\n\t\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t\t//\tadjacent edges of inPt at a distance of 1 unit on the left side.\n\t\t\t\t\tlet v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\t\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\t\t\tconst v_prev_x = inPt.x - inPrev.x,\n\t\t\t\t\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\t\t\tconst v_next_x = inNext.x - inPt.x,\n\t\t\t\t\t\t\t\tv_next_y = inNext.y - inPt.y;\n\t\t\t\t\tconst v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges\n\n\t\t\t\t\tconst collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;\n\n\t\t\t\t\tif (Math.abs(collinear0) > Number.EPSILON) {\n\t\t\t\t\t\t// not collinear\n\t\t\t\t\t\t// length of vectors for normalizing\n\t\t\t\t\t\tconst v_prev_len = Math.sqrt(v_prev_lensq);\n\t\t\t\t\t\tconst v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left\n\n\t\t\t\t\t\tconst ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;\n\t\t\t\t\t\tconst ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;\n\t\t\t\t\t\tconst ptNextShift_x = inNext.x - v_next_y / v_next_len;\n\t\t\t\t\t\tconst ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point\n\n\t\t\t\t\t\tconst sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point\n\n\t\t\t\t\t\tv_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;\n\t\t\t\t\t\tv_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t\t//\tbut prevent crazy spikes\n\n\t\t\t\t\t\tconst v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;\n\n\t\t\t\t\t\tif (v_trans_lensq <= 2) {\n\t\t\t\t\t\t\treturn new Vector2(v_trans_x, v_trans_y);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tshrink_by = Math.sqrt(v_trans_lensq / 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// handle special case of collinear edges\n\t\t\t\t\t\tlet direction_eq = false; // assumes: opposite\n\n\t\t\t\t\t\tif (v_prev_x > Number.EPSILON) {\n\t\t\t\t\t\t\tif (v_next_x > Number.EPSILON) {\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (v_prev_x < -Number.EPSILON) {\n\t\t\t\t\t\t\t\tif (v_next_x < -Number.EPSILON) {\n\t\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (Math.sign(v_prev_y) === Math.sign(v_next_y)) {\n\t\t\t\t\t\t\t\t\tdirection_eq = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (direction_eq) {\n\t\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\t\tv_trans_x = -v_prev_y;\n\t\t\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\t\t\tshrink_by = Math.sqrt(v_prev_lensq);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\t\tshrink_by = Math.sqrt(v_prev_lensq / 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);\n\t\t\t\t}\n\n\t\t\t\tconst contourMovements = [];\n\n\t\t\t\tfor (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n\t\t\t\t\tif (j === il) j = 0;\n\t\t\t\t\tif (k === il) k = 0; //\t(j)---(i)---(k)\n\t\t\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\t\t\tcontourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);\n\t\t\t\t}\n\n\t\t\t\tconst holesMovements = [];\n\t\t\t\tlet oneHoleMovements,\n\t\t\t\t\t\tverticesMovements = contourMovements.concat();\n\n\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\tconst ahole = holes[h];\n\t\t\t\t\toneHoleMovements = [];\n\n\t\t\t\t\tfor (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n\t\t\t\t\t\tif (j === il) j = 0;\n\t\t\t\t\t\tif (k === il) k = 0; //\t(j)---(i)---(k)\n\n\t\t\t\t\t\toneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);\n\t\t\t\t\t}\n\n\t\t\t\t\tholesMovements.push(oneHoleMovements);\n\t\t\t\t\tverticesMovements = verticesMovements.concat(oneHoleMovements);\n\t\t\t\t} // Loop bevelSegments, 1 for the front, 1 for the back\n\n\n\t\t\t\tfor (let b = 0; b < bevelSegments; b++) {\n\t\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\t\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\t\tconst z = bevelThickness * Math.cos(t * Math.PI / 2);\n\t\t\t\t\tconst bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape\n\n\t\t\t\t\tfor (let i = 0, il = contour.length; i < il; i++) {\n\t\t\t\t\t\tconst vert = scalePt2(contour[i], contourMovements[i], bs);\n\t\t\t\t\t\tv(vert.x, vert.y, -z);\n\t\t\t\t\t} // expand holes\n\n\n\t\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\t\tconst ahole = holes[h];\n\t\t\t\t\t\toneHoleMovements = holesMovements[h];\n\n\t\t\t\t\t\tfor (let i = 0, il = ahole.length; i < il; i++) {\n\t\t\t\t\t\t\tconst vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n\t\t\t\t\t\t\tv(vert.x, vert.y, -z);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst bs = bevelSize + bevelOffset; // Back facing vertices\n\n\t\t\t\tfor (let i = 0; i < vlen; i++) {\n\t\t\t\t\tconst vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n\n\t\t\t\t\tif (!extrudeByPath) {\n\t\t\t\t\t\tv(vert.x, vert.y, 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\t\t\t\t\t\tnormal.copy(splineTube.normals[0]).multiplyScalar(vert.x);\n\t\t\t\t\t\tbinormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);\n\t\t\t\t\t\tposition2.copy(extrudePts[0]).add(normal).add(binormal);\n\t\t\t\t\t\tv(position2.x, position2.y, position2.z);\n\t\t\t\t\t}\n\t\t\t\t} // Add stepped vertices...\n\t\t\t\t// Including front facing vertices\n\n\n\t\t\t\tfor (let s = 1; s <= steps; s++) {\n\t\t\t\t\tfor (let i = 0; i < vlen; i++) {\n\t\t\t\t\t\tconst vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n\n\t\t\t\t\t\tif (!extrudeByPath) {\n\t\t\t\t\t\t\tv(vert.x, vert.y, depth / steps * s);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\t\t\t\t\t\t\tnormal.copy(splineTube.normals[s]).multiplyScalar(vert.x);\n\t\t\t\t\t\t\tbinormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);\n\t\t\t\t\t\t\tposition2.copy(extrudePts[s]).add(normal).add(binormal);\n\t\t\t\t\t\t\tv(position2.x, position2.y, position2.z);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // Add bevel segments planes\n\t\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\n\n\t\t\t\tfor (let b = bevelSegments - 1; b >= 0; b--) {\n\t\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\t\tconst z = bevelThickness * Math.cos(t * Math.PI / 2);\n\t\t\t\t\tconst bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape\n\n\t\t\t\t\tfor (let i = 0, il = contour.length; i < il; i++) {\n\t\t\t\t\t\tconst vert = scalePt2(contour[i], contourMovements[i], bs);\n\t\t\t\t\t\tv(vert.x, vert.y, depth + z);\n\t\t\t\t\t} // expand holes\n\n\n\t\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\t\tconst ahole = holes[h];\n\t\t\t\t\t\toneHoleMovements = holesMovements[h];\n\n\t\t\t\t\t\tfor (let i = 0, il = ahole.length; i < il; i++) {\n\t\t\t\t\t\t\tconst vert = scalePt2(ahole[i], oneHoleMovements[i], bs);\n\n\t\t\t\t\t\t\tif (!extrudeByPath) {\n\t\t\t\t\t\t\t\tv(vert.x, vert.y, depth + z);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tv(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Faces */\n\t\t\t\t// Top and bottom faces\n\n\n\t\t\t\tbuildLidFaces(); // Sides faces\n\n\t\t\t\tbuildSideFaces(); /////\tInternal functions\n\n\t\t\t\tfunction buildLidFaces() {\n\t\t\t\t\tconst start = verticesArray.length / 3;\n\n\t\t\t\t\tif (bevelEnabled) {\n\t\t\t\t\t\tlet layer = 0; // steps + 1\n\n\t\t\t\t\t\tlet offset = vlen * layer; // Bottom faces\n\n\t\t\t\t\t\tfor (let i = 0; i < flen; i++) {\n\t\t\t\t\t\t\tconst face = faces[i];\n\t\t\t\t\t\t\tf3(face[2] + offset, face[1] + offset, face[0] + offset);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\t\toffset = vlen * layer; // Top faces\n\n\t\t\t\t\t\tfor (let i = 0; i < flen; i++) {\n\t\t\t\t\t\t\tconst face = faces[i];\n\t\t\t\t\t\t\tf3(face[0] + offset, face[1] + offset, face[2] + offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Bottom faces\n\t\t\t\t\t\tfor (let i = 0; i < flen; i++) {\n\t\t\t\t\t\t\tconst face = faces[i];\n\t\t\t\t\t\t\tf3(face[2], face[1], face[0]);\n\t\t\t\t\t\t} // Top faces\n\n\n\t\t\t\t\t\tfor (let i = 0; i < flen; i++) {\n\t\t\t\t\t\t\tconst face = faces[i];\n\t\t\t\t\t\t\tf3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addGroup(start, verticesArray.length / 3 - start, 0);\n\t\t\t\t} // Create faces for the z-sides of the shape\n\n\n\t\t\t\tfunction buildSideFaces() {\n\t\t\t\t\tconst start = verticesArray.length / 3;\n\t\t\t\t\tlet layeroffset = 0;\n\t\t\t\t\tsidewalls(contour, layeroffset);\n\t\t\t\t\tlayeroffset += contour.length;\n\n\t\t\t\t\tfor (let h = 0, hl = holes.length; h < hl; h++) {\n\t\t\t\t\t\tconst ahole = holes[h];\n\t\t\t\t\t\tsidewalls(ahole, layeroffset); //, true\n\n\t\t\t\t\t\tlayeroffset += ahole.length;\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.addGroup(start, verticesArray.length / 3 - start, 1);\n\t\t\t\t}\n\n\t\t\t\tfunction sidewalls(contour, layeroffset) {\n\t\t\t\t\tlet i = contour.length;\n\n\t\t\t\t\twhile (--i >= 0) {\n\t\t\t\t\t\tconst j = i;\n\t\t\t\t\t\tlet k = i - 1;\n\t\t\t\t\t\tif (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\t\t\tfor (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {\n\t\t\t\t\t\t\tconst slen1 = vlen * s;\n\t\t\t\t\t\t\tconst slen2 = vlen * (s + 1);\n\t\t\t\t\t\t\tconst a = layeroffset + j + slen1,\n\t\t\t\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\t\t\t\t\t\t\tf4(a, b, c, d);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction v(x, y, z) {\n\t\t\t\t\tplaceholder.push(x);\n\t\t\t\t\tplaceholder.push(y);\n\t\t\t\t\tplaceholder.push(z);\n\t\t\t\t}\n\n\t\t\t\tfunction f3(a, b, c) {\n\t\t\t\t\taddVertex(a);\n\t\t\t\t\taddVertex(b);\n\t\t\t\t\taddVertex(c);\n\t\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\t\tconst uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n\t\t\t\t\taddUV(uvs[0]);\n\t\t\t\t\taddUV(uvs[1]);\n\t\t\t\t\taddUV(uvs[2]);\n\t\t\t\t}\n\n\t\t\t\tfunction f4(a, b, c, d) {\n\t\t\t\t\taddVertex(a);\n\t\t\t\t\taddVertex(b);\n\t\t\t\t\taddVertex(d);\n\t\t\t\t\taddVertex(b);\n\t\t\t\t\taddVertex(c);\n\t\t\t\t\taddVertex(d);\n\t\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\t\tconst uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n\t\t\t\t\taddUV(uvs[0]);\n\t\t\t\t\taddUV(uvs[1]);\n\t\t\t\t\taddUV(uvs[3]);\n\t\t\t\t\taddUV(uvs[1]);\n\t\t\t\t\taddUV(uvs[2]);\n\t\t\t\t\taddUV(uvs[3]);\n\t\t\t\t}\n\n\t\t\t\tfunction addVertex(index) {\n\t\t\t\t\tverticesArray.push(placeholder[index * 3 + 0]);\n\t\t\t\t\tverticesArray.push(placeholder[index * 3 + 1]);\n\t\t\t\t\tverticesArray.push(placeholder[index * 3 + 2]);\n\t\t\t\t}\n\n\t\t\t\tfunction addUV(vector2) {\n\t\t\t\t\tuvArray.push(vector2.x);\n\t\t\t\t\tuvArray.push(vector2.y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tconst shapes = this.parameters.shapes;\n\t\t\tconst options = this.parameters.options;\n\t\t\treturn toJSON$1(shapes, options, data);\n\t\t}\n\n\t}\n\n\tconst WorldUVGenerator = {\n\t\tgenerateTopUV: function (geometry, vertices, indexA, indexB, indexC) {\n\t\t\tconst a_x = vertices[indexA * 3];\n\t\t\tconst a_y = vertices[indexA * 3 + 1];\n\t\t\tconst b_x = vertices[indexB * 3];\n\t\t\tconst b_y = vertices[indexB * 3 + 1];\n\t\t\tconst c_x = vertices[indexC * 3];\n\t\t\tconst c_y = vertices[indexC * 3 + 1];\n\t\t\treturn [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];\n\t\t},\n\t\tgenerateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {\n\t\t\tconst a_x = vertices[indexA * 3];\n\t\t\tconst a_y = vertices[indexA * 3 + 1];\n\t\t\tconst a_z = vertices[indexA * 3 + 2];\n\t\t\tconst b_x = vertices[indexB * 3];\n\t\t\tconst b_y = vertices[indexB * 3 + 1];\n\t\t\tconst b_z = vertices[indexB * 3 + 2];\n\t\t\tconst c_x = vertices[indexC * 3];\n\t\t\tconst c_y = vertices[indexC * 3 + 1];\n\t\t\tconst c_z = vertices[indexC * 3 + 2];\n\t\t\tconst d_x = vertices[indexD * 3];\n\t\t\tconst d_y = vertices[indexD * 3 + 1];\n\t\t\tconst d_z = vertices[indexD * 3 + 2];\n\n\t\t\tif (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {\n\t\t\t\treturn [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];\n\t\t\t} else {\n\t\t\t\treturn [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction toJSON$1(shapes, options, data) {\n\t\tdata.shapes = [];\n\n\t\tif (Array.isArray(shapes)) {\n\t\t\tfor (let i = 0, l = shapes.length; i < l; i++) {\n\t\t\t\tconst shape = shapes[i];\n\t\t\t\tdata.shapes.push(shape.uuid);\n\t\t\t}\n\t\t} else {\n\t\t\tdata.shapes.push(shapes.uuid);\n\t\t}\n\n\t\tif (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();\n\t\treturn data;\n\t}\n\n\tclass IcosahedronGeometry extends PolyhedronGeometry {\n\t\tconstructor(radius = 1, detail = 0) {\n\t\t\tconst t = (1 + Math.sqrt(5)) / 2;\n\t\t\tconst vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];\n\t\t\tconst indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];\n\t\t\tsuper(vertices, indices, radius, detail);\n\t\t\tthis.type = 'IcosahedronGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\t}\n\n\t}\n\n\tclass LatheGeometry extends BufferGeometry {\n\t\tconstructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'LatheGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tpoints: points,\n\t\t\t\tsegments: segments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength\n\t\t\t};\n\t\t\tsegments = Math.floor(segments); // clamp phiLength so it's in range of [ 0, 2PI ]\n\n\t\t\tphiLength = clamp(phiLength, 0, Math.PI * 2); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tconst inverseSegments = 1.0 / segments;\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst uv = new Vector2(); // generate vertices and uvs\n\n\t\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\t\tconst phi = phiStart + i * inverseSegments * phiLength;\n\t\t\t\tconst sin = Math.sin(phi);\n\t\t\t\tconst cos = Math.cos(phi);\n\n\t\t\t\tfor (let j = 0; j <= points.length - 1; j++) {\n\t\t\t\t\t// vertex\n\t\t\t\t\tvertex.x = points[j].x * sin;\n\t\t\t\t\tvertex.y = points[j].y;\n\t\t\t\t\tvertex.z = points[j].x * cos;\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // uv\n\n\t\t\t\t\tuv.x = i / segments;\n\t\t\t\t\tuv.y = j / (points.length - 1);\n\t\t\t\t\tuvs.push(uv.x, uv.y);\n\t\t\t\t}\n\t\t\t} // indices\n\n\n\t\t\tfor (let i = 0; i < segments; i++) {\n\t\t\t\tfor (let j = 0; j < points.length - 1; j++) {\n\t\t\t\t\tconst base = j + i * points.length;\n\t\t\t\t\tconst a = base;\n\t\t\t\t\tconst b = base + points.length;\n\t\t\t\t\tconst c = base + points.length + 1;\n\t\t\t\t\tconst d = base + 1; // faces\n\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals\n\n\t\t\tthis.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.\n\t\t\t// because the corresponding vertices are identical (but still have different UVs).\n\n\t\t\tif (phiLength === Math.PI * 2) {\n\t\t\t\tconst normals = this.attributes.normal.array;\n\t\t\t\tconst n1 = new Vector3();\n\t\t\t\tconst n2 = new Vector3();\n\t\t\t\tconst n = new Vector3(); // this is the buffer offset for the last line of vertices\n\n\t\t\t\tconst base = segments * points.length * 3;\n\n\t\t\t\tfor (let i = 0, j = 0; i < points.length; i++, j += 3) {\n\t\t\t\t\t// select the normal of the vertex in the first line\n\t\t\t\t\tn1.x = normals[j + 0];\n\t\t\t\t\tn1.y = normals[j + 1];\n\t\t\t\t\tn1.z = normals[j + 2]; // select the normal of the vertex in the last line\n\n\t\t\t\t\tn2.x = normals[base + j + 0];\n\t\t\t\t\tn2.y = normals[base + j + 1];\n\t\t\t\t\tn2.z = normals[base + j + 2]; // average normals\n\n\t\t\t\t\tn.addVectors(n1, n2).normalize(); // assign the new values to both normals\n\n\t\t\t\t\tnormals[j + 0] = normals[base + j + 0] = n.x;\n\t\t\t\t\tnormals[j + 1] = normals[base + j + 1] = n.y;\n\t\t\t\t\tnormals[j + 2] = normals[base + j + 2] = n.z;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass OctahedronGeometry extends PolyhedronGeometry {\n\t\tconstructor(radius = 1, detail = 0) {\n\t\t\tconst vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];\n\t\t\tconst indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];\n\t\t\tsuper(vertices, indices, radius, detail);\n\t\t\tthis.type = 'OctahedronGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\t}\n\n\t}\n\n\t/**\n\t * Parametric Surfaces Geometry\n\t * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html\n\t */\n\n\tclass ParametricGeometry extends BufferGeometry {\n\t\tconstructor(func, slices, stacks) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ParametricGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tfunc: func,\n\t\t\t\tslices: slices,\n\t\t\t\tstacks: stacks\n\t\t\t}; // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = [];\n\t\t\tconst EPS = 0.00001;\n\t\t\tconst normal = new Vector3();\n\t\t\tconst p0 = new Vector3(),\n\t\t\t\t\t\tp1 = new Vector3();\n\t\t\tconst pu = new Vector3(),\n\t\t\t\t\t\tpv = new Vector3();\n\n\t\t\tif (func.length < 3) {\n\t\t\t\tconsole.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');\n\t\t\t} // generate vertices, normals and uvs\n\n\n\t\t\tconst sliceCount = slices + 1;\n\n\t\t\tfor (let i = 0; i <= stacks; i++) {\n\t\t\t\tconst v = i / stacks;\n\n\t\t\t\tfor (let j = 0; j <= slices; j++) {\n\t\t\t\t\tconst u = j / slices; // vertex\n\n\t\t\t\t\tfunc(u, v, p0);\n\t\t\t\t\tvertices.push(p0.x, p0.y, p0.z); // normal\n\t\t\t\t\t// approximate tangent vectors via finite differences\n\n\t\t\t\t\tif (u - EPS >= 0) {\n\t\t\t\t\t\tfunc(u - EPS, v, p1);\n\t\t\t\t\t\tpu.subVectors(p0, p1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfunc(u + EPS, v, p1);\n\t\t\t\t\t\tpu.subVectors(p1, p0);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (v - EPS >= 0) {\n\t\t\t\t\t\tfunc(u, v - EPS, p1);\n\t\t\t\t\t\tpv.subVectors(p0, p1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfunc(u, v + EPS, p1);\n\t\t\t\t\t\tpv.subVectors(p1, p0);\n\t\t\t\t\t} // cross product of tangent vectors returns surface normal\n\n\n\t\t\t\t\tnormal.crossVectors(pu, pv).normalize();\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // uv\n\n\t\t\t\t\tuvs.push(u, v);\n\t\t\t\t}\n\t\t\t} // generate indices\n\n\n\t\t\tfor (let i = 0; i < stacks; i++) {\n\t\t\t\tfor (let j = 0; j < slices; j++) {\n\t\t\t\t\tconst a = i * sliceCount + j;\n\t\t\t\t\tconst b = i * sliceCount + j + 1;\n\t\t\t\t\tconst c = (i + 1) * sliceCount + j + 1;\n\t\t\t\t\tconst d = (i + 1) * sliceCount + j; // faces one and two\n\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tclass RingGeometry extends BufferGeometry {\n\t\tconstructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'RingGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tinnerRadius: innerRadius,\n\t\t\t\touterRadius: outerRadius,\n\t\t\t\tthetaSegments: thetaSegments,\n\t\t\t\tphiSegments: phiSegments,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\t\tthetaSegments = Math.max(3, thetaSegments);\n\t\t\tphiSegments = Math.max(1, phiSegments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // some helper variables\n\n\t\t\tlet radius = innerRadius;\n\t\t\tconst radiusStep = (outerRadius - innerRadius) / phiSegments;\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst uv = new Vector2(); // generate vertices, normals and uvs\n\n\t\t\tfor (let j = 0; j <= phiSegments; j++) {\n\t\t\t\tfor (let i = 0; i <= thetaSegments; i++) {\n\t\t\t\t\t// values are generate from the inside of the ring to the outside\n\t\t\t\t\tconst segment = thetaStart + i / thetaSegments * thetaLength; // vertex\n\n\t\t\t\t\tvertex.x = radius * Math.cos(segment);\n\t\t\t\t\tvertex.y = radius * Math.sin(segment);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\t\tnormals.push(0, 0, 1); // uv\n\n\t\t\t\t\tuv.x = (vertex.x / outerRadius + 1) / 2;\n\t\t\t\t\tuv.y = (vertex.y / outerRadius + 1) / 2;\n\t\t\t\t\tuvs.push(uv.x, uv.y);\n\t\t\t\t} // increase the radius for next row of vertices\n\n\n\t\t\t\tradius += radiusStep;\n\t\t\t} // indices\n\n\n\t\t\tfor (let j = 0; j < phiSegments; j++) {\n\t\t\t\tconst thetaSegmentLevel = j * (thetaSegments + 1);\n\n\t\t\t\tfor (let i = 0; i < thetaSegments; i++) {\n\t\t\t\t\tconst segment = i + thetaSegmentLevel;\n\t\t\t\t\tconst a = segment;\n\t\t\t\t\tconst b = segment + thetaSegments + 1;\n\t\t\t\t\tconst c = segment + thetaSegments + 2;\n\t\t\t\t\tconst d = segment + 1; // faces\n\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tclass ShapeGeometry extends BufferGeometry {\n\t\tconstructor(shapes, curveSegments = 12) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ShapeGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tshapes: shapes,\n\t\t\t\tcurveSegments: curveSegments\n\t\t\t}; // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tlet groupStart = 0;\n\t\t\tlet groupCount = 0; // allow single and array values for \"shapes\" parameter\n\n\t\t\tif (Array.isArray(shapes) === false) {\n\t\t\t\taddShape(shapes);\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\t\t\taddShape(shapes[i]);\n\t\t\t\t\tthis.addGroup(groupStart, groupCount, i); // enables MultiMaterial support\n\n\t\t\t\t\tgroupStart += groupCount;\n\t\t\t\t\tgroupCount = 0;\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions\n\n\t\t\tfunction addShape(shape) {\n\t\t\t\tconst indexOffset = vertices.length / 3;\n\t\t\t\tconst points = shape.extractPoints(curveSegments);\n\t\t\t\tlet shapeVertices = points.shape;\n\t\t\t\tconst shapeHoles = points.holes; // check direction of vertices\n\n\t\t\t\tif (ShapeUtils.isClockWise(shapeVertices) === false) {\n\t\t\t\t\tshapeVertices = shapeVertices.reverse();\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0, l = shapeHoles.length; i < l; i++) {\n\t\t\t\t\tconst shapeHole = shapeHoles[i];\n\n\t\t\t\t\tif (ShapeUtils.isClockWise(shapeHole) === true) {\n\t\t\t\t\t\tshapeHoles[i] = shapeHole.reverse();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array\n\n\t\t\t\tfor (let i = 0, l = shapeHoles.length; i < l; i++) {\n\t\t\t\t\tconst shapeHole = shapeHoles[i];\n\t\t\t\t\tshapeVertices = shapeVertices.concat(shapeHole);\n\t\t\t\t} // vertices, normals, uvs\n\n\n\t\t\t\tfor (let i = 0, l = shapeVertices.length; i < l; i++) {\n\t\t\t\t\tconst vertex = shapeVertices[i];\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, 0);\n\t\t\t\t\tnormals.push(0, 0, 1);\n\t\t\t\t\tuvs.push(vertex.x, vertex.y); // world uvs\n\t\t\t\t} // incides\n\n\n\t\t\t\tfor (let i = 0, l = faces.length; i < l; i++) {\n\t\t\t\t\tconst face = faces[i];\n\t\t\t\t\tconst a = face[0] + indexOffset;\n\t\t\t\t\tconst b = face[1] + indexOffset;\n\t\t\t\t\tconst c = face[2] + indexOffset;\n\t\t\t\t\tindices.push(a, b, c);\n\t\t\t\t\tgroupCount += 3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tconst shapes = this.parameters.shapes;\n\t\t\treturn toJSON(shapes, data);\n\t\t}\n\n\t}\n\n\tfunction toJSON(shapes, data) {\n\t\tdata.shapes = [];\n\n\t\tif (Array.isArray(shapes)) {\n\t\t\tfor (let i = 0, l = shapes.length; i < l; i++) {\n\t\t\t\tconst shape = shapes[i];\n\t\t\t\tdata.shapes.push(shape.uuid);\n\t\t\t}\n\t\t} else {\n\t\t\tdata.shapes.push(shapes.uuid);\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tclass SphereGeometry extends BufferGeometry {\n\t\tconstructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {\n\t\t\tsuper();\n\t\t\tthis.type = 'SphereGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\twidthSegments: widthSegments,\n\t\t\t\theightSegments: heightSegments,\n\t\t\t\tphiStart: phiStart,\n\t\t\t\tphiLength: phiLength,\n\t\t\t\tthetaStart: thetaStart,\n\t\t\t\tthetaLength: thetaLength\n\t\t\t};\n\t\t\twidthSegments = Math.max(3, Math.floor(widthSegments));\n\t\t\theightSegments = Math.max(2, Math.floor(heightSegments));\n\t\t\tconst thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n\t\t\tlet index = 0;\n\t\t\tconst grid = [];\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst normal = new Vector3(); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // generate vertices, normals and uvs\n\n\t\t\tfor (let iy = 0; iy <= heightSegments; iy++) {\n\t\t\t\tconst verticesRow = [];\n\t\t\t\tconst v = iy / heightSegments; // special case for the poles\n\n\t\t\t\tlet uOffset = 0;\n\n\t\t\t\tif (iy == 0 && thetaStart == 0) {\n\t\t\t\t\tuOffset = 0.5 / widthSegments;\n\t\t\t\t} else if (iy == heightSegments && thetaEnd == Math.PI) {\n\t\t\t\t\tuOffset = -0.5 / widthSegments;\n\t\t\t\t}\n\n\t\t\t\tfor (let ix = 0; ix <= widthSegments; ix++) {\n\t\t\t\t\tconst u = ix / widthSegments; // vertex\n\n\t\t\t\t\tvertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n\t\t\t\t\tvertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n\t\t\t\t\tvertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\t\tnormal.copy(vertex).normalize();\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // uv\n\n\t\t\t\t\tuvs.push(u + uOffset, 1 - v);\n\t\t\t\t\tverticesRow.push(index++);\n\t\t\t\t}\n\n\t\t\t\tgrid.push(verticesRow);\n\t\t\t} // indices\n\n\n\t\t\tfor (let iy = 0; iy < heightSegments; iy++) {\n\t\t\t\tfor (let ix = 0; ix < widthSegments; ix++) {\n\t\t\t\t\tconst a = grid[iy][ix + 1];\n\t\t\t\t\tconst b = grid[iy][ix];\n\t\t\t\t\tconst c = grid[iy + 1][ix];\n\t\t\t\t\tconst d = grid[iy + 1][ix + 1];\n\t\t\t\t\tif (iy !== 0 || thetaStart > 0) indices.push(a, b, d);\n\t\t\t\t\tif (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tclass TetrahedronGeometry extends PolyhedronGeometry {\n\t\tconstructor(radius = 1, detail = 0) {\n\t\t\tconst vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];\n\t\t\tconst indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];\n\t\t\tsuper(vertices, indices, radius, detail);\n\t\t\tthis.type = 'TetrahedronGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\tdetail: detail\n\t\t\t};\n\t\t}\n\n\t}\n\n\t/**\n\t * Text = 3D Text\n\t *\n\t * parameters = {\n\t *\tfont: <THREE.Font>, // font\n\t *\n\t *\tsize: <float>, // size of the text\n\t *\theight: <float>, // thickness to extrude text\n\t *\tcurveSegments: <int>, // number of points on the curves\n\t *\n\t *\tbevelEnabled: <bool>, // turn on bevel\n\t *\tbevelThickness: <float>, // how deep into text bevel goes\n\t *\tbevelSize: <float>, // how far from text outline (including bevelOffset) is bevel\n\t *\tbevelOffset: <float> // how far from text outline does bevel start\n\t * }\n\t */\n\n\tclass TextGeometry extends ExtrudeGeometry {\n\t\tconstructor(text, parameters = {}) {\n\t\t\tconst font = parameters.font;\n\n\t\t\tif (!(font && font.isFont)) {\n\t\t\t\tconsole.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');\n\t\t\t\treturn new BufferGeometry();\n\t\t\t}\n\n\t\t\tconst shapes = font.generateShapes(text, parameters.size); // translate parameters to ExtrudeGeometry API\n\n\t\t\tparameters.depth = parameters.height !== undefined ? parameters.height : 50; // defaults\n\n\t\t\tif (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;\n\t\t\tif (parameters.bevelSize === undefined) parameters.bevelSize = 8;\n\t\t\tif (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;\n\t\t\tsuper(shapes, parameters);\n\t\t\tthis.type = 'TextGeometry';\n\t\t}\n\n\t}\n\n\tclass TorusGeometry extends BufferGeometry {\n\t\tconstructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'TorusGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tarc: arc\n\t\t\t};\n\t\t\tradialSegments = Math.floor(radialSegments);\n\t\t\ttubularSegments = Math.floor(tubularSegments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tconst center = new Vector3();\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst normal = new Vector3(); // generate vertices, normals and uvs\n\n\t\t\tfor (let j = 0; j <= radialSegments; j++) {\n\t\t\t\tfor (let i = 0; i <= tubularSegments; i++) {\n\t\t\t\t\tconst u = i / tubularSegments * arc;\n\t\t\t\t\tconst v = j / radialSegments * Math.PI * 2; // vertex\n\n\t\t\t\t\tvertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);\n\t\t\t\t\tvertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);\n\t\t\t\t\tvertex.z = tube * Math.sin(v);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal\n\n\t\t\t\t\tcenter.x = radius * Math.cos(u);\n\t\t\t\t\tcenter.y = radius * Math.sin(u);\n\t\t\t\t\tnormal.subVectors(vertex, center).normalize();\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // uv\n\n\t\t\t\t\tuvs.push(i / tubularSegments);\n\t\t\t\t\tuvs.push(j / radialSegments);\n\t\t\t\t}\n\t\t\t} // generate indices\n\n\n\t\t\tfor (let j = 1; j <= radialSegments; j++) {\n\t\t\t\tfor (let i = 1; i <= tubularSegments; i++) {\n\t\t\t\t\t// indices\n\t\t\t\t\tconst a = (tubularSegments + 1) * j + i - 1;\n\t\t\t\t\tconst b = (tubularSegments + 1) * (j - 1) + i - 1;\n\t\t\t\t\tconst c = (tubularSegments + 1) * (j - 1) + i;\n\t\t\t\t\tconst d = (tubularSegments + 1) * j + i; // faces\n\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2));\n\t\t}\n\n\t}\n\n\tclass TorusKnotGeometry extends BufferGeometry {\n\t\tconstructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {\n\t\t\tsuper();\n\t\t\tthis.type = 'TorusKnotGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tradius: radius,\n\t\t\t\ttube: tube,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tp: p,\n\t\t\t\tq: q\n\t\t\t};\n\t\t\ttubularSegments = Math.floor(tubularSegments);\n\t\t\tradialSegments = Math.floor(radialSegments); // buffers\n\n\t\t\tconst indices = [];\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = []; // helper variables\n\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst normal = new Vector3();\n\t\t\tconst P1 = new Vector3();\n\t\t\tconst P2 = new Vector3();\n\t\t\tconst B = new Vector3();\n\t\t\tconst T = new Vector3();\n\t\t\tconst N = new Vector3(); // generate vertices, normals and uvs\n\n\t\t\tfor (let i = 0; i <= tubularSegments; ++i) {\n\t\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\n\t\t\t\tconst u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\t\tcalculatePositionOnCurve(u, p, q, radius, P1);\n\t\t\t\tcalculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis\n\n\t\t\t\tT.subVectors(P2, P1);\n\t\t\t\tN.addVectors(P2, P1);\n\t\t\t\tB.crossVectors(T, N);\n\t\t\t\tN.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it\n\n\t\t\t\tB.normalize();\n\t\t\t\tN.normalize();\n\n\t\t\t\tfor (let j = 0; j <= radialSegments; ++j) {\n\t\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\t\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\t\tconst cx = -tube * Math.cos(v);\n\t\t\t\t\tconst cy = tube * Math.sin(v); // now calculate the final vertex position.\n\t\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\n\n\t\t\t\t\tvertex.x = P1.x + (cx * N.x + cy * B.x);\n\t\t\t\t\tvertex.y = P1.y + (cx * N.y + cy * B.y);\n\t\t\t\t\tvertex.z = P1.z + (cx * N.z + cy * B.z);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\t\t\tnormal.subVectors(vertex, P1).normalize();\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // uv\n\n\t\t\t\t\tuvs.push(i / tubularSegments);\n\t\t\t\t\tuvs.push(j / radialSegments);\n\t\t\t\t}\n\t\t\t} // generate indices\n\n\n\t\t\tfor (let j = 1; j <= tubularSegments; j++) {\n\t\t\t\tfor (let i = 1; i <= radialSegments; i++) {\n\t\t\t\t\t// indices\n\t\t\t\t\tconst a = (radialSegments + 1) * (j - 1) + (i - 1);\n\t\t\t\t\tconst b = (radialSegments + 1) * j + (i - 1);\n\t\t\t\t\tconst c = (radialSegments + 1) * j + i;\n\t\t\t\t\tconst d = (radialSegments + 1) * (j - 1) + i; // faces\n\n\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve\n\n\t\t\tfunction calculatePositionOnCurve(u, p, q, radius, position) {\n\t\t\t\tconst cu = Math.cos(u);\n\t\t\t\tconst su = Math.sin(u);\n\t\t\t\tconst quOverP = q / p * u;\n\t\t\t\tconst cs = Math.cos(quOverP);\n\t\t\t\tposition.x = radius * (2 + cs) * 0.5 * cu;\n\t\t\t\tposition.y = radius * (2 + cs) * su * 0.5;\n\t\t\t\tposition.z = radius * Math.sin(quOverP) * 0.5;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass TubeGeometry extends BufferGeometry {\n\t\tconstructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {\n\t\t\tsuper();\n\t\t\tthis.type = 'TubeGeometry';\n\t\t\tthis.parameters = {\n\t\t\t\tpath: path,\n\t\t\t\ttubularSegments: tubularSegments,\n\t\t\t\tradius: radius,\n\t\t\t\tradialSegments: radialSegments,\n\t\t\t\tclosed: closed\n\t\t\t};\n\t\t\tconst frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals\n\n\t\t\tthis.tangents = frames.tangents;\n\t\t\tthis.normals = frames.normals;\n\t\t\tthis.binormals = frames.binormals; // helper variables\n\n\t\t\tconst vertex = new Vector3();\n\t\t\tconst normal = new Vector3();\n\t\t\tconst uv = new Vector2();\n\t\t\tlet P = new Vector3(); // buffer\n\n\t\t\tconst vertices = [];\n\t\t\tconst normals = [];\n\t\t\tconst uvs = [];\n\t\t\tconst indices = []; // create buffer data\n\n\t\t\tgenerateBufferData(); // build geometry\n\n\t\t\tthis.setIndex(indices);\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tthis.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n\t\t\tthis.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions\n\n\t\t\tfunction generateBufferData() {\n\t\t\t\tfor (let i = 0; i < tubularSegments; i++) {\n\t\t\t\t\tgenerateSegment(i);\n\t\t\t\t} // if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t\t// at the regular position on the given path\n\t\t\t\t//\n\t\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\n\t\t\t\tgenerateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.\n\t\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\t\tgenerateUVs(); // finally create faces\n\n\t\t\t\tgenerateIndices();\n\t\t\t}\n\n\t\t\tfunction generateSegment(i) {\n\t\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\t\t\t\tP = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal\n\n\t\t\t\tconst N = frames.normals[i];\n\t\t\t\tconst B = frames.binormals[i]; // generate normals and vertices for the current segment\n\n\t\t\t\tfor (let j = 0; j <= radialSegments; j++) {\n\t\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\t\tconst sin = Math.sin(v);\n\t\t\t\t\tconst cos = -Math.cos(v); // normal\n\n\t\t\t\t\tnormal.x = cos * N.x + sin * B.x;\n\t\t\t\t\tnormal.y = cos * N.y + sin * B.y;\n\t\t\t\t\tnormal.z = cos * N.z + sin * B.z;\n\t\t\t\t\tnormal.normalize();\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z); // vertex\n\n\t\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\t\tvertex.z = P.z + radius * normal.z;\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction generateIndices() {\n\t\t\t\tfor (let j = 1; j <= tubularSegments; j++) {\n\t\t\t\t\tfor (let i = 1; i <= radialSegments; i++) {\n\t\t\t\t\t\tconst a = (radialSegments + 1) * (j - 1) + (i - 1);\n\t\t\t\t\t\tconst b = (radialSegments + 1) * j + (i - 1);\n\t\t\t\t\t\tconst c = (radialSegments + 1) * j + i;\n\t\t\t\t\t\tconst d = (radialSegments + 1) * (j - 1) + i; // faces\n\n\t\t\t\t\t\tindices.push(a, b, d);\n\t\t\t\t\t\tindices.push(b, c, d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction generateUVs() {\n\t\t\t\tfor (let i = 0; i <= tubularSegments; i++) {\n\t\t\t\t\tfor (let j = 0; j <= radialSegments; j++) {\n\t\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\t\tuv.y = j / radialSegments;\n\t\t\t\t\t\tuvs.push(uv.x, uv.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.path = this.parameters.path.toJSON();\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tclass WireframeGeometry extends BufferGeometry {\n\t\tconstructor(geometry) {\n\t\t\tsuper();\n\t\t\tthis.type = 'WireframeGeometry';\n\n\t\t\tif (geometry.isGeometry === true) {\n\t\t\t\tconsole.error('THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');\n\t\t\t\treturn;\n\t\t\t} // buffer\n\n\n\t\t\tconst vertices = []; // helper variables\n\n\t\t\tconst edge = [0, 0],\n\t\t\t\t\t\tedges = {};\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tif (geometry.index !== null) {\n\t\t\t\t// indexed BufferGeometry\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tconst indices = geometry.index;\n\t\t\t\tlet groups = geometry.groups;\n\n\t\t\t\tif (groups.length === 0) {\n\t\t\t\t\tgroups = [{\n\t\t\t\t\t\tstart: 0,\n\t\t\t\t\t\tcount: indices.count,\n\t\t\t\t\t\tmaterialIndex: 0\n\t\t\t\t\t}];\n\t\t\t\t} // create a data structure that contains all eges without duplicates\n\n\n\t\t\t\tfor (let o = 0, ol = groups.length; o < ol; ++o) {\n\t\t\t\t\tconst group = groups[o];\n\t\t\t\t\tconst start = group.start;\n\t\t\t\t\tconst count = group.count;\n\n\t\t\t\t\tfor (let i = start, l = start + count; i < l; i += 3) {\n\t\t\t\t\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t\t\t\t\tconst edge1 = indices.getX(i + j);\n\t\t\t\t\t\t\tconst edge2 = indices.getX(i + (j + 1) % 3);\n\t\t\t\t\t\t\tedge[0] = Math.min(edge1, edge2); // sorting prevents duplicates\n\n\t\t\t\t\t\t\tedge[1] = Math.max(edge1, edge2);\n\t\t\t\t\t\t\tconst key = edge[0] + ',' + edge[1];\n\n\t\t\t\t\t\t\tif (edges[key] === undefined) {\n\t\t\t\t\t\t\t\tedges[key] = {\n\t\t\t\t\t\t\t\t\tindex1: edge[0],\n\t\t\t\t\t\t\t\t\tindex2: edge[1]\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // generate vertices\n\n\n\t\t\t\tfor (const key in edges) {\n\t\t\t\t\tconst e = edges[key];\n\t\t\t\t\tvertex.fromBufferAttribute(position, e.index1);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\t\t\t\t\tvertex.fromBufferAttribute(position, e.index2);\n\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// non-indexed BufferGeometry\n\t\t\t\tconst position = geometry.attributes.position;\n\n\t\t\t\tfor (let i = 0, l = position.count / 3; i < l; i++) {\n\t\t\t\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\t\t\t\t\t\tconst index1 = 3 * i + j;\n\t\t\t\t\t\tvertex.fromBufferAttribute(position, index1);\n\t\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\t\t\t\t\t\tconst index2 = 3 * i + (j + 1) % 3;\n\t\t\t\t\t\tvertex.fromBufferAttribute(position, index2);\n\t\t\t\t\t\tvertices.push(vertex.x, vertex.y, vertex.z);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // build geometry\n\n\n\t\t\tthis.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t}\n\n\t}\n\n\tvar Geometries = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tBoxGeometry: BoxGeometry,\n\t\tBoxBufferGeometry: BoxGeometry,\n\t\tCircleGeometry: CircleGeometry,\n\t\tCircleBufferGeometry: CircleGeometry,\n\t\tConeGeometry: ConeGeometry,\n\t\tConeBufferGeometry: ConeGeometry,\n\t\tCylinderGeometry: CylinderGeometry,\n\t\tCylinderBufferGeometry: CylinderGeometry,\n\t\tDodecahedronGeometry: DodecahedronGeometry,\n\t\tDodecahedronBufferGeometry: DodecahedronGeometry,\n\t\tEdgesGeometry: EdgesGeometry,\n\t\tExtrudeGeometry: ExtrudeGeometry,\n\t\tExtrudeBufferGeometry: ExtrudeGeometry,\n\t\tIcosahedronGeometry: IcosahedronGeometry,\n\t\tIcosahedronBufferGeometry: IcosahedronGeometry,\n\t\tLatheGeometry: LatheGeometry,\n\t\tLatheBufferGeometry: LatheGeometry,\n\t\tOctahedronGeometry: OctahedronGeometry,\n\t\tOctahedronBufferGeometry: OctahedronGeometry,\n\t\tParametricGeometry: ParametricGeometry,\n\t\tParametricBufferGeometry: ParametricGeometry,\n\t\tPlaneGeometry: PlaneGeometry,\n\t\tPlaneBufferGeometry: PlaneGeometry,\n\t\tPolyhedronGeometry: PolyhedronGeometry,\n\t\tPolyhedronBufferGeometry: PolyhedronGeometry,\n\t\tRingGeometry: RingGeometry,\n\t\tRingBufferGeometry: RingGeometry,\n\t\tShapeGeometry: ShapeGeometry,\n\t\tShapeBufferGeometry: ShapeGeometry,\n\t\tSphereGeometry: SphereGeometry,\n\t\tSphereBufferGeometry: SphereGeometry,\n\t\tTetrahedronGeometry: TetrahedronGeometry,\n\t\tTetrahedronBufferGeometry: TetrahedronGeometry,\n\t\tTextGeometry: TextGeometry,\n\t\tTextBufferGeometry: TextGeometry,\n\t\tTorusGeometry: TorusGeometry,\n\t\tTorusBufferGeometry: TorusGeometry,\n\t\tTorusKnotGeometry: TorusKnotGeometry,\n\t\tTorusKnotBufferGeometry: TorusKnotGeometry,\n\t\tTubeGeometry: TubeGeometry,\n\t\tTubeBufferGeometry: TubeGeometry,\n\t\tWireframeGeometry: WireframeGeometry\n\t});\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <THREE.Color>\n\t * }\n\t */\n\n\tclass ShadowMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ShadowMaterial';\n\t\t\tthis.color = new Color(0x000000);\n\t\t\tthis.transparent = true;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tShadowMaterial.prototype.isShadowMaterial = true;\n\n\tclass RawShaderMaterial extends ShaderMaterial {\n\t\tconstructor(parameters) {\n\t\t\tsuper(parameters);\n\t\t\tthis.type = 'RawShaderMaterial';\n\t\t}\n\n\t}\n\n\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\troughness: <float>,\n\t *\tmetalness: <float>,\n\t *\topacity: <float>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\tlightMap: new THREE.Texture( <Image> ),\n\t *\tlightMapIntensity: <float>\n\t *\n\t *\taoMap: new THREE.Texture( <Image> ),\n\t *\taoMapIntensity: <float>\n\t *\n\t *\temissive: <hex>,\n\t *\temissiveIntensity: <float>\n\t *\temissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tbumpMap: new THREE.Texture( <Image> ),\n\t *\tbumpScale: <float>,\n\t *\n\t *\tnormalMap: new THREE.Texture( <Image> ),\n\t *\tnormalMapType: THREE.TangentSpaceNormalMap,\n\t *\tnormalScale: <Vector2>,\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\troughnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tmetalnessMap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tenvMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *\tenvMapIntensity: <float>\n\t *\n\t *\trefractionRatio: <float>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>,\n\t *\n\t *\tflatShading: <bool>\n\t * }\n\t */\n\n\tclass MeshStandardMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.defines = {\n\t\t\t\t'STANDARD': ''\n\t\t\t};\n\t\t\tthis.type = 'MeshStandardMaterial';\n\t\t\tthis.color = new Color(0xffffff); // diffuse\n\n\t\t\tthis.roughness = 1.0;\n\t\t\tthis.metalness = 0.0;\n\t\t\tthis.map = null;\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\t\tthis.emissive = new Color(0x000000);\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\t\tthis.normalScale = new Vector2(1, 1);\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.roughnessMap = null;\n\t\t\tthis.metalnessMap = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.envMap = null;\n\t\t\tthis.envMapIntensity = 1.0;\n\t\t\tthis.refractionRatio = 0.98;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.flatShading = false;\n\t\t\tthis.vertexTangents = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.defines = {\n\t\t\t\t'STANDARD': ''\n\t\t\t};\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.roughness = source.roughness;\n\t\t\tthis.metalness = source.metalness;\n\t\t\tthis.map = source.map;\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\t\tthis.emissive.copy(source.emissive);\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalMapType = source.normalMapType;\n\t\t\tthis.normalScale.copy(source.normalScale);\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.roughnessMap = source.roughnessMap;\n\t\t\tthis.metalnessMap = source.metalnessMap;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.envMapIntensity = source.envMapIntensity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\tthis.flatShading = source.flatShading;\n\t\t\tthis.vertexTangents = source.vertexTangents;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tclearcoat: <float>,\n\t *\tclearcoatMap: new THREE.Texture( <Image> ),\n\t *\tclearcoatRoughness: <float>,\n\t *\tclearcoatRoughnessMap: new THREE.Texture( <Image> ),\n\t *\tclearcoatNormalScale: <Vector2>,\n\t *\tclearcoatNormalMap: new THREE.Texture( <Image> ),\n\t *\n\t *\treflectivity: <float>,\n\t *\tior: <float>,\n\t *\n\t *\tsheen: <Color>,\n\t *\n\t *\ttransmission: <float>,\n\t *\ttransmissionMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tthickness: <float>,\n\t *\tthicknessMap: new THREE.Texture( <Image> ),\n\t *\tattenuationDistance: <float>,\n\t *\tattenuationColor: <Color>\n\t * }\n\t */\n\n\tclass MeshPhysicalMaterial extends MeshStandardMaterial {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.defines = {\n\t\t\t\t'STANDARD': '',\n\t\t\t\t'PHYSICAL': ''\n\t\t\t};\n\t\t\tthis.type = 'MeshPhysicalMaterial';\n\t\t\tthis.clearcoat = 0.0;\n\t\t\tthis.clearcoatMap = null;\n\t\t\tthis.clearcoatRoughness = 0.0;\n\t\t\tthis.clearcoatRoughnessMap = null;\n\t\t\tthis.clearcoatNormalScale = new Vector2(1, 1);\n\t\t\tthis.clearcoatNormalMap = null;\n\t\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\n\n\t\t\tObject.defineProperty(this, 'ior', {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);\n\t\t\t\t},\n\t\t\t\tset: function (ior) {\n\t\t\t\t\tthis.reflectivity = clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.sheen = null; // null will disable sheen bsdf\n\n\t\t\tthis.transmission = 0.0;\n\t\t\tthis.transmissionMap = null;\n\t\t\tthis.thickness = 0.01;\n\t\t\tthis.thicknessMap = null;\n\t\t\tthis.attenuationDistance = 0.0;\n\t\t\tthis.attenuationColor = new Color(1, 1, 1);\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.defines = {\n\t\t\t\t'STANDARD': '',\n\t\t\t\t'PHYSICAL': ''\n\t\t\t};\n\t\t\tthis.clearcoat = source.clearcoat;\n\t\t\tthis.clearcoatMap = source.clearcoatMap;\n\t\t\tthis.clearcoatRoughness = source.clearcoatRoughness;\n\t\t\tthis.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n\t\t\tthis.clearcoatNormalMap = source.clearcoatNormalMap;\n\t\t\tthis.clearcoatNormalScale.copy(source.clearcoatNormalScale);\n\t\t\tthis.reflectivity = source.reflectivity;\n\n\t\t\tif (source.sheen) {\n\t\t\t\tthis.sheen = (this.sheen || new Color()).copy(source.sheen);\n\t\t\t} else {\n\t\t\t\tthis.sheen = null;\n\t\t\t}\n\n\t\t\tthis.transmission = source.transmission;\n\t\t\tthis.transmissionMap = source.transmissionMap;\n\t\t\tthis.thickness = source.thickness;\n\t\t\tthis.thicknessMap = source.thicknessMap;\n\t\t\tthis.attenuationDistance = source.attenuationDistance;\n\t\t\tthis.attenuationColor.copy(source.attenuationColor);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\tspecular: <hex>,\n\t *\tshininess: <float>,\n\t *\topacity: <float>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\tlightMap: new THREE.Texture( <Image> ),\n\t *\tlightMapIntensity: <float>\n\t *\n\t *\taoMap: new THREE.Texture( <Image> ),\n\t *\taoMapIntensity: <float>\n\t *\n\t *\temissive: <hex>,\n\t *\temissiveIntensity: <float>\n\t *\temissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tbumpMap: new THREE.Texture( <Image> ),\n\t *\tbumpScale: <float>,\n\t *\n\t *\tnormalMap: new THREE.Texture( <Image> ),\n\t *\tnormalMapType: THREE.TangentSpaceNormalMap,\n\t *\tnormalScale: <Vector2>,\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\tspecularMap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tenvMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *\tcombine: THREE.MultiplyOperation,\n\t *\treflectivity: <float>,\n\t *\trefractionRatio: <float>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>,\n\t *\n\t *\tflatShading: <bool>\n\t * }\n\t */\n\n\tclass MeshPhongMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshPhongMaterial';\n\t\t\tthis.color = new Color(0xffffff); // diffuse\n\n\t\t\tthis.specular = new Color(0x111111);\n\t\t\tthis.shininess = 30;\n\t\t\tthis.map = null;\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\t\tthis.emissive = new Color(0x000000);\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\t\tthis.normalScale = new Vector2(1, 1);\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.specularMap = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.flatShading = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.specular.copy(source.specular);\n\t\t\tthis.shininess = source.shininess;\n\t\t\tthis.map = source.map;\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\t\tthis.emissive.copy(source.emissive);\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalMapType = source.normalMapType;\n\t\t\tthis.normalScale.copy(source.normalScale);\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.specularMap = source.specularMap;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\tthis.flatShading = source.flatShading;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\tgradientMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tlightMap: new THREE.Texture( <Image> ),\n\t *\tlightMapIntensity: <float>\n\t *\n\t *\taoMap: new THREE.Texture( <Image> ),\n\t *\taoMapIntensity: <float>\n\t *\n\t *\temissive: <hex>,\n\t *\temissiveIntensity: <float>\n\t *\temissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tbumpMap: new THREE.Texture( <Image> ),\n\t *\tbumpScale: <float>,\n\t *\n\t *\tnormalMap: new THREE.Texture( <Image> ),\n\t *\tnormalMapType: THREE.TangentSpaceNormalMap,\n\t *\tnormalScale: <Vector2>,\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>\n\t * }\n\t */\n\n\tclass MeshToonMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.defines = {\n\t\t\t\t'TOON': ''\n\t\t\t};\n\t\t\tthis.type = 'MeshToonMaterial';\n\t\t\tthis.color = new Color(0xffffff);\n\t\t\tthis.map = null;\n\t\t\tthis.gradientMap = null;\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\t\tthis.emissive = new Color(0x000000);\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\t\tthis.normalScale = new Vector2(1, 1);\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.map = source.map;\n\t\t\tthis.gradientMap = source.gradientMap;\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\t\tthis.emissive.copy(source.emissive);\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalMapType = source.normalMapType;\n\t\t\tthis.normalScale.copy(source.normalScale);\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshToonMaterial.prototype.isMeshToonMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\topacity: <float>,\n\t *\n\t *\tbumpMap: new THREE.Texture( <Image> ),\n\t *\tbumpScale: <float>,\n\t *\n\t *\tnormalMap: new THREE.Texture( <Image> ),\n\t *\tnormalMapType: THREE.TangentSpaceNormalMap,\n\t *\tnormalScale: <Vector2>,\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>,\n\t *\n\t *\tflatShading: <bool>\n\t * }\n\t */\n\n\tclass MeshNormalMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshNormalMaterial';\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\t\tthis.normalScale = new Vector2(1, 1);\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.fog = false;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.flatShading = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalMapType = source.normalMapType;\n\t\t\tthis.normalScale.copy(source.normalScale);\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\tthis.flatShading = source.flatShading;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\tlightMap: new THREE.Texture( <Image> ),\n\t *\tlightMapIntensity: <float>\n\t *\n\t *\taoMap: new THREE.Texture( <Image> ),\n\t *\taoMapIntensity: <float>\n\t *\n\t *\temissive: <hex>,\n\t *\temissiveIntensity: <float>\n\t *\temissiveMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tspecularMap: new THREE.Texture( <Image> ),\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tenvMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n\t *\tcombine: THREE.Multiply,\n\t *\treflectivity: <float>,\n\t *\trefractionRatio: <float>,\n\t *\n\t *\twireframe: <boolean>,\n\t *\twireframeLinewidth: <float>,\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>\n\t * }\n\t */\n\n\tclass MeshLambertMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'MeshLambertMaterial';\n\t\t\tthis.color = new Color(0xffffff); // diffuse\n\n\t\t\tthis.map = null;\n\t\t\tthis.lightMap = null;\n\t\t\tthis.lightMapIntensity = 1.0;\n\t\t\tthis.aoMap = null;\n\t\t\tthis.aoMapIntensity = 1.0;\n\t\t\tthis.emissive = new Color(0x000000);\n\t\t\tthis.emissiveIntensity = 1.0;\n\t\t\tthis.emissiveMap = null;\n\t\t\tthis.specularMap = null;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.envMap = null;\n\t\t\tthis.combine = MultiplyOperation;\n\t\t\tthis.reflectivity = 1;\n\t\t\tthis.refractionRatio = 0.98;\n\t\t\tthis.wireframe = false;\n\t\t\tthis.wireframeLinewidth = 1;\n\t\t\tthis.wireframeLinecap = 'round';\n\t\t\tthis.wireframeLinejoin = 'round';\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.map = source.map;\n\t\t\tthis.lightMap = source.lightMap;\n\t\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\t\t\tthis.aoMap = source.aoMap;\n\t\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\t\t\tthis.emissive.copy(source.emissive);\n\t\t\tthis.emissiveMap = source.emissiveMap;\n\t\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\t\t\tthis.specularMap = source.specularMap;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.envMap = source.envMap;\n\t\t\tthis.combine = source.combine;\n\t\t\tthis.reflectivity = source.reflectivity;\n\t\t\tthis.refractionRatio = source.refractionRatio;\n\t\t\tthis.wireframe = source.wireframe;\n\t\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\n\t *\tmatcap: new THREE.Texture( <Image> ),\n\t *\n\t *\tmap: new THREE.Texture( <Image> ),\n\t *\n\t *\tbumpMap: new THREE.Texture( <Image> ),\n\t *\tbumpScale: <float>,\n\t *\n\t *\tnormalMap: new THREE.Texture( <Image> ),\n\t *\tnormalMapType: THREE.TangentSpaceNormalMap,\n\t *\tnormalScale: <Vector2>,\n\t *\n\t *\tdisplacementMap: new THREE.Texture( <Image> ),\n\t *\tdisplacementScale: <float>,\n\t *\tdisplacementBias: <float>,\n\t *\n\t *\talphaMap: new THREE.Texture( <Image> ),\n\t *\n\t *\tmorphTargets: <bool>,\n\t *\tmorphNormals: <bool>\n\t *\n\t *\tflatShading: <bool>\n\t * }\n\t */\n\n\tclass MeshMatcapMaterial extends Material {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.defines = {\n\t\t\t\t'MATCAP': ''\n\t\t\t};\n\t\t\tthis.type = 'MeshMatcapMaterial';\n\t\t\tthis.color = new Color(0xffffff); // diffuse\n\n\t\t\tthis.matcap = null;\n\t\t\tthis.map = null;\n\t\t\tthis.bumpMap = null;\n\t\t\tthis.bumpScale = 1;\n\t\t\tthis.normalMap = null;\n\t\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\t\tthis.normalScale = new Vector2(1, 1);\n\t\t\tthis.displacementMap = null;\n\t\t\tthis.displacementScale = 1;\n\t\t\tthis.displacementBias = 0;\n\t\t\tthis.alphaMap = null;\n\t\t\tthis.morphTargets = false;\n\t\t\tthis.morphNormals = false;\n\t\t\tthis.flatShading = false;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.defines = {\n\t\t\t\t'MATCAP': ''\n\t\t\t};\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.matcap = source.matcap;\n\t\t\tthis.map = source.map;\n\t\t\tthis.bumpMap = source.bumpMap;\n\t\t\tthis.bumpScale = source.bumpScale;\n\t\t\tthis.normalMap = source.normalMap;\n\t\t\tthis.normalMapType = source.normalMapType;\n\t\t\tthis.normalScale.copy(source.normalScale);\n\t\t\tthis.displacementMap = source.displacementMap;\n\t\t\tthis.displacementScale = source.displacementScale;\n\t\t\tthis.displacementBias = source.displacementBias;\n\t\t\tthis.alphaMap = source.alphaMap;\n\t\t\tthis.morphTargets = source.morphTargets;\n\t\t\tthis.morphNormals = source.morphNormals;\n\t\t\tthis.flatShading = source.flatShading;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tMeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;\n\n\t/**\n\t * parameters = {\n\t *\tcolor: <hex>,\n\t *\topacity: <float>,\n\t *\n\t *\tlinewidth: <float>,\n\t *\n\t *\tscale: <float>,\n\t *\tdashSize: <float>,\n\t *\tgapSize: <float>\n\t * }\n\t */\n\n\tclass LineDashedMaterial extends LineBasicMaterial {\n\t\tconstructor(parameters) {\n\t\t\tsuper();\n\t\t\tthis.type = 'LineDashedMaterial';\n\t\t\tthis.scale = 1;\n\t\t\tthis.dashSize = 3;\n\t\t\tthis.gapSize = 1;\n\t\t\tthis.setValues(parameters);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.scale = source.scale;\n\t\t\tthis.dashSize = source.dashSize;\n\t\t\tthis.gapSize = source.gapSize;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\n\n\tvar Materials = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tShadowMaterial: ShadowMaterial,\n\t\tSpriteMaterial: SpriteMaterial,\n\t\tRawShaderMaterial: RawShaderMaterial,\n\t\tShaderMaterial: ShaderMaterial,\n\t\tPointsMaterial: PointsMaterial,\n\t\tMeshPhysicalMaterial: MeshPhysicalMaterial,\n\t\tMeshStandardMaterial: MeshStandardMaterial,\n\t\tMeshPhongMaterial: MeshPhongMaterial,\n\t\tMeshToonMaterial: MeshToonMaterial,\n\t\tMeshNormalMaterial: MeshNormalMaterial,\n\t\tMeshLambertMaterial: MeshLambertMaterial,\n\t\tMeshDepthMaterial: MeshDepthMaterial,\n\t\tMeshDistanceMaterial: MeshDistanceMaterial,\n\t\tMeshBasicMaterial: MeshBasicMaterial,\n\t\tMeshMatcapMaterial: MeshMatcapMaterial,\n\t\tLineDashedMaterial: LineDashedMaterial,\n\t\tLineBasicMaterial: LineBasicMaterial,\n\t\tMaterial: Material\n\t});\n\n\tconst AnimationUtils = {\n\t\t// same as Array.prototype.slice, but also works on typed arrays\n\t\tarraySlice: function (array, from, to) {\n\t\t\tif (AnimationUtils.isTypedArray(array)) {\n\t\t\t\t// in ios9 array.subarray(from, undefined) will return empty array\n\t\t\t\t// but array.subarray(from) or array.subarray(from, len) is correct\n\t\t\t\treturn new array.constructor(array.subarray(from, to !== undefined ? to : array.length));\n\t\t\t}\n\n\t\t\treturn array.slice(from, to);\n\t\t},\n\t\t// converts an array to a specific type\n\t\tconvertArray: function (array, type, forceClone) {\n\t\t\tif (!array || // let 'undefined' and 'null' pass\n\t\t\t!forceClone && array.constructor === type) return array;\n\n\t\t\tif (typeof type.BYTES_PER_ELEMENT === 'number') {\n\t\t\t\treturn new type(array); // create typed array\n\t\t\t}\n\n\t\t\treturn Array.prototype.slice.call(array); // create Array\n\t\t},\n\t\tisTypedArray: function (object) {\n\t\t\treturn ArrayBuffer.isView(object) && !(object instanceof DataView);\n\t\t},\n\t\t// returns an array by which times and values can be sorted\n\t\tgetKeyframeOrder: function (times) {\n\t\t\tfunction compareTime(i, j) {\n\t\t\t\treturn times[i] - times[j];\n\t\t\t}\n\n\t\t\tconst n = times.length;\n\t\t\tconst result = new Array(n);\n\n\t\t\tfor (let i = 0; i !== n; ++i) result[i] = i;\n\n\t\t\tresult.sort(compareTime);\n\t\t\treturn result;\n\t\t},\n\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\n\t\tsortedArray: function (values, stride, order) {\n\t\t\tconst nValues = values.length;\n\t\t\tconst result = new values.constructor(nValues);\n\n\t\t\tfor (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {\n\t\t\t\tconst srcOffset = order[i] * stride;\n\n\t\t\t\tfor (let j = 0; j !== stride; ++j) {\n\t\t\t\t\tresult[dstOffset++] = values[srcOffset + j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\t\t// function for parsing AOS keyframe formats\n\t\tflattenJSON: function (jsonKeys, times, values, valuePropertyName) {\n\t\t\tlet i = 1,\n\t\t\t\t\tkey = jsonKeys[0];\n\n\t\t\twhile (key !== undefined && key[valuePropertyName] === undefined) {\n\t\t\t\tkey = jsonKeys[i++];\n\t\t\t}\n\n\t\t\tif (key === undefined) return; // no data\n\n\t\t\tlet value = key[valuePropertyName];\n\t\t\tif (value === undefined) return; // no data\n\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tdo {\n\t\t\t\t\tvalue = key[valuePropertyName];\n\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\ttimes.push(key.time);\n\t\t\t\t\t\tvalues.push.apply(values, value); // push all elements\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[i++];\n\t\t\t\t} while (key !== undefined);\n\t\t\t} else if (value.toArray !== undefined) {\n\t\t\t\t// ...assume THREE.Math-ish\n\t\t\t\tdo {\n\t\t\t\t\tvalue = key[valuePropertyName];\n\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\ttimes.push(key.time);\n\t\t\t\t\t\tvalue.toArray(values, values.length);\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[i++];\n\t\t\t\t} while (key !== undefined);\n\t\t\t} else {\n\t\t\t\t// otherwise push as-is\n\t\t\t\tdo {\n\t\t\t\t\tvalue = key[valuePropertyName];\n\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\ttimes.push(key.time);\n\t\t\t\t\t\tvalues.push(value);\n\t\t\t\t\t}\n\n\t\t\t\t\tkey = jsonKeys[i++];\n\t\t\t\t} while (key !== undefined);\n\t\t\t}\n\t\t},\n\t\tsubclip: function (sourceClip, name, startFrame, endFrame, fps = 30) {\n\t\t\tconst clip = sourceClip.clone();\n\t\t\tclip.name = name;\n\t\t\tconst tracks = [];\n\n\t\t\tfor (let i = 0; i < clip.tracks.length; ++i) {\n\t\t\t\tconst track = clip.tracks[i];\n\t\t\t\tconst valueSize = track.getValueSize();\n\t\t\t\tconst times = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tfor (let j = 0; j < track.times.length; ++j) {\n\t\t\t\t\tconst frame = track.times[j] * fps;\n\t\t\t\t\tif (frame < startFrame || frame >= endFrame) continue;\n\t\t\t\t\ttimes.push(track.times[j]);\n\n\t\t\t\t\tfor (let k = 0; k < valueSize; ++k) {\n\t\t\t\t\t\tvalues.push(track.values[j * valueSize + k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (times.length === 0) continue;\n\t\t\t\ttrack.times = AnimationUtils.convertArray(times, track.times.constructor);\n\t\t\t\ttrack.values = AnimationUtils.convertArray(values, track.values.constructor);\n\t\t\t\ttracks.push(track);\n\t\t\t}\n\n\t\t\tclip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip\n\n\t\t\tlet minStartTime = Infinity;\n\n\t\t\tfor (let i = 0; i < clip.tracks.length; ++i) {\n\t\t\t\tif (minStartTime > clip.tracks[i].times[0]) {\n\t\t\t\t\tminStartTime = clip.tracks[i].times[0];\n\t\t\t\t}\n\t\t\t} // shift all tracks such that clip begins at t=0\n\n\n\t\t\tfor (let i = 0; i < clip.tracks.length; ++i) {\n\t\t\t\tclip.tracks[i].shift(-1 * minStartTime);\n\t\t\t}\n\n\t\t\tclip.resetDuration();\n\t\t\treturn clip;\n\t\t},\n\t\tmakeClipAdditive: function (targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {\n\t\t\tif (fps <= 0) fps = 30;\n\t\t\tconst numTracks = referenceClip.tracks.length;\n\t\t\tconst referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame\n\n\t\t\tfor (let i = 0; i < numTracks; ++i) {\n\t\t\t\tconst referenceTrack = referenceClip.tracks[i];\n\t\t\t\tconst referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric\n\n\t\t\t\tif (referenceTrackType === 'bool' || referenceTrackType === 'string') continue; // Find the track in the target clip whose name and type matches the reference track\n\n\t\t\t\tconst targetTrack = targetClip.tracks.find(function (track) {\n\t\t\t\t\treturn track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;\n\t\t\t\t});\n\t\t\t\tif (targetTrack === undefined) continue;\n\t\t\t\tlet referenceOffset = 0;\n\t\t\t\tconst referenceValueSize = referenceTrack.getValueSize();\n\n\t\t\t\tif (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n\t\t\t\t\treferenceOffset = referenceValueSize / 3;\n\t\t\t\t}\n\n\t\t\t\tlet targetOffset = 0;\n\t\t\t\tconst targetValueSize = targetTrack.getValueSize();\n\n\t\t\t\tif (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n\t\t\t\t\ttargetOffset = targetValueSize / 3;\n\t\t\t\t}\n\n\t\t\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\t\t\tlet referenceValue; // Find the value to subtract out of the track\n\n\t\t\t\tif (referenceTime <= referenceTrack.times[0]) {\n\t\t\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\t\t\tconst startIndex = referenceOffset;\n\t\t\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\t\t\treferenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);\n\t\t\t\t} else if (referenceTime >= referenceTrack.times[lastIndex]) {\n\t\t\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\n\t\t\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\n\t\t\t\t\treferenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);\n\t\t\t\t} else {\n\t\t\t\t\t// Interpolate to the reference value\n\t\t\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\t\t\tconst startIndex = referenceOffset;\n\t\t\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\t\t\tinterpolant.evaluate(referenceTime);\n\t\t\t\t\treferenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);\n\t\t\t\t} // Conjugate the quaternion\n\n\n\t\t\t\tif (referenceTrackType === 'quaternion') {\n\t\t\t\t\tconst referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();\n\t\t\t\t\treferenceQuat.toArray(referenceValue);\n\t\t\t\t} // Subtract the reference value from all of the track values\n\n\n\t\t\t\tconst numTimes = targetTrack.times.length;\n\n\t\t\t\tfor (let j = 0; j < numTimes; ++j) {\n\t\t\t\t\tconst valueStart = j * targetValueSize + targetOffset;\n\n\t\t\t\t\tif (referenceTrackType === 'quaternion') {\n\t\t\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\t\t\tQuaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types\n\n\t\t\t\t\t\tfor (let k = 0; k < valueEnd; ++k) {\n\t\t\t\t\t\t\ttargetTrack.values[valueStart + k] -= referenceValue[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\t\t\treturn targetClip;\n\t\t}\n\t};\n\n\t/**\n\t * Abstract base class of interpolants over parametric samples.\n\t *\n\t * The parameter domain is one dimensional, typically the time or a path\n\t * along a curve defined by the data.\n\t *\n\t * The sample values can have any dimensionality and derived classes may\n\t * apply special interpretations to the data.\n\t *\n\t * This class provides the interval seek in a Template Method, deferring\n\t * the actual interpolation to derived classes.\n\t *\n\t * Time complexity is O(1) for linear access crossing at most two points\n\t * and O(log N) for random access, where N is the number of positions.\n\t *\n\t * References:\n\t *\n\t * \t\thttp://www.oodesign.com/template-method-pattern.html\n\t *\n\t */\n\tclass Interpolant {\n\t\tconstructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\t\t\tthis.parameterPositions = parameterPositions;\n\t\t\tthis._cachedIndex = 0;\n\t\t\tthis.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);\n\t\t\tthis.sampleValues = sampleValues;\n\t\t\tthis.valueSize = sampleSize;\n\t\t\tthis.settings = null;\n\t\t\tthis.DefaultSettings_ = {};\n\t\t}\n\n\t\tevaluate(t) {\n\t\t\tconst pp = this.parameterPositions;\n\t\t\tlet i1 = this._cachedIndex,\n\t\t\t\t\tt1 = pp[i1],\n\t\t\t\t\tt0 = pp[i1 - 1];\n\n\t\t\tvalidate_interval: {\n\t\t\t\tseek: {\n\t\t\t\t\tlet right;\n\n\t\t\t\t\tlinear_scan: {\n\t\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t\t//- slower code:\n\t\t\t\t\t\t//-\n\t\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\t\tforward_scan: if (!(t < t1)) {\n\t\t\t\t\t\t\tfor (let giveUpAt = i1 + 2;;) {\n\t\t\t\t\t\t\t\tif (t1 === undefined) {\n\t\t\t\t\t\t\t\t\tif (t < t0) break forward_scan; // after end\n\n\t\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\t\treturn this.afterEnd_(i1 - 1, t, t0);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (i1 === giveUpAt) break; // this loop\n\n\t\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\t\tt1 = pp[++i1];\n\n\t\t\t\t\t\t\t\tif (t < t1) {\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} // prepare binary search on the right side of the index\n\n\n\t\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\t\tbreak linear_scan;\n\t\t\t\t\t\t} //- slower code:\n\t\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\n\n\t\t\t\t\t\tif (!(t >= t0)) {\n\t\t\t\t\t\t\t// looping?\n\t\t\t\t\t\t\tconst t1global = pp[1];\n\n\t\t\t\t\t\t\tif (t < t1global) {\n\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\n\t\t\t\t\t\t\t\tt0 = t1global;\n\t\t\t\t\t\t\t} // linear reverse scan\n\n\n\t\t\t\t\t\t\tfor (let giveUpAt = i1 - 2;;) {\n\t\t\t\t\t\t\t\tif (t0 === undefined) {\n\t\t\t\t\t\t\t\t\t// before start\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\t\treturn this.beforeStart_(0, t, t1);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (i1 === giveUpAt) break; // this loop\n\n\t\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\t\tt0 = pp[--i1 - 1];\n\n\t\t\t\t\t\t\t\tif (t >= t0) {\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\t\tbreak seek;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} // prepare binary search on the left side of the index\n\n\n\t\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\t\tbreak linear_scan;\n\t\t\t\t\t\t} // the interval is valid\n\n\n\t\t\t\t\t\tbreak validate_interval;\n\t\t\t\t\t} // linear scan\n\t\t\t\t\t// binary search\n\n\n\t\t\t\t\twhile (i1 < right) {\n\t\t\t\t\t\tconst mid = i1 + right >>> 1;\n\n\t\t\t\t\t\tif (t < pp[mid]) {\n\t\t\t\t\t\t\tright = mid;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ti1 = mid + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tt1 = pp[i1];\n\t\t\t\t\tt0 = pp[i1 - 1]; // check boundary cases, again\n\n\t\t\t\t\tif (t0 === undefined) {\n\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\treturn this.beforeStart_(0, t, t1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (t1 === undefined) {\n\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\treturn this.afterEnd_(i1 - 1, t0, t);\n\t\t\t\t\t}\n\t\t\t\t} // seek\n\n\n\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\tthis.intervalChanged_(i1, t0, t1);\n\t\t\t} // validate_interval\n\n\n\t\t\treturn this.interpolate_(i1, t0, t, t1);\n\t\t}\n\n\t\tgetSettings_() {\n\t\t\treturn this.settings || this.DefaultSettings_;\n\t\t}\n\n\t\tcopySampleValue_(index) {\n\t\t\t// copies a sample value to the result buffer\n\t\t\tconst result = this.resultBuffer,\n\t\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\toffset = index * stride;\n\n\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\tresult[i] = values[offset + i];\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} // Template methods for derived classes:\n\n\n\t\tinterpolate_()\n\t\t/* i1, t0, t, t1 */\n\t\t{\n\t\t\tthrow new Error('call to abstract method'); // implementations shall return this.resultBuffer\n\t\t}\n\n\t\tintervalChanged_()\n\t\t/* i1, t0, t1 */\n\t\t{// empty\n\t\t}\n\n\t} // ALIAS DEFINITIONS\n\n\n\tInterpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;\n\tInterpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;\n\n\t/**\n\t * Fast and simple cubic spline interpolant.\n\t *\n\t * It was derived from a Hermitian construction setting the first derivative\n\t * at each sample position to the linear slope between neighboring positions\n\t * over their parameter interval.\n\t */\n\n\tclass CubicInterpolant extends Interpolant {\n\t\tconstructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\t\t\tsuper(parameterPositions, sampleValues, sampleSize, resultBuffer);\n\t\t\tthis._weightPrev = -0;\n\t\t\tthis._offsetPrev = -0;\n\t\t\tthis._weightNext = -0;\n\t\t\tthis._offsetNext = -0;\n\t\t\tthis.DefaultSettings_ = {\n\t\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t\t};\n\t\t}\n\n\t\tintervalChanged_(i1, t0, t1) {\n\t\t\tconst pp = this.parameterPositions;\n\t\t\tlet iPrev = i1 - 2,\n\t\t\t\t\tiNext = i1 + 1,\n\t\t\t\t\ttPrev = pp[iPrev],\n\t\t\t\t\ttNext = pp[iNext];\n\n\t\t\tif (tPrev === undefined) {\n\t\t\t\tswitch (this.getSettings_().endingStart) {\n\t\t\t\t\tcase ZeroSlopeEnding:\n\t\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = 2 * t0 - t1;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\t\ttPrev = t0 + pp[iPrev] - pp[iPrev + 1];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// ZeroCurvatureEnding\n\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\t\tiPrev = i1;\n\t\t\t\t\t\ttPrev = t1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tNext === undefined) {\n\t\t\t\tswitch (this.getSettings_().endingEnd) {\n\t\t\t\t\tcase ZeroSlopeEnding:\n\t\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\t\tiNext = i1;\n\t\t\t\t\t\ttNext = 2 * t1 - t0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase WrapAroundEnding:\n\t\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\t\tiNext = 1;\n\t\t\t\t\t\ttNext = t1 + pp[1] - pp[0];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// ZeroCurvatureEnding\n\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\t\ttNext = t0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst halfDt = (t1 - t0) * 0.5,\n\t\t\t\t\t\tstride = this.valueSize;\n\t\t\tthis._weightPrev = halfDt / (t0 - tPrev);\n\t\t\tthis._weightNext = halfDt / (tNext - t1);\n\t\t\tthis._offsetPrev = iPrev * stride;\n\t\t\tthis._offsetNext = iNext * stride;\n\t\t}\n\n\t\tinterpolate_(i1, t0, t, t1) {\n\t\t\tconst result = this.resultBuffer,\n\t\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\to1 = i1 * stride,\n\t\t\t\t\t\to0 = o1 - stride,\n\t\t\t\t\t\toP = this._offsetPrev,\n\t\t\t\t\t\toN = this._offsetNext,\n\t\t\t\t\t\twP = this._weightPrev,\n\t\t\t\t\t\twN = this._weightNext,\n\t\t\t\t\t\tp = (t - t0) / (t1 - t0),\n\t\t\t\t\t\tpp = p * p,\n\t\t\t\t\t\tppp = pp * p; // evaluate polynomials\n\n\t\t\tconst sP = -wP * ppp + 2 * wP * pp - wP * p;\n\t\t\tconst s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\n\t\t\tconst s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\n\t\t\tconst sN = wN * ppp - wN * pp; // combine data linearly\n\n\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\tresult[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t}\n\n\tclass LinearInterpolant extends Interpolant {\n\t\tconstructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\t\t\tsuper(parameterPositions, sampleValues, sampleSize, resultBuffer);\n\t\t}\n\n\t\tinterpolate_(i1, t0, t, t1) {\n\t\t\tconst result = this.resultBuffer,\n\t\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\toffset1 = i1 * stride,\n\t\t\t\t\t\toffset0 = offset1 - stride,\n\t\t\t\t\t\tweight1 = (t - t0) / (t1 - t0),\n\t\t\t\t\t\tweight0 = 1 - weight1;\n\n\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\tresult[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t}\n\n\t/**\n\t *\n\t * Interpolant that evaluates to the sample value at the position preceeding\n\t * the parameter.\n\t */\n\n\tclass DiscreteInterpolant extends Interpolant {\n\t\tconstructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\t\t\tsuper(parameterPositions, sampleValues, sampleSize, resultBuffer);\n\t\t}\n\n\t\tinterpolate_(i1\n\t\t/*, t0, t, t1 */\n\t\t) {\n\t\t\treturn this.copySampleValue_(i1 - 1);\n\t\t}\n\n\t}\n\n\tclass KeyframeTrack {\n\t\tconstructor(name, times, values, interpolation) {\n\t\t\tif (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');\n\t\t\tif (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);\n\t\t\tthis.name = name;\n\t\t\tthis.times = AnimationUtils.convertArray(times, this.TimeBufferType);\n\t\t\tthis.values = AnimationUtils.convertArray(values, this.ValueBufferType);\n\t\t\tthis.setInterpolation(interpolation || this.DefaultInterpolation);\n\t\t} // Serialization (in static context, because of constructor invocation\n\t\t// and automatic invocation of .toJSON):\n\n\n\t\tstatic toJSON(track) {\n\t\t\tconst trackType = track.constructor;\n\t\t\tlet json; // derived classes can define a static toJSON method\n\n\t\t\tif (trackType.toJSON !== this.toJSON) {\n\t\t\t\tjson = trackType.toJSON(track);\n\t\t\t} else {\n\t\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\t\tjson = {\n\t\t\t\t\t'name': track.name,\n\t\t\t\t\t'times': AnimationUtils.convertArray(track.times, Array),\n\t\t\t\t\t'values': AnimationUtils.convertArray(track.values, Array)\n\t\t\t\t};\n\t\t\t\tconst interpolation = track.getInterpolation();\n\n\t\t\t\tif (interpolation !== track.DefaultInterpolation) {\n\t\t\t\t\tjson.interpolation = interpolation;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\t\treturn json;\n\t\t}\n\n\t\tInterpolantFactoryMethodDiscrete(result) {\n\t\t\treturn new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);\n\t\t}\n\n\t\tInterpolantFactoryMethodLinear(result) {\n\t\t\treturn new LinearInterpolant(this.times, this.values, this.getValueSize(), result);\n\t\t}\n\n\t\tInterpolantFactoryMethodSmooth(result) {\n\t\t\treturn new CubicInterpolant(this.times, this.values, this.getValueSize(), result);\n\t\t}\n\n\t\tsetInterpolation(interpolation) {\n\t\t\tlet factoryMethod;\n\n\t\t\tswitch (interpolation) {\n\t\t\t\tcase InterpolateDiscrete:\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateLinear:\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase InterpolateSmooth:\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (factoryMethod === undefined) {\n\t\t\t\tconst message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;\n\n\t\t\t\tif (this.createInterpolant === undefined) {\n\t\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\t\tif (interpolation !== this.DefaultInterpolation) {\n\t\t\t\t\t\tthis.setInterpolation(this.DefaultInterpolation);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(message); // fatal, in this case\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconsole.warn('THREE.KeyframeTrack:', message);\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tthis.createInterpolant = factoryMethod;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetInterpolation() {\n\t\t\tswitch (this.createInterpolant) {\n\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\t\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\t\tcase this.InterpolantFactoryMethodLinear:\n\t\t\t\t\treturn InterpolateLinear;\n\n\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\t\t\t\t\treturn InterpolateSmooth;\n\t\t\t}\n\t\t}\n\n\t\tgetValueSize() {\n\t\t\treturn this.values.length / this.times.length;\n\t\t} // move all keyframes either forwards or backwards in time\n\n\n\t\tshift(timeOffset) {\n\t\t\tif (timeOffset !== 0.0) {\n\t\t\t\tconst times = this.times;\n\n\t\t\t\tfor (let i = 0, n = times.length; i !== n; ++i) {\n\t\t\t\t\ttimes[i] += timeOffset;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\n\n\t\tscale(timeScale) {\n\t\t\tif (timeScale !== 1.0) {\n\t\t\t\tconst times = this.times;\n\n\t\t\t\tfor (let i = 0, n = times.length; i !== n; ++i) {\n\t\t\t\t\ttimes[i] *= timeScale;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\n\n\t\ttrim(startTime, endTime) {\n\t\t\tconst times = this.times,\n\t\t\t\t\t\tnKeys = times.length;\n\t\t\tlet from = 0,\n\t\t\t\t\tto = nKeys - 1;\n\n\t\t\twhile (from !== nKeys && times[from] < startTime) {\n\t\t\t\t++from;\n\t\t\t}\n\n\t\t\twhile (to !== -1 && times[to] > endTime) {\n\t\t\t\t--to;\n\t\t\t}\n\n\t\t\t++to; // inclusive -> exclusive bound\n\n\t\t\tif (from !== 0 || to !== nKeys) {\n\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\t\tif (from >= to) {\n\t\t\t\t\tto = Math.max(to, 1);\n\t\t\t\t\tfrom = to - 1;\n\t\t\t\t}\n\n\t\t\t\tconst stride = this.getValueSize();\n\t\t\t\tthis.times = AnimationUtils.arraySlice(times, from, to);\n\t\t\t\tthis.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\n\n\t\tvalidate() {\n\t\t\tlet valid = true;\n\t\t\tconst valueSize = this.getValueSize();\n\n\t\t\tif (valueSize - Math.floor(valueSize) !== 0) {\n\t\t\t\tconsole.error('THREE.KeyframeTrack: Invalid value size in track.', this);\n\t\t\t\tvalid = false;\n\t\t\t}\n\n\t\t\tconst times = this.times,\n\t\t\t\t\t\tvalues = this.values,\n\t\t\t\t\t\tnKeys = times.length;\n\n\t\t\tif (nKeys === 0) {\n\t\t\t\tconsole.error('THREE.KeyframeTrack: Track is empty.', this);\n\t\t\t\tvalid = false;\n\t\t\t}\n\n\t\t\tlet prevTime = null;\n\n\t\t\tfor (let i = 0; i !== nKeys; i++) {\n\t\t\t\tconst currTime = times[i];\n\n\t\t\t\tif (typeof currTime === 'number' && isNaN(currTime)) {\n\t\t\t\t\tconsole.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (prevTime !== null && prevTime > currTime) {\n\t\t\t\t\tconsole.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);\n\t\t\t\t\tvalid = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tprevTime = currTime;\n\t\t\t}\n\n\t\t\tif (values !== undefined) {\n\t\t\t\tif (AnimationUtils.isTypedArray(values)) {\n\t\t\t\t\tfor (let i = 0, n = values.length; i !== n; ++i) {\n\t\t\t\t\t\tconst value = values[i];\n\n\t\t\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\t\t\tconsole.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);\n\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn valid;\n\t\t} // removes equivalent sequential keys as common in morph target sequences\n\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\n\n\t\toptimize() {\n\t\t\t// times or values may be shared with other tracks, so overwriting is unsafe\n\t\t\tconst times = AnimationUtils.arraySlice(this.times),\n\t\t\t\t\t\tvalues = AnimationUtils.arraySlice(this.values),\n\t\t\t\t\t\tstride = this.getValueSize(),\n\t\t\t\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\t\t\t\t\t\tlastIndex = times.length - 1;\n\t\t\tlet writeIndex = 1;\n\n\t\t\tfor (let i = 1; i < lastIndex; ++i) {\n\t\t\t\tlet keep = false;\n\t\t\t\tconst time = times[i];\n\t\t\t\tconst timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time\n\n\t\t\t\tif (time !== timeNext && (i !== 1 || time !== times[0])) {\n\t\t\t\t\tif (!smoothInterpolation) {\n\t\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\t\t\t\t\t\tconst offset = i * stride,\n\t\t\t\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\t\tfor (let j = 0; j !== stride; ++j) {\n\t\t\t\t\t\t\tconst value = values[offset + j];\n\n\t\t\t\t\t\t\tif (value !== values[offsetP + j] || value !== values[offsetN + j]) {\n\t\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t}\n\t\t\t\t} // in-place compaction\n\n\n\t\t\t\tif (keep) {\n\t\t\t\t\tif (i !== writeIndex) {\n\t\t\t\t\t\ttimes[writeIndex] = times[i];\n\t\t\t\t\t\tconst readOffset = i * stride,\n\t\t\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\t\tfor (let j = 0; j !== stride; ++j) {\n\t\t\t\t\t\t\tvalues[writeOffset + j] = values[readOffset + j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t++writeIndex;\n\t\t\t\t}\n\t\t\t} // flush last keyframe (compaction looks ahead)\n\n\n\t\t\tif (lastIndex > 0) {\n\t\t\t\ttimes[writeIndex] = times[lastIndex];\n\n\t\t\t\tfor (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {\n\t\t\t\t\tvalues[writeOffset + j] = values[readOffset + j];\n\t\t\t\t}\n\n\t\t\t\t++writeIndex;\n\t\t\t}\n\n\t\t\tif (writeIndex !== times.length) {\n\t\t\t\tthis.times = AnimationUtils.arraySlice(times, 0, writeIndex);\n\t\t\t\tthis.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);\n\t\t\t} else {\n\t\t\t\tthis.times = times;\n\t\t\t\tthis.values = values;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\tconst times = AnimationUtils.arraySlice(this.times, 0);\n\t\t\tconst values = AnimationUtils.arraySlice(this.values, 0);\n\t\t\tconst TypedKeyframeTrack = this.constructor;\n\t\t\tconst track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.\n\n\t\t\ttrack.createInterpolant = this.createInterpolant;\n\t\t\treturn track;\n\t\t}\n\n\t}\n\n\tKeyframeTrack.prototype.TimeBufferType = Float32Array;\n\tKeyframeTrack.prototype.ValueBufferType = Float32Array;\n\tKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\n\t/**\n\t * A Track of Boolean keyframe values.\n\t */\n\n\tclass BooleanKeyframeTrack extends KeyframeTrack {}\n\n\tBooleanKeyframeTrack.prototype.ValueTypeName = 'bool';\n\tBooleanKeyframeTrack.prototype.ValueBufferType = Array;\n\tBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\n\tBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\n\tBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined; // Note: Actually this track could have a optimized / compressed\n\n\t/**\n\t * A Track of keyframe values that represent color.\n\t */\n\n\tclass ColorKeyframeTrack extends KeyframeTrack {}\n\n\tColorKeyframeTrack.prototype.ValueTypeName = 'color'; // ValueBufferType is inherited\n\n\t/**\n\t * A Track of numeric keyframe values.\n\t */\n\n\tclass NumberKeyframeTrack extends KeyframeTrack {}\n\n\tNumberKeyframeTrack.prototype.ValueTypeName = 'number'; // ValueBufferType is inherited\n\n\t/**\n\t * Spherical linear unit quaternion interpolant.\n\t */\n\n\tclass QuaternionLinearInterpolant extends Interpolant {\n\t\tconstructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\t\t\tsuper(parameterPositions, sampleValues, sampleSize, resultBuffer);\n\t\t}\n\n\t\tinterpolate_(i1, t0, t, t1) {\n\t\t\tconst result = this.resultBuffer,\n\t\t\t\t\t\tvalues = this.sampleValues,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\talpha = (t - t0) / (t1 - t0);\n\t\t\tlet offset = i1 * stride;\n\n\t\t\tfor (let end = offset + stride; offset !== end; offset += 4) {\n\t\t\t\tQuaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t}\n\n\t/**\n\t * A Track of quaternion keyframe values.\n\t */\n\n\tclass QuaternionKeyframeTrack extends KeyframeTrack {\n\t\tInterpolantFactoryMethodLinear(result) {\n\t\t\treturn new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);\n\t\t}\n\n\t}\n\n\tQuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion'; // ValueBufferType is inherited\n\n\tQuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\tQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n\t/**\n\t * A Track that interpolates Strings\n\t */\n\n\tclass StringKeyframeTrack extends KeyframeTrack {}\n\n\tStringKeyframeTrack.prototype.ValueTypeName = 'string';\n\tStringKeyframeTrack.prototype.ValueBufferType = Array;\n\tStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\n\tStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\n\tStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n\t/**\n\t * A Track of vectored keyframe values.\n\t */\n\n\tclass VectorKeyframeTrack extends KeyframeTrack {}\n\n\tVectorKeyframeTrack.prototype.ValueTypeName = 'vector'; // ValueBufferType is inherited\n\n\tclass AnimationClip {\n\t\tconstructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {\n\t\t\tthis.name = name;\n\t\t\tthis.tracks = tracks;\n\t\t\tthis.duration = duration;\n\t\t\tthis.blendMode = blendMode;\n\t\t\tthis.uuid = generateUUID(); // this means it should figure out its duration by scanning the tracks\n\n\t\t\tif (this.duration < 0) {\n\t\t\t\tthis.resetDuration();\n\t\t\t}\n\t\t}\n\n\t\tstatic parse(json) {\n\t\t\tconst tracks = [],\n\t\t\t\t\t\tjsonTracks = json.tracks,\n\t\t\t\t\t\tframeTime = 1.0 / (json.fps || 1.0);\n\n\t\t\tfor (let i = 0, n = jsonTracks.length; i !== n; ++i) {\n\t\t\t\ttracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));\n\t\t\t}\n\n\t\t\tconst clip = new this(json.name, json.duration, tracks, json.blendMode);\n\t\t\tclip.uuid = json.uuid;\n\t\t\treturn clip;\n\t\t}\n\n\t\tstatic toJSON(clip) {\n\t\t\tconst tracks = [],\n\t\t\t\t\t\tclipTracks = clip.tracks;\n\t\t\tconst json = {\n\t\t\t\t'name': clip.name,\n\t\t\t\t'duration': clip.duration,\n\t\t\t\t'tracks': tracks,\n\t\t\t\t'uuid': clip.uuid,\n\t\t\t\t'blendMode': clip.blendMode\n\t\t\t};\n\n\t\t\tfor (let i = 0, n = clipTracks.length; i !== n; ++i) {\n\t\t\t\ttracks.push(KeyframeTrack.toJSON(clipTracks[i]));\n\t\t\t}\n\n\t\t\treturn json;\n\t\t}\n\n\t\tstatic CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {\n\t\t\tconst numMorphTargets = morphTargetSequence.length;\n\t\t\tconst tracks = [];\n\n\t\t\tfor (let i = 0; i < numMorphTargets; i++) {\n\t\t\t\tlet times = [];\n\t\t\t\tlet values = [];\n\t\t\t\ttimes.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);\n\t\t\t\tvalues.push(0, 1, 0);\n\t\t\t\tconst order = AnimationUtils.getKeyframeOrder(times);\n\t\t\t\ttimes = AnimationUtils.sortedArray(times, 1, order);\n\t\t\t\tvalues = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the\n\t\t\t\t// last frame as well for perfect loop.\n\n\t\t\t\tif (!noLoop && times[0] === 0) {\n\t\t\t\t\ttimes.push(numMorphTargets);\n\t\t\t\t\tvalues.push(values[0]);\n\t\t\t\t}\n\n\t\t\t\ttracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));\n\t\t\t}\n\n\t\t\treturn new this(name, -1, tracks);\n\t\t}\n\n\t\tstatic findByName(objectOrClipArray, name) {\n\t\t\tlet clipArray = objectOrClipArray;\n\n\t\t\tif (!Array.isArray(objectOrClipArray)) {\n\t\t\t\tconst o = objectOrClipArray;\n\t\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < clipArray.length; i++) {\n\t\t\t\tif (clipArray[i].name === name) {\n\t\t\t\t\treturn clipArray[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tstatic CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {\n\t\t\tconst animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences\n\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\n\t\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/; // sort morph target names into animation groups based\n\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\n\t\t\tfor (let i = 0, il = morphTargets.length; i < il; i++) {\n\t\t\t\tconst morphTarget = morphTargets[i];\n\t\t\t\tconst parts = morphTarget.name.match(pattern);\n\n\t\t\t\tif (parts && parts.length > 1) {\n\t\t\t\t\tconst name = parts[1];\n\t\t\t\t\tlet animationMorphTargets = animationToMorphTargets[name];\n\n\t\t\t\t\tif (!animationMorphTargets) {\n\t\t\t\t\t\tanimationToMorphTargets[name] = animationMorphTargets = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationMorphTargets.push(morphTarget);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst clips = [];\n\n\t\t\tfor (const name in animationToMorphTargets) {\n\t\t\t\tclips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));\n\t\t\t}\n\n\t\t\treturn clips;\n\t\t} // parse the animation.hierarchy format\n\n\n\t\tstatic parseAnimation(animation, bones) {\n\t\t\tif (!animation) {\n\t\t\t\tconsole.error('THREE.AnimationClip: No animation in JSONLoader data.');\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {\n\t\t\t\t// only return track if there are actually keys.\n\t\t\t\tif (animationKeys.length !== 0) {\n\t\t\t\t\tconst times = [];\n\t\t\t\t\tconst values = [];\n\t\t\t\t\tAnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again\n\n\t\t\t\t\tif (times.length !== 0) {\n\t\t\t\t\t\tdestTracks.push(new trackType(trackName, times, values));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst tracks = [];\n\t\t\tconst clipName = animation.name || 'default';\n\t\t\tconst fps = animation.fps || 30;\n\t\t\tconst blendMode = animation.blendMode; // automatic length determination in AnimationClip.\n\n\t\t\tlet duration = animation.length || -1;\n\t\t\tconst hierarchyTracks = animation.hierarchy || [];\n\n\t\t\tfor (let h = 0; h < hierarchyTracks.length; h++) {\n\t\t\t\tconst animationKeys = hierarchyTracks[h].keys; // skip empty tracks\n\n\t\t\t\tif (!animationKeys || animationKeys.length === 0) continue; // process morph targets\n\n\t\t\t\tif (animationKeys[0].morphTargets) {\n\t\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\t\tconst morphTargetNames = {};\n\t\t\t\t\tlet k;\n\n\t\t\t\t\tfor (k = 0; k < animationKeys.length; k++) {\n\t\t\t\t\t\tif (animationKeys[k].morphTargets) {\n\t\t\t\t\t\t\tfor (let m = 0; m < animationKeys[k].morphTargets.length; m++) {\n\t\t\t\t\t\t\t\tmorphTargetNames[animationKeys[k].morphTargets[m]] = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} // create a track for each morph target with all zero\n\t\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t\t// the morphTarget is named.\n\n\n\t\t\t\t\tfor (const morphTargetName in morphTargetNames) {\n\t\t\t\t\t\tconst times = [];\n\t\t\t\t\t\tconst values = [];\n\n\t\t\t\t\t\tfor (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {\n\t\t\t\t\t\t\tconst animationKey = animationKeys[k];\n\t\t\t\t\t\t\ttimes.push(animationKey.time);\n\t\t\t\t\t\t\tvalues.push(animationKey.morphTarget === morphTargetName ? 1 : 0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));\n\t\t\t\t\t}\n\n\t\t\t\t\tduration = morphTargetNames.length * (fps || 1.0);\n\t\t\t\t} else {\n\t\t\t\t\t// ...assume skeletal animation\n\t\t\t\t\tconst boneName = '.bones[' + bones[h].name + ']';\n\t\t\t\t\taddNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);\n\t\t\t\t\taddNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);\n\t\t\t\t\taddNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tracks.length === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst clip = new this(clipName, duration, tracks, blendMode);\n\t\t\treturn clip;\n\t\t}\n\n\t\tresetDuration() {\n\t\t\tconst tracks = this.tracks;\n\t\t\tlet duration = 0;\n\n\t\t\tfor (let i = 0, n = tracks.length; i !== n; ++i) {\n\t\t\t\tconst track = this.tracks[i];\n\t\t\t\tduration = Math.max(duration, track.times[track.times.length - 1]);\n\t\t\t}\n\n\t\t\tthis.duration = duration;\n\t\t\treturn this;\n\t\t}\n\n\t\ttrim() {\n\t\t\tfor (let i = 0; i < this.tracks.length; i++) {\n\t\t\t\tthis.tracks[i].trim(0, this.duration);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tvalidate() {\n\t\t\tlet valid = true;\n\n\t\t\tfor (let i = 0; i < this.tracks.length; i++) {\n\t\t\t\tvalid = valid && this.tracks[i].validate();\n\t\t\t}\n\n\t\t\treturn valid;\n\t\t}\n\n\t\toptimize() {\n\t\t\tfor (let i = 0; i < this.tracks.length; i++) {\n\t\t\t\tthis.tracks[i].optimize();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\tconst tracks = [];\n\n\t\t\tfor (let i = 0; i < this.tracks.length; i++) {\n\t\t\t\ttracks.push(this.tracks[i].clone());\n\t\t\t}\n\n\t\t\treturn new this.constructor(this.name, this.duration, tracks, this.blendMode);\n\t\t}\n\n\t\ttoJSON() {\n\t\t\treturn this.constructor.toJSON(this);\n\t\t}\n\n\t}\n\n\tfunction getTrackTypeForValueTypeName(typeName) {\n\t\tswitch (typeName.toLowerCase()) {\n\t\t\tcase 'scalar':\n\t\t\tcase 'double':\n\t\t\tcase 'float':\n\t\t\tcase 'number':\n\t\t\tcase 'integer':\n\t\t\t\treturn NumberKeyframeTrack;\n\n\t\t\tcase 'vector':\n\t\t\tcase 'vector2':\n\t\t\tcase 'vector3':\n\t\t\tcase 'vector4':\n\t\t\t\treturn VectorKeyframeTrack;\n\n\t\t\tcase 'color':\n\t\t\t\treturn ColorKeyframeTrack;\n\n\t\t\tcase 'quaternion':\n\t\t\t\treturn QuaternionKeyframeTrack;\n\n\t\t\tcase 'bool':\n\t\t\tcase 'boolean':\n\t\t\t\treturn BooleanKeyframeTrack;\n\n\t\t\tcase 'string':\n\t\t\t\treturn StringKeyframeTrack;\n\t\t}\n\n\t\tthrow new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);\n\t}\n\n\tfunction parseKeyframeTrack(json) {\n\t\tif (json.type === undefined) {\n\t\t\tthrow new Error('THREE.KeyframeTrack: track type undefined, can not parse');\n\t\t}\n\n\t\tconst trackType = getTrackTypeForValueTypeName(json.type);\n\n\t\tif (json.times === undefined) {\n\t\t\tconst times = [],\n\t\t\t\t\t\tvalues = [];\n\t\t\tAnimationUtils.flattenJSON(json.keys, times, values, 'value');\n\t\t\tjson.times = times;\n\t\t\tjson.values = values;\n\t\t} // derived classes can define a static parse method\n\n\n\t\tif (trackType.parse !== undefined) {\n\t\t\treturn trackType.parse(json);\n\t\t} else {\n\t\t\t// by default, we assume a constructor compatible with the base\n\t\t\treturn new trackType(json.name, json.times, json.values, json.interpolation);\n\t\t}\n\t}\n\n\tconst Cache = {\n\t\tenabled: false,\n\t\tfiles: {},\n\t\tadd: function (key, file) {\n\t\t\tif (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\t\tthis.files[key] = file;\n\t\t},\n\t\tget: function (key) {\n\t\t\tif (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\t\treturn this.files[key];\n\t\t},\n\t\tremove: function (key) {\n\t\t\tdelete this.files[key];\n\t\t},\n\t\tclear: function () {\n\t\t\tthis.files = {};\n\t\t}\n\t};\n\n\tclass LoadingManager {\n\t\tconstructor(onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tlet isLoading = false;\n\t\t\tlet itemsLoaded = 0;\n\t\t\tlet itemsTotal = 0;\n\t\t\tlet urlModifier = undefined;\n\t\t\tconst handlers = []; // Refer to #5689 for the reason why we don't set .onStart\n\t\t\t// in the constructor\n\n\t\t\tthis.onStart = undefined;\n\t\t\tthis.onLoad = onLoad;\n\t\t\tthis.onProgress = onProgress;\n\t\t\tthis.onError = onError;\n\n\t\t\tthis.itemStart = function (url) {\n\t\t\t\titemsTotal++;\n\n\t\t\t\tif (isLoading === false) {\n\t\t\t\t\tif (scope.onStart !== undefined) {\n\t\t\t\t\t\tscope.onStart(url, itemsLoaded, itemsTotal);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tisLoading = true;\n\t\t\t};\n\n\t\t\tthis.itemEnd = function (url) {\n\t\t\t\titemsLoaded++;\n\n\t\t\t\tif (scope.onProgress !== undefined) {\n\t\t\t\t\tscope.onProgress(url, itemsLoaded, itemsTotal);\n\t\t\t\t}\n\n\t\t\t\tif (itemsLoaded === itemsTotal) {\n\t\t\t\t\tisLoading = false;\n\n\t\t\t\t\tif (scope.onLoad !== undefined) {\n\t\t\t\t\t\tscope.onLoad();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.itemError = function (url) {\n\t\t\t\tif (scope.onError !== undefined) {\n\t\t\t\t\tscope.onError(url);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.resolveURL = function (url) {\n\t\t\t\tif (urlModifier) {\n\t\t\t\t\treturn urlModifier(url);\n\t\t\t\t}\n\n\t\t\t\treturn url;\n\t\t\t};\n\n\t\t\tthis.setURLModifier = function (transform) {\n\t\t\t\turlModifier = transform;\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tthis.addHandler = function (regex, loader) {\n\t\t\t\thandlers.push(regex, loader);\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tthis.removeHandler = function (regex) {\n\t\t\t\tconst index = handlers.indexOf(regex);\n\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\thandlers.splice(index, 2);\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\tthis.getHandler = function (file) {\n\t\t\t\tfor (let i = 0, l = handlers.length; i < l; i += 2) {\n\t\t\t\t\tconst regex = handlers[i];\n\t\t\t\t\tconst loader = handlers[i + 1];\n\t\t\t\t\tif (regex.global) regex.lastIndex = 0; // see #17920\n\n\t\t\t\t\tif (regex.test(file)) {\n\t\t\t\t\t\treturn loader;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t};\n\t\t}\n\n\t}\n\n\tconst DefaultLoadingManager = new LoadingManager();\n\n\tclass Loader {\n\t\tconstructor(manager) {\n\t\t\tthis.manager = manager !== undefined ? manager : DefaultLoadingManager;\n\t\t\tthis.crossOrigin = 'anonymous';\n\t\t\tthis.withCredentials = false;\n\t\t\tthis.path = '';\n\t\t\tthis.resourcePath = '';\n\t\t\tthis.requestHeader = {};\n\t\t}\n\n\t\tload()\n\t\t/* url, onLoad, onProgress, onError */\n\t\t{}\n\n\t\tloadAsync(url, onProgress) {\n\t\t\tconst scope = this;\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tscope.load(url, resolve, onProgress, reject);\n\t\t\t});\n\t\t}\n\n\t\tparse()\n\t\t/* data */\n\t\t{}\n\n\t\tsetCrossOrigin(crossOrigin) {\n\t\t\tthis.crossOrigin = crossOrigin;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetWithCredentials(value) {\n\t\t\tthis.withCredentials = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetPath(path) {\n\t\t\tthis.path = path;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetResourcePath(resourcePath) {\n\t\t\tthis.resourcePath = resourcePath;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetRequestHeader(requestHeader) {\n\t\t\tthis.requestHeader = requestHeader;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tconst loading = {};\n\n\tclass FileLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tif (url === undefined) url = '';\n\t\t\tif (this.path !== undefined) url = this.path + url;\n\t\t\turl = this.manager.resolveURL(url);\n\t\t\tconst scope = this;\n\t\t\tconst cached = Cache.get(url);\n\n\t\t\tif (cached !== undefined) {\n\t\t\t\tscope.manager.itemStart(url);\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tif (onLoad) onLoad(cached);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, 0);\n\t\t\t\treturn cached;\n\t\t\t} // Check if request is duplicate\n\n\n\t\t\tif (loading[url] !== undefined) {\n\t\t\t\tloading[url].push({\n\t\t\t\t\tonLoad: onLoad,\n\t\t\t\t\tonProgress: onProgress,\n\t\t\t\t\tonError: onError\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t} // Check for data: URI\n\n\n\t\t\tconst dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n\t\t\tconst dataUriRegexResult = url.match(dataUriRegex);\n\t\t\tlet request; // Safari can not handle Data URIs through XMLHttpRequest so process manually\n\n\t\t\tif (dataUriRegexResult) {\n\t\t\t\tconst mimeType = dataUriRegexResult[1];\n\t\t\t\tconst isBase64 = !!dataUriRegexResult[2];\n\t\t\t\tlet data = dataUriRegexResult[3];\n\t\t\t\tdata = decodeURIComponent(data);\n\t\t\t\tif (isBase64) data = atob(data);\n\n\t\t\t\ttry {\n\t\t\t\t\tlet response;\n\t\t\t\t\tconst responseType = (this.responseType || '').toLowerCase();\n\n\t\t\t\t\tswitch (responseType) {\n\t\t\t\t\t\tcase 'arraybuffer':\n\t\t\t\t\t\tcase 'blob':\n\t\t\t\t\t\t\tconst view = new Uint8Array(data.length);\n\n\t\t\t\t\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\t\t\t\t\tview[i] = data.charCodeAt(i);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (responseType === 'blob') {\n\t\t\t\t\t\t\t\tresponse = new Blob([view.buffer], {\n\t\t\t\t\t\t\t\t\ttype: mimeType\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresponse = view.buffer;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'document':\n\t\t\t\t\t\t\tconst parser = new DOMParser();\n\t\t\t\t\t\t\tresponse = parser.parseFromString(data, mimeType);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'json':\n\t\t\t\t\t\t\tresponse = JSON.parse(data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// 'text' or other\n\t\t\t\t\t\t\tresponse = data;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\n\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tif (onLoad) onLoad(response);\n\t\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t\t}, 0);\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tif (onError) onError(error);\n\t\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Initialise array for duplicate requests\n\t\t\t\tloading[url] = [];\n\t\t\t\tloading[url].push({\n\t\t\t\t\tonLoad: onLoad,\n\t\t\t\t\tonProgress: onProgress,\n\t\t\t\t\tonError: onError\n\t\t\t\t});\n\t\t\t\trequest = new XMLHttpRequest();\n\t\t\t\trequest.open('GET', url, true);\n\t\t\t\trequest.addEventListener('load', function (event) {\n\t\t\t\t\tconst response = this.response;\n\t\t\t\t\tconst callbacks = loading[url];\n\t\t\t\t\tdelete loading[url];\n\n\t\t\t\t\tif (this.status === 200 || this.status === 0) {\n\t\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\t\t\t\t\t\tif (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.'); // Add to cache only on HTTP success, so that we do not cache\n\t\t\t\t\t\t// error response bodies as proper responses to requests.\n\n\t\t\t\t\t\tCache.add(url, response);\n\n\t\t\t\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n\t\t\t\t\t\t\tconst callback = callbacks[i];\n\t\t\t\t\t\t\tif (callback.onLoad) callback.onLoad(response);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n\t\t\t\t\t\t\tconst callback = callbacks[i];\n\t\t\t\t\t\t\tif (callback.onError) callback.onError(event);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t\t}\n\t\t\t\t}, false);\n\t\t\t\trequest.addEventListener('progress', function (event) {\n\t\t\t\t\tconst callbacks = loading[url];\n\n\t\t\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n\t\t\t\t\t\tconst callback = callbacks[i];\n\t\t\t\t\t\tif (callback.onProgress) callback.onProgress(event);\n\t\t\t\t\t}\n\t\t\t\t}, false);\n\t\t\t\trequest.addEventListener('error', function (event) {\n\t\t\t\t\tconst callbacks = loading[url];\n\t\t\t\t\tdelete loading[url];\n\n\t\t\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n\t\t\t\t\t\tconst callback = callbacks[i];\n\t\t\t\t\t\tif (callback.onError) callback.onError(event);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, false);\n\t\t\t\trequest.addEventListener('abort', function (event) {\n\t\t\t\t\tconst callbacks = loading[url];\n\t\t\t\t\tdelete loading[url];\n\n\t\t\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n\t\t\t\t\t\tconst callback = callbacks[i];\n\t\t\t\t\t\tif (callback.onError) callback.onError(event);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, false);\n\t\t\t\tif (this.responseType !== undefined) request.responseType = this.responseType;\n\t\t\t\tif (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;\n\t\t\t\tif (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');\n\n\t\t\t\tfor (const header in this.requestHeader) {\n\t\t\t\t\trequest.setRequestHeader(header, this.requestHeader[header]);\n\t\t\t\t}\n\n\t\t\t\trequest.send(null);\n\t\t\t}\n\n\t\t\tscope.manager.itemStart(url);\n\t\t\treturn request;\n\t\t}\n\n\t\tsetResponseType(value) {\n\t\t\tthis.responseType = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetMimeType(value) {\n\t\t\tthis.mimeType = value;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass AnimationLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setWithCredentials(this.withCredentials);\n\t\t\tloader.load(url, function (text) {\n\t\t\t\ttry {\n\t\t\t\t\tonLoad(scope.parse(JSON.parse(text)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onError) {\n\t\t\t\t\t\tonError(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t\tparse(json) {\n\t\t\tconst animations = [];\n\n\t\t\tfor (let i = 0; i < json.length; i++) {\n\t\t\t\tconst clip = AnimationClip.parse(json[i]);\n\t\t\t\tanimations.push(clip);\n\t\t\t}\n\n\t\t\treturn animations;\n\t\t}\n\n\t}\n\n\t/**\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\n\t *\n\t * Sub classes have to implement the parse() method which will be used in load().\n\t */\n\n\tclass CompressedTextureLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst images = [];\n\t\t\tconst texture = new CompressedTexture();\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setResponseType('arraybuffer');\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setWithCredentials(scope.withCredentials);\n\t\t\tlet loaded = 0;\n\n\t\t\tfunction loadTexture(i) {\n\t\t\t\tloader.load(url[i], function (buffer) {\n\t\t\t\t\tconst texDatas = scope.parse(buffer, true);\n\t\t\t\t\timages[i] = {\n\t\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t\t};\n\t\t\t\t\tloaded += 1;\n\n\t\t\t\t\tif (loaded === 6) {\n\t\t\t\t\t\tif (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;\n\t\t\t\t\t\ttexture.image = images;\n\t\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\t\tif (onLoad) onLoad(texture);\n\t\t\t\t\t}\n\t\t\t\t}, onProgress, onError);\n\t\t\t}\n\n\t\t\tif (Array.isArray(url)) {\n\t\t\t\tfor (let i = 0, il = url.length; i < il; ++i) {\n\t\t\t\t\tloadTexture(i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// compressed cubemap texture stored in a single DDS file\n\t\t\t\tloader.load(url, function (buffer) {\n\t\t\t\t\tconst texDatas = scope.parse(buffer, true);\n\n\t\t\t\t\tif (texDatas.isCubemap) {\n\t\t\t\t\t\tconst faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\t\tfor (let f = 0; f < faces; f++) {\n\t\t\t\t\t\t\timages[f] = {\n\t\t\t\t\t\t\t\tmipmaps: []\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tfor (let i = 0; i < texDatas.mipmapCount; i++) {\n\t\t\t\t\t\t\t\timages[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);\n\t\t\t\t\t\t\t\timages[f].format = texDatas.format;\n\t\t\t\t\t\t\t\timages[f].width = texDatas.width;\n\t\t\t\t\t\t\t\timages[f].height = texDatas.height;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttexture.image = images;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (texDatas.mipmapCount === 1) {\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\tif (onLoad) onLoad(texture);\n\t\t\t\t}, onProgress, onError);\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t}\n\n\t}\n\n\tclass ImageLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tif (this.path !== undefined) url = this.path + url;\n\t\t\turl = this.manager.resolveURL(url);\n\t\t\tconst scope = this;\n\t\t\tconst cached = Cache.get(url);\n\n\t\t\tif (cached !== undefined) {\n\t\t\t\tscope.manager.itemStart(url);\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tif (onLoad) onLoad(cached);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, 0);\n\t\t\t\treturn cached;\n\t\t\t}\n\n\t\t\tconst image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');\n\n\t\t\tfunction onImageLoad() {\n\t\t\t\timage.removeEventListener('load', onImageLoad, false);\n\t\t\t\timage.removeEventListener('error', onImageError, false);\n\t\t\t\tCache.add(url, this);\n\t\t\t\tif (onLoad) onLoad(this);\n\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t}\n\n\t\t\tfunction onImageError(event) {\n\t\t\t\timage.removeEventListener('load', onImageLoad, false);\n\t\t\t\timage.removeEventListener('error', onImageError, false);\n\t\t\t\tif (onError) onError(event);\n\t\t\t\tscope.manager.itemError(url);\n\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t}\n\n\t\t\timage.addEventListener('load', onImageLoad, false);\n\t\t\timage.addEventListener('error', onImageError, false);\n\n\t\t\tif (url.substr(0, 5) !== 'data:') {\n\t\t\t\tif (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;\n\t\t\t}\n\n\t\t\tscope.manager.itemStart(url);\n\t\t\timage.src = url;\n\t\t\treturn image;\n\t\t}\n\n\t}\n\n\tclass CubeTextureLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(urls, onLoad, onProgress, onError) {\n\t\t\tconst texture = new CubeTexture();\n\t\t\tconst loader = new ImageLoader(this.manager);\n\t\t\tloader.setCrossOrigin(this.crossOrigin);\n\t\t\tloader.setPath(this.path);\n\t\t\tlet loaded = 0;\n\n\t\t\tfunction loadTexture(i) {\n\t\t\t\tloader.load(urls[i], function (image) {\n\t\t\t\t\ttexture.images[i] = image;\n\t\t\t\t\tloaded++;\n\n\t\t\t\t\tif (loaded === 6) {\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\t\tif (onLoad) onLoad(texture);\n\t\t\t\t\t}\n\t\t\t\t}, undefined, onError);\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < urls.length; ++i) {\n\t\t\t\tloadTexture(i);\n\t\t\t}\n\n\t\t\treturn texture;\n\t\t}\n\n\t}\n\n\t/**\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n\t *\n\t * Sub classes have to implement the parse() method which will be used in load().\n\t */\n\n\tclass DataTextureLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst texture = new DataTexture();\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setResponseType('arraybuffer');\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setWithCredentials(scope.withCredentials);\n\t\t\tloader.load(url, function (buffer) {\n\t\t\t\tconst texData = scope.parse(buffer);\n\t\t\t\tif (!texData) return;\n\n\t\t\t\tif (texData.image !== undefined) {\n\t\t\t\t\ttexture.image = texData.image;\n\t\t\t\t} else if (texData.data !== undefined) {\n\t\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\t\ttexture.image.data = texData.data;\n\t\t\t\t}\n\n\t\t\t\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\t\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n\t\t\t\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n\t\t\t\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n\t\t\t\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n\t\t\t\tif (texData.encoding !== undefined) {\n\t\t\t\t\ttexture.encoding = texData.encoding;\n\t\t\t\t}\n\n\t\t\t\tif (texData.flipY !== undefined) {\n\t\t\t\t\ttexture.flipY = texData.flipY;\n\t\t\t\t}\n\n\t\t\t\tif (texData.format !== undefined) {\n\t\t\t\t\ttexture.format = texData.format;\n\t\t\t\t}\n\n\t\t\t\tif (texData.type !== undefined) {\n\t\t\t\t\ttexture.type = texData.type;\n\t\t\t\t}\n\n\t\t\t\tif (texData.mipmaps !== undefined) {\n\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\t\t\t\ttexture.minFilter = LinearMipmapLinearFilter; // presumably...\n\t\t\t\t}\n\n\t\t\t\tif (texData.mipmapCount === 1) {\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t}\n\n\t\t\t\tif (texData.generateMipmaps !== undefined) {\n\t\t\t\t\ttexture.generateMipmaps = texData.generateMipmaps;\n\t\t\t\t}\n\n\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\tif (onLoad) onLoad(texture, texData);\n\t\t\t}, onProgress, onError);\n\t\t\treturn texture;\n\t\t}\n\n\t}\n\n\tclass TextureLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst texture = new Texture();\n\t\t\tconst loader = new ImageLoader(this.manager);\n\t\t\tloader.setCrossOrigin(this.crossOrigin);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.load(url, function (image) {\n\t\t\t\ttexture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\n\t\t\t\tconst isJPEG = url.search(/\\.jpe?g($|\\?)/i) > 0 || url.search(/^data\\:image\\/jpeg/) === 0;\n\t\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif (onLoad !== undefined) {\n\t\t\t\t\tonLoad(texture);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t\treturn texture;\n\t\t}\n\n\t}\n\n\t/**\n\t * Extensible curve object.\n\t *\n\t * Some common of curve methods:\n\t * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n\t * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n\t * .getPoints(), .getSpacedPoints()\n\t * .getLength()\n\t * .updateArcLengths()\n\t *\n\t * This following curves inherit from THREE.Curve:\n\t *\n\t * -- 2D curves --\n\t * THREE.ArcCurve\n\t * THREE.CubicBezierCurve\n\t * THREE.EllipseCurve\n\t * THREE.LineCurve\n\t * THREE.QuadraticBezierCurve\n\t * THREE.SplineCurve\n\t *\n\t * -- 3D curves --\n\t * THREE.CatmullRomCurve3\n\t * THREE.CubicBezierCurve3\n\t * THREE.LineCurve3\n\t * THREE.QuadraticBezierCurve3\n\t *\n\t * A series of curves can be represented as a THREE.CurvePath.\n\t *\n\t **/\n\n\tclass Curve {\n\t\tconstructor() {\n\t\t\tthis.type = 'Curve';\n\t\t\tthis.arcLengthDivisions = 200;\n\t\t} // Virtual base class method to overwrite and implement in subclasses\n\t\t//\t- t [0 .. 1]\n\n\n\t\tgetPoint()\n\t\t/* t, optionalTarget */\n\t\t{\n\t\t\tconsole.warn('THREE.Curve: .getPoint() not implemented.');\n\t\t\treturn null;\n\t\t} // Get point at relative position in curve according to arc length\n\t\t// - u [0 .. 1]\n\n\n\t\tgetPointAt(u, optionalTarget) {\n\t\t\tconst t = this.getUtoTmapping(u);\n\t\t\treturn this.getPoint(t, optionalTarget);\n\t\t} // Get sequence of points using getPoint( t )\n\n\n\t\tgetPoints(divisions = 5) {\n\t\t\tconst points = [];\n\n\t\t\tfor (let d = 0; d <= divisions; d++) {\n\t\t\t\tpoints.push(this.getPoint(d / divisions));\n\t\t\t}\n\n\t\t\treturn points;\n\t\t} // Get sequence of points using getPointAt( u )\n\n\n\t\tgetSpacedPoints(divisions = 5) {\n\t\t\tconst points = [];\n\n\t\t\tfor (let d = 0; d <= divisions; d++) {\n\t\t\t\tpoints.push(this.getPointAt(d / divisions));\n\t\t\t}\n\n\t\t\treturn points;\n\t\t} // Get total curve arc length\n\n\n\t\tgetLength() {\n\t\t\tconst lengths = this.getLengths();\n\t\t\treturn lengths[lengths.length - 1];\n\t\t} // Get list of cumulative segment lengths\n\n\n\t\tgetLengths(divisions = this.arcLengthDivisions) {\n\t\t\tif (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n\t\t\t\treturn this.cacheArcLengths;\n\t\t\t}\n\n\t\t\tthis.needsUpdate = false;\n\t\t\tconst cache = [];\n\t\t\tlet current,\n\t\t\t\t\tlast = this.getPoint(0);\n\t\t\tlet sum = 0;\n\t\t\tcache.push(0);\n\n\t\t\tfor (let p = 1; p <= divisions; p++) {\n\t\t\t\tcurrent = this.getPoint(p / divisions);\n\t\t\t\tsum += current.distanceTo(last);\n\t\t\t\tcache.push(sum);\n\t\t\t\tlast = current;\n\t\t\t}\n\n\t\t\tthis.cacheArcLengths = cache;\n\t\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\t\t}\n\n\t\tupdateArcLengths() {\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.getLengths();\n\t\t} // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\n\t\tgetUtoTmapping(u, distance) {\n\t\t\tconst arcLengths = this.getLengths();\n\t\t\tlet i = 0;\n\t\t\tconst il = arcLengths.length;\n\t\t\tlet targetArcLength; // The targeted u distance value to get\n\n\t\t\tif (distance) {\n\t\t\t\ttargetArcLength = distance;\n\t\t\t} else {\n\t\t\t\ttargetArcLength = u * arcLengths[il - 1];\n\t\t\t} // binary search for the index with largest value smaller than target u distance\n\n\n\t\t\tlet low = 0,\n\t\t\t\t\thigh = il - 1,\n\t\t\t\t\tcomparison;\n\n\t\t\twhile (low <= high) {\n\t\t\t\ti = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\t\tcomparison = arcLengths[i] - targetArcLength;\n\n\t\t\t\tif (comparison < 0) {\n\t\t\t\t\tlow = i + 1;\n\t\t\t\t} else if (comparison > 0) {\n\t\t\t\t\thigh = i - 1;\n\t\t\t\t} else {\n\t\t\t\t\thigh = i;\n\t\t\t\t\tbreak; // DONE\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = high;\n\n\t\t\tif (arcLengths[i] === targetArcLength) {\n\t\t\t\treturn i / (il - 1);\n\t\t\t} // we could get finer grain at lengths, or use simple interpolation between two points\n\n\n\t\t\tconst lengthBefore = arcLengths[i];\n\t\t\tconst lengthAfter = arcLengths[i + 1];\n\t\t\tconst segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points\n\n\t\t\tconst segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t\n\n\t\t\tconst t = (i + segmentFraction) / (il - 1);\n\t\t\treturn t;\n\t\t} // Returns a unit vector tangent at t\n\t\t// In case any sub curve does not implement its tangent derivation,\n\t\t// 2 points a small delta apart will be used to find its gradient\n\t\t// which seems to give a reasonable approximation\n\n\n\t\tgetTangent(t, optionalTarget) {\n\t\t\tconst delta = 0.0001;\n\t\t\tlet t1 = t - delta;\n\t\t\tlet t2 = t + delta; // Capping in case of danger\n\n\t\t\tif (t1 < 0) t1 = 0;\n\t\t\tif (t2 > 1) t2 = 1;\n\t\t\tconst pt1 = this.getPoint(t1);\n\t\t\tconst pt2 = this.getPoint(t2);\n\t\t\tconst tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());\n\t\t\ttangent.copy(pt2).sub(pt1).normalize();\n\t\t\treturn tangent;\n\t\t}\n\n\t\tgetTangentAt(u, optionalTarget) {\n\t\t\tconst t = this.getUtoTmapping(u);\n\t\t\treturn this.getTangent(t, optionalTarget);\n\t\t}\n\n\t\tcomputeFrenetFrames(segments, closed) {\n\t\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\t\t\tconst normal = new Vector3();\n\t\t\tconst tangents = [];\n\t\t\tconst normals = [];\n\t\t\tconst binormals = [];\n\t\t\tconst vec = new Vector3();\n\t\t\tconst mat = new Matrix4(); // compute the tangent vectors for each segment on the curve\n\n\t\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\t\tconst u = i / segments;\n\t\t\t\ttangents[i] = this.getTangentAt(u, new Vector3());\n\t\t\t\ttangents[i].normalize();\n\t\t\t} // select an initial normal vector perpendicular to the first tangent vector,\n\t\t\t// and in the direction of the minimum tangent xyz component\n\n\n\t\t\tnormals[0] = new Vector3();\n\t\t\tbinormals[0] = new Vector3();\n\t\t\tlet min = Number.MAX_VALUE;\n\t\t\tconst tx = Math.abs(tangents[0].x);\n\t\t\tconst ty = Math.abs(tangents[0].y);\n\t\t\tconst tz = Math.abs(tangents[0].z);\n\n\t\t\tif (tx <= min) {\n\t\t\t\tmin = tx;\n\t\t\t\tnormal.set(1, 0, 0);\n\t\t\t}\n\n\t\t\tif (ty <= min) {\n\t\t\t\tmin = ty;\n\t\t\t\tnormal.set(0, 1, 0);\n\t\t\t}\n\n\t\t\tif (tz <= min) {\n\t\t\t\tnormal.set(0, 0, 1);\n\t\t\t}\n\n\t\t\tvec.crossVectors(tangents[0], normal).normalize();\n\t\t\tnormals[0].crossVectors(tangents[0], vec);\n\t\t\tbinormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\t\tfor (let i = 1; i <= segments; i++) {\n\t\t\t\tnormals[i] = normals[i - 1].clone();\n\t\t\t\tbinormals[i] = binormals[i - 1].clone();\n\t\t\t\tvec.crossVectors(tangents[i - 1], tangents[i]);\n\n\t\t\t\tif (vec.length() > Number.EPSILON) {\n\t\t\t\t\tvec.normalize();\n\t\t\t\t\tconst theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors\n\n\t\t\t\t\tnormals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\n\t\t\t\t}\n\n\t\t\t\tbinormals[i].crossVectors(tangents[i], normals[i]);\n\t\t\t} // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\n\t\t\tif (closed === true) {\n\t\t\t\tlet theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));\n\t\t\t\ttheta /= segments;\n\n\t\t\t\tif (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {\n\t\t\t\t\ttheta = -theta;\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 1; i <= segments; i++) {\n\t\t\t\t\t// twist a little...\n\t\t\t\t\tnormals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\n\t\t\t\t\tbinormals[i].crossVectors(tangents[i], normals[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttangents: tangents,\n\t\t\t\tnormals: normals,\n\t\t\t\tbinormals: binormals\n\t\t\t};\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = {\n\t\t\t\tmetadata: {\n\t\t\t\t\tversion: 4.5,\n\t\t\t\t\ttype: 'Curve',\n\t\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t\t}\n\t\t\t};\n\t\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\t\tdata.type = this.type;\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass EllipseCurve extends Curve {\n\t\tconstructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {\n\t\t\tsuper();\n\t\t\tthis.type = 'EllipseCurve';\n\t\t\tthis.aX = aX;\n\t\t\tthis.aY = aY;\n\t\t\tthis.xRadius = xRadius;\n\t\t\tthis.yRadius = yRadius;\n\t\t\tthis.aStartAngle = aStartAngle;\n\t\t\tthis.aEndAngle = aEndAngle;\n\t\t\tthis.aClockwise = aClockwise;\n\t\t\tthis.aRotation = aRotation;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget) {\n\t\t\tconst point = optionalTarget || new Vector2();\n\t\t\tconst twoPi = Math.PI * 2;\n\t\t\tlet deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\t\tconst samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI\n\n\t\t\twhile (deltaAngle < 0) deltaAngle += twoPi;\n\n\t\t\twhile (deltaAngle > twoPi) deltaAngle -= twoPi;\n\n\t\t\tif (deltaAngle < Number.EPSILON) {\n\t\t\t\tif (samePoints) {\n\t\t\t\t\tdeltaAngle = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdeltaAngle = twoPi;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.aClockwise === true && !samePoints) {\n\t\t\t\tif (deltaAngle === twoPi) {\n\t\t\t\t\tdeltaAngle = -twoPi;\n\t\t\t\t} else {\n\t\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst angle = this.aStartAngle + t * deltaAngle;\n\t\t\tlet x = this.aX + this.xRadius * Math.cos(angle);\n\t\t\tlet y = this.aY + this.yRadius * Math.sin(angle);\n\n\t\t\tif (this.aRotation !== 0) {\n\t\t\t\tconst cos = Math.cos(this.aRotation);\n\t\t\t\tconst sin = Math.sin(this.aRotation);\n\t\t\t\tconst tx = x - this.aX;\n\t\t\t\tconst ty = y - this.aY; // Rotate the point about the center of the ellipse.\n\n\t\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\t\ty = tx * sin + ty * cos + this.aY;\n\t\t\t}\n\n\t\t\treturn point.set(x, y);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.aX = source.aX;\n\t\t\tthis.aY = source.aY;\n\t\t\tthis.xRadius = source.xRadius;\n\t\t\tthis.yRadius = source.yRadius;\n\t\t\tthis.aStartAngle = source.aStartAngle;\n\t\t\tthis.aEndAngle = source.aEndAngle;\n\t\t\tthis.aClockwise = source.aClockwise;\n\t\t\tthis.aRotation = source.aRotation;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.aX = this.aX;\n\t\t\tdata.aY = this.aY;\n\t\t\tdata.xRadius = this.xRadius;\n\t\t\tdata.yRadius = this.yRadius;\n\t\t\tdata.aStartAngle = this.aStartAngle;\n\t\t\tdata.aEndAngle = this.aEndAngle;\n\t\t\tdata.aClockwise = this.aClockwise;\n\t\t\tdata.aRotation = this.aRotation;\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.aX = json.aX;\n\t\t\tthis.aY = json.aY;\n\t\t\tthis.xRadius = json.xRadius;\n\t\t\tthis.yRadius = json.yRadius;\n\t\t\tthis.aStartAngle = json.aStartAngle;\n\t\t\tthis.aEndAngle = json.aEndAngle;\n\t\t\tthis.aClockwise = json.aClockwise;\n\t\t\tthis.aRotation = json.aRotation;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tEllipseCurve.prototype.isEllipseCurve = true;\n\n\tclass ArcCurve extends EllipseCurve {\n\t\tconstructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n\t\t\tsuper(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n\t\t\tthis.type = 'ArcCurve';\n\t\t}\n\n\t}\n\n\tArcCurve.prototype.isArcCurve = true;\n\n\t/**\n\t * Centripetal CatmullRom Curve - which is useful for avoiding\n\t * cusps and self-intersections in non-uniform catmull rom curves.\n\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n\t *\n\t * curve.type accepts centripetal(default), chordal and catmullrom\n\t * curve.tension is used for catmullrom which defaults to 0.5\n\t */\n\n\t/*\n\tBased on an optimized c++ solution in\n\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n\t - http://ideone.com/NoEbVM\n\n\tThis CubicPoly class could be used for reusing some variables and calculations,\n\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\n\twhich can be placed in CurveUtils.\n\t*/\n\n\tfunction CubicPoly() {\n\t\tlet c0 = 0,\n\t\t\t\tc1 = 0,\n\t\t\t\tc2 = 0,\n\t\t\t\tc3 = 0;\n\t\t/*\n\t\t * Compute coefficients for a cubic polynomial\n\t\t *\t p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t\t * such that\n\t\t *\t p(0) = x0, p(1) = x1\n\t\t *\tand\n\t\t *\t p'(0) = t0, p'(1) = t1.\n\t\t */\n\n\t\tfunction init(x0, x1, t0, t1) {\n\t\t\tc0 = x0;\n\t\t\tc1 = t0;\n\t\t\tc2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\t\t}\n\n\t\treturn {\n\t\t\tinitCatmullRom: function (x0, x1, x2, x3, tension) {\n\t\t\t\tinit(x1, x2, tension * (x2 - x0), tension * (x3 - x1));\n\t\t\t},\n\t\t\tinitNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {\n\t\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\t\tlet t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;\n\t\t\t\tlet t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]\n\n\t\t\t\tt1 *= dt1;\n\t\t\t\tt2 *= dt1;\n\t\t\t\tinit(x1, x2, t1, t2);\n\t\t\t},\n\t\t\tcalc: function (t) {\n\t\t\t\tconst t2 = t * t;\n\t\t\t\tconst t3 = t2 * t;\n\t\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\t\t\t}\n\t\t};\n\t} //\n\n\n\tconst tmp = new Vector3();\n\tconst px = new CubicPoly(),\n\t\t\t\tpy = new CubicPoly(),\n\t\t\t\tpz = new CubicPoly();\n\n\tclass CatmullRomCurve3 extends Curve {\n\t\tconstructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CatmullRomCurve3';\n\t\t\tthis.points = points;\n\t\t\tthis.closed = closed;\n\t\t\tthis.curveType = curveType;\n\t\t\tthis.tension = tension;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector3()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst points = this.points;\n\t\t\tconst l = points.length;\n\t\t\tconst p = (l - (this.closed ? 0 : 1)) * t;\n\t\t\tlet intPoint = Math.floor(p);\n\t\t\tlet weight = p - intPoint;\n\n\t\t\tif (this.closed) {\n\t\t\t\tintPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;\n\t\t\t} else if (weight === 0 && intPoint === l - 1) {\n\t\t\t\tintPoint = l - 2;\n\t\t\t\tweight = 1;\n\t\t\t}\n\n\t\t\tlet p0, p3; // 4 points (p1 & p2 defined below)\n\n\t\t\tif (this.closed || intPoint > 0) {\n\t\t\t\tp0 = points[(intPoint - 1) % l];\n\t\t\t} else {\n\t\t\t\t// extrapolate first point\n\t\t\t\ttmp.subVectors(points[0], points[1]).add(points[0]);\n\t\t\t\tp0 = tmp;\n\t\t\t}\n\n\t\t\tconst p1 = points[intPoint % l];\n\t\t\tconst p2 = points[(intPoint + 1) % l];\n\n\t\t\tif (this.closed || intPoint + 2 < l) {\n\t\t\t\tp3 = points[(intPoint + 2) % l];\n\t\t\t} else {\n\t\t\t\t// extrapolate last point\n\t\t\t\ttmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);\n\t\t\t\tp3 = tmp;\n\t\t\t}\n\n\t\t\tif (this.curveType === 'centripetal' || this.curveType === 'chordal') {\n\t\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\t\tconst pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\t\t\tlet dt0 = Math.pow(p0.distanceToSquared(p1), pow);\n\t\t\t\tlet dt1 = Math.pow(p1.distanceToSquared(p2), pow);\n\t\t\t\tlet dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points\n\n\t\t\t\tif (dt1 < 1e-4) dt1 = 1.0;\n\t\t\t\tif (dt0 < 1e-4) dt0 = dt1;\n\t\t\t\tif (dt2 < 1e-4) dt2 = dt1;\n\t\t\t\tpx.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);\n\t\t\t\tpy.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);\n\t\t\t\tpz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);\n\t\t\t} else if (this.curveType === 'catmullrom') {\n\t\t\t\tpx.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);\n\t\t\t\tpy.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);\n\t\t\t\tpz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);\n\t\t\t}\n\n\t\t\tpoint.set(px.calc(weight), py.calc(weight), pz.calc(weight));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.points = [];\n\n\t\t\tfor (let i = 0, l = source.points.length; i < l; i++) {\n\t\t\t\tconst point = source.points[i];\n\t\t\t\tthis.points.push(point.clone());\n\t\t\t}\n\n\t\t\tthis.closed = source.closed;\n\t\t\tthis.curveType = source.curveType;\n\t\t\tthis.tension = source.tension;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.points = [];\n\n\t\t\tfor (let i = 0, l = this.points.length; i < l; i++) {\n\t\t\t\tconst point = this.points[i];\n\t\t\t\tdata.points.push(point.toArray());\n\t\t\t}\n\n\t\t\tdata.closed = this.closed;\n\t\t\tdata.curveType = this.curveType;\n\t\t\tdata.tension = this.tension;\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.points = [];\n\n\t\t\tfor (let i = 0, l = json.points.length; i < l; i++) {\n\t\t\t\tconst point = json.points[i];\n\t\t\t\tthis.points.push(new Vector3().fromArray(point));\n\t\t\t}\n\n\t\t\tthis.closed = json.closed;\n\t\t\tthis.curveType = json.curveType;\n\t\t\tthis.tension = json.tension;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\n\n\t/**\n\t * Bezier Curves formulas obtained from\n\t * http://en.wikipedia.org/wiki/Bézier_curve\n\t */\n\tfunction CatmullRom(t, p0, p1, p2, p3) {\n\t\tconst v0 = (p2 - p0) * 0.5;\n\t\tconst v1 = (p3 - p1) * 0.5;\n\t\tconst t2 = t * t;\n\t\tconst t3 = t * t2;\n\t\treturn (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n\t} //\n\n\n\tfunction QuadraticBezierP0(t, p) {\n\t\tconst k = 1 - t;\n\t\treturn k * k * p;\n\t}\n\n\tfunction QuadraticBezierP1(t, p) {\n\t\treturn 2 * (1 - t) * t * p;\n\t}\n\n\tfunction QuadraticBezierP2(t, p) {\n\t\treturn t * t * p;\n\t}\n\n\tfunction QuadraticBezier(t, p0, p1, p2) {\n\t\treturn QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);\n\t} //\n\n\n\tfunction CubicBezierP0(t, p) {\n\t\tconst k = 1 - t;\n\t\treturn k * k * k * p;\n\t}\n\n\tfunction CubicBezierP1(t, p) {\n\t\tconst k = 1 - t;\n\t\treturn 3 * k * k * t * p;\n\t}\n\n\tfunction CubicBezierP2(t, p) {\n\t\treturn 3 * (1 - t) * t * t * p;\n\t}\n\n\tfunction CubicBezierP3(t, p) {\n\t\treturn t * t * t * p;\n\t}\n\n\tfunction CubicBezier(t, p0, p1, p2, p3) {\n\t\treturn CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);\n\t}\n\n\tclass CubicBezierCurve extends Curve {\n\t\tconstructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CubicBezierCurve';\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector2()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst v0 = this.v0,\n\t\t\t\t\t\tv1 = this.v1,\n\t\t\t\t\t\tv2 = this.v2,\n\t\t\t\t\t\tv3 = this.v3;\n\t\t\tpoint.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v0.copy(source.v0);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\tthis.v3.copy(source.v3);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v0 = this.v0.toArray();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\tdata.v3 = this.v3.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v0.fromArray(json.v0);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\tthis.v3.fromArray(json.v3);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tCubicBezierCurve.prototype.isCubicBezierCurve = true;\n\n\tclass CubicBezierCurve3 extends Curve {\n\t\tconstructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'CubicBezierCurve3';\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.v3 = v3;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector3()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst v0 = this.v0,\n\t\t\t\t\t\tv1 = this.v1,\n\t\t\t\t\t\tv2 = this.v2,\n\t\t\t\t\t\tv3 = this.v3;\n\t\t\tpoint.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v0.copy(source.v0);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\tthis.v3.copy(source.v3);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v0 = this.v0.toArray();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\tdata.v3 = this.v3.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v0.fromArray(json.v0);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\tthis.v3.fromArray(json.v3);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\n\n\tclass LineCurve extends Curve {\n\t\tconstructor(v1 = new Vector2(), v2 = new Vector2()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'LineCurve';\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector2()) {\n\t\t\tconst point = optionalTarget;\n\n\t\t\tif (t === 1) {\n\t\t\t\tpoint.copy(this.v2);\n\t\t\t} else {\n\t\t\t\tpoint.copy(this.v2).sub(this.v1);\n\t\t\t\tpoint.multiplyScalar(t).add(this.v1);\n\t\t\t}\n\n\t\t\treturn point;\n\t\t} // Line curve is linear, so we can overwrite default getPointAt\n\n\n\t\tgetPointAt(u, optionalTarget) {\n\t\t\treturn this.getPoint(u, optionalTarget);\n\t\t}\n\n\t\tgetTangent(t, optionalTarget) {\n\t\t\tconst tangent = optionalTarget || new Vector2();\n\t\t\ttangent.copy(this.v2).sub(this.v1).normalize();\n\t\t\treturn tangent;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tLineCurve.prototype.isLineCurve = true;\n\n\tclass LineCurve3 extends Curve {\n\t\tconstructor(v1 = new Vector3(), v2 = new Vector3()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'LineCurve3';\n\t\t\tthis.isLineCurve3 = true;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector3()) {\n\t\t\tconst point = optionalTarget;\n\n\t\t\tif (t === 1) {\n\t\t\t\tpoint.copy(this.v2);\n\t\t\t} else {\n\t\t\t\tpoint.copy(this.v2).sub(this.v1);\n\t\t\t\tpoint.multiplyScalar(t).add(this.v1);\n\t\t\t}\n\n\t\t\treturn point;\n\t\t} // Line curve is linear, so we can overwrite default getPointAt\n\n\n\t\tgetPointAt(u, optionalTarget) {\n\t\t\treturn this.getPoint(u, optionalTarget);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass QuadraticBezierCurve extends Curve {\n\t\tconstructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'QuadraticBezierCurve';\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector2()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst v0 = this.v0,\n\t\t\t\t\t\tv1 = this.v1,\n\t\t\t\t\t\tv2 = this.v2;\n\t\t\tpoint.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v0.copy(source.v0);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v0 = this.v0.toArray();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v0.fromArray(json.v0);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\n\n\tclass QuadraticBezierCurve3 extends Curve {\n\t\tconstructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {\n\t\t\tsuper();\n\t\t\tthis.type = 'QuadraticBezierCurve3';\n\t\t\tthis.v0 = v0;\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector3()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst v0 = this.v0,\n\t\t\t\t\t\tv1 = this.v1,\n\t\t\t\t\t\tv2 = this.v2;\n\t\t\tpoint.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.v0.copy(source.v0);\n\t\t\tthis.v1.copy(source.v1);\n\t\t\tthis.v2.copy(source.v2);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.v0 = this.v0.toArray();\n\t\t\tdata.v1 = this.v1.toArray();\n\t\t\tdata.v2 = this.v2.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.v0.fromArray(json.v0);\n\t\t\tthis.v1.fromArray(json.v1);\n\t\t\tthis.v2.fromArray(json.v2);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\n\n\tclass SplineCurve extends Curve {\n\t\tconstructor(points = []) {\n\t\t\tsuper();\n\t\t\tthis.type = 'SplineCurve';\n\t\t\tthis.points = points;\n\t\t}\n\n\t\tgetPoint(t, optionalTarget = new Vector2()) {\n\t\t\tconst point = optionalTarget;\n\t\t\tconst points = this.points;\n\t\t\tconst p = (points.length - 1) * t;\n\t\t\tconst intPoint = Math.floor(p);\n\t\t\tconst weight = p - intPoint;\n\t\t\tconst p0 = points[intPoint === 0 ? intPoint : intPoint - 1];\n\t\t\tconst p1 = points[intPoint];\n\t\t\tconst p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];\n\t\t\tconst p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];\n\t\t\tpoint.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));\n\t\t\treturn point;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.points = [];\n\n\t\t\tfor (let i = 0, l = source.points.length; i < l; i++) {\n\t\t\t\tconst point = source.points[i];\n\t\t\t\tthis.points.push(point.clone());\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.points = [];\n\n\t\t\tfor (let i = 0, l = this.points.length; i < l; i++) {\n\t\t\t\tconst point = this.points[i];\n\t\t\t\tdata.points.push(point.toArray());\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.points = [];\n\n\t\t\tfor (let i = 0, l = json.points.length; i < l; i++) {\n\t\t\t\tconst point = json.points[i];\n\t\t\t\tthis.points.push(new Vector2().fromArray(point));\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tSplineCurve.prototype.isSplineCurve = true;\n\n\tvar Curves = /*#__PURE__*/Object.freeze({\n\t\t__proto__: null,\n\t\tArcCurve: ArcCurve,\n\t\tCatmullRomCurve3: CatmullRomCurve3,\n\t\tCubicBezierCurve: CubicBezierCurve,\n\t\tCubicBezierCurve3: CubicBezierCurve3,\n\t\tEllipseCurve: EllipseCurve,\n\t\tLineCurve: LineCurve,\n\t\tLineCurve3: LineCurve3,\n\t\tQuadraticBezierCurve: QuadraticBezierCurve,\n\t\tQuadraticBezierCurve3: QuadraticBezierCurve3,\n\t\tSplineCurve: SplineCurve\n\t});\n\n\t/**************************************************************\n\t *\tCurved Path - a curve path is simply a array of connected\n\t *\tcurves, but retains the api of a curve\n\t **************************************************************/\n\n\tclass CurvePath extends Curve {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'CurvePath';\n\t\t\tthis.curves = [];\n\t\t\tthis.autoClose = false; // Automatically closes the path\n\t\t}\n\n\t\tadd(curve) {\n\t\t\tthis.curves.push(curve);\n\t\t}\n\n\t\tclosePath() {\n\t\t\t// Add a line curve if start and end of lines are not connected\n\t\t\tconst startPoint = this.curves[0].getPoint(0);\n\t\t\tconst endPoint = this.curves[this.curves.length - 1].getPoint(1);\n\n\t\t\tif (!startPoint.equals(endPoint)) {\n\t\t\t\tthis.curves.push(new LineCurve(endPoint, startPoint));\n\t\t\t}\n\t\t} // To get accurate point with reference to\n\t\t// entire path distance at time t,\n\t\t// following has to be done:\n\t\t// 1. Length of each sub path have to be known\n\t\t// 2. Locate and identify type of curve\n\t\t// 3. Get t for the curve\n\t\t// 4. Return curve.getPointAt(t')\n\n\n\t\tgetPoint(t) {\n\t\t\tconst d = t * this.getLength();\n\t\t\tconst curveLengths = this.getCurveLengths();\n\t\t\tlet i = 0; // To think about boundaries points.\n\n\t\t\twhile (i < curveLengths.length) {\n\t\t\t\tif (curveLengths[i] >= d) {\n\t\t\t\t\tconst diff = curveLengths[i] - d;\n\t\t\t\t\tconst curve = this.curves[i];\n\t\t\t\t\tconst segmentLength = curve.getLength();\n\t\t\t\t\tconst u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\t\t\t\t\treturn curve.getPointAt(u);\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\treturn null; // loop where sum != 0, sum > d , sum+1 <d\n\t\t} // We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t\t// getPoint() depends on getLength\n\n\n\t\tgetLength() {\n\t\t\tconst lens = this.getCurveLengths();\n\t\t\treturn lens[lens.length - 1];\n\t\t} // cacheLengths must be recalculated.\n\n\n\t\tupdateArcLengths() {\n\t\t\tthis.needsUpdate = true;\n\t\t\tthis.cacheLengths = null;\n\t\t\tthis.getCurveLengths();\n\t\t} // Compute lengths and cache them\n\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\n\t\tgetCurveLengths() {\n\t\t\t// We use cache values if curves and cache array are same length\n\t\t\tif (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\n\t\t\t\treturn this.cacheLengths;\n\t\t\t} // Get length of sub-curve\n\t\t\t// Push sums into cached array\n\n\n\t\t\tconst lengths = [];\n\t\t\tlet sums = 0;\n\n\t\t\tfor (let i = 0, l = this.curves.length; i < l; i++) {\n\t\t\t\tsums += this.curves[i].getLength();\n\t\t\t\tlengths.push(sums);\n\t\t\t}\n\n\t\t\tthis.cacheLengths = lengths;\n\t\t\treturn lengths;\n\t\t}\n\n\t\tgetSpacedPoints(divisions = 40) {\n\t\t\tconst points = [];\n\n\t\t\tfor (let i = 0; i <= divisions; i++) {\n\t\t\t\tpoints.push(this.getPoint(i / divisions));\n\t\t\t}\n\n\t\t\tif (this.autoClose) {\n\t\t\t\tpoints.push(points[0]);\n\t\t\t}\n\n\t\t\treturn points;\n\t\t}\n\n\t\tgetPoints(divisions = 12) {\n\t\t\tconst points = [];\n\t\t\tlet last;\n\n\t\t\tfor (let i = 0, curves = this.curves; i < curves.length; i++) {\n\t\t\t\tconst curve = curves[i];\n\t\t\t\tconst resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;\n\t\t\t\tconst pts = curve.getPoints(resolution);\n\n\t\t\t\tfor (let j = 0; j < pts.length; j++) {\n\t\t\t\t\tconst point = pts[j];\n\t\t\t\t\tif (last && last.equals(point)) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\t\tpoints.push(point);\n\t\t\t\t\tlast = point;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {\n\t\t\t\tpoints.push(points[0]);\n\t\t\t}\n\n\t\t\treturn points;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.curves = [];\n\n\t\t\tfor (let i = 0, l = source.curves.length; i < l; i++) {\n\t\t\t\tconst curve = source.curves[i];\n\t\t\t\tthis.curves.push(curve.clone());\n\t\t\t}\n\n\t\t\tthis.autoClose = source.autoClose;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.autoClose = this.autoClose;\n\t\t\tdata.curves = [];\n\n\t\t\tfor (let i = 0, l = this.curves.length; i < l; i++) {\n\t\t\t\tconst curve = this.curves[i];\n\t\t\t\tdata.curves.push(curve.toJSON());\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.autoClose = json.autoClose;\n\t\t\tthis.curves = [];\n\n\t\t\tfor (let i = 0, l = json.curves.length; i < l; i++) {\n\t\t\t\tconst curve = json.curves[i];\n\t\t\t\tthis.curves.push(new Curves[curve.type]().fromJSON(curve));\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass Path extends CurvePath {\n\t\tconstructor(points) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Path';\n\t\t\tthis.currentPoint = new Vector2();\n\n\t\t\tif (points) {\n\t\t\t\tthis.setFromPoints(points);\n\t\t\t}\n\t\t}\n\n\t\tsetFromPoints(points) {\n\t\t\tthis.moveTo(points[0].x, points[0].y);\n\n\t\t\tfor (let i = 1, l = points.length; i < l; i++) {\n\t\t\t\tthis.lineTo(points[i].x, points[i].y);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tmoveTo(x, y) {\n\t\t\tthis.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?\n\n\t\t\treturn this;\n\t\t}\n\n\t\tlineTo(x, y) {\n\t\t\tconst curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));\n\t\t\tthis.curves.push(curve);\n\t\t\tthis.currentPoint.set(x, y);\n\t\t\treturn this;\n\t\t}\n\n\t\tquadraticCurveTo(aCPx, aCPy, aX, aY) {\n\t\t\tconst curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));\n\t\t\tthis.curves.push(curve);\n\t\t\tthis.currentPoint.set(aX, aY);\n\t\t\treturn this;\n\t\t}\n\n\t\tbezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n\t\t\tconst curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));\n\t\t\tthis.curves.push(curve);\n\t\t\tthis.currentPoint.set(aX, aY);\n\t\t\treturn this;\n\t\t}\n\n\t\tsplineThru(pts\n\t\t/*Array of Vector*/\n\t\t) {\n\t\t\tconst npts = [this.currentPoint.clone()].concat(pts);\n\t\t\tconst curve = new SplineCurve(npts);\n\t\t\tthis.curves.push(curve);\n\t\t\tthis.currentPoint.copy(pts[pts.length - 1]);\n\t\t\treturn this;\n\t\t}\n\n\t\tarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n\t\t\tconst x0 = this.currentPoint.x;\n\t\t\tconst y0 = this.currentPoint.y;\n\t\t\tthis.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);\n\t\t\treturn this;\n\t\t}\n\n\t\tabsarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n\t\t\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n\t\t\treturn this;\n\t\t}\n\n\t\tellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n\t\t\tconst x0 = this.currentPoint.x;\n\t\t\tconst y0 = this.currentPoint.y;\n\t\t\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n\t\t\treturn this;\n\t\t}\n\n\t\tabsellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n\t\t\tconst curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n\n\t\t\tif (this.curves.length > 0) {\n\t\t\t\t// if a previous curve is present, attempt to join\n\t\t\t\tconst firstPoint = curve.getPoint(0);\n\n\t\t\t\tif (!firstPoint.equals(this.currentPoint)) {\n\t\t\t\t\tthis.lineTo(firstPoint.x, firstPoint.y);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.curves.push(curve);\n\t\t\tconst lastPoint = curve.getPoint(1);\n\t\t\tthis.currentPoint.copy(lastPoint);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.currentPoint.copy(source.currentPoint);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.currentPoint = this.currentPoint.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.currentPoint.fromArray(json.currentPoint);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass Shape extends Path {\n\t\tconstructor(points) {\n\t\t\tsuper(points);\n\t\t\tthis.uuid = generateUUID();\n\t\t\tthis.type = 'Shape';\n\t\t\tthis.holes = [];\n\t\t}\n\n\t\tgetPointsHoles(divisions) {\n\t\t\tconst holesPts = [];\n\n\t\t\tfor (let i = 0, l = this.holes.length; i < l; i++) {\n\t\t\t\tholesPts[i] = this.holes[i].getPoints(divisions);\n\t\t\t}\n\n\t\t\treturn holesPts;\n\t\t} // get points of shape and holes (keypoints based on segments parameter)\n\n\n\t\textractPoints(divisions) {\n\t\t\treturn {\n\t\t\t\tshape: this.getPoints(divisions),\n\t\t\t\tholes: this.getPointsHoles(divisions)\n\t\t\t};\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.holes = [];\n\n\t\t\tfor (let i = 0, l = source.holes.length; i < l; i++) {\n\t\t\t\tconst hole = source.holes[i];\n\t\t\t\tthis.holes.push(hole.clone());\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.uuid = this.uuid;\n\t\t\tdata.holes = [];\n\n\t\t\tfor (let i = 0, l = this.holes.length; i < l; i++) {\n\t\t\t\tconst hole = this.holes[i];\n\t\t\t\tdata.holes.push(hole.toJSON());\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tsuper.fromJSON(json);\n\t\t\tthis.uuid = json.uuid;\n\t\t\tthis.holes = [];\n\n\t\t\tfor (let i = 0, l = json.holes.length; i < l; i++) {\n\t\t\t\tconst hole = json.holes[i];\n\t\t\t\tthis.holes.push(new Path().fromJSON(hole));\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass Light extends Object3D {\n\t\tconstructor(color, intensity = 1) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Light';\n\t\t\tthis.color = new Color(color);\n\t\t\tthis.intensity = intensity;\n\t\t}\n\n\t\tdispose() {// Empty here in base class; some subclasses override.\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.color.copy(source.color);\n\t\t\tthis.intensity = source.intensity;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.object.color = this.color.getHex();\n\t\t\tdata.object.intensity = this.intensity;\n\t\t\tif (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();\n\t\t\tif (this.distance !== undefined) data.object.distance = this.distance;\n\t\t\tif (this.angle !== undefined) data.object.angle = this.angle;\n\t\t\tif (this.decay !== undefined) data.object.decay = this.decay;\n\t\t\tif (this.penumbra !== undefined) data.object.penumbra = this.penumbra;\n\t\t\tif (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tLight.prototype.isLight = true;\n\n\tclass HemisphereLight extends Light {\n\t\tconstructor(skyColor, groundColor, intensity) {\n\t\t\tsuper(skyColor, intensity);\n\t\t\tthis.type = 'HemisphereLight';\n\t\t\tthis.position.copy(Object3D.DefaultUp);\n\t\t\tthis.updateMatrix();\n\t\t\tthis.groundColor = new Color(groundColor);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tLight.prototype.copy.call(this, source);\n\t\t\tthis.groundColor.copy(source.groundColor);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tHemisphereLight.prototype.isHemisphereLight = true;\n\n\tconst _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();\n\n\tconst _lightPositionWorld$1 = /*@__PURE__*/new Vector3();\n\n\tconst _lookTarget$1 = /*@__PURE__*/new Vector3();\n\n\tclass LightShadow {\n\t\tconstructor(camera) {\n\t\t\tthis.camera = camera;\n\t\t\tthis.bias = 0;\n\t\t\tthis.normalBias = 0;\n\t\t\tthis.radius = 1;\n\t\t\tthis.mapSize = new Vector2(512, 512);\n\t\t\tthis.map = null;\n\t\t\tthis.mapPass = null;\n\t\t\tthis.matrix = new Matrix4();\n\t\t\tthis.autoUpdate = true;\n\t\t\tthis.needsUpdate = false;\n\t\t\tthis._frustum = new Frustum();\n\t\t\tthis._frameExtents = new Vector2(1, 1);\n\t\t\tthis._viewportCount = 1;\n\t\t\tthis._viewports = [new Vector4(0, 0, 1, 1)];\n\t\t}\n\n\t\tgetViewportCount() {\n\t\t\treturn this._viewportCount;\n\t\t}\n\n\t\tgetFrustum() {\n\t\t\treturn this._frustum;\n\t\t}\n\n\t\tupdateMatrices(light) {\n\t\t\tconst shadowCamera = this.camera;\n\t\t\tconst shadowMatrix = this.matrix;\n\n\t\t\t_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);\n\n\t\t\tshadowCamera.position.copy(_lightPositionWorld$1);\n\n\t\t\t_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);\n\n\t\t\tshadowCamera.lookAt(_lookTarget$1);\n\t\t\tshadowCamera.updateMatrixWorld();\n\n\t\t\t_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);\n\n\t\t\tthis._frustum.setFromProjectionMatrix(_projScreenMatrix$1);\n\n\t\t\tshadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n\t\t\tshadowMatrix.multiply(shadowCamera.projectionMatrix);\n\t\t\tshadowMatrix.multiply(shadowCamera.matrixWorldInverse);\n\t\t}\n\n\t\tgetViewport(viewportIndex) {\n\t\t\treturn this._viewports[viewportIndex];\n\t\t}\n\n\t\tgetFrameExtents() {\n\t\t\treturn this._frameExtents;\n\t\t}\n\n\t\tdispose() {\n\t\t\tif (this.map) {\n\t\t\t\tthis.map.dispose();\n\t\t\t}\n\n\t\t\tif (this.mapPass) {\n\t\t\t\tthis.mapPass.dispose();\n\t\t\t}\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tthis.camera = source.camera.clone();\n\t\t\tthis.bias = source.bias;\n\t\t\tthis.radius = source.radius;\n\t\t\tthis.mapSize.copy(source.mapSize);\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst object = {};\n\t\t\tif (this.bias !== 0) object.bias = this.bias;\n\t\t\tif (this.normalBias !== 0) object.normalBias = this.normalBias;\n\t\t\tif (this.radius !== 1) object.radius = this.radius;\n\t\t\tif (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();\n\t\t\tobject.camera = this.camera.toJSON(false).object;\n\t\t\tdelete object.camera.matrix;\n\t\t\treturn object;\n\t\t}\n\n\t}\n\n\tclass SpotLightShadow extends LightShadow {\n\t\tconstructor() {\n\t\t\tsuper(new PerspectiveCamera(50, 1, 0.5, 500));\n\t\t\tthis.focus = 1;\n\t\t}\n\n\t\tupdateMatrices(light) {\n\t\t\tconst camera = this.camera;\n\t\t\tconst fov = RAD2DEG * 2 * light.angle * this.focus;\n\t\t\tconst aspect = this.mapSize.width / this.mapSize.height;\n\t\t\tconst far = light.distance || camera.far;\n\n\t\t\tif (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {\n\t\t\t\tcamera.fov = fov;\n\t\t\t\tcamera.aspect = aspect;\n\t\t\t\tcamera.far = far;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t}\n\n\t\t\tsuper.updateMatrices(light);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.focus = source.focus;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tSpotLightShadow.prototype.isSpotLightShadow = true;\n\n\tclass SpotLight extends Light {\n\t\tconstructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {\n\t\t\tsuper(color, intensity);\n\t\t\tthis.type = 'SpotLight';\n\t\t\tthis.position.copy(Object3D.DefaultUp);\n\t\t\tthis.updateMatrix();\n\t\t\tthis.target = new Object3D();\n\t\t\tthis.distance = distance;\n\t\t\tthis.angle = angle;\n\t\t\tthis.penumbra = penumbra;\n\t\t\tthis.decay = decay; // for physically correct lights, should be 2.\n\n\t\t\tthis.shadow = new SpotLightShadow();\n\t\t}\n\n\t\tget power() {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\treturn this.intensity * Math.PI;\n\t\t}\n\n\t\tset power(power) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\tthis.intensity = power / Math.PI;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.shadow.dispose();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.angle = source.angle;\n\t\t\tthis.penumbra = source.penumbra;\n\t\t\tthis.decay = source.decay;\n\t\t\tthis.target = source.target.clone();\n\t\t\tthis.shadow = source.shadow.clone();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tSpotLight.prototype.isSpotLight = true;\n\n\tconst _projScreenMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _lightPositionWorld = /*@__PURE__*/new Vector3();\n\n\tconst _lookTarget = /*@__PURE__*/new Vector3();\n\n\tclass PointLightShadow extends LightShadow {\n\t\tconstructor() {\n\t\t\tsuper(new PerspectiveCamera(90, 1, 0.5, 500));\n\t\t\tthis._frameExtents = new Vector2(4, 2);\n\t\t\tthis._viewportCount = 6;\n\t\t\tthis._viewports = [// These viewports map a cube-map onto a 2D texture with the\n\t\t\t// following orientation:\n\t\t\t//\n\t\t\t//\txzXZ\n\t\t\t//\t y Y\n\t\t\t//\n\t\t\t// X - Positive x direction\n\t\t\t// x - Negative x direction\n\t\t\t// Y - Positive y direction\n\t\t\t// y - Negative y direction\n\t\t\t// Z - Positive z direction\n\t\t\t// z - Negative z direction\n\t\t\t// positive X\n\t\t\tnew Vector4(2, 1, 1, 1), // negative X\n\t\t\tnew Vector4(0, 1, 1, 1), // positive Z\n\t\t\tnew Vector4(3, 1, 1, 1), // negative Z\n\t\t\tnew Vector4(1, 1, 1, 1), // positive Y\n\t\t\tnew Vector4(3, 0, 1, 1), // negative Y\n\t\t\tnew Vector4(1, 0, 1, 1)];\n\t\t\tthis._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];\n\t\t\tthis._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];\n\t\t}\n\n\t\tupdateMatrices(light, viewportIndex = 0) {\n\t\t\tconst camera = this.camera;\n\t\t\tconst shadowMatrix = this.matrix;\n\t\t\tconst far = light.distance || camera.far;\n\n\t\t\tif (far !== camera.far) {\n\t\t\t\tcamera.far = far;\n\t\t\t\tcamera.updateProjectionMatrix();\n\t\t\t}\n\n\t\t\t_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);\n\n\t\t\tcamera.position.copy(_lightPositionWorld);\n\n\t\t\t_lookTarget.copy(camera.position);\n\n\t\t\t_lookTarget.add(this._cubeDirections[viewportIndex]);\n\n\t\t\tcamera.up.copy(this._cubeUps[viewportIndex]);\n\t\t\tcamera.lookAt(_lookTarget);\n\t\t\tcamera.updateMatrixWorld();\n\t\t\tshadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);\n\n\t\t\t_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n\n\t\t\tthis._frustum.setFromProjectionMatrix(_projScreenMatrix);\n\t\t}\n\n\t}\n\n\tPointLightShadow.prototype.isPointLightShadow = true;\n\n\tclass PointLight extends Light {\n\t\tconstructor(color, intensity, distance = 0, decay = 1) {\n\t\t\tsuper(color, intensity);\n\t\t\tthis.type = 'PointLight';\n\t\t\tthis.distance = distance;\n\t\t\tthis.decay = decay; // for physically correct lights, should be 2.\n\n\t\t\tthis.shadow = new PointLightShadow();\n\t\t}\n\n\t\tget power() {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\treturn this.intensity * 4 * Math.PI;\n\t\t}\n\n\t\tset power(power) {\n\t\t\t// intensity = power per solid angle.\n\t\t\t// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\t\tthis.intensity = power / (4 * Math.PI);\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.shadow.dispose();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.distance = source.distance;\n\t\t\tthis.decay = source.decay;\n\t\t\tthis.shadow = source.shadow.clone();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tPointLight.prototype.isPointLight = true;\n\n\tclass OrthographicCamera extends Camera {\n\t\tconstructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {\n\t\t\tsuper();\n\t\t\tthis.type = 'OrthographicCamera';\n\t\t\tthis.zoom = 1;\n\t\t\tthis.view = null;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t\tthis.top = top;\n\t\t\tthis.bottom = bottom;\n\t\t\tthis.near = near;\n\t\t\tthis.far = far;\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tcopy(source, recursive) {\n\t\t\tsuper.copy(source, recursive);\n\t\t\tthis.left = source.left;\n\t\t\tthis.right = source.right;\n\t\t\tthis.top = source.top;\n\t\t\tthis.bottom = source.bottom;\n\t\t\tthis.near = source.near;\n\t\t\tthis.far = source.far;\n\t\t\tthis.zoom = source.zoom;\n\t\t\tthis.view = source.view === null ? null : Object.assign({}, source.view);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetViewOffset(fullWidth, fullHeight, x, y, width, height) {\n\t\t\tif (this.view === null) {\n\t\t\t\tthis.view = {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tfullWidth: 1,\n\t\t\t\t\tfullHeight: 1,\n\t\t\t\t\toffsetX: 0,\n\t\t\t\t\toffsetY: 0,\n\t\t\t\t\twidth: 1,\n\t\t\t\t\theight: 1\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis.view.enabled = true;\n\t\t\tthis.view.fullWidth = fullWidth;\n\t\t\tthis.view.fullHeight = fullHeight;\n\t\t\tthis.view.offsetX = x;\n\t\t\tthis.view.offsetY = y;\n\t\t\tthis.view.width = width;\n\t\t\tthis.view.height = height;\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tclearViewOffset() {\n\t\t\tif (this.view !== null) {\n\t\t\t\tthis.view.enabled = false;\n\t\t\t}\n\n\t\t\tthis.updateProjectionMatrix();\n\t\t}\n\n\t\tupdateProjectionMatrix() {\n\t\t\tconst dx = (this.right - this.left) / (2 * this.zoom);\n\t\t\tconst dy = (this.top - this.bottom) / (2 * this.zoom);\n\t\t\tconst cx = (this.right + this.left) / 2;\n\t\t\tconst cy = (this.top + this.bottom) / 2;\n\t\t\tlet left = cx - dx;\n\t\t\tlet right = cx + dx;\n\t\t\tlet top = cy + dy;\n\t\t\tlet bottom = cy - dy;\n\n\t\t\tif (this.view !== null && this.view.enabled) {\n\t\t\t\tconst scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;\n\t\t\t\tconst scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n\t\t\t\tleft += scaleW * this.view.offsetX;\n\t\t\t\tright = left + scaleW * this.view.width;\n\t\t\t\ttop -= scaleH * this.view.offsetY;\n\t\t\t\tbottom = top - scaleH * this.view.height;\n\t\t\t}\n\n\t\t\tthis.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);\n\t\t\tthis.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.object.zoom = this.zoom;\n\t\t\tdata.object.left = this.left;\n\t\t\tdata.object.right = this.right;\n\t\t\tdata.object.top = this.top;\n\t\t\tdata.object.bottom = this.bottom;\n\t\t\tdata.object.near = this.near;\n\t\t\tdata.object.far = this.far;\n\t\t\tif (this.view !== null) data.object.view = Object.assign({}, this.view);\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tOrthographicCamera.prototype.isOrthographicCamera = true;\n\n\tclass DirectionalLightShadow extends LightShadow {\n\t\tconstructor() {\n\t\t\tsuper(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));\n\t\t}\n\n\t}\n\n\tDirectionalLightShadow.prototype.isDirectionalLightShadow = true;\n\n\tclass DirectionalLight extends Light {\n\t\tconstructor(color, intensity) {\n\t\t\tsuper(color, intensity);\n\t\t\tthis.type = 'DirectionalLight';\n\t\t\tthis.position.copy(Object3D.DefaultUp);\n\t\t\tthis.updateMatrix();\n\t\t\tthis.target = new Object3D();\n\t\t\tthis.shadow = new DirectionalLightShadow();\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.shadow.dispose();\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.target = source.target.clone();\n\t\t\tthis.shadow = source.shadow.clone();\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tDirectionalLight.prototype.isDirectionalLight = true;\n\n\tclass AmbientLight extends Light {\n\t\tconstructor(color, intensity) {\n\t\t\tsuper(color, intensity);\n\t\t\tthis.type = 'AmbientLight';\n\t\t}\n\n\t}\n\n\tAmbientLight.prototype.isAmbientLight = true;\n\n\tclass RectAreaLight extends Light {\n\t\tconstructor(color, intensity, width = 10, height = 10) {\n\t\t\tsuper(color, intensity);\n\t\t\tthis.type = 'RectAreaLight';\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.width = source.width;\n\t\t\tthis.height = source.height;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.object.width = this.width;\n\t\t\tdata.object.height = this.height;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tRectAreaLight.prototype.isRectAreaLight = true;\n\n\t/**\n\t * Primary reference:\n\t *\t https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\t *\n\t * Secondary reference:\n\t *\t https://www.ppsloan.org/publications/StupidSH36.pdf\n\t */\n\t// 3-band SH defined by 9 coefficients\n\n\tclass SphericalHarmonics3 {\n\t\tconstructor() {\n\t\t\tthis.coefficients = [];\n\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients.push(new Vector3());\n\t\t\t}\n\t\t}\n\n\t\tset(coefficients) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].copy(coefficients[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tzero() {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].set(0, 0, 0);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // get the radiance in the direction of the normal\n\t\t// target is a Vector3\n\n\n\t\tgetAt(normal, target) {\n\t\t\t// normal is assumed to be unit length\n\t\t\tconst x = normal.x,\n\t\t\t\t\t\ty = normal.y,\n\t\t\t\t\t\tz = normal.z;\n\t\t\tconst coeff = this.coefficients; // band 0\n\n\t\t\ttarget.copy(coeff[0]).multiplyScalar(0.282095); // band 1\n\n\t\t\ttarget.addScaledVector(coeff[1], 0.488603 * y);\n\t\t\ttarget.addScaledVector(coeff[2], 0.488603 * z);\n\t\t\ttarget.addScaledVector(coeff[3], 0.488603 * x); // band 2\n\n\t\t\ttarget.addScaledVector(coeff[4], 1.092548 * (x * y));\n\t\t\ttarget.addScaledVector(coeff[5], 1.092548 * (y * z));\n\t\t\ttarget.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));\n\t\t\ttarget.addScaledVector(coeff[7], 1.092548 * (x * z));\n\t\t\ttarget.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));\n\t\t\treturn target;\n\t\t} // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n\t\t// target is a Vector3\n\t\t// https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\n\n\t\tgetIrradianceAt(normal, target) {\n\t\t\t// normal is assumed to be unit length\n\t\t\tconst x = normal.x,\n\t\t\t\t\t\ty = normal.y,\n\t\t\t\t\t\tz = normal.z;\n\t\t\tconst coeff = this.coefficients; // band 0\n\n\t\t\ttarget.copy(coeff[0]).multiplyScalar(0.886227); // π * 0.282095\n\t\t\t// band 1\n\n\t\t\ttarget.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 * π / 3 ) * 0.488603\n\n\t\t\ttarget.addScaledVector(coeff[2], 2.0 * 0.511664 * z);\n\t\t\ttarget.addScaledVector(coeff[3], 2.0 * 0.511664 * x); // band 2\n\n\t\t\ttarget.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // ( π / 4 ) * 1.092548\n\n\t\t\ttarget.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);\n\t\t\ttarget.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // ( π / 4 ) * 0.315392 * 3\n\n\t\t\ttarget.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);\n\t\t\ttarget.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // ( π / 4 ) * 0.546274\n\n\t\t\treturn target;\n\t\t}\n\n\t\tadd(sh) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].add(sh.coefficients[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\taddScaledSH(sh, s) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].addScaledVector(sh.coefficients[i], s);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tscale(s) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].multiplyScalar(s);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tlerp(sh, alpha) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tthis.coefficients[i].lerp(sh.coefficients[i], alpha);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(sh) {\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tif (!this.coefficients[i].equals(sh.coefficients[i])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tcopy(sh) {\n\t\t\treturn this.set(sh.coefficients);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tfromArray(array, offset = 0) {\n\t\t\tconst coefficients = this.coefficients;\n\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tcoefficients[i].fromArray(array, offset + i * 3);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\ttoArray(array = [], offset = 0) {\n\t\t\tconst coefficients = this.coefficients;\n\n\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\tcoefficients[i].toArray(array, offset + i * 3);\n\t\t\t}\n\n\t\t\treturn array;\n\t\t} // evaluate the basis functions\n\t\t// shBasis is an Array[ 9 ]\n\n\n\t\tstatic getBasisAt(normal, shBasis) {\n\t\t\t// normal is assumed to be unit length\n\t\t\tconst x = normal.x,\n\t\t\t\t\t\ty = normal.y,\n\t\t\t\t\t\tz = normal.z; // band 0\n\n\t\t\tshBasis[0] = 0.282095; // band 1\n\n\t\t\tshBasis[1] = 0.488603 * y;\n\t\t\tshBasis[2] = 0.488603 * z;\n\t\t\tshBasis[3] = 0.488603 * x; // band 2\n\n\t\t\tshBasis[4] = 1.092548 * x * y;\n\t\t\tshBasis[5] = 1.092548 * y * z;\n\t\t\tshBasis[6] = 0.315392 * (3 * z * z - 1);\n\t\t\tshBasis[7] = 1.092548 * x * z;\n\t\t\tshBasis[8] = 0.546274 * (x * x - y * y);\n\t\t}\n\n\t}\n\n\tSphericalHarmonics3.prototype.isSphericalHarmonics3 = true;\n\n\tclass LightProbe extends Light {\n\t\tconstructor(sh = new SphericalHarmonics3(), intensity = 1) {\n\t\t\tsuper(undefined, intensity);\n\t\t\tthis.sh = sh;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.sh.copy(source.sh);\n\t\t\treturn this;\n\t\t}\n\n\t\tfromJSON(json) {\n\t\t\tthis.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();\n\n\t\t\tthis.sh.fromArray(json.sh);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON(meta) {\n\t\t\tconst data = super.toJSON(meta);\n\t\t\tdata.object.sh = this.sh.toArray();\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tLightProbe.prototype.isLightProbe = true;\n\n\tclass MaterialLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t\tthis.textures = {};\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst loader = new FileLoader(scope.manager);\n\t\t\tloader.setPath(scope.path);\n\t\t\tloader.setRequestHeader(scope.requestHeader);\n\t\t\tloader.setWithCredentials(scope.withCredentials);\n\t\t\tloader.load(url, function (text) {\n\t\t\t\ttry {\n\t\t\t\t\tonLoad(scope.parse(JSON.parse(text)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onError) {\n\t\t\t\t\t\tonError(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t\tparse(json) {\n\t\t\tconst textures = this.textures;\n\n\t\t\tfunction getTexture(name) {\n\t\t\t\tif (textures[name] === undefined) {\n\t\t\t\t\tconsole.warn('THREE.MaterialLoader: Undefined texture', name);\n\t\t\t\t}\n\n\t\t\t\treturn textures[name];\n\t\t\t}\n\n\t\t\tconst material = new Materials[json.type]();\n\t\t\tif (json.uuid !== undefined) material.uuid = json.uuid;\n\t\t\tif (json.name !== undefined) material.name = json.name;\n\t\t\tif (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);\n\t\t\tif (json.roughness !== undefined) material.roughness = json.roughness;\n\t\t\tif (json.metalness !== undefined) material.metalness = json.metalness;\n\t\t\tif (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);\n\t\t\tif (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);\n\t\t\tif (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);\n\t\t\tif (json.shininess !== undefined) material.shininess = json.shininess;\n\t\t\tif (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;\n\t\t\tif (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;\n\t\t\tif (json.transmission !== undefined) material.transmission = json.transmission;\n\t\t\tif (json.thickness !== undefined) material.thickness = json.thickness;\n\t\t\tif (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;\n\t\t\tif (json.attenuationColor !== undefined && material.attenuationColor !== undefined) material.attenuationColor.setHex(json.attenuationColor);\n\t\t\tif (json.fog !== undefined) material.fog = json.fog;\n\t\t\tif (json.flatShading !== undefined) material.flatShading = json.flatShading;\n\t\t\tif (json.blending !== undefined) material.blending = json.blending;\n\t\t\tif (json.combine !== undefined) material.combine = json.combine;\n\t\t\tif (json.side !== undefined) material.side = json.side;\n\t\t\tif (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;\n\t\t\tif (json.opacity !== undefined) material.opacity = json.opacity;\n\t\t\tif (json.transparent !== undefined) material.transparent = json.transparent;\n\t\t\tif (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;\n\t\t\tif (json.depthTest !== undefined) material.depthTest = json.depthTest;\n\t\t\tif (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;\n\t\t\tif (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;\n\t\t\tif (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;\n\t\t\tif (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;\n\t\t\tif (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;\n\t\t\tif (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;\n\t\t\tif (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;\n\t\t\tif (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;\n\t\t\tif (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;\n\t\t\tif (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;\n\t\t\tif (json.wireframe !== undefined) material.wireframe = json.wireframe;\n\t\t\tif (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\t\tif (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;\n\t\t\tif (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;\n\t\t\tif (json.rotation !== undefined) material.rotation = json.rotation;\n\t\t\tif (json.linewidth !== 1) material.linewidth = json.linewidth;\n\t\t\tif (json.dashSize !== undefined) material.dashSize = json.dashSize;\n\t\t\tif (json.gapSize !== undefined) material.gapSize = json.gapSize;\n\t\t\tif (json.scale !== undefined) material.scale = json.scale;\n\t\t\tif (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;\n\t\t\tif (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;\n\t\t\tif (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;\n\t\t\tif (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;\n\t\t\tif (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;\n\t\t\tif (json.dithering !== undefined) material.dithering = json.dithering;\n\t\t\tif (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;\n\t\t\tif (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;\n\t\t\tif (json.vertexTangents !== undefined) material.vertexTangents = json.vertexTangents;\n\t\t\tif (json.visible !== undefined) material.visible = json.visible;\n\t\t\tif (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;\n\t\t\tif (json.userData !== undefined) material.userData = json.userData;\n\n\t\t\tif (json.vertexColors !== undefined) {\n\t\t\t\tif (typeof json.vertexColors === 'number') {\n\t\t\t\t\tmaterial.vertexColors = json.vertexColors > 0 ? true : false;\n\t\t\t\t} else {\n\t\t\t\t\tmaterial.vertexColors = json.vertexColors;\n\t\t\t\t}\n\t\t\t} // Shader Material\n\n\n\t\t\tif (json.uniforms !== undefined) {\n\t\t\t\tfor (const name in json.uniforms) {\n\t\t\t\t\tconst uniform = json.uniforms[name];\n\t\t\t\t\tmaterial.uniforms[name] = {};\n\n\t\t\t\t\tswitch (uniform.type) {\n\t\t\t\t\t\tcase 't':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = getTexture(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Color().setHex(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'v2':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Vector2().fromArray(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'v3':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Vector3().fromArray(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'v4':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Vector4().fromArray(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'm3':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Matrix3().fromArray(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'm4':\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = new Matrix4().fromArray(uniform.value);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tmaterial.uniforms[name].value = uniform.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (json.defines !== undefined) material.defines = json.defines;\n\t\t\tif (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;\n\t\t\tif (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;\n\n\t\t\tif (json.extensions !== undefined) {\n\t\t\t\tfor (const key in json.extensions) {\n\t\t\t\t\tmaterial.extensions[key] = json.extensions[key];\n\t\t\t\t}\n\t\t\t} // Deprecated\n\n\n\t\t\tif (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading\n\t\t\t// for PointsMaterial\n\n\t\t\tif (json.size !== undefined) material.size = json.size;\n\t\t\tif (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps\n\n\t\t\tif (json.map !== undefined) material.map = getTexture(json.map);\n\t\t\tif (json.matcap !== undefined) material.matcap = getTexture(json.matcap);\n\t\t\tif (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);\n\t\t\tif (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);\n\t\t\tif (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;\n\t\t\tif (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);\n\t\t\tif (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;\n\n\t\t\tif (json.normalScale !== undefined) {\n\t\t\t\tlet normalScale = json.normalScale;\n\n\t\t\t\tif (Array.isArray(normalScale) === false) {\n\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\t\t\t\t\tnormalScale = [normalScale, normalScale];\n\t\t\t\t}\n\n\t\t\t\tmaterial.normalScale = new Vector2().fromArray(normalScale);\n\t\t\t}\n\n\t\t\tif (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);\n\t\t\tif (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;\n\t\t\tif (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;\n\t\t\tif (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);\n\t\t\tif (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);\n\t\t\tif (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);\n\t\t\tif (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;\n\t\t\tif (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);\n\t\t\tif (json.envMap !== undefined) material.envMap = getTexture(json.envMap);\n\t\t\tif (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;\n\t\t\tif (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;\n\t\t\tif (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;\n\t\t\tif (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);\n\t\t\tif (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;\n\t\t\tif (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);\n\t\t\tif (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;\n\t\t\tif (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);\n\t\t\tif (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);\n\t\t\tif (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);\n\t\t\tif (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);\n\t\t\tif (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);\n\t\t\tif (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);\n\t\t\tif (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);\n\t\t\treturn material;\n\t\t}\n\n\t\tsetTextures(value) {\n\t\t\tthis.textures = value;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass LoaderUtils {\n\t\tstatic decodeText(array) {\n\t\t\tif (typeof TextDecoder !== 'undefined') {\n\t\t\t\treturn new TextDecoder().decode(array);\n\t\t\t} // Avoid the String.fromCharCode.apply(null, array) shortcut, which\n\t\t\t// throws a \"maximum call stack size exceeded\" error for large arrays.\n\n\n\t\t\tlet s = '';\n\n\t\t\tfor (let i = 0, il = array.length; i < il; i++) {\n\t\t\t\t// Implicitly assumes little-endian.\n\t\t\t\ts += String.fromCharCode(array[i]);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// merges multi-byte utf-8 characters.\n\t\t\t\treturn decodeURIComponent(escape(s));\n\t\t\t} catch (e) {\n\t\t\t\t// see #16358\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\n\t\tstatic extractUrlBase(url) {\n\t\t\tconst index = url.lastIndexOf('/');\n\t\t\tif (index === -1) return './';\n\t\t\treturn url.substr(0, index + 1);\n\t\t}\n\n\t}\n\n\tclass InstancedBufferGeometry extends BufferGeometry {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'InstancedBufferGeometry';\n\t\t\tthis.instanceCount = Infinity;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.instanceCount = source.instanceCount;\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON(this);\n\t\t\tdata.instanceCount = this.instanceCount;\n\t\t\tdata.isInstancedBufferGeometry = true;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tInstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;\n\n\tclass InstancedBufferAttribute extends BufferAttribute {\n\t\tconstructor(array, itemSize, normalized, meshPerAttribute) {\n\t\t\tif (typeof normalized === 'number') {\n\t\t\t\tmeshPerAttribute = normalized;\n\t\t\t\tnormalized = false;\n\t\t\t\tconsole.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');\n\t\t\t}\n\n\t\t\tsuper(array, itemSize, normalized);\n\t\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\t\treturn this;\n\t\t}\n\n\t\ttoJSON() {\n\t\t\tconst data = super.toJSON();\n\t\t\tdata.meshPerAttribute = this.meshPerAttribute;\n\t\t\tdata.isInstancedBufferAttribute = true;\n\t\t\treturn data;\n\t\t}\n\n\t}\n\n\tInstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;\n\n\tclass BufferGeometryLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst loader = new FileLoader(scope.manager);\n\t\t\tloader.setPath(scope.path);\n\t\t\tloader.setRequestHeader(scope.requestHeader);\n\t\t\tloader.setWithCredentials(scope.withCredentials);\n\t\t\tloader.load(url, function (text) {\n\t\t\t\ttry {\n\t\t\t\t\tonLoad(scope.parse(JSON.parse(text)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onError) {\n\t\t\t\t\t\tonError(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t\tparse(json) {\n\t\t\tconst interleavedBufferMap = {};\n\t\t\tconst arrayBufferMap = {};\n\n\t\t\tfunction getInterleavedBuffer(json, uuid) {\n\t\t\t\tif (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];\n\t\t\t\tconst interleavedBuffers = json.interleavedBuffers;\n\t\t\t\tconst interleavedBuffer = interleavedBuffers[uuid];\n\t\t\t\tconst buffer = getArrayBuffer(json, interleavedBuffer.buffer);\n\t\t\t\tconst array = getTypedArray(interleavedBuffer.type, buffer);\n\t\t\t\tconst ib = new InterleavedBuffer(array, interleavedBuffer.stride);\n\t\t\t\tib.uuid = interleavedBuffer.uuid;\n\t\t\t\tinterleavedBufferMap[uuid] = ib;\n\t\t\t\treturn ib;\n\t\t\t}\n\n\t\t\tfunction getArrayBuffer(json, uuid) {\n\t\t\t\tif (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];\n\t\t\t\tconst arrayBuffers = json.arrayBuffers;\n\t\t\t\tconst arrayBuffer = arrayBuffers[uuid];\n\t\t\t\tconst ab = new Uint32Array(arrayBuffer).buffer;\n\t\t\t\tarrayBufferMap[uuid] = ab;\n\t\t\t\treturn ab;\n\t\t\t}\n\n\t\t\tconst geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n\t\t\tconst index = json.data.index;\n\n\t\t\tif (index !== undefined) {\n\t\t\t\tconst typedArray = getTypedArray(index.type, index.array);\n\t\t\t\tgeometry.setIndex(new BufferAttribute(typedArray, 1));\n\t\t\t}\n\n\t\t\tconst attributes = json.data.attributes;\n\n\t\t\tfor (const key in attributes) {\n\t\t\t\tconst attribute = attributes[key];\n\t\t\t\tlet bufferAttribute;\n\n\t\t\t\tif (attribute.isInterleavedBufferAttribute) {\n\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);\n\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);\n\t\t\t\t} else {\n\t\t\t\t\tconst typedArray = getTypedArray(attribute.type, attribute.array);\n\t\t\t\t\tconst bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n\t\t\t\t\tbufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);\n\t\t\t\t}\n\n\t\t\t\tif (attribute.name !== undefined) bufferAttribute.name = attribute.name;\n\t\t\t\tif (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);\n\n\t\t\t\tif (attribute.updateRange !== undefined) {\n\t\t\t\t\tbufferAttribute.updateRange.offset = attribute.updateRange.offset;\n\t\t\t\t\tbufferAttribute.updateRange.count = attribute.updateRange.count;\n\t\t\t\t}\n\n\t\t\t\tgeometry.setAttribute(key, bufferAttribute);\n\t\t\t}\n\n\t\t\tconst morphAttributes = json.data.morphAttributes;\n\n\t\t\tif (morphAttributes) {\n\t\t\t\tfor (const key in morphAttributes) {\n\t\t\t\t\tconst attributeArray = morphAttributes[key];\n\t\t\t\t\tconst array = [];\n\n\t\t\t\t\tfor (let i = 0, il = attributeArray.length; i < il; i++) {\n\t\t\t\t\t\tconst attribute = attributeArray[i];\n\t\t\t\t\t\tlet bufferAttribute;\n\n\t\t\t\t\t\tif (attribute.isInterleavedBufferAttribute) {\n\t\t\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);\n\t\t\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst typedArray = getTypedArray(attribute.type, attribute.array);\n\t\t\t\t\t\t\tbufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (attribute.name !== undefined) bufferAttribute.name = attribute.name;\n\t\t\t\t\t\tarray.push(bufferAttribute);\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.morphAttributes[key] = array;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst morphTargetsRelative = json.data.morphTargetsRelative;\n\n\t\t\tif (morphTargetsRelative) {\n\t\t\t\tgeometry.morphTargetsRelative = true;\n\t\t\t}\n\n\t\t\tconst groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\t\tif (groups !== undefined) {\n\t\t\t\tfor (let i = 0, n = groups.length; i !== n; ++i) {\n\t\t\t\t\tconst group = groups[i];\n\t\t\t\t\tgeometry.addGroup(group.start, group.count, group.materialIndex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst boundingSphere = json.data.boundingSphere;\n\n\t\t\tif (boundingSphere !== undefined) {\n\t\t\t\tconst center = new Vector3();\n\n\t\t\t\tif (boundingSphere.center !== undefined) {\n\t\t\t\t\tcenter.fromArray(boundingSphere.center);\n\t\t\t\t}\n\n\t\t\t\tgeometry.boundingSphere = new Sphere(center, boundingSphere.radius);\n\t\t\t}\n\n\t\t\tif (json.name) geometry.name = json.name;\n\t\t\tif (json.userData) geometry.userData = json.userData;\n\t\t\treturn geometry;\n\t\t}\n\n\t}\n\n\tclass ObjectLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;\n\t\t\tthis.resourcePath = this.resourcePath || path;\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setWithCredentials(this.withCredentials);\n\t\t\tloader.load(url, function (text) {\n\t\t\t\tlet json = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tjson = JSON.parse(text);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (onError !== undefined) onError(error);\n\t\t\t\t\tconsole.error('THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst metadata = json.metadata;\n\n\t\t\t\tif (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {\n\t\t\t\t\tconsole.error('THREE.ObjectLoader: Can\\'t load ' + url);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tscope.parse(json, onLoad);\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t\tparse(json, onLoad) {\n\t\t\tconst animations = this.parseAnimations(json.animations);\n\t\t\tconst shapes = this.parseShapes(json.shapes);\n\t\t\tconst geometries = this.parseGeometries(json.geometries, shapes);\n\t\t\tconst images = this.parseImages(json.images, function () {\n\t\t\t\tif (onLoad !== undefined) onLoad(object);\n\t\t\t});\n\t\t\tconst textures = this.parseTextures(json.textures, images);\n\t\t\tconst materials = this.parseMaterials(json.materials, textures);\n\t\t\tconst object = this.parseObject(json.object, geometries, materials, animations);\n\t\t\tconst skeletons = this.parseSkeletons(json.skeletons, object);\n\t\t\tthis.bindSkeletons(object, skeletons); //\n\n\t\t\tif (onLoad !== undefined) {\n\t\t\t\tlet hasImages = false;\n\n\t\t\t\tfor (const uuid in images) {\n\t\t\t\t\tif (images[uuid] instanceof HTMLImageElement) {\n\t\t\t\t\t\thasImages = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (hasImages === false) onLoad(object);\n\t\t\t}\n\n\t\t\treturn object;\n\t\t}\n\n\t\tparseShapes(json) {\n\t\t\tconst shapes = {};\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tfor (let i = 0, l = json.length; i < l; i++) {\n\t\t\t\t\tconst shape = new Shape().fromJSON(json[i]);\n\t\t\t\t\tshapes[shape.uuid] = shape;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn shapes;\n\t\t}\n\n\t\tparseSkeletons(json, object) {\n\t\t\tconst skeletons = {};\n\t\t\tconst bones = {}; // generate bone lookup table\n\n\t\t\tobject.traverse(function (child) {\n\t\t\t\tif (child.isBone) bones[child.uuid] = child;\n\t\t\t}); // create skeletons\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tfor (let i = 0, l = json.length; i < l; i++) {\n\t\t\t\t\tconst skeleton = new Skeleton().fromJSON(json[i], bones);\n\t\t\t\t\tskeletons[skeleton.uuid] = skeleton;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn skeletons;\n\t\t}\n\n\t\tparseGeometries(json, shapes) {\n\t\t\tconst geometries = {};\n\t\t\tlet geometryShapes;\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tconst bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\t\tfor (let i = 0, l = json.length; i < l; i++) {\n\t\t\t\t\tlet geometry;\n\t\t\t\t\tconst data = json[i];\n\n\t\t\t\t\tswitch (data.type) {\n\t\t\t\t\t\tcase 'PlaneGeometry':\n\t\t\t\t\t\tcase 'PlaneBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BoxGeometry':\n\t\t\t\t\t\tcase 'BoxBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CircleGeometry':\n\t\t\t\t\t\tcase 'CircleBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'CylinderGeometry':\n\t\t\t\t\t\tcase 'CylinderBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ConeGeometry':\n\t\t\t\t\t\tcase 'ConeBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'SphereGeometry':\n\t\t\t\t\t\tcase 'SphereBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'DodecahedronGeometry':\n\t\t\t\t\t\tcase 'DodecahedronBufferGeometry':\n\t\t\t\t\t\tcase 'IcosahedronGeometry':\n\t\t\t\t\t\tcase 'IcosahedronBufferGeometry':\n\t\t\t\t\t\tcase 'OctahedronGeometry':\n\t\t\t\t\t\tcase 'OctahedronBufferGeometry':\n\t\t\t\t\t\tcase 'TetrahedronGeometry':\n\t\t\t\t\t\tcase 'TetrahedronBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.detail);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'RingGeometry':\n\t\t\t\t\t\tcase 'RingBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusGeometry':\n\t\t\t\t\t\tcase 'TorusBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TorusKnotGeometry':\n\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TubeGeometry':\n\t\t\t\t\t\tcase 'TubeBufferGeometry':\n\t\t\t\t\t\t\t// This only works for built-in curves (e.g. CatmullRomCurve3).\n\t\t\t\t\t\t\t// User defined curves or instances of CurvePath will not be deserialized.\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'LatheGeometry':\n\t\t\t\t\t\tcase 'LatheBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'PolyhedronGeometry':\n\t\t\t\t\t\tcase 'PolyhedronBufferGeometry':\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ShapeGeometry':\n\t\t\t\t\t\tcase 'ShapeBufferGeometry':\n\t\t\t\t\t\t\tgeometryShapes = [];\n\n\t\t\t\t\t\t\tfor (let j = 0, jl = data.shapes.length; j < jl; j++) {\n\t\t\t\t\t\t\t\tconst shape = shapes[data.shapes[j]];\n\t\t\t\t\t\t\t\tgeometryShapes.push(shape);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](geometryShapes, data.curveSegments);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ExtrudeGeometry':\n\t\t\t\t\t\tcase 'ExtrudeBufferGeometry':\n\t\t\t\t\t\t\tgeometryShapes = [];\n\n\t\t\t\t\t\t\tfor (let j = 0, jl = data.shapes.length; j < jl; j++) {\n\t\t\t\t\t\t\t\tconst shape = shapes[data.shapes[j]];\n\t\t\t\t\t\t\t\tgeometryShapes.push(shape);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst extrudePath = data.options.extrudePath;\n\n\t\t\t\t\t\t\tif (extrudePath !== undefined) {\n\t\t\t\t\t\t\t\tdata.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgeometry = new Geometries[data.type](geometryShapes, data.options);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'BufferGeometry':\n\t\t\t\t\t\tcase 'InstancedBufferGeometry':\n\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse(data);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'Geometry':\n\t\t\t\t\t\t\tconsole.error('THREE.ObjectLoader: Loading \"Geometry\" is not supported anymore.');\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn('THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"');\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.uuid = data.uuid;\n\t\t\t\t\tif (data.name !== undefined) geometry.name = data.name;\n\t\t\t\t\tif (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;\n\t\t\t\t\tgeometries[data.uuid] = geometry;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn geometries;\n\t\t}\n\n\t\tparseMaterials(json, textures) {\n\t\t\tconst cache = {}; // MultiMaterial\n\n\t\t\tconst materials = {};\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tconst loader = new MaterialLoader();\n\t\t\t\tloader.setTextures(textures);\n\n\t\t\t\tfor (let i = 0, l = json.length; i < l; i++) {\n\t\t\t\t\tconst data = json[i];\n\n\t\t\t\t\tif (data.type === 'MultiMaterial') {\n\t\t\t\t\t\t// Deprecated\n\t\t\t\t\t\tconst array = [];\n\n\t\t\t\t\t\tfor (let j = 0; j < data.materials.length; j++) {\n\t\t\t\t\t\t\tconst material = data.materials[j];\n\n\t\t\t\t\t\t\tif (cache[material.uuid] === undefined) {\n\t\t\t\t\t\t\t\tcache[material.uuid] = loader.parse(material);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tarray.push(cache[material.uuid]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterials[data.uuid] = array;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cache[data.uuid] === undefined) {\n\t\t\t\t\t\t\tcache[data.uuid] = loader.parse(data);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterials[data.uuid] = cache[data.uuid];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn materials;\n\t\t}\n\n\t\tparseAnimations(json) {\n\t\t\tconst animations = {};\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tfor (let i = 0; i < json.length; i++) {\n\t\t\t\t\tconst data = json[i];\n\t\t\t\t\tconst clip = AnimationClip.parse(data);\n\t\t\t\t\tanimations[clip.uuid] = clip;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn animations;\n\t\t}\n\n\t\tparseImages(json, onLoad) {\n\t\t\tconst scope = this;\n\t\t\tconst images = {};\n\t\t\tlet loader;\n\n\t\t\tfunction loadImage(url) {\n\t\t\t\tscope.manager.itemStart(url);\n\t\t\t\treturn loader.load(url, function () {\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, undefined, function () {\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction deserializeImage(image) {\n\t\t\t\tif (typeof image === 'string') {\n\t\t\t\t\tconst url = image;\n\t\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(url) ? url : scope.resourcePath + url;\n\t\t\t\t\treturn loadImage(path);\n\t\t\t\t} else {\n\t\t\t\t\tif (image.data) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tdata: getTypedArray(image.type, image.data),\n\t\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\t\theight: image.height\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (json !== undefined && json.length > 0) {\n\t\t\t\tconst manager = new LoadingManager(onLoad);\n\t\t\t\tloader = new ImageLoader(manager);\n\t\t\t\tloader.setCrossOrigin(this.crossOrigin);\n\n\t\t\t\tfor (let i = 0, il = json.length; i < il; i++) {\n\t\t\t\t\tconst image = json[i];\n\t\t\t\t\tconst url = image.url;\n\n\t\t\t\t\tif (Array.isArray(url)) {\n\t\t\t\t\t\t// load array of images e.g CubeTexture\n\t\t\t\t\t\timages[image.uuid] = [];\n\n\t\t\t\t\t\tfor (let j = 0, jl = url.length; j < jl; j++) {\n\t\t\t\t\t\t\tconst currentUrl = url[j];\n\t\t\t\t\t\t\tconst deserializedImage = deserializeImage(currentUrl);\n\n\t\t\t\t\t\t\tif (deserializedImage !== null) {\n\t\t\t\t\t\t\t\tif (deserializedImage instanceof HTMLImageElement) {\n\t\t\t\t\t\t\t\t\timages[image.uuid].push(deserializedImage);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\t\t\t\t\t\t\t\t\timages[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// load single image\n\t\t\t\t\t\tconst deserializedImage = deserializeImage(image.url);\n\n\t\t\t\t\t\tif (deserializedImage !== null) {\n\t\t\t\t\t\t\timages[image.uuid] = deserializedImage;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn images;\n\t\t}\n\n\t\tparseTextures(json, images) {\n\t\t\tfunction parseConstant(value, type) {\n\t\t\t\tif (typeof value === 'number') return value;\n\t\t\t\tconsole.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);\n\t\t\t\treturn type[value];\n\t\t\t}\n\n\t\t\tconst textures = {};\n\n\t\t\tif (json !== undefined) {\n\t\t\t\tfor (let i = 0, l = json.length; i < l; i++) {\n\t\t\t\t\tconst data = json[i];\n\n\t\t\t\t\tif (data.image === undefined) {\n\t\t\t\t\t\tconsole.warn('THREE.ObjectLoader: No \"image\" specified for', data.uuid);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (images[data.image] === undefined) {\n\t\t\t\t\t\tconsole.warn('THREE.ObjectLoader: Undefined image', data.image);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet texture;\n\t\t\t\t\tconst image = images[data.image];\n\n\t\t\t\t\tif (Array.isArray(image)) {\n\t\t\t\t\t\ttexture = new CubeTexture(image);\n\t\t\t\t\t\tif (image.length === 6) texture.needsUpdate = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (image && image.data) {\n\t\t\t\t\t\t\ttexture = new DataTexture(image.data, image.width, image.height);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttexture = new Texture(image);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (image) texture.needsUpdate = true; // textures can have undefined image data\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.uuid = data.uuid;\n\t\t\t\t\tif (data.name !== undefined) texture.name = data.name;\n\t\t\t\t\tif (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);\n\t\t\t\t\tif (data.offset !== undefined) texture.offset.fromArray(data.offset);\n\t\t\t\t\tif (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);\n\t\t\t\t\tif (data.center !== undefined) texture.center.fromArray(data.center);\n\t\t\t\t\tif (data.rotation !== undefined) texture.rotation = data.rotation;\n\n\t\t\t\t\tif (data.wrap !== undefined) {\n\t\t\t\t\t\ttexture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);\n\t\t\t\t\t\ttexture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data.format !== undefined) texture.format = data.format;\n\t\t\t\t\tif (data.type !== undefined) texture.type = data.type;\n\t\t\t\t\tif (data.encoding !== undefined) texture.encoding = data.encoding;\n\t\t\t\t\tif (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);\n\t\t\t\t\tif (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);\n\t\t\t\t\tif (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;\n\t\t\t\t\tif (data.flipY !== undefined) texture.flipY = data.flipY;\n\t\t\t\t\tif (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;\n\t\t\t\t\tif (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;\n\t\t\t\t\ttextures[data.uuid] = texture;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn textures;\n\t\t}\n\n\t\tparseObject(data, geometries, materials, animations) {\n\t\t\tlet object;\n\n\t\t\tfunction getGeometry(name) {\n\t\t\t\tif (geometries[name] === undefined) {\n\t\t\t\t\tconsole.warn('THREE.ObjectLoader: Undefined geometry', name);\n\t\t\t\t}\n\n\t\t\t\treturn geometries[name];\n\t\t\t}\n\n\t\t\tfunction getMaterial(name) {\n\t\t\t\tif (name === undefined) return undefined;\n\n\t\t\t\tif (Array.isArray(name)) {\n\t\t\t\t\tconst array = [];\n\n\t\t\t\t\tfor (let i = 0, l = name.length; i < l; i++) {\n\t\t\t\t\t\tconst uuid = name[i];\n\n\t\t\t\t\t\tif (materials[uuid] === undefined) {\n\t\t\t\t\t\t\tconsole.warn('THREE.ObjectLoader: Undefined material', uuid);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tarray.push(materials[uuid]);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn array;\n\t\t\t\t}\n\n\t\t\t\tif (materials[name] === undefined) {\n\t\t\t\t\tconsole.warn('THREE.ObjectLoader: Undefined material', name);\n\t\t\t\t}\n\n\t\t\t\treturn materials[name];\n\t\t\t}\n\n\t\t\tlet geometry, material;\n\n\t\t\tswitch (data.type) {\n\t\t\t\tcase 'Scene':\n\t\t\t\t\tobject = new Scene();\n\n\t\t\t\t\tif (data.background !== undefined) {\n\t\t\t\t\t\tif (Number.isInteger(data.background)) {\n\t\t\t\t\t\t\tobject.background = new Color(data.background);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data.fog !== undefined) {\n\t\t\t\t\t\tif (data.fog.type === 'Fog') {\n\t\t\t\t\t\t\tobject.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);\n\t\t\t\t\t\t} else if (data.fog.type === 'FogExp2') {\n\t\t\t\t\t\t\tobject.fog = new FogExp2(data.fog.color, data.fog.density);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PerspectiveCamera':\n\t\t\t\t\tobject = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);\n\t\t\t\t\tif (data.focus !== undefined) object.focus = data.focus;\n\t\t\t\t\tif (data.zoom !== undefined) object.zoom = data.zoom;\n\t\t\t\t\tif (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;\n\t\t\t\t\tif (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;\n\t\t\t\t\tif (data.view !== undefined) object.view = Object.assign({}, data.view);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'OrthographicCamera':\n\t\t\t\t\tobject = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);\n\t\t\t\t\tif (data.zoom !== undefined) object.zoom = data.zoom;\n\t\t\t\t\tif (data.view !== undefined) object.view = Object.assign({}, data.view);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientLight':\n\t\t\t\t\tobject = new AmbientLight(data.color, data.intensity);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tobject = new DirectionalLight(data.color, data.intensity);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tobject = new PointLight(data.color, data.intensity, data.distance, data.decay);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\tobject = new RectAreaLight(data.color, data.intensity, data.width, data.height);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tobject = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\tobject = new HemisphereLight(data.color, data.groundColor, data.intensity);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LightProbe':\n\t\t\t\t\tobject = new LightProbe().fromJSON(data);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SkinnedMesh':\n\t\t\t\t\tgeometry = getGeometry(data.geometry);\n\t\t\t\t\tmaterial = getMaterial(data.material);\n\t\t\t\t\tobject = new SkinnedMesh(geometry, material);\n\t\t\t\t\tif (data.bindMode !== undefined) object.bindMode = data.bindMode;\n\t\t\t\t\tif (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);\n\t\t\t\t\tif (data.skeleton !== undefined) object.skeleton = data.skeleton;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Mesh':\n\t\t\t\t\tgeometry = getGeometry(data.geometry);\n\t\t\t\t\tmaterial = getMaterial(data.material);\n\t\t\t\t\tobject = new Mesh(geometry, material);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'InstancedMesh':\n\t\t\t\t\tgeometry = getGeometry(data.geometry);\n\t\t\t\t\tmaterial = getMaterial(data.material);\n\t\t\t\t\tconst count = data.count;\n\t\t\t\t\tconst instanceMatrix = data.instanceMatrix;\n\t\t\t\t\tconst instanceColor = data.instanceColor;\n\t\t\t\t\tobject = new InstancedMesh(geometry, material, count);\n\t\t\t\t\tobject.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);\n\t\t\t\t\tif (instanceColor !== undefined) object.instanceColor = new BufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LOD':\n\t\t\t\t\tobject = new LOD();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Line':\n\t\t\t\t\tobject = new Line(getGeometry(data.geometry), getMaterial(data.material));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LineLoop':\n\t\t\t\t\tobject = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'LineSegments':\n\t\t\t\t\tobject = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointCloud':\n\t\t\t\tcase 'Points':\n\t\t\t\t\tobject = new Points(getGeometry(data.geometry), getMaterial(data.material));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Sprite':\n\t\t\t\t\tobject = new Sprite(getMaterial(data.material));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Group':\n\t\t\t\t\tobject = new Group();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Bone':\n\t\t\t\t\tobject = new Bone();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tobject = new Object3D();\n\t\t\t}\n\n\t\t\tobject.uuid = data.uuid;\n\t\t\tif (data.name !== undefined) object.name = data.name;\n\n\t\t\tif (data.matrix !== undefined) {\n\t\t\t\tobject.matrix.fromArray(data.matrix);\n\t\t\t\tif (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;\n\t\t\t\tif (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);\n\t\t\t} else {\n\t\t\t\tif (data.position !== undefined) object.position.fromArray(data.position);\n\t\t\t\tif (data.rotation !== undefined) object.rotation.fromArray(data.rotation);\n\t\t\t\tif (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);\n\t\t\t\tif (data.scale !== undefined) object.scale.fromArray(data.scale);\n\t\t\t}\n\n\t\t\tif (data.castShadow !== undefined) object.castShadow = data.castShadow;\n\t\t\tif (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;\n\n\t\t\tif (data.shadow) {\n\t\t\t\tif (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;\n\t\t\t\tif (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;\n\t\t\t\tif (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;\n\t\t\t\tif (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);\n\t\t\t\tif (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);\n\t\t\t}\n\n\t\t\tif (data.visible !== undefined) object.visible = data.visible;\n\t\t\tif (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;\n\t\t\tif (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;\n\t\t\tif (data.userData !== undefined) object.userData = data.userData;\n\t\t\tif (data.layers !== undefined) object.layers.mask = data.layers;\n\n\t\t\tif (data.children !== undefined) {\n\t\t\t\tconst children = data.children;\n\n\t\t\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\t\t\tobject.add(this.parseObject(children[i], geometries, materials, animations));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (data.animations !== undefined) {\n\t\t\t\tconst objectAnimations = data.animations;\n\n\t\t\t\tfor (let i = 0; i < objectAnimations.length; i++) {\n\t\t\t\t\tconst uuid = objectAnimations[i];\n\t\t\t\t\tobject.animations.push(animations[uuid]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (data.type === 'LOD') {\n\t\t\t\tif (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;\n\t\t\t\tconst levels = data.levels;\n\n\t\t\t\tfor (let l = 0; l < levels.length; l++) {\n\t\t\t\t\tconst level = levels[l];\n\t\t\t\t\tconst child = object.getObjectByProperty('uuid', level.object);\n\n\t\t\t\t\tif (child !== undefined) {\n\t\t\t\t\t\tobject.addLevel(child, level.distance);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn object;\n\t\t}\n\n\t\tbindSkeletons(object, skeletons) {\n\t\t\tif (Object.keys(skeletons).length === 0) return;\n\t\t\tobject.traverse(function (child) {\n\t\t\t\tif (child.isSkinnedMesh === true && child.skeleton !== undefined) {\n\t\t\t\t\tconst skeleton = skeletons[child.skeleton];\n\n\t\t\t\t\tif (skeleton === undefined) {\n\t\t\t\t\t\tconsole.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchild.bind(skeleton, child.bindMatrix);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t/* DEPRECATED */\n\n\n\t\tsetTexturePath(value) {\n\t\t\tconsole.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');\n\t\t\treturn this.setResourcePath(value);\n\t\t}\n\n\t}\n\n\tconst TEXTURE_MAPPING = {\n\t\tUVMapping: UVMapping,\n\t\tCubeReflectionMapping: CubeReflectionMapping,\n\t\tCubeRefractionMapping: CubeRefractionMapping,\n\t\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\t\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\t\tCubeUVReflectionMapping: CubeUVReflectionMapping,\n\t\tCubeUVRefractionMapping: CubeUVRefractionMapping\n\t};\n\tconst TEXTURE_WRAPPING = {\n\t\tRepeatWrapping: RepeatWrapping,\n\t\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\t\tMirroredRepeatWrapping: MirroredRepeatWrapping\n\t};\n\tconst TEXTURE_FILTER = {\n\t\tNearestFilter: NearestFilter,\n\t\tNearestMipmapNearestFilter: NearestMipmapNearestFilter,\n\t\tNearestMipmapLinearFilter: NearestMipmapLinearFilter,\n\t\tLinearFilter: LinearFilter,\n\t\tLinearMipmapNearestFilter: LinearMipmapNearestFilter,\n\t\tLinearMipmapLinearFilter: LinearMipmapLinearFilter\n\t};\n\n\tclass ImageBitmapLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\n\t\t\tif (typeof createImageBitmap === 'undefined') {\n\t\t\t\tconsole.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');\n\t\t\t}\n\n\t\t\tif (typeof fetch === 'undefined') {\n\t\t\t\tconsole.warn('THREE.ImageBitmapLoader: fetch() not supported.');\n\t\t\t}\n\n\t\t\tthis.options = {\n\t\t\t\tpremultiplyAlpha: 'none'\n\t\t\t};\n\t\t}\n\n\t\tsetOptions(options) {\n\t\t\tthis.options = options;\n\t\t\treturn this;\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tif (url === undefined) url = '';\n\t\t\tif (this.path !== undefined) url = this.path + url;\n\t\t\turl = this.manager.resolveURL(url);\n\t\t\tconst scope = this;\n\t\t\tconst cached = Cache.get(url);\n\n\t\t\tif (cached !== undefined) {\n\t\t\t\tscope.manager.itemStart(url);\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tif (onLoad) onLoad(cached);\n\t\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t\t}, 0);\n\t\t\t\treturn cached;\n\t\t\t}\n\n\t\t\tconst fetchOptions = {};\n\t\t\tfetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';\n\t\t\tfetchOptions.headers = this.requestHeader;\n\t\t\tfetch(url, fetchOptions).then(function (res) {\n\t\t\t\treturn res.blob();\n\t\t\t}).then(function (blob) {\n\t\t\t\treturn createImageBitmap(blob, Object.assign(scope.options, {\n\t\t\t\t\tcolorSpaceConversion: 'none'\n\t\t\t\t}));\n\t\t\t}).then(function (imageBitmap) {\n\t\t\t\tCache.add(url, imageBitmap);\n\t\t\t\tif (onLoad) onLoad(imageBitmap);\n\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t}).catch(function (e) {\n\t\t\t\tif (onError) onError(e);\n\t\t\t\tscope.manager.itemError(url);\n\t\t\t\tscope.manager.itemEnd(url);\n\t\t\t});\n\t\t\tscope.manager.itemStart(url);\n\t\t}\n\n\t}\n\n\tImageBitmapLoader.prototype.isImageBitmapLoader = true;\n\n\tclass ShapePath {\n\t\tconstructor() {\n\t\t\tthis.type = 'ShapePath';\n\t\t\tthis.color = new Color();\n\t\t\tthis.subPaths = [];\n\t\t\tthis.currentPath = null;\n\t\t}\n\n\t\tmoveTo(x, y) {\n\t\t\tthis.currentPath = new Path();\n\t\t\tthis.subPaths.push(this.currentPath);\n\t\t\tthis.currentPath.moveTo(x, y);\n\t\t\treturn this;\n\t\t}\n\n\t\tlineTo(x, y) {\n\t\t\tthis.currentPath.lineTo(x, y);\n\t\t\treturn this;\n\t\t}\n\n\t\tquadraticCurveTo(aCPx, aCPy, aX, aY) {\n\t\t\tthis.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);\n\t\t\treturn this;\n\t\t}\n\n\t\tbezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n\t\t\tthis.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);\n\t\t\treturn this;\n\t\t}\n\n\t\tsplineThru(pts) {\n\t\t\tthis.currentPath.splineThru(pts);\n\t\t\treturn this;\n\t\t}\n\n\t\ttoShapes(isCCW, noHoles) {\n\t\t\tfunction toShapesNoHoles(inSubpaths) {\n\t\t\t\tconst shapes = [];\n\n\t\t\t\tfor (let i = 0, l = inSubpaths.length; i < l; i++) {\n\t\t\t\t\tconst tmpPath = inSubpaths[i];\n\t\t\t\t\tconst tmpShape = new Shape();\n\t\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\t\tshapes.push(tmpShape);\n\t\t\t\t}\n\n\t\t\t\treturn shapes;\n\t\t\t}\n\n\t\t\tfunction isPointInsidePolygon(inPt, inPolygon) {\n\t\t\t\tconst polyLen = inPolygon.length; // inPt on polygon contour => immediate success\t\tor\n\t\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t\t//\twith the horizontal line through inPt, left of inPt\n\t\t\t\t//\tnot counting lowerY endpoints of edges and whole edges on that line\n\n\t\t\t\tlet inside = false;\n\n\t\t\t\tfor (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {\n\t\t\t\t\tlet edgeLowPt = inPolygon[p];\n\t\t\t\t\tlet edgeHighPt = inPolygon[q];\n\t\t\t\t\tlet edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\t\tlet edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\t\tif (Math.abs(edgeDy) > Number.EPSILON) {\n\t\t\t\t\t\t// not parallel\n\t\t\t\t\t\tif (edgeDy < 0) {\n\t\t\t\t\t\t\tedgeLowPt = inPolygon[q];\n\t\t\t\t\t\t\tedgeDx = -edgeDx;\n\t\t\t\t\t\t\tedgeHighPt = inPolygon[p];\n\t\t\t\t\t\t\tedgeDy = -edgeDy;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;\n\n\t\t\t\t\t\tif (inPt.y === edgeLowPt.y) {\n\t\t\t\t\t\t\tif (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?\n\t\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\n\t\t\t\t\t\t\tif (perpEdge === 0) return true; // inPt is on contour ?\n\n\t\t\t\t\t\t\tif (perpEdge < 0) continue;\n\t\t\t\t\t\t\tinside = !inside; // true intersection left of inPt\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// parallel or collinear\n\t\t\t\t\t\tif (inPt.y !== edgeLowPt.y) continue; // parallel\n\t\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\n\t\t\t\t\t\tif (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !\n\t\t\t\t\t\t// continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn inside;\n\t\t\t}\n\n\t\t\tconst isClockWise = ShapeUtils.isClockWise;\n\t\t\tconst subPaths = this.subPaths;\n\t\t\tif (subPaths.length === 0) return [];\n\t\t\tif (noHoles === true) return toShapesNoHoles(subPaths);\n\t\t\tlet solid, tmpPath, tmpShape;\n\t\t\tconst shapes = [];\n\n\t\t\tif (subPaths.length === 1) {\n\t\t\t\ttmpPath = subPaths[0];\n\t\t\t\ttmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\t\tshapes.push(tmpShape);\n\t\t\t\treturn shapes;\n\t\t\t}\n\n\t\t\tlet holesFirst = !isClockWise(subPaths[0].getPoints());\n\t\t\tholesFirst = isCCW ? !holesFirst : holesFirst; // console.log(\"Holes first\", holesFirst);\n\n\t\t\tconst betterShapeHoles = [];\n\t\t\tconst newShapes = [];\n\t\t\tlet newShapeHoles = [];\n\t\t\tlet mainIdx = 0;\n\t\t\tlet tmpPoints;\n\t\t\tnewShapes[mainIdx] = undefined;\n\t\t\tnewShapeHoles[mainIdx] = [];\n\n\t\t\tfor (let i = 0, l = subPaths.length; i < l; i++) {\n\t\t\t\ttmpPath = subPaths[i];\n\t\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\t\tsolid = isClockWise(tmpPoints);\n\t\t\t\tsolid = isCCW ? !solid : solid;\n\n\t\t\t\tif (solid) {\n\t\t\t\t\tif (!holesFirst && newShapes[mainIdx]) mainIdx++;\n\t\t\t\t\tnewShapes[mainIdx] = {\n\t\t\t\t\t\ts: new Shape(),\n\t\t\t\t\t\tp: tmpPoints\n\t\t\t\t\t};\n\t\t\t\t\tnewShapes[mainIdx].s.curves = tmpPath.curves;\n\t\t\t\t\tif (holesFirst) mainIdx++;\n\t\t\t\t\tnewShapeHoles[mainIdx] = []; //console.log('cw', i);\n\t\t\t\t} else {\n\t\t\t\t\tnewShapeHoles[mainIdx].push({\n\t\t\t\t\t\th: tmpPath,\n\t\t\t\t\t\tp: tmpPoints[0]\n\t\t\t\t\t}); //console.log('ccw', i);\n\t\t\t\t}\n\t\t\t} // only Holes? -> probably all Shapes with wrong orientation\n\n\n\t\t\tif (!newShapes[0]) return toShapesNoHoles(subPaths);\n\n\t\t\tif (newShapes.length > 1) {\n\t\t\t\tlet ambiguous = false;\n\t\t\t\tconst toChange = [];\n\n\t\t\t\tfor (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n\t\t\t\t\tbetterShapeHoles[sIdx] = [];\n\t\t\t\t}\n\n\t\t\t\tfor (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n\t\t\t\t\tconst sho = newShapeHoles[sIdx];\n\n\t\t\t\t\tfor (let hIdx = 0; hIdx < sho.length; hIdx++) {\n\t\t\t\t\t\tconst ho = sho[hIdx];\n\t\t\t\t\t\tlet hole_unassigned = true;\n\n\t\t\t\t\t\tfor (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {\n\t\t\t\t\t\t\tif (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {\n\t\t\t\t\t\t\t\tif (sIdx !== s2Idx) toChange.push({\n\t\t\t\t\t\t\t\t\tfroms: sIdx,\n\t\t\t\t\t\t\t\t\ttos: s2Idx,\n\t\t\t\t\t\t\t\t\thole: hIdx\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tif (hole_unassigned) {\n\t\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\t\tbetterShapeHoles[s2Idx].push(ho);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tambiguous = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (hole_unassigned) {\n\t\t\t\t\t\t\tbetterShapeHoles[sIdx].push(ho);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // console.log(\"ambiguous: \", ambiguous);\n\n\n\t\t\t\tif (toChange.length > 0) {\n\t\t\t\t\t// console.log(\"to change: \", toChange);\n\t\t\t\t\tif (!ambiguous) newShapeHoles = betterShapeHoles;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet tmpHoles;\n\n\t\t\tfor (let i = 0, il = newShapes.length; i < il; i++) {\n\t\t\t\ttmpShape = newShapes[i].s;\n\t\t\t\tshapes.push(tmpShape);\n\t\t\t\ttmpHoles = newShapeHoles[i];\n\n\t\t\t\tfor (let j = 0, jl = tmpHoles.length; j < jl; j++) {\n\t\t\t\t\ttmpShape.holes.push(tmpHoles[j].h);\n\t\t\t\t}\n\t\t\t} //console.log(\"shape\", shapes);\n\n\n\t\t\treturn shapes;\n\t\t}\n\n\t}\n\n\tclass Font {\n\t\tconstructor(data) {\n\t\t\tthis.type = 'Font';\n\t\t\tthis.data = data;\n\t\t}\n\n\t\tgenerateShapes(text, size = 100) {\n\t\t\tconst shapes = [];\n\t\t\tconst paths = createPaths(text, size, this.data);\n\n\t\t\tfor (let p = 0, pl = paths.length; p < pl; p++) {\n\t\t\t\tArray.prototype.push.apply(shapes, paths[p].toShapes());\n\t\t\t}\n\n\t\t\treturn shapes;\n\t\t}\n\n\t}\n\n\tfunction createPaths(text, size, data) {\n\t\tconst chars = Array.from(text);\n\t\tconst scale = size / data.resolution;\n\t\tconst line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n\t\tconst paths = [];\n\t\tlet offsetX = 0,\n\t\t\t\toffsetY = 0;\n\n\t\tfor (let i = 0; i < chars.length; i++) {\n\t\t\tconst char = chars[i];\n\n\t\t\tif (char === '\\n') {\n\t\t\t\toffsetX = 0;\n\t\t\t\toffsetY -= line_height;\n\t\t\t} else {\n\t\t\t\tconst ret = createPath(char, scale, offsetX, offsetY, data);\n\t\t\t\toffsetX += ret.offsetX;\n\t\t\t\tpaths.push(ret.path);\n\t\t\t}\n\t\t}\n\n\t\treturn paths;\n\t}\n\n\tfunction createPath(char, scale, offsetX, offsetY, data) {\n\t\tconst glyph = data.glyphs[char] || data.glyphs['?'];\n\n\t\tif (!glyph) {\n\t\t\tconsole.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.');\n\t\t\treturn;\n\t\t}\n\n\t\tconst path = new ShapePath();\n\t\tlet x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\n\t\tif (glyph.o) {\n\t\t\tconst outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));\n\n\t\t\tfor (let i = 0, l = outline.length; i < l;) {\n\t\t\t\tconst action = outline[i++];\n\n\t\t\t\tswitch (action) {\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\t// moveTo\n\t\t\t\t\t\tx = outline[i++] * scale + offsetX;\n\t\t\t\t\t\ty = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tpath.moveTo(x, y);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t// lineTo\n\t\t\t\t\t\tx = outline[i++] * scale + offsetX;\n\t\t\t\t\t\ty = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tpath.lineTo(x, y);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\t// quadraticCurveTo\n\t\t\t\t\t\tcpx = outline[i++] * scale + offsetX;\n\t\t\t\t\t\tcpy = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tcpx1 = outline[i++] * scale + offsetX;\n\t\t\t\t\t\tcpy1 = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tpath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t// bezierCurveTo\n\t\t\t\t\t\tcpx = outline[i++] * scale + offsetX;\n\t\t\t\t\t\tcpy = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tcpx1 = outline[i++] * scale + offsetX;\n\t\t\t\t\t\tcpy1 = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tcpx2 = outline[i++] * scale + offsetX;\n\t\t\t\t\t\tcpy2 = outline[i++] * scale + offsetY;\n\t\t\t\t\t\tpath.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\toffsetX: glyph.ha * scale,\n\t\t\tpath: path\n\t\t};\n\t}\n\n\tFont.prototype.isFont = true;\n\n\tclass FontLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setWithCredentials(scope.withCredentials);\n\t\t\tloader.load(url, function (text) {\n\t\t\t\tlet json;\n\n\t\t\t\ttry {\n\t\t\t\t\tjson = JSON.parse(text);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');\n\t\t\t\t\tjson = JSON.parse(text.substring(65, text.length - 2));\n\t\t\t\t}\n\n\t\t\t\tconst font = scope.parse(json);\n\t\t\t\tif (onLoad) onLoad(font);\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t\tparse(json) {\n\t\t\treturn new Font(json);\n\t\t}\n\n\t}\n\n\tlet _context;\n\n\tconst AudioContext = {\n\t\tgetContext: function () {\n\t\t\tif (_context === undefined) {\n\t\t\t\t_context = new (window.AudioContext || window.webkitAudioContext)();\n\t\t\t}\n\n\t\t\treturn _context;\n\t\t},\n\t\tsetContext: function (value) {\n\t\t\t_context = value;\n\t\t}\n\t};\n\n\tclass AudioLoader extends Loader {\n\t\tconstructor(manager) {\n\t\t\tsuper(manager);\n\t\t}\n\n\t\tload(url, onLoad, onProgress, onError) {\n\t\t\tconst scope = this;\n\t\t\tconst loader = new FileLoader(this.manager);\n\t\t\tloader.setResponseType('arraybuffer');\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.setRequestHeader(this.requestHeader);\n\t\t\tloader.setWithCredentials(this.withCredentials);\n\t\t\tloader.load(url, function (buffer) {\n\t\t\t\ttry {\n\t\t\t\t\t// Create a copy of the buffer. The `decodeAudioData` method\n\t\t\t\t\t// detaches the buffer when complete, preventing reuse.\n\t\t\t\t\tconst bufferCopy = buffer.slice(0);\n\t\t\t\t\tconst context = AudioContext.getContext();\n\t\t\t\t\tcontext.decodeAudioData(bufferCopy, function (audioBuffer) {\n\t\t\t\t\t\tonLoad(audioBuffer);\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (onError) {\n\t\t\t\t\t\tonError(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tscope.manager.itemError(url);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t}\n\n\t}\n\n\tclass HemisphereLightProbe extends LightProbe {\n\t\tconstructor(skyColor, groundColor, intensity = 1) {\n\t\t\tsuper(undefined, intensity);\n\t\t\tconst color1 = new Color().set(skyColor);\n\t\t\tconst color2 = new Color().set(groundColor);\n\t\t\tconst sky = new Vector3(color1.r, color1.g, color1.b);\n\t\t\tconst ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );\n\n\t\t\tconst c0 = Math.sqrt(Math.PI);\n\t\t\tconst c1 = c0 * Math.sqrt(0.75);\n\t\t\tthis.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);\n\t\t\tthis.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);\n\t\t}\n\n\t}\n\n\tHemisphereLightProbe.prototype.isHemisphereLightProbe = true;\n\n\tclass AmbientLightProbe extends LightProbe {\n\t\tconstructor(color, intensity = 1) {\n\t\t\tsuper(undefined, intensity);\n\t\t\tconst color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );\n\n\t\t\tthis.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));\n\t\t}\n\n\t}\n\n\tAmbientLightProbe.prototype.isAmbientLightProbe = true;\n\n\tconst _eyeRight = /*@__PURE__*/new Matrix4();\n\n\tconst _eyeLeft = /*@__PURE__*/new Matrix4();\n\n\tclass StereoCamera {\n\t\tconstructor() {\n\t\t\tthis.type = 'StereoCamera';\n\t\t\tthis.aspect = 1;\n\t\t\tthis.eyeSep = 0.064;\n\t\t\tthis.cameraL = new PerspectiveCamera();\n\t\t\tthis.cameraL.layers.enable(1);\n\t\t\tthis.cameraL.matrixAutoUpdate = false;\n\t\t\tthis.cameraR = new PerspectiveCamera();\n\t\t\tthis.cameraR.layers.enable(2);\n\t\t\tthis.cameraR.matrixAutoUpdate = false;\n\t\t\tthis._cache = {\n\t\t\t\tfocus: null,\n\t\t\t\tfov: null,\n\t\t\t\taspect: null,\n\t\t\t\tnear: null,\n\t\t\t\tfar: null,\n\t\t\t\tzoom: null,\n\t\t\t\teyeSep: null\n\t\t\t};\n\t\t}\n\n\t\tupdate(camera) {\n\t\t\tconst cache = this._cache;\n\t\t\tconst needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;\n\n\t\t\tif (needsUpdate) {\n\t\t\t\tcache.focus = camera.focus;\n\t\t\t\tcache.fov = camera.fov;\n\t\t\t\tcache.aspect = camera.aspect * this.aspect;\n\t\t\t\tcache.near = camera.near;\n\t\t\t\tcache.far = camera.far;\n\t\t\t\tcache.zoom = camera.zoom;\n\t\t\t\tcache.eyeSep = this.eyeSep; // Off-axis stereoscopic effect based on\n\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t\tconst projectionMatrix = camera.projectionMatrix.clone();\n\t\t\t\tconst eyeSepHalf = cache.eyeSep / 2;\n\t\t\t\tconst eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\n\t\t\t\tconst ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;\n\t\t\t\tlet xmin, xmax; // translate xOffset\n\n\t\t\t\t_eyeLeft.elements[12] = -eyeSepHalf;\n\t\t\t\t_eyeRight.elements[12] = eyeSepHalf; // for left eye\n\n\t\t\t\txmin = -ymax * cache.aspect + eyeSepOnProjection;\n\t\t\t\txmax = ymax * cache.aspect + eyeSepOnProjection;\n\t\t\t\tprojectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);\n\t\t\t\tprojectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);\n\t\t\t\tthis.cameraL.projectionMatrix.copy(projectionMatrix); // for right eye\n\n\t\t\t\txmin = -ymax * cache.aspect - eyeSepOnProjection;\n\t\t\t\txmax = ymax * cache.aspect - eyeSepOnProjection;\n\t\t\t\tprojectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);\n\t\t\t\tprojectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);\n\t\t\t\tthis.cameraR.projectionMatrix.copy(projectionMatrix);\n\t\t\t}\n\n\t\t\tthis.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);\n\t\t\tthis.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);\n\t\t}\n\n\t}\n\n\tclass Clock {\n\t\tconstructor(autoStart = true) {\n\t\t\tthis.autoStart = autoStart;\n\t\t\tthis.startTime = 0;\n\t\t\tthis.oldTime = 0;\n\t\t\tthis.elapsedTime = 0;\n\t\t\tthis.running = false;\n\t\t}\n\n\t\tstart() {\n\t\t\tthis.startTime = now();\n\t\t\tthis.oldTime = this.startTime;\n\t\t\tthis.elapsedTime = 0;\n\t\t\tthis.running = true;\n\t\t}\n\n\t\tstop() {\n\t\t\tthis.getElapsedTime();\n\t\t\tthis.running = false;\n\t\t\tthis.autoStart = false;\n\t\t}\n\n\t\tgetElapsedTime() {\n\t\t\tthis.getDelta();\n\t\t\treturn this.elapsedTime;\n\t\t}\n\n\t\tgetDelta() {\n\t\t\tlet diff = 0;\n\n\t\t\tif (this.autoStart && !this.running) {\n\t\t\t\tthis.start();\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (this.running) {\n\t\t\t\tconst newTime = now();\n\t\t\t\tdiff = (newTime - this.oldTime) / 1000;\n\t\t\t\tthis.oldTime = newTime;\n\t\t\t\tthis.elapsedTime += diff;\n\t\t\t}\n\n\t\t\treturn diff;\n\t\t}\n\n\t}\n\n\tfunction now() {\n\t\treturn (typeof performance === 'undefined' ? Date : performance).now(); // see #10732\n\t}\n\n\tconst _position$1 = /*@__PURE__*/new Vector3();\n\n\tconst _quaternion$1 = /*@__PURE__*/new Quaternion();\n\n\tconst _scale$1 = /*@__PURE__*/new Vector3();\n\n\tconst _orientation$1 = /*@__PURE__*/new Vector3();\n\n\tclass AudioListener extends Object3D {\n\t\tconstructor() {\n\t\t\tsuper();\n\t\t\tthis.type = 'AudioListener';\n\t\t\tthis.context = AudioContext.getContext();\n\t\t\tthis.gain = this.context.createGain();\n\t\t\tthis.gain.connect(this.context.destination);\n\t\t\tthis.filter = null;\n\t\t\tthis.timeDelta = 0; // private\n\n\t\t\tthis._clock = new Clock();\n\t\t}\n\n\t\tgetInput() {\n\t\t\treturn this.gain;\n\t\t}\n\n\t\tremoveFilter() {\n\t\t\tif (this.filter !== null) {\n\t\t\t\tthis.gain.disconnect(this.filter);\n\t\t\t\tthis.filter.disconnect(this.context.destination);\n\t\t\t\tthis.gain.connect(this.context.destination);\n\t\t\t\tthis.filter = null;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetFilter() {\n\t\t\treturn this.filter;\n\t\t}\n\n\t\tsetFilter(value) {\n\t\t\tif (this.filter !== null) {\n\t\t\t\tthis.gain.disconnect(this.filter);\n\t\t\t\tthis.filter.disconnect(this.context.destination);\n\t\t\t} else {\n\t\t\t\tthis.gain.disconnect(this.context.destination);\n\t\t\t}\n\n\t\t\tthis.filter = value;\n\t\t\tthis.gain.connect(this.filter);\n\t\t\tthis.filter.connect(this.context.destination);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetMasterVolume() {\n\t\t\treturn this.gain.gain.value;\n\t\t}\n\n\t\tsetMasterVolume(value) {\n\t\t\tthis.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\n\t\t\treturn this;\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t\tconst listener = this.context.listener;\n\t\t\tconst up = this.up;\n\t\t\tthis.timeDelta = this._clock.getDelta();\n\t\t\tthis.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);\n\n\t\t\t_orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);\n\n\t\t\tif (listener.positionX) {\n\t\t\t\t// code path for Chrome (see #14393)\n\t\t\t\tconst endTime = this.context.currentTime + this.timeDelta;\n\t\t\t\tlistener.positionX.linearRampToValueAtTime(_position$1.x, endTime);\n\t\t\t\tlistener.positionY.linearRampToValueAtTime(_position$1.y, endTime);\n\t\t\t\tlistener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);\n\t\t\t\tlistener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);\n\t\t\t\tlistener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);\n\t\t\t\tlistener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);\n\t\t\t\tlistener.upX.linearRampToValueAtTime(up.x, endTime);\n\t\t\t\tlistener.upY.linearRampToValueAtTime(up.y, endTime);\n\t\t\t\tlistener.upZ.linearRampToValueAtTime(up.z, endTime);\n\t\t\t} else {\n\t\t\t\tlistener.setPosition(_position$1.x, _position$1.y, _position$1.z);\n\t\t\t\tlistener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass Audio extends Object3D {\n\t\tconstructor(listener) {\n\t\t\tsuper();\n\t\t\tthis.type = 'Audio';\n\t\t\tthis.listener = listener;\n\t\t\tthis.context = listener.context;\n\t\t\tthis.gain = this.context.createGain();\n\t\t\tthis.gain.connect(listener.getInput());\n\t\t\tthis.autoplay = false;\n\t\t\tthis.buffer = null;\n\t\t\tthis.detune = 0;\n\t\t\tthis.loop = false;\n\t\t\tthis.loopStart = 0;\n\t\t\tthis.loopEnd = 0;\n\t\t\tthis.offset = 0;\n\t\t\tthis.duration = undefined;\n\t\t\tthis.playbackRate = 1;\n\t\t\tthis.isPlaying = false;\n\t\t\tthis.hasPlaybackControl = true;\n\t\t\tthis.source = null;\n\t\t\tthis.sourceType = 'empty';\n\t\t\tthis._startedAt = 0;\n\t\t\tthis._progress = 0;\n\t\t\tthis._connected = false;\n\t\t\tthis.filters = [];\n\t\t}\n\n\t\tgetOutput() {\n\t\t\treturn this.gain;\n\t\t}\n\n\t\tsetNodeSource(audioNode) {\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'audioNode';\n\t\t\tthis.source = audioNode;\n\t\t\tthis.connect();\n\t\t\treturn this;\n\t\t}\n\n\t\tsetMediaElementSource(mediaElement) {\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'mediaNode';\n\t\t\tthis.source = this.context.createMediaElementSource(mediaElement);\n\t\t\tthis.connect();\n\t\t\treturn this;\n\t\t}\n\n\t\tsetMediaStreamSource(mediaStream) {\n\t\t\tthis.hasPlaybackControl = false;\n\t\t\tthis.sourceType = 'mediaStreamNode';\n\t\t\tthis.source = this.context.createMediaStreamSource(mediaStream);\n\t\t\tthis.connect();\n\t\t\treturn this;\n\t\t}\n\n\t\tsetBuffer(audioBuffer) {\n\t\t\tthis.buffer = audioBuffer;\n\t\t\tthis.sourceType = 'buffer';\n\t\t\tif (this.autoplay) this.play();\n\t\t\treturn this;\n\t\t}\n\n\t\tplay(delay = 0) {\n\t\t\tif (this.isPlaying === true) {\n\t\t\t\tconsole.warn('THREE.Audio: Audio is already playing.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._startedAt = this.context.currentTime + delay;\n\t\t\tconst source = this.context.createBufferSource();\n\t\t\tsource.buffer = this.buffer;\n\t\t\tsource.loop = this.loop;\n\t\t\tsource.loopStart = this.loopStart;\n\t\t\tsource.loopEnd = this.loopEnd;\n\t\t\tsource.onended = this.onEnded.bind(this);\n\t\t\tsource.start(this._startedAt, this._progress + this.offset, this.duration);\n\t\t\tthis.isPlaying = true;\n\t\t\tthis.source = source;\n\t\t\tthis.setDetune(this.detune);\n\t\t\tthis.setPlaybackRate(this.playbackRate);\n\t\t\treturn this.connect();\n\t\t}\n\n\t\tpause() {\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.isPlaying === true) {\n\t\t\t\t// update current progress\n\t\t\t\tthis._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;\n\n\t\t\t\tif (this.loop === true) {\n\t\t\t\t\t// ensure _progress does not exceed duration with looped audios\n\t\t\t\t\tthis._progress = this._progress % (this.duration || this.buffer.duration);\n\t\t\t\t}\n\n\t\t\t\tthis.source.stop();\n\t\t\t\tthis.source.onended = null;\n\t\t\t\tthis.isPlaying = false;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tstop() {\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._progress = 0;\n\t\t\tthis.source.stop();\n\t\t\tthis.source.onended = null;\n\t\t\tthis.isPlaying = false;\n\t\t\treturn this;\n\t\t}\n\n\t\tconnect() {\n\t\t\tif (this.filters.length > 0) {\n\t\t\t\tthis.source.connect(this.filters[0]);\n\n\t\t\t\tfor (let i = 1, l = this.filters.length; i < l; i++) {\n\t\t\t\t\tthis.filters[i - 1].connect(this.filters[i]);\n\t\t\t\t}\n\n\t\t\t\tthis.filters[this.filters.length - 1].connect(this.getOutput());\n\t\t\t} else {\n\t\t\t\tthis.source.connect(this.getOutput());\n\t\t\t}\n\n\t\t\tthis._connected = true;\n\t\t\treturn this;\n\t\t}\n\n\t\tdisconnect() {\n\t\t\tif (this.filters.length > 0) {\n\t\t\t\tthis.source.disconnect(this.filters[0]);\n\n\t\t\t\tfor (let i = 1, l = this.filters.length; i < l; i++) {\n\t\t\t\t\tthis.filters[i - 1].disconnect(this.filters[i]);\n\t\t\t\t}\n\n\t\t\t\tthis.filters[this.filters.length - 1].disconnect(this.getOutput());\n\t\t\t} else {\n\t\t\t\tthis.source.disconnect(this.getOutput());\n\t\t\t}\n\n\t\t\tthis._connected = false;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetFilters() {\n\t\t\treturn this.filters;\n\t\t}\n\n\t\tsetFilters(value) {\n\t\t\tif (!value) value = [];\n\n\t\t\tif (this._connected === true) {\n\t\t\t\tthis.disconnect();\n\t\t\t\tthis.filters = value.slice();\n\t\t\t\tthis.connect();\n\t\t\t} else {\n\t\t\t\tthis.filters = value.slice();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetDetune(value) {\n\t\t\tthis.detune = value;\n\t\t\tif (this.source.detune === undefined) return; // only set detune when available\n\n\t\t\tif (this.isPlaying === true) {\n\t\t\t\tthis.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetDetune() {\n\t\t\treturn this.detune;\n\t\t}\n\n\t\tgetFilter() {\n\t\t\treturn this.getFilters()[0];\n\t\t}\n\n\t\tsetFilter(filter) {\n\t\t\treturn this.setFilters(filter ? [filter] : []);\n\t\t}\n\n\t\tsetPlaybackRate(value) {\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.playbackRate = value;\n\n\t\t\tif (this.isPlaying === true) {\n\t\t\t\tthis.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tgetPlaybackRate() {\n\t\t\treturn this.playbackRate;\n\t\t}\n\n\t\tonEnded() {\n\t\t\tthis.isPlaying = false;\n\t\t}\n\n\t\tgetLoop() {\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn this.loop;\n\t\t}\n\n\t\tsetLoop(value) {\n\t\t\tif (this.hasPlaybackControl === false) {\n\t\t\t\tconsole.warn('THREE.Audio: this Audio has no playback control.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.loop = value;\n\n\t\t\tif (this.isPlaying === true) {\n\t\t\t\tthis.source.loop = this.loop;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetLoopStart(value) {\n\t\t\tthis.loopStart = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetLoopEnd(value) {\n\t\t\tthis.loopEnd = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetVolume() {\n\t\t\treturn this.gain.gain.value;\n\t\t}\n\n\t\tsetVolume(value) {\n\t\t\tthis.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tconst _position = /*@__PURE__*/new Vector3();\n\n\tconst _quaternion = /*@__PURE__*/new Quaternion();\n\n\tconst _scale = /*@__PURE__*/new Vector3();\n\n\tconst _orientation = /*@__PURE__*/new Vector3();\n\n\tclass PositionalAudio extends Audio {\n\t\tconstructor(listener) {\n\t\t\tsuper(listener);\n\t\t\tthis.panner = this.context.createPanner();\n\t\t\tthis.panner.panningModel = 'HRTF';\n\t\t\tthis.panner.connect(this.gain);\n\t\t}\n\n\t\tgetOutput() {\n\t\t\treturn this.panner;\n\t\t}\n\n\t\tgetRefDistance() {\n\t\t\treturn this.panner.refDistance;\n\t\t}\n\n\t\tsetRefDistance(value) {\n\t\t\tthis.panner.refDistance = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetRolloffFactor() {\n\t\t\treturn this.panner.rolloffFactor;\n\t\t}\n\n\t\tsetRolloffFactor(value) {\n\t\t\tthis.panner.rolloffFactor = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetDistanceModel() {\n\t\t\treturn this.panner.distanceModel;\n\t\t}\n\n\t\tsetDistanceModel(value) {\n\t\t\tthis.panner.distanceModel = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tgetMaxDistance() {\n\t\t\treturn this.panner.maxDistance;\n\t\t}\n\n\t\tsetMaxDistance(value) {\n\t\t\tthis.panner.maxDistance = value;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {\n\t\t\tthis.panner.coneInnerAngle = coneInnerAngle;\n\t\t\tthis.panner.coneOuterAngle = coneOuterAngle;\n\t\t\tthis.panner.coneOuterGain = coneOuterGain;\n\t\t\treturn this;\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t\tif (this.hasPlaybackControl === true && this.isPlaying === false) return;\n\t\t\tthis.matrixWorld.decompose(_position, _quaternion, _scale);\n\n\t\t\t_orientation.set(0, 0, 1).applyQuaternion(_quaternion);\n\n\t\t\tconst panner = this.panner;\n\n\t\t\tif (panner.positionX) {\n\t\t\t\t// code path for Chrome and Firefox (see #14393)\n\t\t\t\tconst endTime = this.context.currentTime + this.listener.timeDelta;\n\t\t\t\tpanner.positionX.linearRampToValueAtTime(_position.x, endTime);\n\t\t\t\tpanner.positionY.linearRampToValueAtTime(_position.y, endTime);\n\t\t\t\tpanner.positionZ.linearRampToValueAtTime(_position.z, endTime);\n\t\t\t\tpanner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);\n\t\t\t\tpanner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);\n\t\t\t\tpanner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);\n\t\t\t} else {\n\t\t\t\tpanner.setPosition(_position.x, _position.y, _position.z);\n\t\t\t\tpanner.setOrientation(_orientation.x, _orientation.y, _orientation.z);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tclass AudioAnalyser {\n\t\tconstructor(audio, fftSize = 2048) {\n\t\t\tthis.analyser = audio.context.createAnalyser();\n\t\t\tthis.analyser.fftSize = fftSize;\n\t\t\tthis.data = new Uint8Array(this.analyser.frequencyBinCount);\n\t\t\taudio.getOutput().connect(this.analyser);\n\t\t}\n\n\t\tgetFrequencyData() {\n\t\t\tthis.analyser.getByteFrequencyData(this.data);\n\t\t\treturn this.data;\n\t\t}\n\n\t\tgetAverageFrequency() {\n\t\t\tlet value = 0;\n\t\t\tconst data = this.getFrequencyData();\n\n\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\tvalue += data[i];\n\t\t\t}\n\n\t\t\treturn value / data.length;\n\t\t}\n\n\t}\n\n\tclass PropertyMixer {\n\t\tconstructor(binding, typeName, valueSize) {\n\t\t\tthis.binding = binding;\n\t\t\tthis.valueSize = valueSize;\n\t\t\tlet mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t\t\t//\n\t\t\t// interpolators can use .buffer as their .result\n\t\t\t// the data then goes to 'incoming'\n\t\t\t//\n\t\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t\t// the cumulative result and are compared to detect\n\t\t\t// changes\n\t\t\t//\n\t\t\t// 'orig' stores the original state of the property\n\t\t\t//\n\t\t\t// 'add' is used for additive cumulative results\n\t\t\t//\n\t\t\t// 'work' is optional and is only present for quaternion types. It is used\n\t\t\t// to store intermediate quaternion multiplication results\n\n\t\t\tswitch (typeName) {\n\t\t\t\tcase 'quaternion':\n\t\t\t\t\tmixFunction = this._slerp;\n\t\t\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\t\t\t\t\tthis.buffer = new Float64Array(valueSize * 6);\n\t\t\t\t\tthis._workIndex = 5;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'string':\n\t\t\t\tcase 'bool':\n\t\t\t\t\tmixFunction = this._select; // Use the regular mix function and for additive on these types,\n\t\t\t\t\t// additive is not relevant for non-numeric types\n\n\t\t\t\t\tmixFunctionAdditive = this._select;\n\t\t\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\t\t\t\t\tthis.buffer = new Array(valueSize * 5);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmixFunction = this._lerp;\n\t\t\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\t\t\t\t\tthis.buffer = new Float64Array(valueSize * 5);\n\t\t\t}\n\n\t\t\tthis._mixBufferRegion = mixFunction;\n\t\t\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\t\t\tthis._setIdentity = setIdentity;\n\t\t\tthis._origIndex = 3;\n\t\t\tthis._addIndex = 4;\n\t\t\tthis.cumulativeWeight = 0;\n\t\t\tthis.cumulativeWeightAdditive = 0;\n\t\t\tthis.useCount = 0;\n\t\t\tthis.referenceCount = 0;\n\t\t} // accumulate data in the 'incoming' region into 'accu<i>'\n\n\n\t\taccumulate(accuIndex, weight) {\n\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t\t// the weight and shouldn't have made the call in the first place\n\t\t\tconst buffer = this.buffer,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\toffset = accuIndex * stride + stride;\n\t\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\t\tif (currentWeight === 0) {\n\t\t\t\t// accuN := incoming * weight\n\t\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\t\tbuffer[offset + i] = buffer[i];\n\t\t\t\t}\n\n\t\t\t\tcurrentWeight = weight;\n\t\t\t} else {\n\t\t\t\t// accuN := accuN + incoming * weight\n\t\t\t\tcurrentWeight += weight;\n\t\t\t\tconst mix = weight / currentWeight;\n\n\t\t\t\tthis._mixBufferRegion(buffer, offset, 0, mix, stride);\n\t\t\t}\n\n\t\t\tthis.cumulativeWeight = currentWeight;\n\t\t} // accumulate data in the 'incoming' region into 'add'\n\n\n\t\taccumulateAdditive(weight) {\n\t\t\tconst buffer = this.buffer,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\toffset = stride * this._addIndex;\n\n\t\t\tif (this.cumulativeWeightAdditive === 0) {\n\t\t\t\t// add = identity\n\t\t\t\tthis._setIdentity();\n\t\t\t} // add := add + incoming * weight\n\n\n\t\t\tthis._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);\n\n\t\t\tthis.cumulativeWeightAdditive += weight;\n\t\t} // apply the state of 'accu<i>' to the binding when accus differ\n\n\n\t\tapply(accuIndex) {\n\t\t\tconst stride = this.valueSize,\n\t\t\t\t\t\tbuffer = this.buffer,\n\t\t\t\t\t\toffset = accuIndex * stride + stride,\n\t\t\t\t\t\tweight = this.cumulativeWeight,\n\t\t\t\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\t\t\t\t\t\tbinding = this.binding;\n\t\t\tthis.cumulativeWeight = 0;\n\t\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\t\tif (weight < 1) {\n\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\t\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\t\tthis._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);\n\t\t\t}\n\n\t\t\tif (weightAdditive > 0) {\n\t\t\t\t// accuN := accuN + additive accuN\n\t\t\t\tthis._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);\n\t\t\t}\n\n\t\t\tfor (let i = stride, e = stride + stride; i !== e; ++i) {\n\t\t\t\tif (buffer[i] !== buffer[i + stride]) {\n\t\t\t\t\t// value has changed -> update scene graph\n\t\t\t\t\tbinding.setValue(buffer, offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} // remember the state of the bound property and copy it to both accus\n\n\n\t\tsaveOriginalState() {\n\t\t\tconst binding = this.binding;\n\t\t\tconst buffer = this.buffer,\n\t\t\t\t\t\tstride = this.valueSize,\n\t\t\t\t\t\toriginalValueOffset = stride * this._origIndex;\n\t\t\tbinding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original\n\n\t\t\tfor (let i = stride, e = originalValueOffset; i !== e; ++i) {\n\t\t\t\tbuffer[i] = buffer[originalValueOffset + i % stride];\n\t\t\t} // Add to identity for additive\n\n\n\t\t\tthis._setIdentity();\n\n\t\t\tthis.cumulativeWeight = 0;\n\t\t\tthis.cumulativeWeightAdditive = 0;\n\t\t} // apply the state previously taken via 'saveOriginalState' to the binding\n\n\n\t\trestoreOriginalState() {\n\t\t\tconst originalValueOffset = this.valueSize * 3;\n\t\t\tthis.binding.setValue(this.buffer, originalValueOffset);\n\t\t}\n\n\t\t_setAdditiveIdentityNumeric() {\n\t\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\t\tfor (let i = startIndex; i < endIndex; i++) {\n\t\t\t\tthis.buffer[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t_setAdditiveIdentityQuaternion() {\n\t\t\tthis._setAdditiveIdentityNumeric();\n\n\t\t\tthis.buffer[this._addIndex * this.valueSize + 3] = 1;\n\t\t}\n\n\t\t_setAdditiveIdentityOther() {\n\t\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\t\tfor (let i = 0; i < this.valueSize; i++) {\n\t\t\t\tthis.buffer[targetIndex + i] = this.buffer[startIndex + i];\n\t\t\t}\n\t\t} // mix functions\n\n\n\t\t_select(buffer, dstOffset, srcOffset, t, stride) {\n\t\t\tif (t >= 0.5) {\n\t\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\t\tbuffer[dstOffset + i] = buffer[srcOffset + i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_slerp(buffer, dstOffset, srcOffset, t) {\n\t\t\tQuaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);\n\t\t}\n\n\t\t_slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n\t\t\tconst workOffset = this._workIndex * stride; // Store result in intermediate buffer offset\n\n\t\t\tQuaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result\n\n\t\t\tQuaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);\n\t\t}\n\n\t\t_lerp(buffer, dstOffset, srcOffset, t, stride) {\n\t\t\tconst s = 1 - t;\n\n\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\tconst j = dstOffset + i;\n\t\t\t\tbuffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;\n\t\t\t}\n\t\t}\n\n\t\t_lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n\t\t\tfor (let i = 0; i !== stride; ++i) {\n\t\t\t\tconst j = dstOffset + i;\n\t\t\t\tbuffer[j] = buffer[j] + buffer[srcOffset + i] * t;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// Characters [].:/ are reserved for track binding syntax.\n\tconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\n\n\tconst _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\\w` regexp matches\n\t// only latin characters, and the unicode \\p{L} is not yet supported. So\n\t// instead, we exclude reserved characters and match everything else.\n\n\n\tconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\n\n\tconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must\n\t// be matched to parse the rest of the track name.\n\n\n\tconst _directoryRe = /((?:WC+[\\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\n\n\n\tconst _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved\n\t// characters. Accessor may contain any character except closing bracket.\n\n\n\tconst _objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may\n\t// contain any non-bracket characters.\n\n\n\tconst _propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace('WC', _wordChar);\n\n\tconst _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');\n\n\tconst _supportedObjectNames = ['material', 'materials', 'bones'];\n\n\tclass Composite {\n\t\tconstructor(targetGroup, path, optionalParsedPath) {\n\t\t\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);\n\t\t\tthis._targetGroup = targetGroup;\n\t\t\tthis._bindings = targetGroup.subscribe_(path, parsedPath);\n\t\t}\n\n\t\tgetValue(array, offset) {\n\t\t\tthis.bind(); // bind all binding\n\n\t\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\t\t\t\tbinding = this._bindings[firstValidIndex]; // and only call .getValue on the first\n\n\t\t\tif (binding !== undefined) binding.getValue(array, offset);\n\t\t}\n\n\t\tsetValue(array, offset) {\n\t\t\tconst bindings = this._bindings;\n\n\t\t\tfor (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n\t\t\t\tbindings[i].setValue(array, offset);\n\t\t\t}\n\t\t}\n\n\t\tbind() {\n\t\t\tconst bindings = this._bindings;\n\n\t\t\tfor (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n\t\t\t\tbindings[i].bind();\n\t\t\t}\n\t\t}\n\n\t\tunbind() {\n\t\t\tconst bindings = this._bindings;\n\n\t\t\tfor (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n\t\t\t\tbindings[i].unbind();\n\t\t\t}\n\t\t}\n\n\t} // Note: This class uses a State pattern on a per-method basis:\n\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n\t// prototype version of these methods with one that represents\n\t// the bound state. When the property is not found, the methods\n\t// become no-ops.\n\n\n\tclass PropertyBinding {\n\t\tconstructor(rootNode, path, parsedPath) {\n\t\t\tthis.path = path;\n\t\t\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);\n\t\t\tthis.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;\n\t\t\tthis.rootNode = rootNode; // initial state of these methods that calls 'bind'\n\n\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\tthis.setValue = this._setValue_unbound;\n\t\t}\n\n\t\tstatic create(root, path, parsedPath) {\n\t\t\tif (!(root && root.isAnimationObjectGroup)) {\n\t\t\t\treturn new PropertyBinding(root, path, parsedPath);\n\t\t\t} else {\n\t\t\t\treturn new PropertyBinding.Composite(root, path, parsedPath);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Replaces spaces with underscores and removes unsupported characters from\n\t\t * node names, to ensure compatibility with parseTrackName().\n\t\t *\n\t\t * @param {string} name Node name to be sanitized.\n\t\t * @return {string}\n\t\t */\n\n\n\t\tstatic sanitizeNodeName(name) {\n\t\t\treturn name.replace(/\\s/g, '_').replace(_reservedRe, '');\n\t\t}\n\n\t\tstatic parseTrackName(trackName) {\n\t\t\tconst matches = _trackRe.exec(trackName);\n\n\t\t\tif (!matches) {\n\t\t\t\tthrow new Error('PropertyBinding: Cannot parse trackName: ' + trackName);\n\t\t\t}\n\n\t\t\tconst results = {\n\t\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\t\tnodeName: matches[2],\n\t\t\t\tobjectName: matches[3],\n\t\t\t\tobjectIndex: matches[4],\n\t\t\t\tpropertyName: matches[5],\n\t\t\t\t// required\n\t\t\t\tpropertyIndex: matches[6]\n\t\t\t};\n\t\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf('.');\n\n\t\t\tif (lastDot !== undefined && lastDot !== -1) {\n\t\t\t\tconst objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there\n\t\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t\t// include '.' characters).\n\n\t\t\t\tif (_supportedObjectNames.indexOf(objectName) !== -1) {\n\t\t\t\t\tresults.nodeName = results.nodeName.substring(0, lastDot);\n\t\t\t\t\tresults.objectName = objectName;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (results.propertyName === null || results.propertyName.length === 0) {\n\t\t\t\tthrow new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);\n\t\t\t}\n\n\t\t\treturn results;\n\t\t}\n\n\t\tstatic findNode(root, nodeName) {\n\t\t\tif (!nodeName || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {\n\t\t\t\treturn root;\n\t\t\t} // search into skeleton bones.\n\n\n\t\t\tif (root.skeleton) {\n\t\t\t\tconst bone = root.skeleton.getBoneByName(nodeName);\n\n\t\t\t\tif (bone !== undefined) {\n\t\t\t\t\treturn bone;\n\t\t\t\t}\n\t\t\t} // search into node subtree.\n\n\n\t\t\tif (root.children) {\n\t\t\t\tconst searchNodeSubtree = function (children) {\n\t\t\t\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\t\t\t\tconst childNode = children[i];\n\n\t\t\t\t\t\tif (childNode.name === nodeName || childNode.uuid === nodeName) {\n\t\t\t\t\t\t\treturn childNode;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst result = searchNodeSubtree(childNode.children);\n\t\t\t\t\t\tif (result) return result;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t};\n\n\t\t\t\tconst subTreeNode = searchNodeSubtree(root.children);\n\n\t\t\t\tif (subTreeNode) {\n\t\t\t\t\treturn subTreeNode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t} // these are used to \"bind\" a nonexistent property\n\n\n\t\t_getValue_unavailable() {}\n\n\t\t_setValue_unavailable() {} // Getters\n\n\n\t\t_getValue_direct(buffer, offset) {\n\t\t\tbuffer[offset] = this.node[this.propertyName];\n\t\t}\n\n\t\t_getValue_array(buffer, offset) {\n\t\t\tconst source = this.resolvedProperty;\n\n\t\t\tfor (let i = 0, n = source.length; i !== n; ++i) {\n\t\t\t\tbuffer[offset++] = source[i];\n\t\t\t}\n\t\t}\n\n\t\t_getValue_arrayElement(buffer, offset) {\n\t\t\tbuffer[offset] = this.resolvedProperty[this.propertyIndex];\n\t\t}\n\n\t\t_getValue_toArray(buffer, offset) {\n\t\t\tthis.resolvedProperty.toArray(buffer, offset);\n\t\t} // Direct\n\n\n\t\t_setValue_direct(buffer, offset) {\n\t\t\tthis.targetObject[this.propertyName] = buffer[offset];\n\t\t}\n\n\t\t_setValue_direct_setNeedsUpdate(buffer, offset) {\n\t\t\tthis.targetObject[this.propertyName] = buffer[offset];\n\t\t\tthis.targetObject.needsUpdate = true;\n\t\t}\n\n\t\t_setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {\n\t\t\tthis.targetObject[this.propertyName] = buffer[offset];\n\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\t} // EntireArray\n\n\n\t\t_setValue_array(buffer, offset) {\n\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\tfor (let i = 0, n = dest.length; i !== n; ++i) {\n\t\t\t\tdest[i] = buffer[offset++];\n\t\t\t}\n\t\t}\n\n\t\t_setValue_array_setNeedsUpdate(buffer, offset) {\n\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\tfor (let i = 0, n = dest.length; i !== n; ++i) {\n\t\t\t\tdest[i] = buffer[offset++];\n\t\t\t}\n\n\t\t\tthis.targetObject.needsUpdate = true;\n\t\t}\n\n\t\t_setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {\n\t\t\tconst dest = this.resolvedProperty;\n\n\t\t\tfor (let i = 0, n = dest.length; i !== n; ++i) {\n\t\t\t\tdest[i] = buffer[offset++];\n\t\t\t}\n\n\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\t} // ArrayElement\n\n\n\t\t_setValue_arrayElement(buffer, offset) {\n\t\t\tthis.resolvedProperty[this.propertyIndex] = buffer[offset];\n\t\t}\n\n\t\t_setValue_arrayElement_setNeedsUpdate(buffer, offset) {\n\t\t\tthis.resolvedProperty[this.propertyIndex] = buffer[offset];\n\t\t\tthis.targetObject.needsUpdate = true;\n\t\t}\n\n\t\t_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {\n\t\t\tthis.resolvedProperty[this.propertyIndex] = buffer[offset];\n\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\t} // HasToFromArray\n\n\n\t\t_setValue_fromArray(buffer, offset) {\n\t\t\tthis.resolvedProperty.fromArray(buffer, offset);\n\t\t}\n\n\t\t_setValue_fromArray_setNeedsUpdate(buffer, offset) {\n\t\t\tthis.resolvedProperty.fromArray(buffer, offset);\n\t\t\tthis.targetObject.needsUpdate = true;\n\t\t}\n\n\t\t_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {\n\t\t\tthis.resolvedProperty.fromArray(buffer, offset);\n\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\t\t}\n\n\t\t_getValue_unbound(targetArray, offset) {\n\t\t\tthis.bind();\n\t\t\tthis.getValue(targetArray, offset);\n\t\t}\n\n\t\t_setValue_unbound(sourceArray, offset) {\n\t\t\tthis.bind();\n\t\t\tthis.setValue(sourceArray, offset);\n\t\t} // create getter / setter pair for a property in the scene graph\n\n\n\t\tbind() {\n\t\t\tlet targetObject = this.node;\n\t\t\tconst parsedPath = this.parsedPath;\n\t\t\tconst objectName = parsedPath.objectName;\n\t\t\tconst propertyName = parsedPath.propertyName;\n\t\t\tlet propertyIndex = parsedPath.propertyIndex;\n\n\t\t\tif (!targetObject) {\n\t\t\t\ttargetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;\n\t\t\t\tthis.node = targetObject;\n\t\t\t} // set fail state so we can just 'return' on error\n\n\n\t\t\tthis.getValue = this._getValue_unavailable;\n\t\t\tthis.setValue = this._setValue_unavailable; // ensure there is a value node\n\n\t\t\tif (!targetObject) {\n\t\t\t\tconsole.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (objectName) {\n\t\t\t\tlet objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....\n\n\t\t\t\tswitch (objectName) {\n\t\t\t\t\tcase 'materials':\n\t\t\t\t\t\tif (!targetObject.material) {\n\t\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!targetObject.material.materials) {\n\t\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject.material.materials;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bones':\n\t\t\t\t\t\tif (!targetObject.skeleton) {\n\t\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} // potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t\t// and convert the integer string to a true integer.\n\n\n\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.\n\n\t\t\t\t\t\tfor (let i = 0; i < targetObject.length; i++) {\n\t\t\t\t\t\t\tif (targetObject[i].name === objectIndex) {\n\t\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif (targetObject[objectName] === undefined) {\n\t\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttargetObject = targetObject[objectName];\n\t\t\t\t}\n\n\t\t\t\tif (objectIndex !== undefined) {\n\t\t\t\t\tif (targetObject[objectIndex] === undefined) {\n\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[objectIndex];\n\t\t\t\t}\n\t\t\t} // resolve property\n\n\n\t\t\tconst nodeProperty = targetObject[propertyName];\n\n\t\t\tif (nodeProperty === undefined) {\n\t\t\t\tconst nodeName = parsedPath.nodeName;\n\t\t\t\tconsole.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\\'t found.', targetObject);\n\t\t\t\treturn;\n\t\t\t} // determine versioning scheme\n\n\n\t\t\tlet versioning = this.Versioning.None;\n\t\t\tthis.targetObject = targetObject;\n\n\t\t\tif (targetObject.needsUpdate !== undefined) {\n\t\t\t\t// material\n\t\t\t\tversioning = this.Versioning.NeedsUpdate;\n\t\t\t} else if (targetObject.matrixWorldNeedsUpdate !== undefined) {\n\t\t\t\t// node transform\n\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\t\t\t} // determine how the property gets bound\n\n\n\t\t\tlet bindingType = this.BindingType.Direct;\n\n\t\t\tif (propertyIndex !== undefined) {\n\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\t\t\t\tif (propertyName === 'morphTargetInfluences') {\n\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tif (!targetObject.geometry) {\n\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (targetObject.geometry.isBufferGeometry) {\n\t\t\t\t\t\tif (!targetObject.geometry.morphAttributes) {\n\t\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {\n\t\t\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[propertyIndex];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbindingType = this.BindingType.ArrayElement;\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t\tthis.propertyIndex = propertyIndex;\n\t\t\t} else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {\n\t\t\t\t// must use copy for Object3D.Euler/Quaternion\n\t\t\t\tbindingType = this.BindingType.HasFromToArray;\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t} else if (Array.isArray(nodeProperty)) {\n\t\t\t\tbindingType = this.BindingType.EntireArray;\n\t\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\t} else {\n\t\t\t\tthis.propertyName = propertyName;\n\t\t\t} // select getter / setter\n\n\n\t\t\tthis.getValue = this.GetterByBindingType[bindingType];\n\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];\n\t\t}\n\n\t\tunbind() {\n\t\t\tthis.node = null; // back to the prototype version of getValue / setValue\n\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\n\t\t\tthis.getValue = this._getValue_unbound;\n\t\t\tthis.setValue = this._setValue_unbound;\n\t\t}\n\n\t}\n\n\tPropertyBinding.Composite = Composite;\n\tPropertyBinding.prototype.BindingType = {\n\t\tDirect: 0,\n\t\tEntireArray: 1,\n\t\tArrayElement: 2,\n\t\tHasFromToArray: 3\n\t};\n\tPropertyBinding.prototype.Versioning = {\n\t\tNone: 0,\n\t\tNeedsUpdate: 1,\n\t\tMatrixWorldNeedsUpdate: 2\n\t};\n\tPropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];\n\tPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[// Direct\n\tPropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [// EntireArray\n\tPropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [// ArrayElement\n\tPropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [// HasToFromArray\n\tPropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];\n\n\t/**\n\t *\n\t * A group of objects that receives a shared animation state.\n\t *\n\t * Usage:\n\t *\n\t *\t- Add objects you would otherwise pass as 'root' to the\n\t *\t\tconstructor or the .clipAction method of AnimationMixer.\n\t *\n\t *\t- Instead pass this object as 'root'.\n\t *\n\t *\t- You can also add and remove objects later when the mixer\n\t *\t\tis running.\n\t *\n\t * Note:\n\t *\n\t *\t\tObjects of this class appear as one object to the mixer,\n\t *\t\tso cache control of the individual objects must be done\n\t *\t\ton the group.\n\t *\n\t * Limitation:\n\t *\n\t *\t- The animated properties must be compatible among the\n\t *\t\tall objects in the group.\n\t *\n\t *\t- A single property can either be controlled through a\n\t *\t\ttarget group or directly, but not both.\n\t */\n\n\tclass AnimationObjectGroup {\n\t\tconstructor() {\n\t\t\tthis.uuid = generateUUID(); // cached objects followed by the active ones\n\n\t\t\tthis._objects = Array.prototype.slice.call(arguments);\n\t\t\tthis.nCachedObjects_ = 0; // threshold\n\t\t\t// note: read by PropertyBinding.Composite\n\n\t\t\tconst indices = {};\n\t\t\tthis._indicesByUUID = indices; // for bookkeeping\n\n\t\t\tfor (let i = 0, n = arguments.length; i !== n; ++i) {\n\t\t\t\tindices[arguments[i].uuid] = i;\n\t\t\t}\n\n\t\t\tthis._paths = []; // inside: string\n\n\t\t\tthis._parsedPaths = []; // inside: { we don't care, here }\n\n\t\t\tthis._bindings = []; // inside: Array< PropertyBinding >\n\n\t\t\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\t\t\tconst scope = this;\n\t\t\tthis.stats = {\n\t\t\t\tobjects: {\n\t\t\t\t\tget total() {\n\t\t\t\t\t\treturn scope._objects.length;\n\t\t\t\t\t},\n\n\t\t\t\t\tget inUse() {\n\t\t\t\t\t\treturn this.total - scope.nCachedObjects_;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tget bindingsPerObject() {\n\t\t\t\t\treturn scope._bindings.length;\n\t\t\t\t}\n\n\t\t\t};\n\t\t}\n\n\t\tadd() {\n\t\t\tconst objects = this._objects,\n\t\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\t\tpaths = this._paths,\n\t\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\t\tnBindings = bindings.length;\n\t\t\tlet knownObject = undefined,\n\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\tnCachedObjects = this.nCachedObjects_;\n\n\t\t\tfor (let i = 0, n = arguments.length; i !== n; ++i) {\n\t\t\t\tconst object = arguments[i],\n\t\t\t\t\t\t\tuuid = object.uuid;\n\t\t\t\tlet index = indicesByUUID[uuid];\n\n\t\t\t\tif (index === undefined) {\n\t\t\t\t\t// unknown object -> add it to the ACTIVE region\n\t\t\t\t\tindex = nObjects++;\n\t\t\t\t\tindicesByUUID[uuid] = index;\n\t\t\t\t\tobjects.push(object); // accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor (let j = 0, m = nBindings; j !== m; ++j) {\n\t\t\t\t\t\tbindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));\n\t\t\t\t\t}\n\t\t\t\t} else if (index < nCachedObjects) {\n\t\t\t\t\tknownObject = objects[index]; // move existing object to the ACTIVE region\n\n\t\t\t\t\tconst firstActiveIndex = --nCachedObjects,\n\t\t\t\t\t\t\t\tlastCachedObject = objects[firstActiveIndex];\n\t\t\t\t\tindicesByUUID[lastCachedObject.uuid] = index;\n\t\t\t\t\tobjects[index] = lastCachedObject;\n\t\t\t\t\tindicesByUUID[uuid] = firstActiveIndex;\n\t\t\t\t\tobjects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor (let j = 0, m = nBindings; j !== m; ++j) {\n\t\t\t\t\t\tconst bindingsForPath = bindings[j],\n\t\t\t\t\t\t\t\t\tlastCached = bindingsForPath[firstActiveIndex];\n\t\t\t\t\t\tlet binding = bindingsForPath[index];\n\t\t\t\t\t\tbindingsForPath[index] = lastCached;\n\n\t\t\t\t\t\tif (binding === undefined) {\n\t\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t\t// or may not exist\n\t\t\t\t\t\t\tbinding = new PropertyBinding(object, paths[j], parsedPaths[j]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbindingsForPath[firstActiveIndex] = binding;\n\t\t\t\t\t}\n\t\t\t\t} else if (objects[index] !== knownObject) {\n\t\t\t\t\tconsole.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');\n\t\t\t\t} // else the object is already where we want it to be\n\n\t\t\t} // for arguments\n\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\t}\n\n\t\tremove() {\n\t\t\tconst objects = this._objects,\n\t\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\t\tnBindings = bindings.length;\n\t\t\tlet nCachedObjects = this.nCachedObjects_;\n\n\t\t\tfor (let i = 0, n = arguments.length; i !== n; ++i) {\n\t\t\t\tconst object = arguments[i],\n\t\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\t\tindex = indicesByUUID[uuid];\n\n\t\t\t\tif (index !== undefined && index >= nCachedObjects) {\n\t\t\t\t\t// move existing object into the CACHED region\n\t\t\t\t\tconst lastCachedIndex = nCachedObjects++,\n\t\t\t\t\t\t\t\tfirstActiveObject = objects[lastCachedIndex];\n\t\t\t\t\tindicesByUUID[firstActiveObject.uuid] = index;\n\t\t\t\t\tobjects[index] = firstActiveObject;\n\t\t\t\t\tindicesByUUID[uuid] = lastCachedIndex;\n\t\t\t\t\tobjects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor (let j = 0, m = nBindings; j !== m; ++j) {\n\t\t\t\t\t\tconst bindingsForPath = bindings[j],\n\t\t\t\t\t\t\t\t\tfirstActive = bindingsForPath[lastCachedIndex],\n\t\t\t\t\t\t\t\t\tbinding = bindingsForPath[index];\n\t\t\t\t\t\tbindingsForPath[index] = firstActive;\n\t\t\t\t\t\tbindingsForPath[lastCachedIndex] = binding;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // for arguments\n\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\t} // remove & forget\n\n\n\t\tuncache() {\n\t\t\tconst objects = this._objects,\n\t\t\t\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\t\tnBindings = bindings.length;\n\t\t\tlet nCachedObjects = this.nCachedObjects_,\n\t\t\t\t\tnObjects = objects.length;\n\n\t\t\tfor (let i = 0, n = arguments.length; i !== n; ++i) {\n\t\t\t\tconst object = arguments[i],\n\t\t\t\t\t\t\tuuid = object.uuid,\n\t\t\t\t\t\t\tindex = indicesByUUID[uuid];\n\n\t\t\t\tif (index !== undefined) {\n\t\t\t\t\tdelete indicesByUUID[uuid];\n\n\t\t\t\t\tif (index < nCachedObjects) {\n\t\t\t\t\t\t// object is cached, shrink the CACHED region\n\t\t\t\t\t\tconst firstActiveIndex = --nCachedObjects,\n\t\t\t\t\t\t\t\t\tlastCachedObject = objects[firstActiveIndex],\n\t\t\t\t\t\t\t\t\tlastIndex = --nObjects,\n\t\t\t\t\t\t\t\t\tlastObject = objects[lastIndex]; // last cached object takes this object's place\n\n\t\t\t\t\t\tindicesByUUID[lastCachedObject.uuid] = index;\n\t\t\t\t\t\tobjects[index] = lastCachedObject; // last object goes to the activated slot and pop\n\n\t\t\t\t\t\tindicesByUUID[lastObject.uuid] = firstActiveIndex;\n\t\t\t\t\t\tobjects[firstActiveIndex] = lastObject;\n\t\t\t\t\t\tobjects.pop(); // accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor (let j = 0, m = nBindings; j !== m; ++j) {\n\t\t\t\t\t\t\tconst bindingsForPath = bindings[j],\n\t\t\t\t\t\t\t\t\t\tlastCached = bindingsForPath[firstActiveIndex],\n\t\t\t\t\t\t\t\t\t\tlast = bindingsForPath[lastIndex];\n\t\t\t\t\t\t\tbindingsForPath[index] = lastCached;\n\t\t\t\t\t\t\tbindingsForPath[firstActiveIndex] = last;\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// object is active, just swap with the last and pop\n\t\t\t\t\t\tconst lastIndex = --nObjects,\n\t\t\t\t\t\t\t\t\tlastObject = objects[lastIndex];\n\n\t\t\t\t\t\tif (lastIndex > 0) {\n\t\t\t\t\t\t\tindicesByUUID[lastObject.uuid] = index;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobjects[index] = lastObject;\n\t\t\t\t\t\tobjects.pop(); // accounting is done, now do the same for all bindings\n\n\t\t\t\t\t\tfor (let j = 0, m = nBindings; j !== m; ++j) {\n\t\t\t\t\t\t\tconst bindingsForPath = bindings[j];\n\t\t\t\t\t\t\tbindingsForPath[index] = bindingsForPath[lastIndex];\n\t\t\t\t\t\t\tbindingsForPath.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} // cached or active\n\n\t\t\t\t} // if object is known\n\n\t\t\t} // for arguments\n\n\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\n\t\t} // Internal interface used by befriended PropertyBinding.Composite:\n\n\n\t\tsubscribe_(path, parsedPath) {\n\t\t\t// returns an array of bindings for the given path that is changed\n\t\t\t// according to the contained objects in the group\n\t\t\tconst indicesByPath = this._bindingsIndicesByPath;\n\t\t\tlet index = indicesByPath[path];\n\t\t\tconst bindings = this._bindings;\n\t\t\tif (index !== undefined) return bindings[index];\n\t\t\tconst paths = this._paths,\n\t\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\t\tobjects = this._objects,\n\t\t\t\t\t\tnObjects = objects.length,\n\t\t\t\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\t\t\t\tbindingsForPath = new Array(nObjects);\n\t\t\tindex = bindings.length;\n\t\t\tindicesByPath[path] = index;\n\t\t\tpaths.push(path);\n\t\t\tparsedPaths.push(parsedPath);\n\t\t\tbindings.push(bindingsForPath);\n\n\t\t\tfor (let i = nCachedObjects, n = objects.length; i !== n; ++i) {\n\t\t\t\tconst object = objects[i];\n\t\t\t\tbindingsForPath[i] = new PropertyBinding(object, path, parsedPath);\n\t\t\t}\n\n\t\t\treturn bindingsForPath;\n\t\t}\n\n\t\tunsubscribe_(path) {\n\t\t\t// tells the group to forget about a property path and no longer\n\t\t\t// update the array previously obtained with 'subscribe_'\n\t\t\tconst indicesByPath = this._bindingsIndicesByPath,\n\t\t\t\t\t\tindex = indicesByPath[path];\n\n\t\t\tif (index !== undefined) {\n\t\t\t\tconst paths = this._paths,\n\t\t\t\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\t\t\t\tbindings = this._bindings,\n\t\t\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\t\t\t\tlastBindings = bindings[lastBindingsIndex],\n\t\t\t\t\t\t\tlastBindingsPath = path[lastBindingsIndex];\n\t\t\t\tindicesByPath[lastBindingsPath] = index;\n\t\t\t\tbindings[index] = lastBindings;\n\t\t\t\tbindings.pop();\n\t\t\t\tparsedPaths[index] = parsedPaths[lastBindingsIndex];\n\t\t\t\tparsedPaths.pop();\n\t\t\t\tpaths[index] = paths[lastBindingsIndex];\n\t\t\t\tpaths.pop();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tAnimationObjectGroup.prototype.isAnimationObjectGroup = true;\n\n\tclass AnimationAction {\n\t\tconstructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {\n\t\t\tthis._mixer = mixer;\n\t\t\tthis._clip = clip;\n\t\t\tthis._localRoot = localRoot;\n\t\t\tthis.blendMode = blendMode;\n\t\t\tconst tracks = clip.tracks,\n\t\t\t\t\t\tnTracks = tracks.length,\n\t\t\t\t\t\tinterpolants = new Array(nTracks);\n\t\t\tconst interpolantSettings = {\n\t\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t\t};\n\n\t\t\tfor (let i = 0; i !== nTracks; ++i) {\n\t\t\t\tconst interpolant = tracks[i].createInterpolant(null);\n\t\t\t\tinterpolants[i] = interpolant;\n\t\t\t\tinterpolant.settings = interpolantSettings;\n\t\t\t}\n\n\t\t\tthis._interpolantSettings = interpolantSettings;\n\t\t\tthis._interpolants = interpolants; // bound by the mixer\n\t\t\t// inside: PropertyMixer (managed by the mixer)\n\n\t\t\tthis._propertyBindings = new Array(nTracks);\n\t\t\tthis._cacheIndex = null; // for the memory manager\n\n\t\t\tthis._byClipCacheIndex = null; // for the memory manager\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis.loop = LoopRepeat;\n\t\t\tthis._loopCount = -1; // global mixer time when the action is to be started\n\t\t\t// it's set back to 'null' upon start of the action\n\n\t\t\tthis._startTime = null; // scaled local time of the action\n\t\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\n\t\t\tthis.time = 0;\n\t\t\tthis.timeScale = 1;\n\t\t\tthis._effectiveTimeScale = 1;\n\t\t\tthis.weight = 1;\n\t\t\tthis._effectiveWeight = 1;\n\t\t\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\t\t\tthis.paused = false; // true -> zero effective time scale\n\n\t\t\tthis.enabled = true; // false -> zero effective weight\n\n\t\t\tthis.clampWhenFinished = false; // keep feeding the last frame?\n\n\t\t\tthis.zeroSlopeAtStart = true; // for smooth interpolation w/o separate\n\n\t\t\tthis.zeroSlopeAtEnd = true; // clips for start, loop and end\n\t\t} // State & Scheduling\n\n\n\t\tplay() {\n\t\t\tthis._mixer._activateAction(this);\n\n\t\t\treturn this;\n\t\t}\n\n\t\tstop() {\n\t\t\tthis._mixer._deactivateAction(this);\n\n\t\t\treturn this.reset();\n\t\t}\n\n\t\treset() {\n\t\t\tthis.paused = false;\n\t\t\tthis.enabled = true;\n\t\t\tthis.time = 0; // restart clip\n\n\t\t\tthis._loopCount = -1; // forget previous loops\n\n\t\t\tthis._startTime = null; // forget scheduling\n\n\t\t\treturn this.stopFading().stopWarping();\n\t\t}\n\n\t\tisRunning() {\n\t\t\treturn this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);\n\t\t} // return true when play has been called\n\n\n\t\tisScheduled() {\n\t\t\treturn this._mixer._isActiveAction(this);\n\t\t}\n\n\t\tstartAt(time) {\n\t\t\tthis._startTime = time;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetLoop(mode, repetitions) {\n\t\t\tthis.loop = mode;\n\t\t\tthis.repetitions = repetitions;\n\t\t\treturn this;\n\t\t} // Weight\n\t\t// set the weight stopping any scheduled fading\n\t\t// although .enabled = false yields an effective weight of zero, this\n\t\t// method does *not* change .enabled, because it would be confusing\n\n\n\t\tsetEffectiveWeight(weight) {\n\t\t\tthis.weight = weight; // note: same logic as when updated at runtime\n\n\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\t\t\treturn this.stopFading();\n\t\t} // return the weight considering fading and .enabled\n\n\n\t\tgetEffectiveWeight() {\n\t\t\treturn this._effectiveWeight;\n\t\t}\n\n\t\tfadeIn(duration) {\n\t\t\treturn this._scheduleFading(duration, 0, 1);\n\t\t}\n\n\t\tfadeOut(duration) {\n\t\t\treturn this._scheduleFading(duration, 1, 0);\n\t\t}\n\n\t\tcrossFadeFrom(fadeOutAction, duration, warp) {\n\t\t\tfadeOutAction.fadeOut(duration);\n\t\t\tthis.fadeIn(duration);\n\n\t\t\tif (warp) {\n\t\t\t\tconst fadeInDuration = this._clip.duration,\n\t\t\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\t\t\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\t\t\t\tfadeOutAction.warp(1.0, startEndRatio, duration);\n\t\t\t\tthis.warp(endStartRatio, 1.0, duration);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tcrossFadeTo(fadeInAction, duration, warp) {\n\t\t\treturn fadeInAction.crossFadeFrom(this, duration, warp);\n\t\t}\n\n\t\tstopFading() {\n\t\t\tconst weightInterpolant = this._weightInterpolant;\n\n\t\t\tif (weightInterpolant !== null) {\n\t\t\t\tthis._weightInterpolant = null;\n\n\t\t\t\tthis._mixer._takeBackControlInterpolant(weightInterpolant);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // Time Scale Control\n\t\t// set the time scale stopping any scheduled warping\n\t\t// although .paused = true yields an effective time scale of zero, this\n\t\t// method does *not* change .paused, because it would be confusing\n\n\n\t\tsetEffectiveTimeScale(timeScale) {\n\t\t\tthis.timeScale = timeScale;\n\t\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\t\t\treturn this.stopWarping();\n\t\t} // return the time scale considering warping and .paused\n\n\n\t\tgetEffectiveTimeScale() {\n\t\t\treturn this._effectiveTimeScale;\n\t\t}\n\n\t\tsetDuration(duration) {\n\t\t\tthis.timeScale = this._clip.duration / duration;\n\t\t\treturn this.stopWarping();\n\t\t}\n\n\t\tsyncWith(action) {\n\t\t\tthis.time = action.time;\n\t\t\tthis.timeScale = action.timeScale;\n\t\t\treturn this.stopWarping();\n\t\t}\n\n\t\thalt(duration) {\n\t\t\treturn this.warp(this._effectiveTimeScale, 0, duration);\n\t\t}\n\n\t\twarp(startTimeScale, endTimeScale, duration) {\n\t\t\tconst mixer = this._mixer,\n\t\t\t\t\t\tnow = mixer.time,\n\t\t\t\t\t\ttimeScale = this.timeScale;\n\t\t\tlet interpolant = this._timeScaleInterpolant;\n\n\t\t\tif (interpolant === null) {\n\t\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\t\tthis._timeScaleInterpolant = interpolant;\n\t\t\t}\n\n\t\t\tconst times = interpolant.parameterPositions,\n\t\t\t\t\t\tvalues = interpolant.sampleValues;\n\t\t\ttimes[0] = now;\n\t\t\ttimes[1] = now + duration;\n\t\t\tvalues[0] = startTimeScale / timeScale;\n\t\t\tvalues[1] = endTimeScale / timeScale;\n\t\t\treturn this;\n\t\t}\n\n\t\tstopWarping() {\n\t\t\tconst timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\t\tif (timeScaleInterpolant !== null) {\n\t\t\t\tthis._timeScaleInterpolant = null;\n\n\t\t\t\tthis._mixer._takeBackControlInterpolant(timeScaleInterpolant);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // Object Accessors\n\n\n\t\tgetMixer() {\n\t\t\treturn this._mixer;\n\t\t}\n\n\t\tgetClip() {\n\t\t\treturn this._clip;\n\t\t}\n\n\t\tgetRoot() {\n\t\t\treturn this._localRoot || this._mixer._root;\n\t\t} // Interna\n\n\n\t\t_update(time, deltaTime, timeDirection, accuIndex) {\n\t\t\t// called by the mixer\n\t\t\tif (!this.enabled) {\n\t\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\t\t\t\tthis._updateWeight(time);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst startTime = this._startTime;\n\n\t\t\tif (startTime !== null) {\n\t\t\t\t// check for scheduled start of action\n\t\t\t\tconst timeRunning = (time - startTime) * timeDirection;\n\n\t\t\t\tif (timeRunning < 0 || timeDirection === 0) {\n\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\n\t\t\t\t} // start\n\n\n\t\t\t\tthis._startTime = null; // unschedule\n\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\t\t\t} // apply time scale and advance time\n\n\n\t\t\tdeltaTime *= this._updateTimeScale(time);\n\n\t\t\tconst clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in\n\t\t\t// an effective weight of 0\n\n\n\t\t\tconst weight = this._updateWeight(time);\n\n\t\t\tif (weight > 0) {\n\t\t\t\tconst interpolants = this._interpolants;\n\t\t\t\tconst propertyMixers = this._propertyBindings;\n\n\t\t\t\tswitch (this.blendMode) {\n\t\t\t\t\tcase AdditiveAnimationBlendMode:\n\t\t\t\t\t\tfor (let j = 0, m = interpolants.length; j !== m; ++j) {\n\t\t\t\t\t\t\tinterpolants[j].evaluate(clipTime);\n\t\t\t\t\t\t\tpropertyMixers[j].accumulateAdditive(weight);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase NormalAnimationBlendMode:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfor (let j = 0, m = interpolants.length; j !== m; ++j) {\n\t\t\t\t\t\t\tinterpolants[j].evaluate(clipTime);\n\t\t\t\t\t\t\tpropertyMixers[j].accumulate(accuIndex, weight);\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_updateWeight(time) {\n\t\t\tlet weight = 0;\n\n\t\t\tif (this.enabled) {\n\t\t\t\tweight = this.weight;\n\t\t\t\tconst interpolant = this._weightInterpolant;\n\n\t\t\t\tif (interpolant !== null) {\n\t\t\t\t\tconst interpolantValue = interpolant.evaluate(time)[0];\n\t\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\t\tif (time > interpolant.parameterPositions[1]) {\n\t\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\t\tif (interpolantValue === 0) {\n\t\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\t\tthis.enabled = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._effectiveWeight = weight;\n\t\t\treturn weight;\n\t\t}\n\n\t\t_updateTimeScale(time) {\n\t\t\tlet timeScale = 0;\n\n\t\t\tif (!this.paused) {\n\t\t\t\ttimeScale = this.timeScale;\n\t\t\t\tconst interpolant = this._timeScaleInterpolant;\n\n\t\t\t\tif (interpolant !== null) {\n\t\t\t\t\tconst interpolantValue = interpolant.evaluate(time)[0];\n\t\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\t\tif (time > interpolant.parameterPositions[1]) {\n\t\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\t\tif (timeScale === 0) {\n\t\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\t\tthis.paused = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\t\tthis.timeScale = timeScale;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._effectiveTimeScale = timeScale;\n\t\t\treturn timeScale;\n\t\t}\n\n\t\t_updateTime(deltaTime) {\n\t\t\tconst duration = this._clip.duration;\n\t\t\tconst loop = this.loop;\n\t\t\tlet time = this.time + deltaTime;\n\t\t\tlet loopCount = this._loopCount;\n\t\t\tconst pingPong = loop === LoopPingPong;\n\n\t\t\tif (deltaTime === 0) {\n\t\t\t\tif (loopCount === -1) return time;\n\t\t\t\treturn pingPong && (loopCount & 1) === 1 ? duration - time : time;\n\t\t\t}\n\n\t\t\tif (loop === LoopOnce) {\n\t\t\t\tif (loopCount === -1) {\n\t\t\t\t\t// just started\n\t\t\t\t\tthis._loopCount = 0;\n\n\t\t\t\t\tthis._setEndings(true, true, false);\n\t\t\t\t}\n\n\t\t\t\thandle_stop: {\n\t\t\t\t\tif (time >= duration) {\n\t\t\t\t\t\ttime = duration;\n\t\t\t\t\t} else if (time < 0) {\n\t\t\t\t\t\ttime = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.time = time;\n\t\t\t\t\t\tbreak handle_stop;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.clampWhenFinished) this.paused = true;else this.enabled = false;\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent({\n\t\t\t\t\t\ttype: 'finished',\n\t\t\t\t\t\taction: this,\n\t\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// repetitive Repeat or PingPong\n\t\t\t\tif (loopCount === -1) {\n\t\t\t\t\t// just started\n\t\t\t\t\tif (deltaTime >= 0) {\n\t\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\t\tthis._setEndings(true, this.repetitions === 0, pingPong);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t\t// so leave loopCount at -1\n\t\t\t\t\t\tthis._setEndings(this.repetitions === 0, true, pingPong);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (time >= duration || time < 0) {\n\t\t\t\t\t// wrap around\n\t\t\t\t\tconst loopDelta = Math.floor(time / duration); // signed\n\n\t\t\t\t\ttime -= duration * loopDelta;\n\t\t\t\t\tloopCount += Math.abs(loopDelta);\n\t\t\t\t\tconst pending = this.repetitions - loopCount;\n\n\t\t\t\t\tif (pending <= 0) {\n\t\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\t\t\t\t\t\tif (this.clampWhenFinished) this.paused = true;else this.enabled = false;\n\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\t\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'finished',\n\t\t\t\t\t\t\taction: this,\n\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// keep running\n\t\t\t\t\t\tif (pending === 1) {\n\t\t\t\t\t\t\t// entering the last round\n\t\t\t\t\t\t\tconst atStart = deltaTime < 0;\n\n\t\t\t\t\t\t\tthis._setEndings(atStart, !atStart, pingPong);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._setEndings(false, false, pingPong);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._loopCount = loopCount;\n\t\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\t\tthis._mixer.dispatchEvent({\n\t\t\t\t\t\t\ttype: 'loop',\n\t\t\t\t\t\t\taction: this,\n\t\t\t\t\t\t\tloopDelta: loopDelta\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.time = time;\n\t\t\t\t}\n\n\t\t\t\tif (pingPong && (loopCount & 1) === 1) {\n\t\t\t\t\t// invert time for the \"pong round\"\n\t\t\t\t\treturn duration - time;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn time;\n\t\t}\n\n\t\t_setEndings(atStart, atEnd, pingPong) {\n\t\t\tconst settings = this._interpolantSettings;\n\n\t\t\tif (pingPong) {\n\t\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\t\t\t} else {\n\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\t\t\t\tif (atStart) {\n\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\t\t\t\t} else {\n\t\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\t\t\t\t}\n\n\t\t\t\tif (atEnd) {\n\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\t\t\t\t} else {\n\t\t\t\t\tsettings.endingEnd = WrapAroundEnding;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_scheduleFading(duration, weightNow, weightThen) {\n\t\t\tconst mixer = this._mixer,\n\t\t\t\t\t\tnow = mixer.time;\n\t\t\tlet interpolant = this._weightInterpolant;\n\n\t\t\tif (interpolant === null) {\n\t\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\t\tthis._weightInterpolant = interpolant;\n\t\t\t}\n\n\t\t\tconst times = interpolant.parameterPositions,\n\t\t\t\t\t\tvalues = interpolant.sampleValues;\n\t\t\ttimes[0] = now;\n\t\t\tvalues[0] = weightNow;\n\t\t\ttimes[1] = now + duration;\n\t\t\tvalues[1] = weightThen;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass AnimationMixer extends EventDispatcher {\n\t\tconstructor(root) {\n\t\t\tsuper();\n\t\t\tthis._root = root;\n\n\t\t\tthis._initMemoryManager();\n\n\t\t\tthis._accuIndex = 0;\n\t\t\tthis.time = 0;\n\t\t\tthis.timeScale = 1.0;\n\t\t}\n\n\t\t_bindAction(action, prototypeAction) {\n\t\t\tconst root = action._localRoot || this._root,\n\t\t\t\t\t\ttracks = action._clip.tracks,\n\t\t\t\t\t\tnTracks = tracks.length,\n\t\t\t\t\t\tbindings = action._propertyBindings,\n\t\t\t\t\t\tinterpolants = action._interpolants,\n\t\t\t\t\t\trootUuid = root.uuid,\n\t\t\t\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\t\t\tlet bindingsByName = bindingsByRoot[rootUuid];\n\n\t\t\tif (bindingsByName === undefined) {\n\t\t\t\tbindingsByName = {};\n\t\t\t\tbindingsByRoot[rootUuid] = bindingsByName;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i !== nTracks; ++i) {\n\t\t\t\tconst track = tracks[i],\n\t\t\t\t\t\t\ttrackName = track.name;\n\t\t\t\tlet binding = bindingsByName[trackName];\n\n\t\t\t\tif (binding !== undefined) {\n\t\t\t\t\tbindings[i] = binding;\n\t\t\t\t} else {\n\t\t\t\t\tbinding = bindings[i];\n\n\t\t\t\t\tif (binding !== undefined) {\n\t\t\t\t\t\t// existing binding, make sure the cache knows\n\t\t\t\t\t\tif (binding._cacheIndex === null) {\n\t\t\t\t\t\t\t++binding.referenceCount;\n\n\t\t\t\t\t\t\tthis._addInactiveBinding(binding, rootUuid, trackName);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;\n\t\t\t\t\tbinding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());\n\t\t\t\t\t++binding.referenceCount;\n\n\t\t\t\t\tthis._addInactiveBinding(binding, rootUuid, trackName);\n\n\t\t\t\t\tbindings[i] = binding;\n\t\t\t\t}\n\n\t\t\t\tinterpolants[i].resultBuffer = binding.buffer;\n\t\t\t}\n\t\t}\n\n\t\t_activateAction(action) {\n\t\t\tif (!this._isActiveAction(action)) {\n\t\t\t\tif (action._cacheIndex === null) {\n\t\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t\t// appears to be still using it -> rebind\n\t\t\t\t\tconst rootUuid = (action._localRoot || this._root).uuid,\n\t\t\t\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\t\t\t\tactionsForClip = this._actionsByClip[clipUuid];\n\n\t\t\t\t\tthis._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);\n\n\t\t\t\t\tthis._addInactiveAction(action, clipUuid, rootUuid);\n\t\t\t\t}\n\n\t\t\t\tconst bindings = action._propertyBindings; // increment reference counts / sort out state\n\n\t\t\t\tfor (let i = 0, n = bindings.length; i !== n; ++i) {\n\t\t\t\t\tconst binding = bindings[i];\n\n\t\t\t\t\tif (binding.useCount++ === 0) {\n\t\t\t\t\t\tthis._lendBinding(binding);\n\n\t\t\t\t\t\tbinding.saveOriginalState();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._lendAction(action);\n\t\t\t}\n\t\t}\n\n\t\t_deactivateAction(action) {\n\t\t\tif (this._isActiveAction(action)) {\n\t\t\t\tconst bindings = action._propertyBindings; // decrement reference counts / sort out state\n\n\t\t\t\tfor (let i = 0, n = bindings.length; i !== n; ++i) {\n\t\t\t\t\tconst binding = bindings[i];\n\n\t\t\t\t\tif (--binding.useCount === 0) {\n\t\t\t\t\t\tbinding.restoreOriginalState();\n\n\t\t\t\t\t\tthis._takeBackBinding(binding);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._takeBackAction(action);\n\t\t\t}\n\t\t} // Memory manager\n\n\n\t\t_initMemoryManager() {\n\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\n\t\t\tthis._nActiveActions = 0;\n\t\t\tthis._actionsByClip = {}; // inside:\n\t\t\t// {\n\t\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t\t// }\n\n\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\n\t\t\tthis._nActiveBindings = 0;\n\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\t\t\tthis._controlInterpolants = []; // same game as above\n\n\t\t\tthis._nActiveControlInterpolants = 0;\n\t\t\tconst scope = this;\n\t\t\tthis.stats = {\n\t\t\t\tactions: {\n\t\t\t\t\tget total() {\n\t\t\t\t\t\treturn scope._actions.length;\n\t\t\t\t\t},\n\n\t\t\t\t\tget inUse() {\n\t\t\t\t\t\treturn scope._nActiveActions;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\t\t\t\tbindings: {\n\t\t\t\t\tget total() {\n\t\t\t\t\t\treturn scope._bindings.length;\n\t\t\t\t\t},\n\n\t\t\t\t\tget inUse() {\n\t\t\t\t\t\treturn scope._nActiveBindings;\n\t\t\t\t\t}\n\n\t\t\t\t},\n\t\t\t\tcontrolInterpolants: {\n\t\t\t\t\tget total() {\n\t\t\t\t\t\treturn scope._controlInterpolants.length;\n\t\t\t\t\t},\n\n\t\t\t\t\tget inUse() {\n\t\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t};\n\t\t} // Memory management for AnimationAction objects\n\n\n\t\t_isActiveAction(action) {\n\t\t\tconst index = action._cacheIndex;\n\t\t\treturn index !== null && index < this._nActiveActions;\n\t\t}\n\n\t\t_addInactiveAction(action, clipUuid, rootUuid) {\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tactionsByClip = this._actionsByClip;\n\t\t\tlet actionsForClip = actionsByClip[clipUuid];\n\n\t\t\tif (actionsForClip === undefined) {\n\t\t\t\tactionsForClip = {\n\t\t\t\t\tknownActions: [action],\n\t\t\t\t\tactionByRoot: {}\n\t\t\t\t};\n\t\t\t\taction._byClipCacheIndex = 0;\n\t\t\t\tactionsByClip[clipUuid] = actionsForClip;\n\t\t\t} else {\n\t\t\t\tconst knownActions = actionsForClip.knownActions;\n\t\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\t\tknownActions.push(action);\n\t\t\t}\n\n\t\t\taction._cacheIndex = actions.length;\n\t\t\tactions.push(action);\n\t\t\tactionsForClip.actionByRoot[rootUuid] = action;\n\t\t}\n\n\t\t_removeInactiveAction(action) {\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tlastInactiveAction = actions[actions.length - 1],\n\t\t\t\t\t\tcacheIndex = action._cacheIndex;\n\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\tactions[cacheIndex] = lastInactiveAction;\n\t\t\tactions.pop();\n\t\t\taction._cacheIndex = null;\n\t\t\tconst clipUuid = action._clip.uuid,\n\t\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\t\tactionsForClip = actionsByClip[clipUuid],\n\t\t\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\t\t\t\t\t\tlastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],\n\t\t\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\t\tknownActionsForClip[byClipCacheIndex] = lastKnownAction;\n\t\t\tknownActionsForClip.pop();\n\t\t\taction._byClipCacheIndex = null;\n\t\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\t\t\t\trootUuid = (action._localRoot || this._root).uuid;\n\t\t\tdelete actionByRoot[rootUuid];\n\n\t\t\tif (knownActionsForClip.length === 0) {\n\t\t\t\tdelete actionsByClip[clipUuid];\n\t\t\t}\n\n\t\t\tthis._removeInactiveBindingsForAction(action);\n\t\t}\n\n\t\t_removeInactiveBindingsForAction(action) {\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\tfor (let i = 0, n = bindings.length; i !== n; ++i) {\n\t\t\t\tconst binding = bindings[i];\n\n\t\t\t\tif (--binding.referenceCount === 0) {\n\t\t\t\t\tthis._removeInactiveBinding(binding);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_lendAction(action) {\n\t\t\t// [ active actions |\tinactive actions\t]\n\t\t\t// [\tactive actions >| inactive actions ]\n\t\t\t//\t\t\t\t\t\t\t\t s\t\t\t\ta\n\t\t\t//\t\t\t\t\t\t\t\t\t<-swap->\n\t\t\t//\t\t\t\t\t\t\t\t a\t\t\t\ts\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tprevIndex = action._cacheIndex,\n\t\t\t\t\t\tlastActiveIndex = this._nActiveActions++,\n\t\t\t\t\t\tfirstInactiveAction = actions[lastActiveIndex];\n\t\t\taction._cacheIndex = lastActiveIndex;\n\t\t\tactions[lastActiveIndex] = action;\n\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\t\tactions[prevIndex] = firstInactiveAction;\n\t\t}\n\n\t\t_takeBackAction(action) {\n\t\t\t// [\tactive actions\t| inactive actions ]\n\t\t\t// [ active actions |< inactive actions\t]\n\t\t\t//\t\t\t\ta\t\t\t\ts\n\t\t\t//\t\t\t\t <-swap->\n\t\t\t//\t\t\t\ts\t\t\t\ta\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tprevIndex = action._cacheIndex,\n\t\t\t\t\t\tfirstInactiveIndex = --this._nActiveActions,\n\t\t\t\t\t\tlastActiveAction = actions[firstInactiveIndex];\n\t\t\taction._cacheIndex = firstInactiveIndex;\n\t\t\tactions[firstInactiveIndex] = action;\n\t\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\t\tactions[prevIndex] = lastActiveAction;\n\t\t} // Memory management for PropertyMixer objects\n\n\n\t\t_addInactiveBinding(binding, rootUuid, trackName) {\n\t\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\t\tbindings = this._bindings;\n\t\t\tlet bindingByName = bindingsByRoot[rootUuid];\n\n\t\t\tif (bindingByName === undefined) {\n\t\t\t\tbindingByName = {};\n\t\t\t\tbindingsByRoot[rootUuid] = bindingByName;\n\t\t\t}\n\n\t\t\tbindingByName[trackName] = binding;\n\t\t\tbinding._cacheIndex = bindings.length;\n\t\t\tbindings.push(binding);\n\t\t}\n\n\t\t_removeInactiveBinding(binding) {\n\t\t\tconst bindings = this._bindings,\n\t\t\t\t\t\tpropBinding = binding.binding,\n\t\t\t\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\t\t\t\ttrackName = propBinding.path,\n\t\t\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\t\tbindingByName = bindingsByRoot[rootUuid],\n\t\t\t\t\t\tlastInactiveBinding = bindings[bindings.length - 1],\n\t\t\t\t\t\tcacheIndex = binding._cacheIndex;\n\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\t\tbindings[cacheIndex] = lastInactiveBinding;\n\t\t\tbindings.pop();\n\t\t\tdelete bindingByName[trackName];\n\n\t\t\tif (Object.keys(bindingByName).length === 0) {\n\t\t\t\tdelete bindingsByRoot[rootUuid];\n\t\t\t}\n\t\t}\n\n\t\t_lendBinding(binding) {\n\t\t\tconst bindings = this._bindings,\n\t\t\t\t\t\tprevIndex = binding._cacheIndex,\n\t\t\t\t\t\tlastActiveIndex = this._nActiveBindings++,\n\t\t\t\t\t\tfirstInactiveBinding = bindings[lastActiveIndex];\n\t\t\tbinding._cacheIndex = lastActiveIndex;\n\t\t\tbindings[lastActiveIndex] = binding;\n\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[prevIndex] = firstInactiveBinding;\n\t\t}\n\n\t\t_takeBackBinding(binding) {\n\t\t\tconst bindings = this._bindings,\n\t\t\t\t\t\tprevIndex = binding._cacheIndex,\n\t\t\t\t\t\tfirstInactiveIndex = --this._nActiveBindings,\n\t\t\t\t\t\tlastActiveBinding = bindings[firstInactiveIndex];\n\t\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\t\tbindings[firstInactiveIndex] = binding;\n\t\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\t\tbindings[prevIndex] = lastActiveBinding;\n\t\t} // Memory management of Interpolants for weight and time scale\n\n\n\t\t_lendControlInterpolant() {\n\t\t\tconst interpolants = this._controlInterpolants,\n\t\t\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants++;\n\t\t\tlet interpolant = interpolants[lastActiveIndex];\n\n\t\t\tif (interpolant === undefined) {\n\t\t\t\tinterpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);\n\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\t\tinterpolants[lastActiveIndex] = interpolant;\n\t\t\t}\n\n\t\t\treturn interpolant;\n\t\t}\n\n\t\t_takeBackControlInterpolant(interpolant) {\n\t\t\tconst interpolants = this._controlInterpolants,\n\t\t\t\t\t\tprevIndex = interpolant.__cacheIndex,\n\t\t\t\t\t\tfirstInactiveIndex = --this._nActiveControlInterpolants,\n\t\t\t\t\t\tlastActiveInterpolant = interpolants[firstInactiveIndex];\n\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\t\tinterpolants[firstInactiveIndex] = interpolant;\n\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\t\tinterpolants[prevIndex] = lastActiveInterpolant;\n\t\t} // return an action for a clip optionally using a custom root target\n\t\t// object (this method allocates a lot of dynamic memory in case a\n\t\t// previously unknown clip/root combination is specified)\n\n\n\t\tclipAction(clip, optionalRoot, blendMode) {\n\t\t\tconst root = optionalRoot || this._root,\n\t\t\t\t\t\trootUuid = root.uuid;\n\t\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;\n\t\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\t\t\tconst actionsForClip = this._actionsByClip[clipUuid];\n\t\t\tlet prototypeAction = null;\n\n\t\t\tif (blendMode === undefined) {\n\t\t\t\tif (clipObject !== null) {\n\t\t\t\t\tblendMode = clipObject.blendMode;\n\t\t\t\t} else {\n\t\t\t\t\tblendMode = NormalAnimationBlendMode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (actionsForClip !== undefined) {\n\t\t\t\tconst existingAction = actionsForClip.actionByRoot[rootUuid];\n\n\t\t\t\tif (existingAction !== undefined && existingAction.blendMode === blendMode) {\n\t\t\t\t\treturn existingAction;\n\t\t\t\t} // we know the clip, so we don't have to parse all\n\t\t\t\t// the bindings again but can just copy\n\n\n\t\t\t\tprototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action\n\n\t\t\t\tif (clipObject === null) clipObject = prototypeAction._clip;\n\t\t\t} // clip must be known when specified via string\n\n\n\t\t\tif (clipObject === null) return null; // allocate all resources required to run it\n\n\t\t\tconst newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);\n\n\t\t\tthis._bindAction(newAction, prototypeAction); // and make the action known to the memory manager\n\n\n\t\t\tthis._addInactiveAction(newAction, clipUuid, rootUuid);\n\n\t\t\treturn newAction;\n\t\t} // get an existing action\n\n\n\t\texistingAction(clip, optionalRoot) {\n\t\t\tconst root = optionalRoot || this._root,\n\t\t\t\t\t\trootUuid = root.uuid,\n\t\t\t\t\t\tclipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,\n\t\t\t\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\t\t\t\t\t\tactionsForClip = this._actionsByClip[clipUuid];\n\n\t\t\tif (actionsForClip !== undefined) {\n\t\t\t\treturn actionsForClip.actionByRoot[rootUuid] || null;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t} // deactivates all previously scheduled actions\n\n\n\t\tstopAllAction() {\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tnActions = this._nActiveActions;\n\n\t\t\tfor (let i = nActions - 1; i >= 0; --i) {\n\t\t\t\tactions[i].stop();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // advance the time and update apply the animation\n\n\n\t\tupdate(deltaTime) {\n\t\t\tdeltaTime *= this.timeScale;\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tnActions = this._nActiveActions,\n\t\t\t\t\t\ttime = this.time += deltaTime,\n\t\t\t\t\t\ttimeDirection = Math.sign(deltaTime),\n\t\t\t\t\t\taccuIndex = this._accuIndex ^= 1; // run active actions\n\n\t\t\tfor (let i = 0; i !== nActions; ++i) {\n\t\t\t\tconst action = actions[i];\n\n\t\t\t\taction._update(time, deltaTime, timeDirection, accuIndex);\n\t\t\t} // update scene graph\n\n\n\t\t\tconst bindings = this._bindings,\n\t\t\t\t\t\tnBindings = this._nActiveBindings;\n\n\t\t\tfor (let i = 0; i !== nBindings; ++i) {\n\t\t\t\tbindings[i].apply(accuIndex);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t} // Allows you to seek to a specific time in an animation.\n\n\n\t\tsetTime(timeInSeconds) {\n\t\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\n\t\t\tfor (let i = 0; i < this._actions.length; i++) {\n\t\t\t\tthis._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\t\t\t}\n\n\t\t\treturn this.update(timeInSeconds); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\t\t} // return this mixer's root target object\n\n\n\t\tgetRoot() {\n\t\t\treturn this._root;\n\t\t} // free all resources specific to a particular clip\n\n\n\t\tuncacheClip(clip) {\n\t\t\tconst actions = this._actions,\n\t\t\t\t\t\tclipUuid = clip.uuid,\n\t\t\t\t\t\tactionsByClip = this._actionsByClip,\n\t\t\t\t\t\tactionsForClip = actionsByClip[clipUuid];\n\n\t\t\tif (actionsForClip !== undefined) {\n\t\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t\t// iteration state and also require updating the state we can\n\t\t\t\t// just throw away\n\t\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\t\tfor (let i = 0, n = actionsToRemove.length; i !== n; ++i) {\n\t\t\t\t\tconst action = actionsToRemove[i];\n\n\t\t\t\t\tthis._deactivateAction(action);\n\n\t\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\t\t\t\tlastInactiveAction = actions[actions.length - 1];\n\t\t\t\t\taction._cacheIndex = null;\n\t\t\t\t\taction._byClipCacheIndex = null;\n\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\t\tactions[cacheIndex] = lastInactiveAction;\n\t\t\t\t\tactions.pop();\n\n\t\t\t\t\tthis._removeInactiveBindingsForAction(action);\n\t\t\t\t}\n\n\t\t\t\tdelete actionsByClip[clipUuid];\n\t\t\t}\n\t\t} // free all resources specific to a particular root target object\n\n\n\t\tuncacheRoot(root) {\n\t\t\tconst rootUuid = root.uuid,\n\t\t\t\t\t\tactionsByClip = this._actionsByClip;\n\n\t\t\tfor (const clipUuid in actionsByClip) {\n\t\t\t\tconst actionByRoot = actionsByClip[clipUuid].actionByRoot,\n\t\t\t\t\t\t\taction = actionByRoot[rootUuid];\n\n\t\t\t\tif (action !== undefined) {\n\t\t\t\t\tthis._deactivateAction(action);\n\n\t\t\t\t\tthis._removeInactiveAction(action);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\t\t\t\tbindingByName = bindingsByRoot[rootUuid];\n\n\t\t\tif (bindingByName !== undefined) {\n\t\t\t\tfor (const trackName in bindingByName) {\n\t\t\t\t\tconst binding = bindingByName[trackName];\n\t\t\t\t\tbinding.restoreOriginalState();\n\n\t\t\t\t\tthis._removeInactiveBinding(binding);\n\t\t\t\t}\n\t\t\t}\n\t\t} // remove a targeted clip from the cache\n\n\n\t\tuncacheAction(clip, optionalRoot) {\n\t\t\tconst action = this.existingAction(clip, optionalRoot);\n\n\t\t\tif (action !== null) {\n\t\t\t\tthis._deactivateAction(action);\n\n\t\t\t\tthis._removeInactiveAction(action);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tAnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);\n\n\tclass Uniform {\n\t\tconstructor(value) {\n\t\t\tif (typeof value === 'string') {\n\t\t\t\tconsole.warn('THREE.Uniform: Type parameter is no longer needed.');\n\t\t\t\tvalue = arguments[1];\n\t\t\t}\n\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new Uniform(this.value.clone === undefined ? this.value : this.value.clone());\n\t\t}\n\n\t}\n\n\tclass InstancedInterleavedBuffer extends InterleavedBuffer {\n\t\tconstructor(array, stride, meshPerAttribute = 1) {\n\t\t\tsuper(array, stride);\n\t\t\tthis.meshPerAttribute = meshPerAttribute || 1;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source);\n\t\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\t\t\treturn this;\n\t\t}\n\n\t\tclone(data) {\n\t\t\tconst ib = super.clone(data);\n\t\t\tib.meshPerAttribute = this.meshPerAttribute;\n\t\t\treturn ib;\n\t\t}\n\n\t\ttoJSON(data) {\n\t\t\tconst json = super.toJSON(data);\n\t\t\tjson.isInstancedInterleavedBuffer = true;\n\t\t\tjson.meshPerAttribute = this.meshPerAttribute;\n\t\t\treturn json;\n\t\t}\n\n\t}\n\n\tInstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;\n\n\tclass GLBufferAttribute {\n\t\tconstructor(buffer, type, itemSize, elementSize, count) {\n\t\t\tthis.buffer = buffer;\n\t\t\tthis.type = type;\n\t\t\tthis.itemSize = itemSize;\n\t\t\tthis.elementSize = elementSize;\n\t\t\tthis.count = count;\n\t\t\tthis.version = 0;\n\t\t}\n\n\t\tset needsUpdate(value) {\n\t\t\tif (value === true) this.version++;\n\t\t}\n\n\t\tsetBuffer(buffer) {\n\t\t\tthis.buffer = buffer;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetType(type, elementSize) {\n\t\t\tthis.type = type;\n\t\t\tthis.elementSize = elementSize;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetItemSize(itemSize) {\n\t\t\tthis.itemSize = itemSize;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetCount(count) {\n\t\t\tthis.count = count;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tGLBufferAttribute.prototype.isGLBufferAttribute = true;\n\n\tclass Raycaster {\n\t\tconstructor(origin, direction, near = 0, far = Infinity) {\n\t\t\tthis.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)\n\n\t\t\tthis.near = near;\n\t\t\tthis.far = far;\n\t\t\tthis.camera = null;\n\t\t\tthis.layers = new Layers();\n\t\t\tthis.params = {\n\t\t\t\tMesh: {},\n\t\t\t\tLine: {\n\t\t\t\t\tthreshold: 1\n\t\t\t\t},\n\t\t\t\tLOD: {},\n\t\t\t\tPoints: {\n\t\t\t\t\tthreshold: 1\n\t\t\t\t},\n\t\t\t\tSprite: {}\n\t\t\t};\n\t\t}\n\n\t\tset(origin, direction) {\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\t\t\tthis.ray.set(origin, direction);\n\t\t}\n\n\t\tsetFromCamera(coords, camera) {\n\t\t\tif (camera && camera.isPerspectiveCamera) {\n\t\t\t\tthis.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n\t\t\t\tthis.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();\n\t\t\t\tthis.camera = camera;\n\t\t\t} else if (camera && camera.isOrthographicCamera) {\n\t\t\t\tthis.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera\n\n\t\t\t\tthis.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n\t\t\t\tthis.camera = camera;\n\t\t\t} else {\n\t\t\t\tconsole.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);\n\t\t\t}\n\t\t}\n\n\t\tintersectObject(object, recursive = false, intersects = []) {\n\t\t\tintersectObject(object, this, intersects, recursive);\n\t\t\tintersects.sort(ascSort);\n\t\t\treturn intersects;\n\t\t}\n\n\t\tintersectObjects(objects, recursive = false, intersects = []) {\n\t\t\tfor (let i = 0, l = objects.length; i < l; i++) {\n\t\t\t\tintersectObject(objects[i], this, intersects, recursive);\n\t\t\t}\n\n\t\t\tintersects.sort(ascSort);\n\t\t\treturn intersects;\n\t\t}\n\n\t}\n\n\tfunction ascSort(a, b) {\n\t\treturn a.distance - b.distance;\n\t}\n\n\tfunction intersectObject(object, raycaster, intersects, recursive) {\n\t\tif (object.layers.test(raycaster.layers)) {\n\t\t\tobject.raycast(raycaster, intersects);\n\t\t}\n\n\t\tif (recursive === true) {\n\t\t\tconst children = object.children;\n\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tintersectObject(children[i], raycaster, intersects, true);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n\t *\n\t * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\n\t * The azimuthal angle (theta) is measured from the positive z-axis.\n\t */\n\n\tclass Spherical {\n\t\tconstructor(radius = 1, phi = 0, theta = 0) {\n\t\t\tthis.radius = radius;\n\t\t\tthis.phi = phi; // polar angle\n\n\t\t\tthis.theta = theta; // azimuthal angle\n\n\t\t\treturn this;\n\t\t}\n\n\t\tset(radius, phi, theta) {\n\t\t\tthis.radius = radius;\n\t\t\tthis.phi = phi;\n\t\t\tthis.theta = theta;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(other) {\n\t\t\tthis.radius = other.radius;\n\t\t\tthis.phi = other.phi;\n\t\t\tthis.theta = other.theta;\n\t\t\treturn this;\n\t\t} // restrict phi to be betwee EPS and PI-EPS\n\n\n\t\tmakeSafe() {\n\t\t\tconst EPS = 0.000001;\n\t\t\tthis.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromVector3(v) {\n\t\t\treturn this.setFromCartesianCoords(v.x, v.y, v.z);\n\t\t}\n\n\t\tsetFromCartesianCoords(x, y, z) {\n\t\t\tthis.radius = Math.sqrt(x * x + y * y + z * z);\n\n\t\t\tif (this.radius === 0) {\n\t\t\t\tthis.theta = 0;\n\t\t\t\tthis.phi = 0;\n\t\t\t} else {\n\t\t\t\tthis.theta = Math.atan2(x, z);\n\t\t\t\tthis.phi = Math.acos(clamp(y / this.radius, -1, 1));\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\t/**\n\t * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n\t */\n\tclass Cylindrical {\n\t\tconstructor(radius = 1, theta = 0, y = 0) {\n\t\t\tthis.radius = radius; // distance from the origin to a point in the x-z plane\n\n\t\t\tthis.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n\n\t\t\tthis.y = y; // height above the x-z plane\n\n\t\t\treturn this;\n\t\t}\n\n\t\tset(radius, theta, y) {\n\t\t\tthis.radius = radius;\n\t\t\tthis.theta = theta;\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(other) {\n\t\t\tthis.radius = other.radius;\n\t\t\tthis.theta = other.theta;\n\t\t\tthis.y = other.y;\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromVector3(v) {\n\t\t\treturn this.setFromCartesianCoords(v.x, v.y, v.z);\n\t\t}\n\n\t\tsetFromCartesianCoords(x, y, z) {\n\t\t\tthis.radius = Math.sqrt(x * x + z * z);\n\t\t\tthis.theta = Math.atan2(x, z);\n\t\t\tthis.y = y;\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tconst _vector$4 = /*@__PURE__*/new Vector2();\n\n\tclass Box2 {\n\t\tconstructor(min = new Vector2(+Infinity, +Infinity), max = new Vector2(-Infinity, -Infinity)) {\n\t\t\tthis.min = min;\n\t\t\tthis.max = max;\n\t\t}\n\n\t\tset(min, max) {\n\t\t\tthis.min.copy(min);\n\t\t\tthis.max.copy(max);\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromPoints(points) {\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor (let i = 0, il = points.length; i < il; i++) {\n\t\t\t\tthis.expandByPoint(points[i]);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\tsetFromCenterAndSize(center, size) {\n\t\t\tconst halfSize = _vector$4.copy(size).multiplyScalar(0.5);\n\n\t\t\tthis.min.copy(center).sub(halfSize);\n\t\t\tthis.max.copy(center).add(halfSize);\n\t\t\treturn this;\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t\tcopy(box) {\n\t\t\tthis.min.copy(box.min);\n\t\t\tthis.max.copy(box.max);\n\t\t\treturn this;\n\t\t}\n\n\t\tmakeEmpty() {\n\t\t\tthis.min.x = this.min.y = +Infinity;\n\t\t\tthis.max.x = this.max.y = -Infinity;\n\t\t\treturn this;\n\t\t}\n\n\t\tisEmpty() {\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\t\t\treturn this.max.x < this.min.x || this.max.y < this.min.y;\n\t\t}\n\n\t\tgetCenter(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box2: .getCenter() target is now required');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n\t\t}\n\n\t\tgetSize(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box2: .getSize() target is now required');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);\n\t\t}\n\n\t\texpandByPoint(point) {\n\t\t\tthis.min.min(point);\n\t\t\tthis.max.max(point);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByVector(vector) {\n\t\t\tthis.min.sub(vector);\n\t\t\tthis.max.add(vector);\n\t\t\treturn this;\n\t\t}\n\n\t\texpandByScalar(scalar) {\n\t\t\tthis.min.addScalar(-scalar);\n\t\t\tthis.max.addScalar(scalar);\n\t\t\treturn this;\n\t\t}\n\n\t\tcontainsPoint(point) {\n\t\t\treturn point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;\n\t\t}\n\n\t\tcontainsBox(box) {\n\t\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;\n\t\t}\n\n\t\tgetParameter(point, target) {\n\t\t\t// This can potentially have a divide by zero if the box\n\t\t\t// has a size dimension of 0.\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box2: .getParameter() target is now required');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));\n\t\t}\n\n\t\tintersectsBox(box) {\n\t\t\t// using 4 splitting planes to rule out intersections\n\t\t\treturn box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;\n\t\t}\n\n\t\tclampPoint(point, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Box2: .clampPoint() target is now required');\n\t\t\t\ttarget = new Vector2();\n\t\t\t}\n\n\t\t\treturn target.copy(point).clamp(this.min, this.max);\n\t\t}\n\n\t\tdistanceToPoint(point) {\n\t\t\tconst clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);\n\n\t\t\treturn clampedPoint.sub(point).length();\n\t\t}\n\n\t\tintersect(box) {\n\t\t\tthis.min.max(box.min);\n\t\t\tthis.max.min(box.max);\n\t\t\treturn this;\n\t\t}\n\n\t\tunion(box) {\n\t\t\tthis.min.min(box.min);\n\t\t\tthis.max.max(box.max);\n\t\t\treturn this;\n\t\t}\n\n\t\ttranslate(offset) {\n\t\t\tthis.min.add(offset);\n\t\t\tthis.max.add(offset);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(box) {\n\t\t\treturn box.min.equals(this.min) && box.max.equals(this.max);\n\t\t}\n\n\t}\n\n\tBox2.prototype.isBox2 = true;\n\n\tconst _startP = /*@__PURE__*/new Vector3();\n\n\tconst _startEnd = /*@__PURE__*/new Vector3();\n\n\tclass Line3 {\n\t\tconstructor(start = new Vector3(), end = new Vector3()) {\n\t\t\tthis.start = start;\n\t\t\tthis.end = end;\n\t\t}\n\n\t\tset(start, end) {\n\t\t\tthis.start.copy(start);\n\t\t\tthis.end.copy(end);\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(line) {\n\t\t\tthis.start.copy(line.start);\n\t\t\tthis.end.copy(line.end);\n\t\t\treturn this;\n\t\t}\n\n\t\tgetCenter(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Line3: .getCenter() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.addVectors(this.start, this.end).multiplyScalar(0.5);\n\t\t}\n\n\t\tdelta(target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Line3: .delta() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn target.subVectors(this.end, this.start);\n\t\t}\n\n\t\tdistanceSq() {\n\t\t\treturn this.start.distanceToSquared(this.end);\n\t\t}\n\n\t\tdistance() {\n\t\t\treturn this.start.distanceTo(this.end);\n\t\t}\n\n\t\tat(t, target) {\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Line3: .at() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn this.delta(target).multiplyScalar(t).add(this.start);\n\t\t}\n\n\t\tclosestPointToPointParameter(point, clampToLine) {\n\t\t\t_startP.subVectors(point, this.start);\n\n\t\t\t_startEnd.subVectors(this.end, this.start);\n\n\t\t\tconst startEnd2 = _startEnd.dot(_startEnd);\n\n\t\t\tconst startEnd_startP = _startEnd.dot(_startP);\n\n\t\t\tlet t = startEnd_startP / startEnd2;\n\n\t\t\tif (clampToLine) {\n\t\t\t\tt = clamp(t, 0, 1);\n\t\t\t}\n\n\t\t\treturn t;\n\t\t}\n\n\t\tclosestPointToPoint(point, clampToLine, target) {\n\t\t\tconst t = this.closestPointToPointParameter(point, clampToLine);\n\n\t\t\tif (target === undefined) {\n\t\t\t\tconsole.warn('THREE.Line3: .closestPointToPoint() target is now required');\n\t\t\t\ttarget = new Vector3();\n\t\t\t}\n\n\t\t\treturn this.delta(target).multiplyScalar(t).add(this.start);\n\t\t}\n\n\t\tapplyMatrix4(matrix) {\n\t\t\tthis.start.applyMatrix4(matrix);\n\t\t\tthis.end.applyMatrix4(matrix);\n\t\t\treturn this;\n\t\t}\n\n\t\tequals(line) {\n\t\t\treturn line.start.equals(this.start) && line.end.equals(this.end);\n\t\t}\n\n\t\tclone() {\n\t\t\treturn new this.constructor().copy(this);\n\t\t}\n\n\t}\n\n\tclass ImmediateRenderObject extends Object3D {\n\t\tconstructor(material) {\n\t\t\tsuper();\n\t\t\tthis.material = material;\n\n\t\t\tthis.render = function ()\n\t\t\t/* renderCallback */\n\t\t\t{};\n\n\t\t\tthis.hasPositions = false;\n\t\t\tthis.hasNormals = false;\n\t\t\tthis.hasColors = false;\n\t\t\tthis.hasUvs = false;\n\t\t\tthis.positionArray = null;\n\t\t\tthis.normalArray = null;\n\t\t\tthis.colorArray = null;\n\t\t\tthis.uvArray = null;\n\t\t\tthis.count = 0;\n\t\t}\n\n\t}\n\n\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\n\n\tconst _vector$3 = /*@__PURE__*/new Vector3();\n\n\tclass SpotLightHelper extends Object3D {\n\t\tconstructor(light, color) {\n\t\t\tsuper();\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.color = color;\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];\n\n\t\t\tfor (let i = 0, j = 1, l = 32; i < l; i++, j++) {\n\t\t\t\tconst p1 = i / l * Math.PI * 2;\n\t\t\t\tconst p2 = j / l * Math.PI * 2;\n\t\t\t\tpositions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);\n\t\t\t}\n\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tfog: false,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tthis.cone = new LineSegments(geometry, material);\n\t\t\tthis.add(this.cone);\n\t\t\tthis.update();\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.cone.geometry.dispose();\n\t\t\tthis.cone.material.dispose();\n\t\t}\n\n\t\tupdate() {\n\t\t\tthis.light.updateMatrixWorld();\n\t\t\tconst coneLength = this.light.distance ? this.light.distance : 1000;\n\t\t\tconst coneWidth = coneLength * Math.tan(this.light.angle);\n\t\t\tthis.cone.scale.set(coneWidth, coneWidth, coneLength);\n\n\t\t\t_vector$3.setFromMatrixPosition(this.light.target.matrixWorld);\n\n\t\t\tthis.cone.lookAt(_vector$3);\n\n\t\t\tif (this.color !== undefined) {\n\t\t\t\tthis.cone.material.color.set(this.color);\n\t\t\t} else {\n\t\t\t\tthis.cone.material.color.copy(this.light.color);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tconst _vector$2 = /*@__PURE__*/new Vector3();\n\n\tconst _boneMatrix = /*@__PURE__*/new Matrix4();\n\n\tconst _matrixWorldInv = /*@__PURE__*/new Matrix4();\n\n\tclass SkeletonHelper extends LineSegments {\n\t\tconstructor(object) {\n\t\t\tconst bones = getBoneList(object);\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst vertices = [];\n\t\t\tconst colors = [];\n\t\t\tconst color1 = new Color(0, 0, 1);\n\t\t\tconst color2 = new Color(0, 1, 0);\n\n\t\t\tfor (let i = 0; i < bones.length; i++) {\n\t\t\t\tconst bone = bones[i];\n\n\t\t\t\tif (bone.parent && bone.parent.isBone) {\n\t\t\t\t\tvertices.push(0, 0, 0);\n\t\t\t\t\tvertices.push(0, 0, 0);\n\t\t\t\t\tcolors.push(color1.r, color1.g, color1.b);\n\t\t\t\t\tcolors.push(color2.r, color2.g, color2.b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tvertexColors: true,\n\t\t\t\tdepthTest: false,\n\t\t\t\tdepthWrite: false,\n\t\t\t\ttoneMapped: false,\n\t\t\t\ttransparent: true\n\t\t\t});\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'SkeletonHelper';\n\t\t\tthis.isSkeletonHelper = true;\n\t\t\tthis.root = object;\n\t\t\tthis.bones = bones;\n\t\t\tthis.matrix = object.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tconst bones = this.bones;\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst position = geometry.getAttribute('position');\n\n\t\t\t_matrixWorldInv.copy(this.root.matrixWorld).invert();\n\n\t\t\tfor (let i = 0, j = 0; i < bones.length; i++) {\n\t\t\t\tconst bone = bones[i];\n\n\t\t\t\tif (bone.parent && bone.parent.isBone) {\n\t\t\t\t\t_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);\n\n\t\t\t\t\t_vector$2.setFromMatrixPosition(_boneMatrix);\n\n\t\t\t\t\tposition.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);\n\n\t\t\t\t\t_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);\n\n\t\t\t\t\t_vector$2.setFromMatrixPosition(_boneMatrix);\n\n\t\t\t\t\tposition.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);\n\t\t\t\t\tj += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgeometry.getAttribute('position').needsUpdate = true;\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t}\n\n\t}\n\n\tfunction getBoneList(object) {\n\t\tconst boneList = [];\n\n\t\tif (object && object.isBone) {\n\t\t\tboneList.push(object);\n\t\t}\n\n\t\tfor (let i = 0; i < object.children.length; i++) {\n\t\t\tboneList.push.apply(boneList, getBoneList(object.children[i]));\n\t\t}\n\n\t\treturn boneList;\n\t}\n\n\tclass PointLightHelper extends Mesh {\n\t\tconstructor(light, sphereSize, color) {\n\t\t\tconst geometry = new SphereGeometry(sphereSize, 4, 2);\n\t\t\tconst material = new MeshBasicMaterial({\n\t\t\t\twireframe: true,\n\t\t\t\tfog: false,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tsuper(geometry, material);\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\t\tthis.color = color;\n\t\t\tthis.type = 'PointLightHelper';\n\t\t\tthis.matrix = this.light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.update();\n\t\t\t/*\n\t\t\t// TODO: delete this comment?\n\t\t\tconst distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );\n\t\t\tconst distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\t\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\t\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\t\t\tconst d = light.distance;\n\t\t\tif ( d === 0.0 ) {\n\t\t\t\tthis.lightDistance.visible = false;\n\t\t\t} else {\n\t\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\t\t}\n\t\t\tthis.add( this.lightDistance );\n\t\t\t*/\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.geometry.dispose();\n\t\t\tthis.material.dispose();\n\t\t}\n\n\t\tupdate() {\n\t\t\tif (this.color !== undefined) {\n\t\t\t\tthis.material.color.set(this.color);\n\t\t\t} else {\n\t\t\t\tthis.material.color.copy(this.light.color);\n\t\t\t}\n\t\t\t/*\n\t\t\tconst d = this.light.distance;\n\t\t\t\tif ( d === 0.0 ) {\n\t\t\t\t\tthis.lightDistance.visible = false;\n\t\t\t\t} else {\n\t\t\t\t\tthis.lightDistance.visible = true;\n\t\t\t\tthis.lightDistance.scale.set( d, d, d );\n\t\t\t\t}\n\t\t\t*/\n\n\t\t}\n\n\t}\n\n\tconst _vector$1 = /*@__PURE__*/new Vector3();\n\n\tconst _color1 = /*@__PURE__*/new Color();\n\n\tconst _color2 = /*@__PURE__*/new Color();\n\n\tclass HemisphereLightHelper extends Object3D {\n\t\tconstructor(light, size, color) {\n\t\t\tsuper();\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.color = color;\n\t\t\tconst geometry = new OctahedronGeometry(size);\n\t\t\tgeometry.rotateY(Math.PI * 0.5);\n\t\t\tthis.material = new MeshBasicMaterial({\n\t\t\t\twireframe: true,\n\t\t\t\tfog: false,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tif (this.color === undefined) this.material.vertexColors = true;\n\t\t\tconst position = geometry.getAttribute('position');\n\t\t\tconst colors = new Float32Array(position.count * 3);\n\t\t\tgeometry.setAttribute('color', new BufferAttribute(colors, 3));\n\t\t\tthis.add(new Mesh(geometry, this.material));\n\t\t\tthis.update();\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.children[0].geometry.dispose();\n\t\t\tthis.children[0].material.dispose();\n\t\t}\n\n\t\tupdate() {\n\t\t\tconst mesh = this.children[0];\n\n\t\t\tif (this.color !== undefined) {\n\t\t\t\tthis.material.color.set(this.color);\n\t\t\t} else {\n\t\t\t\tconst colors = mesh.geometry.getAttribute('color');\n\n\t\t\t\t_color1.copy(this.light.color);\n\n\t\t\t\t_color2.copy(this.light.groundColor);\n\n\t\t\t\tfor (let i = 0, l = colors.count; i < l; i++) {\n\t\t\t\t\tconst color = i < l / 2 ? _color1 : _color2;\n\t\t\t\t\tcolors.setXYZ(i, color.r, color.g, color.b);\n\t\t\t\t}\n\n\t\t\t\tcolors.needsUpdate = true;\n\t\t\t}\n\n\t\t\tmesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());\n\t\t}\n\n\t}\n\n\tclass GridHelper extends LineSegments {\n\t\tconstructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {\n\t\t\tcolor1 = new Color(color1);\n\t\t\tcolor2 = new Color(color2);\n\t\t\tconst center = divisions / 2;\n\t\t\tconst step = size / divisions;\n\t\t\tconst halfSize = size / 2;\n\t\t\tconst vertices = [],\n\t\t\t\t\t\tcolors = [];\n\n\t\t\tfor (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {\n\t\t\t\tvertices.push(-halfSize, 0, k, halfSize, 0, k);\n\t\t\t\tvertices.push(k, 0, -halfSize, k, 0, halfSize);\n\t\t\t\tconst color = i === center ? color1 : color2;\n\t\t\t\tcolor.toArray(colors, j);\n\t\t\t\tj += 3;\n\t\t\t\tcolor.toArray(colors, j);\n\t\t\t\tj += 3;\n\t\t\t\tcolor.toArray(colors, j);\n\t\t\t\tj += 3;\n\t\t\t\tcolor.toArray(colors, j);\n\t\t\t\tj += 3;\n\t\t\t}\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tvertexColors: true,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'GridHelper';\n\t\t}\n\n\t}\n\n\tclass PolarGridHelper extends LineSegments {\n\t\tconstructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888) {\n\t\t\tcolor1 = new Color(color1);\n\t\t\tcolor2 = new Color(color2);\n\t\t\tconst vertices = [];\n\t\t\tconst colors = []; // create the radials\n\n\t\t\tfor (let i = 0; i <= radials; i++) {\n\t\t\t\tconst v = i / radials * (Math.PI * 2);\n\t\t\t\tconst x = Math.sin(v) * radius;\n\t\t\t\tconst z = Math.cos(v) * radius;\n\t\t\t\tvertices.push(0, 0, 0);\n\t\t\t\tvertices.push(x, 0, z);\n\t\t\t\tconst color = i & 1 ? color1 : color2;\n\t\t\t\tcolors.push(color.r, color.g, color.b);\n\t\t\t\tcolors.push(color.r, color.g, color.b);\n\t\t\t} // create the circles\n\n\n\t\t\tfor (let i = 0; i <= circles; i++) {\n\t\t\t\tconst color = i & 1 ? color1 : color2;\n\t\t\t\tconst r = radius - radius / circles * i;\n\n\t\t\t\tfor (let j = 0; j < divisions; j++) {\n\t\t\t\t\t// first vertex\n\t\t\t\t\tlet v = j / divisions * (Math.PI * 2);\n\t\t\t\t\tlet x = Math.sin(v) * r;\n\t\t\t\t\tlet z = Math.cos(v) * r;\n\t\t\t\t\tvertices.push(x, 0, z);\n\t\t\t\t\tcolors.push(color.r, color.g, color.b); // second vertex\n\n\t\t\t\t\tv = (j + 1) / divisions * (Math.PI * 2);\n\t\t\t\t\tx = Math.sin(v) * r;\n\t\t\t\t\tz = Math.cos(v) * r;\n\t\t\t\t\tvertices.push(x, 0, z);\n\t\t\t\t\tcolors.push(color.r, color.g, color.b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tvertexColors: true,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'PolarGridHelper';\n\t\t}\n\n\t}\n\n\tconst _v1 = /*@__PURE__*/new Vector3();\n\n\tconst _v2 = /*@__PURE__*/new Vector3();\n\n\tconst _v3 = /*@__PURE__*/new Vector3();\n\n\tclass DirectionalLightHelper extends Object3D {\n\t\tconstructor(light, size, color) {\n\t\t\tsuper();\n\t\t\tthis.light = light;\n\t\t\tthis.light.updateMatrixWorld();\n\t\t\tthis.matrix = light.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.color = color;\n\t\t\tif (size === undefined) size = 1;\n\t\t\tlet geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tfog: false,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tthis.lightPlane = new Line(geometry, material);\n\t\t\tthis.add(this.lightPlane);\n\t\t\tgeometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));\n\t\t\tthis.targetLine = new Line(geometry, material);\n\t\t\tthis.add(this.targetLine);\n\t\t\tthis.update();\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.lightPlane.geometry.dispose();\n\t\t\tthis.lightPlane.material.dispose();\n\t\t\tthis.targetLine.geometry.dispose();\n\t\t\tthis.targetLine.material.dispose();\n\t\t}\n\n\t\tupdate() {\n\t\t\t_v1.setFromMatrixPosition(this.light.matrixWorld);\n\n\t\t\t_v2.setFromMatrixPosition(this.light.target.matrixWorld);\n\n\t\t\t_v3.subVectors(_v2, _v1);\n\n\t\t\tthis.lightPlane.lookAt(_v2);\n\n\t\t\tif (this.color !== undefined) {\n\t\t\t\tthis.lightPlane.material.color.set(this.color);\n\t\t\t\tthis.targetLine.material.color.set(this.color);\n\t\t\t} else {\n\t\t\t\tthis.lightPlane.material.color.copy(this.light.color);\n\t\t\t\tthis.targetLine.material.color.copy(this.light.color);\n\t\t\t}\n\n\t\t\tthis.targetLine.lookAt(_v2);\n\t\t\tthis.targetLine.scale.z = _v3.length();\n\t\t}\n\n\t}\n\n\tconst _vector = /*@__PURE__*/new Vector3();\n\n\tconst _camera = /*@__PURE__*/new Camera();\n\t/**\n\t *\t- shows frustum, line of sight and up of the camera\n\t *\t- suitable for fast updates\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n\t */\n\n\n\tclass CameraHelper extends LineSegments {\n\t\tconstructor(camera) {\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tcolor: 0xffffff,\n\t\t\t\tvertexColors: true,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tconst vertices = [];\n\t\t\tconst colors = [];\n\t\t\tconst pointMap = {}; // colors\n\n\t\t\tconst colorFrustum = new Color(0xffaa00);\n\t\t\tconst colorCone = new Color(0xff0000);\n\t\t\tconst colorUp = new Color(0x00aaff);\n\t\t\tconst colorTarget = new Color(0xffffff);\n\t\t\tconst colorCross = new Color(0x333333); // near\n\n\t\t\taddLine('n1', 'n2', colorFrustum);\n\t\t\taddLine('n2', 'n4', colorFrustum);\n\t\t\taddLine('n4', 'n3', colorFrustum);\n\t\t\taddLine('n3', 'n1', colorFrustum); // far\n\n\t\t\taddLine('f1', 'f2', colorFrustum);\n\t\t\taddLine('f2', 'f4', colorFrustum);\n\t\t\taddLine('f4', 'f3', colorFrustum);\n\t\t\taddLine('f3', 'f1', colorFrustum); // sides\n\n\t\t\taddLine('n1', 'f1', colorFrustum);\n\t\t\taddLine('n2', 'f2', colorFrustum);\n\t\t\taddLine('n3', 'f3', colorFrustum);\n\t\t\taddLine('n4', 'f4', colorFrustum); // cone\n\n\t\t\taddLine('p', 'n1', colorCone);\n\t\t\taddLine('p', 'n2', colorCone);\n\t\t\taddLine('p', 'n3', colorCone);\n\t\t\taddLine('p', 'n4', colorCone); // up\n\n\t\t\taddLine('u1', 'u2', colorUp);\n\t\t\taddLine('u2', 'u3', colorUp);\n\t\t\taddLine('u3', 'u1', colorUp); // target\n\n\t\t\taddLine('c', 't', colorTarget);\n\t\t\taddLine('p', 'c', colorCross); // cross\n\n\t\t\taddLine('cn1', 'cn2', colorCross);\n\t\t\taddLine('cn3', 'cn4', colorCross);\n\t\t\taddLine('cf1', 'cf2', colorCross);\n\t\t\taddLine('cf3', 'cf4', colorCross);\n\n\t\t\tfunction addLine(a, b, color) {\n\t\t\t\taddPoint(a, color);\n\t\t\t\taddPoint(b, color);\n\t\t\t}\n\n\t\t\tfunction addPoint(id, color) {\n\t\t\t\tvertices.push(0, 0, 0);\n\t\t\t\tcolors.push(color.r, color.g, color.b);\n\n\t\t\t\tif (pointMap[id] === undefined) {\n\t\t\t\t\tpointMap[id] = [];\n\t\t\t\t}\n\n\t\t\t\tpointMap[id].push(vertices.length / 3 - 1);\n\t\t\t}\n\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'CameraHelper';\n\t\t\tthis.camera = camera;\n\t\t\tif (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();\n\t\t\tthis.matrix = camera.matrixWorld;\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.pointMap = pointMap;\n\t\t\tthis.update();\n\t\t}\n\n\t\tupdate() {\n\t\t\tconst geometry = this.geometry;\n\t\t\tconst pointMap = this.pointMap;\n\t\t\tconst w = 1,\n\t\t\t\t\t\th = 1; // we need just camera projection matrix inverse\n\t\t\t// world matrix must be identity\n\n\t\t\t_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target\n\n\n\t\t\tsetPoint('c', pointMap, geometry, _camera, 0, 0, -1);\n\t\t\tsetPoint('t', pointMap, geometry, _camera, 0, 0, 1); // near\n\n\t\t\tsetPoint('n1', pointMap, geometry, _camera, -w, -h, -1);\n\t\t\tsetPoint('n2', pointMap, geometry, _camera, w, -h, -1);\n\t\t\tsetPoint('n3', pointMap, geometry, _camera, -w, h, -1);\n\t\t\tsetPoint('n4', pointMap, geometry, _camera, w, h, -1); // far\n\n\t\t\tsetPoint('f1', pointMap, geometry, _camera, -w, -h, 1);\n\t\t\tsetPoint('f2', pointMap, geometry, _camera, w, -h, 1);\n\t\t\tsetPoint('f3', pointMap, geometry, _camera, -w, h, 1);\n\t\t\tsetPoint('f4', pointMap, geometry, _camera, w, h, 1); // up\n\n\t\t\tsetPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);\n\t\t\tsetPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);\n\t\t\tsetPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1); // cross\n\n\t\t\tsetPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);\n\t\t\tsetPoint('cf2', pointMap, geometry, _camera, w, 0, 1);\n\t\t\tsetPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);\n\t\t\tsetPoint('cf4', pointMap, geometry, _camera, 0, h, 1);\n\t\t\tsetPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);\n\t\t\tsetPoint('cn2', pointMap, geometry, _camera, w, 0, -1);\n\t\t\tsetPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);\n\t\t\tsetPoint('cn4', pointMap, geometry, _camera, 0, h, -1);\n\t\t\tgeometry.getAttribute('position').needsUpdate = true;\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.geometry.dispose();\n\t\t\tthis.material.dispose();\n\t\t}\n\n\t}\n\n\tfunction setPoint(point, pointMap, geometry, camera, x, y, z) {\n\t\t_vector.set(x, y, z).unproject(camera);\n\n\t\tconst points = pointMap[point];\n\n\t\tif (points !== undefined) {\n\t\t\tconst position = geometry.getAttribute('position');\n\n\t\t\tfor (let i = 0, l = points.length; i < l; i++) {\n\t\t\t\tposition.setXYZ(points[i], _vector.x, _vector.y, _vector.z);\n\t\t\t}\n\t\t}\n\t}\n\n\tconst _box = /*@__PURE__*/new Box3();\n\n\tclass BoxHelper extends LineSegments {\n\t\tconstructor(object, color = 0xffff00) {\n\t\t\tconst indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\n\t\t\tconst positions = new Float32Array(8 * 3);\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setIndex(new BufferAttribute(indices, 1));\n\t\t\tgeometry.setAttribute('position', new BufferAttribute(positions, 3));\n\t\t\tsuper(geometry, new LineBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\ttoneMapped: false\n\t\t\t}));\n\t\t\tthis.object = object;\n\t\t\tthis.type = 'BoxHelper';\n\t\t\tthis.matrixAutoUpdate = false;\n\t\t\tthis.update();\n\t\t}\n\n\t\tupdate(object) {\n\t\t\tif (object !== undefined) {\n\t\t\t\tconsole.warn('THREE.BoxHelper: .update() has no longer arguments.');\n\t\t\t}\n\n\t\t\tif (this.object !== undefined) {\n\t\t\t\t_box.setFromObject(this.object);\n\t\t\t}\n\n\t\t\tif (_box.isEmpty()) return;\n\t\t\tconst min = _box.min;\n\t\t\tconst max = _box.max;\n\t\t\t/*\n\t\t\t\t5____4\n\t\t\t1/___0/|\n\t\t\t| 6__|_7\n\t\t\t2/___3/\n\t\t\t\t0: max.x, max.y, max.z\n\t\t\t1: min.x, max.y, max.z\n\t\t\t2: min.x, min.y, max.z\n\t\t\t3: max.x, min.y, max.z\n\t\t\t4: max.x, max.y, min.z\n\t\t\t5: min.x, max.y, min.z\n\t\t\t6: min.x, min.y, min.z\n\t\t\t7: max.x, min.y, min.z\n\t\t\t*/\n\n\t\t\tconst position = this.geometry.attributes.position;\n\t\t\tconst array = position.array;\n\t\t\tarray[0] = max.x;\n\t\t\tarray[1] = max.y;\n\t\t\tarray[2] = max.z;\n\t\t\tarray[3] = min.x;\n\t\t\tarray[4] = max.y;\n\t\t\tarray[5] = max.z;\n\t\t\tarray[6] = min.x;\n\t\t\tarray[7] = min.y;\n\t\t\tarray[8] = max.z;\n\t\t\tarray[9] = max.x;\n\t\t\tarray[10] = min.y;\n\t\t\tarray[11] = max.z;\n\t\t\tarray[12] = max.x;\n\t\t\tarray[13] = max.y;\n\t\t\tarray[14] = min.z;\n\t\t\tarray[15] = min.x;\n\t\t\tarray[16] = max.y;\n\t\t\tarray[17] = min.z;\n\t\t\tarray[18] = min.x;\n\t\t\tarray[19] = min.y;\n\t\t\tarray[20] = min.z;\n\t\t\tarray[21] = max.x;\n\t\t\tarray[22] = min.y;\n\t\t\tarray[23] = min.z;\n\t\t\tposition.needsUpdate = true;\n\t\t\tthis.geometry.computeBoundingSphere();\n\t\t}\n\n\t\tsetFromObject(object) {\n\t\t\tthis.object = object;\n\t\t\tthis.update();\n\t\t\treturn this;\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tLineSegments.prototype.copy.call(this, source);\n\t\t\tthis.object = source.object;\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass Box3Helper extends LineSegments {\n\t\tconstructor(box, color = 0xffff00) {\n\t\t\tconst indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\n\t\t\tconst positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setIndex(new BufferAttribute(indices, 1));\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t\t\tsuper(geometry, new LineBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\ttoneMapped: false\n\t\t\t}));\n\t\t\tthis.box = box;\n\t\t\tthis.type = 'Box3Helper';\n\t\t\tthis.geometry.computeBoundingSphere();\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tconst box = this.box;\n\t\t\tif (box.isEmpty()) return;\n\t\t\tbox.getCenter(this.position);\n\t\t\tbox.getSize(this.scale);\n\t\t\tthis.scale.multiplyScalar(0.5);\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t}\n\n\t}\n\n\tclass PlaneHelper extends Line {\n\t\tconstructor(plane, size = 1, hex = 0xffff00) {\n\t\t\tconst color = hex;\n\t\t\tconst positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\t\t\tgeometry.computeBoundingSphere();\n\t\t\tsuper(geometry, new LineBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\ttoneMapped: false\n\t\t\t}));\n\t\t\tthis.type = 'PlaneHelper';\n\t\t\tthis.plane = plane;\n\t\t\tthis.size = size;\n\t\t\tconst positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];\n\t\t\tconst geometry2 = new BufferGeometry();\n\t\t\tgeometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));\n\t\t\tgeometry2.computeBoundingSphere();\n\t\t\tthis.add(new Mesh(geometry2, new MeshBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\topacity: 0.2,\n\t\t\t\ttransparent: true,\n\t\t\t\tdepthWrite: false,\n\t\t\t\ttoneMapped: false\n\t\t\t})));\n\t\t}\n\n\t\tupdateMatrixWorld(force) {\n\t\t\tlet scale = -this.plane.constant;\n\t\t\tif (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter\n\n\t\t\tthis.scale.set(0.5 * this.size, 0.5 * this.size, scale);\n\t\t\tthis.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here\n\n\t\t\tthis.lookAt(this.plane.normal);\n\t\t\tsuper.updateMatrixWorld(force);\n\t\t}\n\n\t}\n\n\tconst _axis = /*@__PURE__*/new Vector3();\n\n\tlet _lineGeometry, _coneGeometry;\n\n\tclass ArrowHelper extends Object3D {\n\t\t// dir is assumed to be normalized\n\t\tconstructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2) {\n\t\t\tsuper();\n\t\t\tthis.type = 'ArrowHelper';\n\n\t\t\tif (_lineGeometry === undefined) {\n\t\t\t\t_lineGeometry = new BufferGeometry();\n\n\t\t\t\t_lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));\n\n\t\t\t\t_coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);\n\n\t\t\t\t_coneGeometry.translate(0, -0.5, 0);\n\t\t\t}\n\n\t\t\tthis.position.copy(origin);\n\t\t\tthis.line = new Line(_lineGeometry, new LineBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\ttoneMapped: false\n\t\t\t}));\n\t\t\tthis.line.matrixAutoUpdate = false;\n\t\t\tthis.add(this.line);\n\t\t\tthis.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({\n\t\t\t\tcolor: color,\n\t\t\t\ttoneMapped: false\n\t\t\t}));\n\t\t\tthis.cone.matrixAutoUpdate = false;\n\t\t\tthis.add(this.cone);\n\t\t\tthis.setDirection(dir);\n\t\t\tthis.setLength(length, headLength, headWidth);\n\t\t}\n\n\t\tsetDirection(dir) {\n\t\t\t// dir is assumed to be normalized\n\t\t\tif (dir.y > 0.99999) {\n\t\t\t\tthis.quaternion.set(0, 0, 0, 1);\n\t\t\t} else if (dir.y < -0.99999) {\n\t\t\t\tthis.quaternion.set(1, 0, 0, 0);\n\t\t\t} else {\n\t\t\t\t_axis.set(dir.z, 0, -dir.x).normalize();\n\n\t\t\t\tconst radians = Math.acos(dir.y);\n\t\t\t\tthis.quaternion.setFromAxisAngle(_axis, radians);\n\t\t\t}\n\t\t}\n\n\t\tsetLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {\n\t\t\tthis.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458\n\n\t\t\tthis.line.updateMatrix();\n\t\t\tthis.cone.scale.set(headWidth, headLength, headWidth);\n\t\t\tthis.cone.position.y = length;\n\t\t\tthis.cone.updateMatrix();\n\t\t}\n\n\t\tsetColor(color) {\n\t\t\tthis.line.material.color.set(color);\n\t\t\tthis.cone.material.color.set(color);\n\t\t}\n\n\t\tcopy(source) {\n\t\t\tsuper.copy(source, false);\n\t\t\tthis.line.copy(source.line);\n\t\t\tthis.cone.copy(source.cone);\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tclass AxesHelper extends LineSegments {\n\t\tconstructor(size = 1) {\n\t\t\tconst vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];\n\t\t\tconst colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];\n\t\t\tconst geometry = new BufferGeometry();\n\t\t\tgeometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n\t\t\tconst material = new LineBasicMaterial({\n\t\t\t\tvertexColors: true,\n\t\t\t\ttoneMapped: false\n\t\t\t});\n\t\t\tsuper(geometry, material);\n\t\t\tthis.type = 'AxesHelper';\n\t\t}\n\n\t\tdispose() {\n\t\t\tthis.geometry.dispose();\n\t\t\tthis.material.dispose();\n\t\t}\n\n\t}\n\n\tconst _floatView = new Float32Array(1);\n\n\tconst _int32View = new Int32Array(_floatView.buffer);\n\n\tclass DataUtils {\n\t\t// Converts float32 to float16 (stored as uint16 value).\n\t\tstatic toHalfFloat(val) {\n\t\t\t// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\n\n\t\t\t/* This method is faster than the OpenEXR implementation (very often\n\t\t\t* used, eg. in Ogre), with the additional benefit of rounding, inspired\n\t\t\t* by James Tursa?s half-precision code. */\n\t\t\t_floatView[0] = val;\n\t\t\tconst x = _int32View[0];\n\t\t\tlet bits = x >> 16 & 0x8000;\n\t\t\t/* Get the sign */\n\n\t\t\tlet m = x >> 12 & 0x07ff;\n\t\t\t/* Keep one extra bit for rounding */\n\n\t\t\tconst e = x >> 23 & 0xff;\n\t\t\t/* Using int is faster here */\n\n\t\t\t/* If zero, or denormal, or exponent underflows too much for a denormal\n\t\t\t\t* half, return signed zero. */\n\n\t\t\tif (e < 103) return bits;\n\t\t\t/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\n\t\t\tif (e > 142) {\n\t\t\t\tbits |= 0x7c00;\n\t\t\t\t/* If exponent was 0xff and one mantissa bit was set, it means NaN,\n\t\t\t\t\t\t\t* not Inf, so make sure we set one mantissa bit too. */\n\n\t\t\t\tbits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n\t\t\t\treturn bits;\n\t\t\t}\n\t\t\t/* If exponent underflows but not too much, return a denormal */\n\n\n\t\t\tif (e < 113) {\n\t\t\t\tm |= 0x0800;\n\t\t\t\t/* Extra rounding may overflow and set mantissa to 0 and exponent\n\t\t\t\t\t* to 1, which is OK. */\n\n\t\t\t\tbits |= (m >> 114 - e) + (m >> 113 - e & 1);\n\t\t\t\treturn bits;\n\t\t\t}\n\n\t\t\tbits |= e - 112 << 10 | m >> 1;\n\t\t\t/* Extra rounding. An overflow will set mantissa to 0 and increment\n\t\t\t\t* the exponent, which is OK. */\n\n\t\t\tbits += m & 1;\n\t\t\treturn bits;\n\t\t}\n\n\t}\n\n\tconst LOD_MIN = 4;\n\tconst LOD_MAX = 8;\n\tconst SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are\n\t// chosen to approximate a Trowbridge-Reitz distribution function times the\n\t// geometric shadowing function. These sigma values squared must match the\n\t// variance #defines in cube_uv_reflection_fragment.glsl.js.\n\n\tconst EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\n\tconst TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer\n\t// samples and exit early, but not recompile the shader.\n\n\tconst MAX_SAMPLES = 20;\n\tconst ENCODINGS = {\n\t\t[LinearEncoding]: 0,\n\t\t[sRGBEncoding]: 1,\n\t\t[RGBEEncoding]: 2,\n\t\t[RGBM7Encoding]: 3,\n\t\t[RGBM16Encoding]: 4,\n\t\t[RGBDEncoding]: 5,\n\t\t[GammaEncoding]: 6\n\t};\n\tconst backgroundMaterial = new MeshBasicMaterial({\n\t\tside: BackSide,\n\t\tdepthWrite: false,\n\t\tdepthTest: false\n\t});\n\tconst backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);\n\n\tconst _flatCamera = /*@__PURE__*/new OrthographicCamera();\n\n\tconst {\n\t\t_lodPlanes,\n\t\t_sizeLods,\n\t\t_sigmas\n\t} = /*@__PURE__*/_createPlanes();\n\n\tconst _clearColor = /*@__PURE__*/new Color();\n\n\tlet _oldTarget = null; // Golden Ratio\n\n\tconst PHI = (1 + Math.sqrt(5)) / 2;\n\tconst INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the\n\t// same axis), used as axis directions evenly spread on a sphere.\n\n\tconst _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];\n\t/**\n\t * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n\t * (PMREM) from a cubeMap environment texture. This allows different levels of\n\t * blur to be quickly accessed based on material roughness. It is packed into a\n\t * special CubeUV format that allows us to perform custom interpolation so that\n\t * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n\t * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n\t * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n\t * higher roughness levels. In this way we maintain resolution to smoothly\n\t * interpolate diffuse lighting while limiting sampling computation.\n\t *\n\t * Paper: Fast, Accurate Image-Based Lighting\n\t * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n\t*/\n\n\tfunction convertLinearToRGBE(color) {\n\t\tconst maxComponent = Math.max(color.r, color.g, color.b);\n\t\tconst fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);\n\t\tcolor.multiplyScalar(Math.pow(2.0, -fExp));\n\t\tconst alpha = (fExp + 128.0) / 255.0;\n\t\treturn alpha;\n\t}\n\n\tclass PMREMGenerator {\n\t\tconstructor(renderer) {\n\t\t\tthis._renderer = renderer;\n\t\t\tthis._pingPongRenderTarget = null;\n\t\t\tthis._blurMaterial = _getBlurShader(MAX_SAMPLES);\n\t\t\tthis._equirectShader = null;\n\t\t\tthis._cubemapShader = null;\n\n\t\t\tthis._compileMaterial(this._blurMaterial);\n\t\t}\n\t\t/**\n\t\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t\t * is placed at the origin).\n\t\t */\n\n\n\t\tfromScene(scene, sigma = 0, near = 0.1, far = 100) {\n\t\t\t_oldTarget = this._renderer.getRenderTarget();\n\n\t\t\tconst cubeUVRenderTarget = this._allocateTargets();\n\n\t\t\tthis._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n\n\t\t\tif (sigma > 0) {\n\t\t\t\tthis._blur(cubeUVRenderTarget, 0, 0, sigma);\n\t\t\t}\n\n\t\t\tthis._applyPMREM(cubeUVRenderTarget);\n\n\t\t\tthis._cleanup(cubeUVRenderTarget);\n\n\t\t\treturn cubeUVRenderTarget;\n\t\t}\n\t\t/**\n\t\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t\t * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),\n\t\t * as this matches best with the 256 x 256 cubemap output.\n\t\t */\n\n\n\t\tfromEquirectangular(equirectangular) {\n\t\t\treturn this._fromTexture(equirectangular);\n\t\t}\n\t\t/**\n\t\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t\t * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,\n\t\t * as this matches best with the 256 x 256 cubemap output.\n\t\t */\n\n\n\t\tfromCubemap(cubemap) {\n\t\t\treturn this._fromTexture(cubemap);\n\t\t}\n\t\t/**\n\t\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t\t * your texture's network fetch for increased concurrency.\n\t\t */\n\n\n\t\tcompileCubemapShader() {\n\t\t\tif (this._cubemapShader === null) {\n\t\t\t\tthis._cubemapShader = _getCubemapShader();\n\n\t\t\t\tthis._compileMaterial(this._cubemapShader);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t\t * your texture's network fetch for increased concurrency.\n\t\t */\n\n\n\t\tcompileEquirectangularShader() {\n\t\t\tif (this._equirectShader === null) {\n\t\t\t\tthis._equirectShader = _getEquirectShader();\n\n\t\t\t\tthis._compileMaterial(this._equirectShader);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t\t * one of them will cause any others to also become unusable.\n\t\t */\n\n\n\t\tdispose() {\n\t\t\tthis._blurMaterial.dispose();\n\n\t\t\tif (this._cubemapShader !== null) this._cubemapShader.dispose();\n\t\t\tif (this._equirectShader !== null) this._equirectShader.dispose();\n\n\t\t\tfor (let i = 0; i < _lodPlanes.length; i++) {\n\t\t\t\t_lodPlanes[i].dispose();\n\t\t\t}\n\t\t} // private interface\n\n\n\t\t_cleanup(outputTarget) {\n\t\t\tthis._pingPongRenderTarget.dispose();\n\n\t\t\tthis._renderer.setRenderTarget(_oldTarget);\n\n\t\t\toutputTarget.scissorTest = false;\n\n\t\t\t_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n\t\t}\n\n\t\t_fromTexture(texture) {\n\t\t\t_oldTarget = this._renderer.getRenderTarget();\n\n\t\t\tconst cubeUVRenderTarget = this._allocateTargets(texture);\n\n\t\t\tthis._textureToCubeUV(texture, cubeUVRenderTarget);\n\n\t\t\tthis._applyPMREM(cubeUVRenderTarget);\n\n\t\t\tthis._cleanup(cubeUVRenderTarget);\n\n\t\t\treturn cubeUVRenderTarget;\n\t\t}\n\n\t\t_allocateTargets(texture) {\n\t\t\t// warning: null texture is valid\n\t\t\tconst params = {\n\t\t\t\tmagFilter: NearestFilter,\n\t\t\t\tminFilter: NearestFilter,\n\t\t\t\tgenerateMipmaps: false,\n\t\t\t\ttype: UnsignedByteType,\n\t\t\t\tformat: RGBEFormat,\n\t\t\t\tencoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,\n\t\t\t\tdepthBuffer: false\n\t\t\t};\n\n\t\t\tconst cubeUVRenderTarget = _createRenderTarget(params);\n\n\t\t\tcubeUVRenderTarget.depthBuffer = texture ? false : true;\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget(params);\n\t\t\treturn cubeUVRenderTarget;\n\t\t}\n\n\t\t_compileMaterial(material) {\n\t\t\tconst tmpMesh = new Mesh(_lodPlanes[0], material);\n\n\t\t\tthis._renderer.compile(tmpMesh, _flatCamera);\n\t\t}\n\n\t\t_sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n\t\t\tconst fov = 90;\n\t\t\tconst aspect = 1;\n\t\t\tconst cubeCamera = new PerspectiveCamera(fov, aspect, near, far);\n\t\t\tconst upSign = [1, -1, 1, 1, 1, 1];\n\t\t\tconst forwardSign = [1, 1, 1, -1, -1, -1];\n\t\t\tconst renderer = this._renderer;\n\t\t\tconst originalAutoClear = renderer.autoClear;\n\t\t\tconst outputEncoding = renderer.outputEncoding;\n\t\t\tconst toneMapping = renderer.toneMapping;\n\t\t\trenderer.getClearColor(_clearColor);\n\t\t\trenderer.toneMapping = NoToneMapping;\n\t\t\trenderer.outputEncoding = LinearEncoding;\n\t\t\trenderer.autoClear = false;\n\t\t\tlet useSolidColor = false;\n\t\t\tconst background = scene.background;\n\n\t\t\tif (background) {\n\t\t\t\tif (background.isColor) {\n\t\t\t\t\tbackgroundMaterial.color.copy(background).convertSRGBToLinear();\n\t\t\t\t\tscene.background = null;\n\t\t\t\t\tconst alpha = convertLinearToRGBE(backgroundMaterial.color);\n\t\t\t\t\tbackgroundMaterial.opacity = alpha;\n\t\t\t\t\tuseSolidColor = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbackgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();\n\t\t\t\tconst alpha = convertLinearToRGBE(backgroundMaterial.color);\n\t\t\t\tbackgroundMaterial.opacity = alpha;\n\t\t\t\tuseSolidColor = true;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tconst col = i % 3;\n\n\t\t\t\tif (col == 0) {\n\t\t\t\t\tcubeCamera.up.set(0, upSign[i], 0);\n\t\t\t\t\tcubeCamera.lookAt(forwardSign[i], 0, 0);\n\t\t\t\t} else if (col == 1) {\n\t\t\t\t\tcubeCamera.up.set(0, 0, upSign[i]);\n\t\t\t\t\tcubeCamera.lookAt(0, forwardSign[i], 0);\n\t\t\t\t} else {\n\t\t\t\t\tcubeCamera.up.set(0, upSign[i], 0);\n\t\t\t\t\tcubeCamera.lookAt(0, 0, forwardSign[i]);\n\t\t\t\t}\n\n\t\t\t\t_setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);\n\n\t\t\t\trenderer.setRenderTarget(cubeUVRenderTarget);\n\n\t\t\t\tif (useSolidColor) {\n\t\t\t\t\trenderer.render(backgroundBox, cubeCamera);\n\t\t\t\t}\n\n\t\t\t\trenderer.render(scene, cubeCamera);\n\t\t\t}\n\n\t\t\trenderer.toneMapping = toneMapping;\n\t\t\trenderer.outputEncoding = outputEncoding;\n\t\t\trenderer.autoClear = originalAutoClear;\n\t\t}\n\n\t\t_textureToCubeUV(texture, cubeUVRenderTarget) {\n\t\t\tconst renderer = this._renderer;\n\n\t\t\tif (texture.isCubeTexture) {\n\t\t\t\tif (this._cubemapShader == null) {\n\t\t\t\t\tthis._cubemapShader = _getCubemapShader();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this._equirectShader == null) {\n\t\t\t\t\tthis._equirectShader = _getEquirectShader();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;\n\t\t\tconst mesh = new Mesh(_lodPlanes[0], material);\n\t\t\tconst uniforms = material.uniforms;\n\t\t\tuniforms['envMap'].value = texture;\n\n\t\t\tif (!texture.isCubeTexture) {\n\t\t\t\tuniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);\n\t\t\t}\n\n\t\t\tuniforms['inputEncoding'].value = ENCODINGS[texture.encoding];\n\t\t\tuniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];\n\n\t\t\t_setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);\n\n\t\t\trenderer.setRenderTarget(cubeUVRenderTarget);\n\t\t\trenderer.render(mesh, _flatCamera);\n\t\t}\n\n\t\t_applyPMREM(cubeUVRenderTarget) {\n\t\t\tconst renderer = this._renderer;\n\t\t\tconst autoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = false;\n\n\t\t\tfor (let i = 1; i < TOTAL_LODS; i++) {\n\t\t\t\tconst sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);\n\t\t\t\tconst poleAxis = _axisDirections[(i - 1) % _axisDirections.length];\n\n\t\t\t\tthis._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n\t\t\t}\n\n\t\t\trenderer.autoClear = autoClear;\n\t\t}\n\t\t/**\n\t\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t\t * accurate at the poles, but still does a decent job.\n\t\t */\n\n\n\t\t_blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n\t\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\t\tthis._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);\n\n\t\t\tthis._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);\n\t\t}\n\n\t\t_halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n\t\t\tconst renderer = this._renderer;\n\t\t\tconst blurMaterial = this._blurMaterial;\n\n\t\t\tif (direction !== 'latitudinal' && direction !== 'longitudinal') {\n\t\t\t\tconsole.error('blur direction must be either latitudinal or longitudinal!');\n\t\t\t} // Number of standard deviations at which to cut off the discrete approximation.\n\n\n\t\t\tconst STANDARD_DEVIATIONS = 3;\n\t\t\tconst blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);\n\t\t\tconst blurUniforms = blurMaterial.uniforms;\n\t\t\tconst pixels = _sizeLods[lodIn] - 1;\n\t\t\tconst radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n\t\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\t\tconst samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n\n\t\t\tif (samples > MAX_SAMPLES) {\n\t\t\t\tconsole.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n\t\t\t}\n\n\t\t\tconst weights = [];\n\t\t\tlet sum = 0;\n\n\t\t\tfor (let i = 0; i < MAX_SAMPLES; ++i) {\n\t\t\t\tconst x = i / sigmaPixels;\n\t\t\t\tconst weight = Math.exp(-x * x / 2);\n\t\t\t\tweights.push(weight);\n\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tsum += weight;\n\t\t\t\t} else if (i < samples) {\n\t\t\t\t\tsum += 2 * weight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < weights.length; i++) {\n\t\t\t\tweights[i] = weights[i] / sum;\n\t\t\t}\n\n\t\t\tblurUniforms['envMap'].value = targetIn.texture;\n\t\t\tblurUniforms['samples'].value = samples;\n\t\t\tblurUniforms['weights'].value = weights;\n\t\t\tblurUniforms['latitudinal'].value = direction === 'latitudinal';\n\n\t\t\tif (poleAxis) {\n\t\t\t\tblurUniforms['poleAxis'].value = poleAxis;\n\t\t\t}\n\n\t\t\tblurUniforms['dTheta'].value = radiansPerPixel;\n\t\t\tblurUniforms['mipInt'].value = LOD_MAX - lodIn;\n\t\t\tblurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];\n\t\t\tblurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];\n\t\t\tconst outputSize = _sizeLods[lodOut];\n\t\t\tconst x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);\n\t\t\tconst y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);\n\n\t\t\t_setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n\n\t\t\trenderer.setRenderTarget(targetOut);\n\t\t\trenderer.render(blurMesh, _flatCamera);\n\t\t}\n\n\t}\n\n\tfunction _isLDR(texture) {\n\t\tif (texture === undefined || texture.type !== UnsignedByteType) return false;\n\t\treturn texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;\n\t}\n\n\tfunction _createPlanes() {\n\t\tconst _lodPlanes = [];\n\t\tconst _sizeLods = [];\n\t\tconst _sigmas = [];\n\t\tlet lod = LOD_MAX;\n\n\t\tfor (let i = 0; i < TOTAL_LODS; i++) {\n\t\t\tconst sizeLod = Math.pow(2, lod);\n\n\t\t\t_sizeLods.push(sizeLod);\n\n\t\t\tlet sigma = 1.0 / sizeLod;\n\n\t\t\tif (i > LOD_MAX - LOD_MIN) {\n\t\t\t\tsigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];\n\t\t\t} else if (i == 0) {\n\t\t\t\tsigma = 0;\n\t\t\t}\n\n\t\t\t_sigmas.push(sigma);\n\n\t\t\tconst texelSize = 1.0 / (sizeLod - 1);\n\t\t\tconst min = -texelSize / 2;\n\t\t\tconst max = 1 + texelSize / 2;\n\t\t\tconst uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n\t\t\tconst cubeFaces = 6;\n\t\t\tconst vertices = 6;\n\t\t\tconst positionSize = 3;\n\t\t\tconst uvSize = 2;\n\t\t\tconst faceIndexSize = 1;\n\t\t\tconst position = new Float32Array(positionSize * vertices * cubeFaces);\n\t\t\tconst uv = new Float32Array(uvSize * vertices * cubeFaces);\n\t\t\tconst faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n\n\t\t\tfor (let face = 0; face < cubeFaces; face++) {\n\t\t\t\tconst x = face % 3 * 2 / 3 - 1;\n\t\t\t\tconst y = face > 2 ? 0 : -1;\n\t\t\t\tconst coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n\t\t\t\tposition.set(coordinates, positionSize * vertices * face);\n\t\t\t\tuv.set(uv1, uvSize * vertices * face);\n\t\t\t\tconst fill = [face, face, face, face, face, face];\n\t\t\t\tfaceIndex.set(fill, faceIndexSize * vertices * face);\n\t\t\t}\n\n\t\t\tconst planes = new BufferGeometry();\n\t\t\tplanes.setAttribute('position', new BufferAttribute(position, positionSize));\n\t\t\tplanes.setAttribute('uv', new BufferAttribute(uv, uvSize));\n\t\t\tplanes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));\n\n\t\t\t_lodPlanes.push(planes);\n\n\t\t\tif (lod > LOD_MIN) {\n\t\t\t\tlod--;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\t_lodPlanes,\n\t\t\t_sizeLods,\n\t\t\t_sigmas\n\t\t};\n\t}\n\n\tfunction _createRenderTarget(params) {\n\t\tconst cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);\n\t\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\t\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\t\tcubeUVRenderTarget.scissorTest = true;\n\t\treturn cubeUVRenderTarget;\n\t}\n\n\tfunction _setViewport(target, x, y, width, height) {\n\t\ttarget.viewport.set(x, y, width, height);\n\t\ttarget.scissor.set(x, y, width, height);\n\t}\n\n\tfunction _getBlurShader(maxSamples) {\n\t\tconst weights = new Float32Array(maxSamples);\n\t\tconst poleAxis = new Vector3(0, 1, 0);\n\t\tconst shaderMaterial = new RawShaderMaterial({\n\t\t\tname: 'SphericalGaussianBlur',\n\t\t\tdefines: {\n\t\t\t\t'n': maxSamples\n\t\t\t},\n\t\t\tuniforms: {\n\t\t\t\t'envMap': {\n\t\t\t\t\tvalue: null\n\t\t\t\t},\n\t\t\t\t'samples': {\n\t\t\t\t\tvalue: 1\n\t\t\t\t},\n\t\t\t\t'weights': {\n\t\t\t\t\tvalue: weights\n\t\t\t\t},\n\t\t\t\t'latitudinal': {\n\t\t\t\t\tvalue: false\n\t\t\t\t},\n\t\t\t\t'dTheta': {\n\t\t\t\t\tvalue: 0\n\t\t\t\t},\n\t\t\t\t'mipInt': {\n\t\t\t\t\tvalue: 0\n\t\t\t\t},\n\t\t\t\t'poleAxis': {\n\t\t\t\t\tvalue: poleAxis\n\t\t\t\t},\n\t\t\t\t'inputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t},\n\t\t\t\t'outputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: _getCommonVertexShader(),\n\t\t\tfragmentShader:\n\t\t\t/* glsl */\n\t\t\t`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\t\t\tblending: NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false\n\t\t});\n\t\treturn shaderMaterial;\n\t}\n\n\tfunction _getEquirectShader() {\n\t\tconst texelSize = new Vector2(1, 1);\n\t\tconst shaderMaterial = new RawShaderMaterial({\n\t\t\tname: 'EquirectangularToCubeUV',\n\t\t\tuniforms: {\n\t\t\t\t'envMap': {\n\t\t\t\t\tvalue: null\n\t\t\t\t},\n\t\t\t\t'texelSize': {\n\t\t\t\t\tvalue: texelSize\n\t\t\t\t},\n\t\t\t\t'inputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t},\n\t\t\t\t'outputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: _getCommonVertexShader(),\n\t\t\tfragmentShader:\n\t\t\t/* glsl */\n\t\t\t`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\t\t\tblending: NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false\n\t\t});\n\t\treturn shaderMaterial;\n\t}\n\n\tfunction _getCubemapShader() {\n\t\tconst shaderMaterial = new RawShaderMaterial({\n\t\t\tname: 'CubemapToCubeUV',\n\t\t\tuniforms: {\n\t\t\t\t'envMap': {\n\t\t\t\t\tvalue: null\n\t\t\t\t},\n\t\t\t\t'inputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t},\n\t\t\t\t'outputEncoding': {\n\t\t\t\t\tvalue: ENCODINGS[LinearEncoding]\n\t\t\t\t}\n\t\t\t},\n\t\t\tvertexShader: _getCommonVertexShader(),\n\t\t\tfragmentShader:\n\t\t\t/* glsl */\n\t\t\t`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${_getEncodings()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n\t\t\tblending: NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false\n\t\t});\n\t\treturn shaderMaterial;\n\t}\n\n\tfunction _getCommonVertexShader() {\n\t\treturn (\n\t\t\t/* glsl */\n\t\t\t`\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`\n\t\t);\n\t}\n\n\tfunction _getEncodings() {\n\t\treturn (\n\t\t\t/* glsl */\n\t\t\t`\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t`\n\t\t);\n\t}\n\n\tconst LineStrip = 0;\n\tconst LinePieces = 1;\n\tconst NoColors = 0;\n\tconst FaceColors = 1;\n\tconst VertexColors = 2;\n\tfunction MeshFaceMaterial(materials) {\n\t\tconsole.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');\n\t\treturn materials;\n\t}\n\tfunction MultiMaterial(materials = []) {\n\t\tconsole.warn('THREE.MultiMaterial has been removed. Use an Array instead.');\n\t\tmaterials.isMultiMaterial = true;\n\t\tmaterials.materials = materials;\n\n\t\tmaterials.clone = function () {\n\t\t\treturn materials.slice();\n\t\t};\n\n\t\treturn materials;\n\t}\n\tfunction PointCloud(geometry, material) {\n\t\tconsole.warn('THREE.PointCloud has been renamed to THREE.Points.');\n\t\treturn new Points(geometry, material);\n\t}\n\tfunction Particle(material) {\n\t\tconsole.warn('THREE.Particle has been renamed to THREE.Sprite.');\n\t\treturn new Sprite(material);\n\t}\n\tfunction ParticleSystem(geometry, material) {\n\t\tconsole.warn('THREE.ParticleSystem has been renamed to THREE.Points.');\n\t\treturn new Points(geometry, material);\n\t}\n\tfunction PointCloudMaterial(parameters) {\n\t\tconsole.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');\n\t\treturn new PointsMaterial(parameters);\n\t}\n\tfunction ParticleBasicMaterial(parameters) {\n\t\tconsole.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');\n\t\treturn new PointsMaterial(parameters);\n\t}\n\tfunction ParticleSystemMaterial(parameters) {\n\t\tconsole.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');\n\t\treturn new PointsMaterial(parameters);\n\t}\n\tfunction Vertex(x, y, z) {\n\t\tconsole.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');\n\t\treturn new Vector3(x, y, z);\n\t} //\n\n\tfunction DynamicBufferAttribute(array, itemSize) {\n\t\tconsole.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');\n\t\treturn new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);\n\t}\n\tfunction Int8Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');\n\t\treturn new Int8BufferAttribute(array, itemSize);\n\t}\n\tfunction Uint8Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');\n\t\treturn new Uint8BufferAttribute(array, itemSize);\n\t}\n\tfunction Uint8ClampedAttribute(array, itemSize) {\n\t\tconsole.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');\n\t\treturn new Uint8ClampedBufferAttribute(array, itemSize);\n\t}\n\tfunction Int16Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');\n\t\treturn new Int16BufferAttribute(array, itemSize);\n\t}\n\tfunction Uint16Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');\n\t\treturn new Uint16BufferAttribute(array, itemSize);\n\t}\n\tfunction Int32Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');\n\t\treturn new Int32BufferAttribute(array, itemSize);\n\t}\n\tfunction Uint32Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');\n\t\treturn new Uint32BufferAttribute(array, itemSize);\n\t}\n\tfunction Float32Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');\n\t\treturn new Float32BufferAttribute(array, itemSize);\n\t}\n\tfunction Float64Attribute(array, itemSize) {\n\t\tconsole.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');\n\t\treturn new Float64BufferAttribute(array, itemSize);\n\t} //\n\n\tCurve.create = function (construct, getPoint) {\n\t\tconsole.log('THREE.Curve.create() has been deprecated');\n\t\tconstruct.prototype = Object.create(Curve.prototype);\n\t\tconstruct.prototype.constructor = construct;\n\t\tconstruct.prototype.getPoint = getPoint;\n\t\treturn construct;\n\t}; //\n\n\n\tPath.prototype.fromPoints = function (points) {\n\t\tconsole.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');\n\t\treturn this.setFromPoints(points);\n\t}; //\n\n\n\tfunction AxisHelper(size) {\n\t\tconsole.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');\n\t\treturn new AxesHelper(size);\n\t}\n\tfunction BoundingBoxHelper(object, color) {\n\t\tconsole.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');\n\t\treturn new BoxHelper(object, color);\n\t}\n\tfunction EdgesHelper(object, hex) {\n\t\tconsole.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');\n\t\treturn new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({\n\t\t\tcolor: hex !== undefined ? hex : 0xffffff\n\t\t}));\n\t}\n\n\tGridHelper.prototype.setColors = function () {\n\t\tconsole.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');\n\t};\n\n\tSkeletonHelper.prototype.update = function () {\n\t\tconsole.error('THREE.SkeletonHelper: update() no longer needs to be called.');\n\t};\n\n\tfunction WireframeHelper(object, hex) {\n\t\tconsole.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');\n\t\treturn new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({\n\t\t\tcolor: hex !== undefined ? hex : 0xffffff\n\t\t}));\n\t} //\n\n\tLoader.prototype.extractUrlBase = function (url) {\n\t\tconsole.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');\n\t\treturn LoaderUtils.extractUrlBase(url);\n\t};\n\n\tLoader.Handlers = {\n\t\tadd: function ()\n\t\t/* regex, loader */\n\t\t{\n\t\t\tconsole.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');\n\t\t},\n\t\tget: function ()\n\t\t/* file */\n\t\t{\n\t\t\tconsole.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');\n\t\t}\n\t};\n\tfunction XHRLoader(manager) {\n\t\tconsole.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');\n\t\treturn new FileLoader(manager);\n\t}\n\tfunction BinaryTextureLoader(manager) {\n\t\tconsole.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');\n\t\treturn new DataTextureLoader(manager);\n\t} //\n\n\tBox2.prototype.center = function (optionalTarget) {\n\t\tconsole.warn('THREE.Box2: .center() has been renamed to .getCenter().');\n\t\treturn this.getCenter(optionalTarget);\n\t};\n\n\tBox2.prototype.empty = function () {\n\t\tconsole.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');\n\t\treturn this.isEmpty();\n\t};\n\n\tBox2.prototype.isIntersectionBox = function (box) {\n\t\tconsole.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');\n\t\treturn this.intersectsBox(box);\n\t};\n\n\tBox2.prototype.size = function (optionalTarget) {\n\t\tconsole.warn('THREE.Box2: .size() has been renamed to .getSize().');\n\t\treturn this.getSize(optionalTarget);\n\t}; //\n\n\n\tBox3.prototype.center = function (optionalTarget) {\n\t\tconsole.warn('THREE.Box3: .center() has been renamed to .getCenter().');\n\t\treturn this.getCenter(optionalTarget);\n\t};\n\n\tBox3.prototype.empty = function () {\n\t\tconsole.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');\n\t\treturn this.isEmpty();\n\t};\n\n\tBox3.prototype.isIntersectionBox = function (box) {\n\t\tconsole.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');\n\t\treturn this.intersectsBox(box);\n\t};\n\n\tBox3.prototype.isIntersectionSphere = function (sphere) {\n\t\tconsole.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');\n\t\treturn this.intersectsSphere(sphere);\n\t};\n\n\tBox3.prototype.size = function (optionalTarget) {\n\t\tconsole.warn('THREE.Box3: .size() has been renamed to .getSize().');\n\t\treturn this.getSize(optionalTarget);\n\t}; //\n\n\n\tSphere.prototype.empty = function () {\n\t\tconsole.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');\n\t\treturn this.isEmpty();\n\t}; //\n\n\n\tFrustum.prototype.setFromMatrix = function (m) {\n\t\tconsole.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');\n\t\treturn this.setFromProjectionMatrix(m);\n\t}; //\n\n\n\tLine3.prototype.center = function (optionalTarget) {\n\t\tconsole.warn('THREE.Line3: .center() has been renamed to .getCenter().');\n\t\treturn this.getCenter(optionalTarget);\n\t}; //\n\n\n\tMatrix3.prototype.flattenToArrayOffset = function (array, offset) {\n\t\tconsole.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');\n\t\treturn this.toArray(array, offset);\n\t};\n\n\tMatrix3.prototype.multiplyVector3 = function (vector) {\n\t\tconsole.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');\n\t\treturn vector.applyMatrix3(this);\n\t};\n\n\tMatrix3.prototype.multiplyVector3Array = function ()\n\t/* a */\n\t{\n\t\tconsole.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');\n\t};\n\n\tMatrix3.prototype.applyToBufferAttribute = function (attribute) {\n\t\tconsole.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');\n\t\treturn attribute.applyMatrix3(this);\n\t};\n\n\tMatrix3.prototype.applyToVector3Array = function ()\n\t/* array, offset, length */\n\t{\n\t\tconsole.error('THREE.Matrix3: .applyToVector3Array() has been removed.');\n\t};\n\n\tMatrix3.prototype.getInverse = function (matrix) {\n\t\tconsole.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');\n\t\treturn this.copy(matrix).invert();\n\t}; //\n\n\n\tMatrix4.prototype.extractPosition = function (m) {\n\t\tconsole.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');\n\t\treturn this.copyPosition(m);\n\t};\n\n\tMatrix4.prototype.flattenToArrayOffset = function (array, offset) {\n\t\tconsole.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');\n\t\treturn this.toArray(array, offset);\n\t};\n\n\tMatrix4.prototype.getPosition = function () {\n\t\tconsole.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');\n\t\treturn new Vector3().setFromMatrixColumn(this, 3);\n\t};\n\n\tMatrix4.prototype.setRotationFromQuaternion = function (q) {\n\t\tconsole.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');\n\t\treturn this.makeRotationFromQuaternion(q);\n\t};\n\n\tMatrix4.prototype.multiplyToArray = function () {\n\t\tconsole.warn('THREE.Matrix4: .multiplyToArray() has been removed.');\n\t};\n\n\tMatrix4.prototype.multiplyVector3 = function (vector) {\n\t\tconsole.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');\n\t\treturn vector.applyMatrix4(this);\n\t};\n\n\tMatrix4.prototype.multiplyVector4 = function (vector) {\n\t\tconsole.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');\n\t\treturn vector.applyMatrix4(this);\n\t};\n\n\tMatrix4.prototype.multiplyVector3Array = function ()\n\t/* a */\n\t{\n\t\tconsole.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');\n\t};\n\n\tMatrix4.prototype.rotateAxis = function (v) {\n\t\tconsole.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');\n\t\tv.transformDirection(this);\n\t};\n\n\tMatrix4.prototype.crossVector = function (vector) {\n\t\tconsole.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');\n\t\treturn vector.applyMatrix4(this);\n\t};\n\n\tMatrix4.prototype.translate = function () {\n\t\tconsole.error('THREE.Matrix4: .translate() has been removed.');\n\t};\n\n\tMatrix4.prototype.rotateX = function () {\n\t\tconsole.error('THREE.Matrix4: .rotateX() has been removed.');\n\t};\n\n\tMatrix4.prototype.rotateY = function () {\n\t\tconsole.error('THREE.Matrix4: .rotateY() has been removed.');\n\t};\n\n\tMatrix4.prototype.rotateZ = function () {\n\t\tconsole.error('THREE.Matrix4: .rotateZ() has been removed.');\n\t};\n\n\tMatrix4.prototype.rotateByAxis = function () {\n\t\tconsole.error('THREE.Matrix4: .rotateByAxis() has been removed.');\n\t};\n\n\tMatrix4.prototype.applyToBufferAttribute = function (attribute) {\n\t\tconsole.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');\n\t\treturn attribute.applyMatrix4(this);\n\t};\n\n\tMatrix4.prototype.applyToVector3Array = function ()\n\t/* array, offset, length */\n\t{\n\t\tconsole.error('THREE.Matrix4: .applyToVector3Array() has been removed.');\n\t};\n\n\tMatrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {\n\t\tconsole.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');\n\t\treturn this.makePerspective(left, right, top, bottom, near, far);\n\t};\n\n\tMatrix4.prototype.getInverse = function (matrix) {\n\t\tconsole.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');\n\t\treturn this.copy(matrix).invert();\n\t}; //\n\n\n\tPlane.prototype.isIntersectionLine = function (line) {\n\t\tconsole.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');\n\t\treturn this.intersectsLine(line);\n\t}; //\n\n\n\tQuaternion.prototype.multiplyVector3 = function (vector) {\n\t\tconsole.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');\n\t\treturn vector.applyQuaternion(this);\n\t};\n\n\tQuaternion.prototype.inverse = function () {\n\t\tconsole.warn('THREE.Quaternion: .inverse() has been renamed to invert().');\n\t\treturn this.invert();\n\t}; //\n\n\n\tRay.prototype.isIntersectionBox = function (box) {\n\t\tconsole.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');\n\t\treturn this.intersectsBox(box);\n\t};\n\n\tRay.prototype.isIntersectionPlane = function (plane) {\n\t\tconsole.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');\n\t\treturn this.intersectsPlane(plane);\n\t};\n\n\tRay.prototype.isIntersectionSphere = function (sphere) {\n\t\tconsole.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');\n\t\treturn this.intersectsSphere(sphere);\n\t}; //\n\n\n\tTriangle.prototype.area = function () {\n\t\tconsole.warn('THREE.Triangle: .area() has been renamed to .getArea().');\n\t\treturn this.getArea();\n\t};\n\n\tTriangle.prototype.barycoordFromPoint = function (point, target) {\n\t\tconsole.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');\n\t\treturn this.getBarycoord(point, target);\n\t};\n\n\tTriangle.prototype.midpoint = function (target) {\n\t\tconsole.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');\n\t\treturn this.getMidpoint(target);\n\t};\n\n\tTriangle.prototypenormal = function (target) {\n\t\tconsole.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');\n\t\treturn this.getNormal(target);\n\t};\n\n\tTriangle.prototype.plane = function (target) {\n\t\tconsole.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');\n\t\treturn this.getPlane(target);\n\t};\n\n\tTriangle.barycoordFromPoint = function (point, a, b, c, target) {\n\t\tconsole.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');\n\t\treturn Triangle.getBarycoord(point, a, b, c, target);\n\t};\n\n\tTriangle.normal = function (a, b, c, target) {\n\t\tconsole.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');\n\t\treturn Triangle.getNormal(a, b, c, target);\n\t}; //\n\n\n\tShape.prototype.extractAllPoints = function (divisions) {\n\t\tconsole.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');\n\t\treturn this.extractPoints(divisions);\n\t};\n\n\tShape.prototype.extrude = function (options) {\n\t\tconsole.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');\n\t\treturn new ExtrudeGeometry(this, options);\n\t};\n\n\tShape.prototype.makeGeometry = function (options) {\n\t\tconsole.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');\n\t\treturn new ShapeGeometry(this, options);\n\t}; //\n\n\n\tVector2.prototype.fromAttribute = function (attribute, index, offset) {\n\t\tconsole.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');\n\t\treturn this.fromBufferAttribute(attribute, index, offset);\n\t};\n\n\tVector2.prototype.distanceToManhattan = function (v) {\n\t\tconsole.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');\n\t\treturn this.manhattanDistanceTo(v);\n\t};\n\n\tVector2.prototype.lengthManhattan = function () {\n\t\tconsole.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');\n\t\treturn this.manhattanLength();\n\t}; //\n\n\n\tVector3.prototype.setEulerFromRotationMatrix = function () {\n\t\tconsole.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');\n\t};\n\n\tVector3.prototype.setEulerFromQuaternion = function () {\n\t\tconsole.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');\n\t};\n\n\tVector3.prototype.getPositionFromMatrix = function (m) {\n\t\tconsole.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');\n\t\treturn this.setFromMatrixPosition(m);\n\t};\n\n\tVector3.prototype.getScaleFromMatrix = function (m) {\n\t\tconsole.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');\n\t\treturn this.setFromMatrixScale(m);\n\t};\n\n\tVector3.prototype.getColumnFromMatrix = function (index, matrix) {\n\t\tconsole.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');\n\t\treturn this.setFromMatrixColumn(matrix, index);\n\t};\n\n\tVector3.prototype.applyProjection = function (m) {\n\t\tconsole.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');\n\t\treturn this.applyMatrix4(m);\n\t};\n\n\tVector3.prototype.fromAttribute = function (attribute, index, offset) {\n\t\tconsole.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');\n\t\treturn this.fromBufferAttribute(attribute, index, offset);\n\t};\n\n\tVector3.prototype.distanceToManhattan = function (v) {\n\t\tconsole.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');\n\t\treturn this.manhattanDistanceTo(v);\n\t};\n\n\tVector3.prototype.lengthManhattan = function () {\n\t\tconsole.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');\n\t\treturn this.manhattanLength();\n\t}; //\n\n\n\tVector4.prototype.fromAttribute = function (attribute, index, offset) {\n\t\tconsole.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');\n\t\treturn this.fromBufferAttribute(attribute, index, offset);\n\t};\n\n\tVector4.prototype.lengthManhattan = function () {\n\t\tconsole.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');\n\t\treturn this.manhattanLength();\n\t}; //\n\n\n\tObject3D.prototype.getChildByName = function (name) {\n\t\tconsole.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');\n\t\treturn this.getObjectByName(name);\n\t};\n\n\tObject3D.prototype.renderDepth = function () {\n\t\tconsole.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');\n\t};\n\n\tObject3D.prototype.translate = function (distance, axis) {\n\t\tconsole.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');\n\t\treturn this.translateOnAxis(axis, distance);\n\t};\n\n\tObject3D.prototype.getWorldRotation = function () {\n\t\tconsole.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');\n\t};\n\n\tObject3D.prototype.applyMatrix = function (matrix) {\n\t\tconsole.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');\n\t\treturn this.applyMatrix4(matrix);\n\t};\n\n\tObject.defineProperties(Object3D.prototype, {\n\t\teulerOrder: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');\n\t\t\t\treturn this.rotation.order;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');\n\t\t\t\tthis.rotation.order = value;\n\t\t\t}\n\t\t},\n\t\tuseQuaternion: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');\n\t\t\t}\n\t\t}\n\t});\n\n\tMesh.prototype.setDrawMode = function () {\n\t\tconsole.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');\n\t};\n\n\tObject.defineProperties(Mesh.prototype, {\n\t\tdrawMode: {\n\t\t\tget: function () {\n\t\t\t\tconsole.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');\n\t\t\t\treturn TrianglesDrawMode;\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');\n\t\t\t}\n\t\t}\n\t});\n\n\tSkinnedMesh.prototype.initBones = function () {\n\t\tconsole.error('THREE.SkinnedMesh: initBones() has been removed.');\n\t}; //\n\n\n\tPerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {\n\t\tconsole.warn('THREE.PerspectiveCamera.setLens is deprecated. ' + 'Use .setFocalLength and .filmGauge for a photographic setup.');\n\t\tif (filmGauge !== undefined) this.filmGauge = filmGauge;\n\t\tthis.setFocalLength(focalLength);\n\t}; //\n\n\n\tObject.defineProperties(Light.prototype, {\n\t\tonlyShadow: {\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Light: .onlyShadow has been removed.');\n\t\t\t}\n\t\t},\n\t\tshadowCameraFov: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');\n\t\t\t\tthis.shadow.camera.fov = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraLeft: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');\n\t\t\t\tthis.shadow.camera.left = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraRight: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');\n\t\t\t\tthis.shadow.camera.right = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraTop: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');\n\t\t\t\tthis.shadow.camera.top = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraBottom: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');\n\t\t\t\tthis.shadow.camera.bottom = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraNear: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');\n\t\t\t\tthis.shadow.camera.near = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraFar: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');\n\t\t\t\tthis.shadow.camera.far = value;\n\t\t\t}\n\t\t},\n\t\tshadowCameraVisible: {\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');\n\t\t\t}\n\t\t},\n\t\tshadowBias: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowBias is now .shadow.bias.');\n\t\t\t\tthis.shadow.bias = value;\n\t\t\t}\n\t\t},\n\t\tshadowDarkness: {\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Light: .shadowDarkness has been removed.');\n\t\t\t}\n\t\t},\n\t\tshadowMapWidth: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');\n\t\t\t\tthis.shadow.mapSize.width = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapHeight: {\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');\n\t\t\t\tthis.shadow.mapSize.height = value;\n\t\t\t}\n\t\t}\n\t}); //\n\n\tObject.defineProperties(BufferAttribute.prototype, {\n\t\tlength: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');\n\t\t\t\treturn this.array.length;\n\t\t\t}\n\t\t},\n\t\tdynamic: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');\n\t\t\t\treturn this.usage === DynamicDrawUsage;\n\t\t\t},\n\t\t\tset: function ()\n\t\t\t/* value */\n\t\t\t{\n\t\t\t\tconsole.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');\n\t\t\t\tthis.setUsage(DynamicDrawUsage);\n\t\t\t}\n\t\t}\n\t});\n\n\tBufferAttribute.prototype.setDynamic = function (value) {\n\t\tconsole.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');\n\t\tthis.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);\n\t\treturn this;\n\t};\n\n\tBufferAttribute.prototype.copyIndicesArray = function ()\n\t/* indices */\n\t{\n\t\tconsole.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');\n\t}, BufferAttribute.prototype.setArray = function ()\n\t/* array */\n\t{\n\t\tconsole.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');\n\t}; //\n\n\tBufferGeometry.prototype.addIndex = function (index) {\n\t\tconsole.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');\n\t\tthis.setIndex(index);\n\t};\n\n\tBufferGeometry.prototype.addAttribute = function (name, attribute) {\n\t\tconsole.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');\n\n\t\tif (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {\n\t\t\tconsole.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');\n\t\t\treturn this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));\n\t\t}\n\n\t\tif (name === 'index') {\n\t\t\tconsole.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');\n\t\t\tthis.setIndex(attribute);\n\t\t\treturn this;\n\t\t}\n\n\t\treturn this.setAttribute(name, attribute);\n\t};\n\n\tBufferGeometry.prototype.addDrawCall = function (start, count, indexOffset) {\n\t\tif (indexOffset !== undefined) {\n\t\t\tconsole.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');\n\t\t}\n\n\t\tconsole.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');\n\t\tthis.addGroup(start, count);\n\t};\n\n\tBufferGeometry.prototype.clearDrawCalls = function () {\n\t\tconsole.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');\n\t\tthis.clearGroups();\n\t};\n\n\tBufferGeometry.prototype.computeOffsets = function () {\n\t\tconsole.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');\n\t};\n\n\tBufferGeometry.prototype.removeAttribute = function (name) {\n\t\tconsole.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');\n\t\treturn this.deleteAttribute(name);\n\t};\n\n\tBufferGeometry.prototype.applyMatrix = function (matrix) {\n\t\tconsole.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');\n\t\treturn this.applyMatrix4(matrix);\n\t};\n\n\tObject.defineProperties(BufferGeometry.prototype, {\n\t\tdrawcalls: {\n\t\t\tget: function () {\n\t\t\t\tconsole.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t},\n\t\toffsets: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');\n\t\t\t\treturn this.groups;\n\t\t\t}\n\t\t}\n\t});\n\n\tInterleavedBuffer.prototype.setDynamic = function (value) {\n\t\tconsole.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');\n\t\tthis.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);\n\t\treturn this;\n\t};\n\n\tInterleavedBuffer.prototype.setArray = function ()\n\t/* array */\n\t{\n\t\tconsole.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');\n\t}; //\n\n\n\tExtrudeGeometry.prototype.getArrays = function () {\n\t\tconsole.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');\n\t};\n\n\tExtrudeGeometry.prototype.addShapeList = function () {\n\t\tconsole.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');\n\t};\n\n\tExtrudeGeometry.prototype.addShape = function () {\n\t\tconsole.error('THREE.ExtrudeGeometry: .addShape() has been removed.');\n\t}; //\n\n\n\tScene.prototype.dispose = function () {\n\t\tconsole.error('THREE.Scene: .dispose() has been removed.');\n\t}; //\n\n\n\tUniform.prototype.onUpdate = function () {\n\t\tconsole.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');\n\t\treturn this;\n\t}; //\n\n\n\tObject.defineProperties(Material.prototype, {\n\t\twrapAround: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.Material: .wrapAround has been removed.');\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Material: .wrapAround has been removed.');\n\t\t\t}\n\t\t},\n\t\toverdraw: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.Material: .overdraw has been removed.');\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.Material: .overdraw has been removed.');\n\t\t\t}\n\t\t},\n\t\twrapRGB: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.Material: .wrapRGB has been removed.');\n\t\t\t\treturn new Color();\n\t\t\t}\n\t\t},\n\t\tshading: {\n\t\t\tget: function () {\n\t\t\t\tconsole.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');\n\t\t\t\tthis.flatShading = value === FlatShading;\n\t\t\t}\n\t\t},\n\t\tstencilMask: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');\n\t\t\t\treturn this.stencilFuncMask;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');\n\t\t\t\tthis.stencilFuncMask = value;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperties(ShaderMaterial.prototype, {\n\t\tderivatives: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');\n\t\t\t\treturn this.extensions.derivatives;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');\n\t\t\t\tthis.extensions.derivatives = value;\n\t\t\t}\n\t\t}\n\t}); //\n\n\tWebGLRenderer.prototype.clearTarget = function (renderTarget, color, depth, stencil) {\n\t\tconsole.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');\n\t\tthis.setRenderTarget(renderTarget);\n\t\tthis.clear(color, depth, stencil);\n\t};\n\n\tWebGLRenderer.prototype.animate = function (callback) {\n\t\tconsole.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');\n\t\tthis.setAnimationLoop(callback);\n\t};\n\n\tWebGLRenderer.prototype.getCurrentRenderTarget = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');\n\t\treturn this.getRenderTarget();\n\t};\n\n\tWebGLRenderer.prototype.getMaxAnisotropy = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');\n\t\treturn this.capabilities.getMaxAnisotropy();\n\t};\n\n\tWebGLRenderer.prototype.getPrecision = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');\n\t\treturn this.capabilities.precision;\n\t};\n\n\tWebGLRenderer.prototype.resetGLState = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');\n\t\treturn this.state.reset();\n\t};\n\n\tWebGLRenderer.prototype.supportsFloatTextures = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).');\n\t\treturn this.extensions.get('OES_texture_float');\n\t};\n\n\tWebGLRenderer.prototype.supportsHalfFloatTextures = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).');\n\t\treturn this.extensions.get('OES_texture_half_float');\n\t};\n\n\tWebGLRenderer.prototype.supportsStandardDerivatives = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).');\n\t\treturn this.extensions.get('OES_standard_derivatives');\n\t};\n\n\tWebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).');\n\t\treturn this.extensions.get('WEBGL_compressed_texture_s3tc');\n\t};\n\n\tWebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).');\n\t\treturn this.extensions.get('WEBGL_compressed_texture_pvrtc');\n\t};\n\n\tWebGLRenderer.prototype.supportsBlendMinMax = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).');\n\t\treturn this.extensions.get('EXT_blend_minmax');\n\t};\n\n\tWebGLRenderer.prototype.supportsVertexTextures = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');\n\t\treturn this.capabilities.vertexTextures;\n\t};\n\n\tWebGLRenderer.prototype.supportsInstancedArrays = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).');\n\t\treturn this.extensions.get('ANGLE_instanced_arrays');\n\t};\n\n\tWebGLRenderer.prototype.enableScissorTest = function (boolean) {\n\t\tconsole.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');\n\t\tthis.setScissorTest(boolean);\n\t};\n\n\tWebGLRenderer.prototype.initMaterial = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.addPrePlugin = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.addPostPlugin = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.updateShadowMap = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.setFaceCulling = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.allocTextureUnit = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.setTexture = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .setTexture() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.setTexture2D = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.setTextureCube = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');\n\t};\n\n\tWebGLRenderer.prototype.getActiveMipMapLevel = function () {\n\t\tconsole.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');\n\t\treturn this.getActiveMipmapLevel();\n\t};\n\n\tObject.defineProperties(WebGLRenderer.prototype, {\n\t\tshadowMapEnabled: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.enabled;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');\n\t\t\t\tthis.shadowMap.enabled = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapType: {\n\t\t\tget: function () {\n\t\t\t\treturn this.shadowMap.type;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');\n\t\t\t\tthis.shadowMap.type = value;\n\t\t\t}\n\t\t},\n\t\tshadowMapCullFace: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');\n\t\t\t\treturn undefined;\n\t\t\t},\n\t\t\tset: function ()\n\t\t\t/* value */\n\t\t\t{\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');\n\t\t\t}\n\t\t},\n\t\tcontext: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');\n\t\t\t\treturn this.getContext();\n\t\t\t}\n\t\t},\n\t\tvr: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');\n\t\t\t\treturn this.xr;\n\t\t\t}\n\t\t},\n\t\tgammaInput: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');\n\t\t\t}\n\t\t},\n\t\tgammaOutput: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');\n\t\t\t\tthis.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;\n\t\t\t}\n\t\t},\n\t\ttoneMappingWhitePoint: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');\n\t\t\t\treturn 1.0;\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperties(WebGLShadowMap.prototype, {\n\t\tcullFace: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');\n\t\t\t\treturn undefined;\n\t\t\t},\n\t\t\tset: function ()\n\t\t\t/* cullFace */\n\t\t\t{\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');\n\t\t\t}\n\t\t},\n\t\trenderReverseSided: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');\n\t\t\t\treturn undefined;\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');\n\t\t\t}\n\t\t},\n\t\trenderSingleSided: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');\n\t\t\t\treturn undefined;\n\t\t\t},\n\t\t\tset: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');\n\t\t\t}\n\t\t}\n\t});\n\tfunction WebGLRenderTargetCube(width, height, options) {\n\t\tconsole.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');\n\t\treturn new WebGLCubeRenderTarget(width, options);\n\t} //\n\n\tObject.defineProperties(WebGLRenderTarget.prototype, {\n\t\twrapS: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');\n\t\t\t\treturn this.texture.wrapS;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');\n\t\t\t\tthis.texture.wrapS = value;\n\t\t\t}\n\t\t},\n\t\twrapT: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');\n\t\t\t\treturn this.texture.wrapT;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');\n\t\t\t\tthis.texture.wrapT = value;\n\t\t\t}\n\t\t},\n\t\tmagFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');\n\t\t\t\treturn this.texture.magFilter;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');\n\t\t\t\tthis.texture.magFilter = value;\n\t\t\t}\n\t\t},\n\t\tminFilter: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');\n\t\t\t\treturn this.texture.minFilter;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');\n\t\t\t\tthis.texture.minFilter = value;\n\t\t\t}\n\t\t},\n\t\tanisotropy: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');\n\t\t\t\treturn this.texture.anisotropy;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');\n\t\t\t\tthis.texture.anisotropy = value;\n\t\t\t}\n\t\t},\n\t\toffset: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');\n\t\t\t\treturn this.texture.offset;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');\n\t\t\t\tthis.texture.offset = value;\n\t\t\t}\n\t\t},\n\t\trepeat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');\n\t\t\t\treturn this.texture.repeat;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');\n\t\t\t\tthis.texture.repeat = value;\n\t\t\t}\n\t\t},\n\t\tformat: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');\n\t\t\t\treturn this.texture.format;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');\n\t\t\t\tthis.texture.format = value;\n\t\t\t}\n\t\t},\n\t\ttype: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');\n\t\t\t\treturn this.texture.type;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');\n\t\t\t\tthis.texture.type = value;\n\t\t\t}\n\t\t},\n\t\tgenerateMipmaps: {\n\t\t\tget: function () {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');\n\t\t\t\treturn this.texture.generateMipmaps;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconsole.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');\n\t\t\t\tthis.texture.generateMipmaps = value;\n\t\t\t}\n\t\t}\n\t}); //\n\n\tAudio.prototype.load = function (file) {\n\t\tconsole.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');\n\t\tconst scope = this;\n\t\tconst audioLoader = new AudioLoader();\n\t\taudioLoader.load(file, function (buffer) {\n\t\t\tscope.setBuffer(buffer);\n\t\t});\n\t\treturn this;\n\t};\n\n\tAudioAnalyser.prototype.getData = function () {\n\t\tconsole.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');\n\t\treturn this.getFrequencyData();\n\t}; //\n\n\n\tCubeCamera.prototype.updateCubeMap = function (renderer, scene) {\n\t\tconsole.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');\n\t\treturn this.update(renderer, scene);\n\t};\n\n\tCubeCamera.prototype.clear = function (renderer, color, depth, stencil) {\n\t\tconsole.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');\n\t\treturn this.renderTarget.clear(renderer, color, depth, stencil);\n\t};\n\n\tImageUtils.crossOrigin = undefined;\n\n\tImageUtils.loadTexture = function (url, mapping, onLoad, onError) {\n\t\tconsole.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');\n\t\tconst loader = new TextureLoader();\n\t\tloader.setCrossOrigin(this.crossOrigin);\n\t\tconst texture = loader.load(url, onLoad, undefined, onError);\n\t\tif (mapping) texture.mapping = mapping;\n\t\treturn texture;\n\t};\n\n\tImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {\n\t\tconsole.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');\n\t\tconst loader = new CubeTextureLoader();\n\t\tloader.setCrossOrigin(this.crossOrigin);\n\t\tconst texture = loader.load(urls, onLoad, undefined, onError);\n\t\tif (mapping) texture.mapping = mapping;\n\t\treturn texture;\n\t};\n\n\tImageUtils.loadCompressedTexture = function () {\n\t\tconsole.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');\n\t};\n\n\tImageUtils.loadCompressedTextureCube = function () {\n\t\tconsole.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');\n\t}; //\n\n\n\tfunction CanvasRenderer() {\n\t\tconsole.error('THREE.CanvasRenderer has been removed');\n\t} //\n\n\tfunction JSONLoader() {\n\t\tconsole.error('THREE.JSONLoader has been removed.');\n\t} //\n\n\tconst SceneUtils = {\n\t\tcreateMultiMaterialObject: function ()\n\t\t/* geometry, materials */\n\t\t{\n\t\t\tconsole.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');\n\t\t},\n\t\tdetach: function ()\n\t\t/* child, parent, scene */\n\t\t{\n\t\t\tconsole.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');\n\t\t},\n\t\tattach: function ()\n\t\t/* child, scene, parent */\n\t\t{\n\t\t\tconsole.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');\n\t\t}\n\t}; //\n\n\tfunction LensFlare() {\n\t\tconsole.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');\n\t}\n\n\tif (typeof __THREE_DEVTOOLS__ !== 'undefined') {\n\t\t/* eslint-disable no-undef */\n\t\t__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {\n\t\t\tdetail: {\n\t\t\t\trevision: REVISION\n\t\t\t}\n\t\t}));\n\t\t/* eslint-enable no-undef */\n\n\t}\n\n\tif (typeof window !== 'undefined') {\n\t\tif (window.__THREE__) {\n\t\t\tconsole.warn('WARNING: Multiple instances of Three.js being imported.');\n\t\t} else {\n\t\t\twindow.__THREE__ = REVISION;\n\t\t}\n\t}\n\n\texports.ACESFilmicToneMapping = ACESFilmicToneMapping;\n\texports.AddEquation = AddEquation;\n\texports.AddOperation = AddOperation;\n\texports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;\n\texports.AdditiveBlending = AdditiveBlending;\n\texports.AlphaFormat = AlphaFormat;\n\texports.AlwaysDepth = AlwaysDepth;\n\texports.AlwaysStencilFunc = AlwaysStencilFunc;\n\texports.AmbientLight = AmbientLight;\n\texports.AmbientLightProbe = AmbientLightProbe;\n\texports.AnimationClip = AnimationClip;\n\texports.AnimationLoader = AnimationLoader;\n\texports.AnimationMixer = AnimationMixer;\n\texports.AnimationObjectGroup = AnimationObjectGroup;\n\texports.AnimationUtils = AnimationUtils;\n\texports.ArcCurve = ArcCurve;\n\texports.ArrayCamera = ArrayCamera;\n\texports.ArrowHelper = ArrowHelper;\n\texports.Audio = Audio;\n\texports.AudioAnalyser = AudioAnalyser;\n\texports.AudioContext = AudioContext;\n\texports.AudioListener = AudioListener;\n\texports.AudioLoader = AudioLoader;\n\texports.AxesHelper = AxesHelper;\n\texports.AxisHelper = AxisHelper;\n\texports.BackSide = BackSide;\n\texports.BasicDepthPacking = BasicDepthPacking;\n\texports.BasicShadowMap = BasicShadowMap;\n\texports.BinaryTextureLoader = BinaryTextureLoader;\n\texports.Bone = Bone;\n\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\n\texports.BoundingBoxHelper = BoundingBoxHelper;\n\texports.Box2 = Box2;\n\texports.Box3 = Box3;\n\texports.Box3Helper = Box3Helper;\n\texports.BoxBufferGeometry = BoxGeometry;\n\texports.BoxGeometry = BoxGeometry;\n\texports.BoxHelper = BoxHelper;\n\texports.BufferAttribute = BufferAttribute;\n\texports.BufferGeometry = BufferGeometry;\n\texports.BufferGeometryLoader = BufferGeometryLoader;\n\texports.ByteType = ByteType;\n\texports.Cache = Cache;\n\texports.Camera = Camera;\n\texports.CameraHelper = CameraHelper;\n\texports.CanvasRenderer = CanvasRenderer;\n\texports.CanvasTexture = CanvasTexture;\n\texports.CatmullRomCurve3 = CatmullRomCurve3;\n\texports.CineonToneMapping = CineonToneMapping;\n\texports.CircleBufferGeometry = CircleGeometry;\n\texports.CircleGeometry = CircleGeometry;\n\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\n\texports.Clock = Clock;\n\texports.Color = Color;\n\texports.ColorKeyframeTrack = ColorKeyframeTrack;\n\texports.CompressedTexture = CompressedTexture;\n\texports.CompressedTextureLoader = CompressedTextureLoader;\n\texports.ConeBufferGeometry = ConeGeometry;\n\texports.ConeGeometry = ConeGeometry;\n\texports.CubeCamera = CubeCamera;\n\texports.CubeReflectionMapping = CubeReflectionMapping;\n\texports.CubeRefractionMapping = CubeRefractionMapping;\n\texports.CubeTexture = CubeTexture;\n\texports.CubeTextureLoader = CubeTextureLoader;\n\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\n\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\n\texports.CubicBezierCurve = CubicBezierCurve;\n\texports.CubicBezierCurve3 = CubicBezierCurve3;\n\texports.CubicInterpolant = CubicInterpolant;\n\texports.CullFaceBack = CullFaceBack;\n\texports.CullFaceFront = CullFaceFront;\n\texports.CullFaceFrontBack = CullFaceFrontBack;\n\texports.CullFaceNone = CullFaceNone;\n\texports.Curve = Curve;\n\texports.CurvePath = CurvePath;\n\texports.CustomBlending = CustomBlending;\n\texports.CustomToneMapping = CustomToneMapping;\n\texports.CylinderBufferGeometry = CylinderGeometry;\n\texports.CylinderGeometry = CylinderGeometry;\n\texports.Cylindrical = Cylindrical;\n\texports.DataTexture = DataTexture;\n\texports.DataTexture2DArray = DataTexture2DArray;\n\texports.DataTexture3D = DataTexture3D;\n\texports.DataTextureLoader = DataTextureLoader;\n\texports.DataUtils = DataUtils;\n\texports.DecrementStencilOp = DecrementStencilOp;\n\texports.DecrementWrapStencilOp = DecrementWrapStencilOp;\n\texports.DefaultLoadingManager = DefaultLoadingManager;\n\texports.DepthFormat = DepthFormat;\n\texports.DepthStencilFormat = DepthStencilFormat;\n\texports.DepthTexture = DepthTexture;\n\texports.DirectionalLight = DirectionalLight;\n\texports.DirectionalLightHelper = DirectionalLightHelper;\n\texports.DiscreteInterpolant = DiscreteInterpolant;\n\texports.DodecahedronBufferGeometry = DodecahedronGeometry;\n\texports.DodecahedronGeometry = DodecahedronGeometry;\n\texports.DoubleSide = DoubleSide;\n\texports.DstAlphaFactor = DstAlphaFactor;\n\texports.DstColorFactor = DstColorFactor;\n\texports.DynamicBufferAttribute = DynamicBufferAttribute;\n\texports.DynamicCopyUsage = DynamicCopyUsage;\n\texports.DynamicDrawUsage = DynamicDrawUsage;\n\texports.DynamicReadUsage = DynamicReadUsage;\n\texports.EdgesGeometry = EdgesGeometry;\n\texports.EdgesHelper = EdgesHelper;\n\texports.EllipseCurve = EllipseCurve;\n\texports.EqualDepth = EqualDepth;\n\texports.EqualStencilFunc = EqualStencilFunc;\n\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\n\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\n\texports.Euler = Euler;\n\texports.EventDispatcher = EventDispatcher;\n\texports.ExtrudeBufferGeometry = ExtrudeGeometry;\n\texports.ExtrudeGeometry = ExtrudeGeometry;\n\texports.FaceColors = FaceColors;\n\texports.FileLoader = FileLoader;\n\texports.FlatShading = FlatShading;\n\texports.Float16BufferAttribute = Float16BufferAttribute;\n\texports.Float32Attribute = Float32Attribute;\n\texports.Float32BufferAttribute = Float32BufferAttribute;\n\texports.Float64Attribute = Float64Attribute;\n\texports.Float64BufferAttribute = Float64BufferAttribute;\n\texports.FloatType = FloatType;\n\texports.Fog = Fog;\n\texports.FogExp2 = FogExp2;\n\texports.Font = Font;\n\texports.FontLoader = FontLoader;\n\texports.FrontSide = FrontSide;\n\texports.Frustum = Frustum;\n\texports.GLBufferAttribute = GLBufferAttribute;\n\texports.GLSL1 = GLSL1;\n\texports.GLSL3 = GLSL3;\n\texports.GammaEncoding = GammaEncoding;\n\texports.GreaterDepth = GreaterDepth;\n\texports.GreaterEqualDepth = GreaterEqualDepth;\n\texports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;\n\texports.GreaterStencilFunc = GreaterStencilFunc;\n\texports.GridHelper = GridHelper;\n\texports.Group = Group;\n\texports.HalfFloatType = HalfFloatType;\n\texports.HemisphereLight = HemisphereLight;\n\texports.HemisphereLightHelper = HemisphereLightHelper;\n\texports.HemisphereLightProbe = HemisphereLightProbe;\n\texports.IcosahedronBufferGeometry = IcosahedronGeometry;\n\texports.IcosahedronGeometry = IcosahedronGeometry;\n\texports.ImageBitmapLoader = ImageBitmapLoader;\n\texports.ImageLoader = ImageLoader;\n\texports.ImageUtils = ImageUtils;\n\texports.ImmediateRenderObject = ImmediateRenderObject;\n\texports.IncrementStencilOp = IncrementStencilOp;\n\texports.IncrementWrapStencilOp = IncrementWrapStencilOp;\n\texports.InstancedBufferAttribute = InstancedBufferAttribute;\n\texports.InstancedBufferGeometry = InstancedBufferGeometry;\n\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\n\texports.InstancedMesh = InstancedMesh;\n\texports.Int16Attribute = Int16Attribute;\n\texports.Int16BufferAttribute = Int16BufferAttribute;\n\texports.Int32Attribute = Int32Attribute;\n\texports.Int32BufferAttribute = Int32BufferAttribute;\n\texports.Int8Attribute = Int8Attribute;\n\texports.Int8BufferAttribute = Int8BufferAttribute;\n\texports.IntType = IntType;\n\texports.InterleavedBuffer = InterleavedBuffer;\n\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\n\texports.Interpolant = Interpolant;\n\texports.InterpolateDiscrete = InterpolateDiscrete;\n\texports.InterpolateLinear = InterpolateLinear;\n\texports.InterpolateSmooth = InterpolateSmooth;\n\texports.InvertStencilOp = InvertStencilOp;\n\texports.JSONLoader = JSONLoader;\n\texports.KeepStencilOp = KeepStencilOp;\n\texports.KeyframeTrack = KeyframeTrack;\n\texports.LOD = LOD;\n\texports.LatheBufferGeometry = LatheGeometry;\n\texports.LatheGeometry = LatheGeometry;\n\texports.Layers = Layers;\n\texports.LensFlare = LensFlare;\n\texports.LessDepth = LessDepth;\n\texports.LessEqualDepth = LessEqualDepth;\n\texports.LessEqualStencilFunc = LessEqualStencilFunc;\n\texports.LessStencilFunc = LessStencilFunc;\n\texports.Light = Light;\n\texports.LightProbe = LightProbe;\n\texports.Line = Line;\n\texports.Line3 = Line3;\n\texports.LineBasicMaterial = LineBasicMaterial;\n\texports.LineCurve = LineCurve;\n\texports.LineCurve3 = LineCurve3;\n\texports.LineDashedMaterial = LineDashedMaterial;\n\texports.LineLoop = LineLoop;\n\texports.LinePieces = LinePieces;\n\texports.LineSegments = LineSegments;\n\texports.LineStrip = LineStrip;\n\texports.LinearEncoding = LinearEncoding;\n\texports.LinearFilter = LinearFilter;\n\texports.LinearInterpolant = LinearInterpolant;\n\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\n\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\n\texports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;\n\texports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;\n\texports.LinearToneMapping = LinearToneMapping;\n\texports.Loader = Loader;\n\texports.LoaderUtils = LoaderUtils;\n\texports.LoadingManager = LoadingManager;\n\texports.LogLuvEncoding = LogLuvEncoding;\n\texports.LoopOnce = LoopOnce;\n\texports.LoopPingPong = LoopPingPong;\n\texports.LoopRepeat = LoopRepeat;\n\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\n\texports.LuminanceFormat = LuminanceFormat;\n\texports.MOUSE = MOUSE;\n\texports.Material = Material;\n\texports.MaterialLoader = MaterialLoader;\n\texports.Math = MathUtils;\n\texports.MathUtils = MathUtils;\n\texports.Matrix3 = Matrix3;\n\texports.Matrix4 = Matrix4;\n\texports.MaxEquation = MaxEquation;\n\texports.Mesh = Mesh;\n\texports.MeshBasicMaterial = MeshBasicMaterial;\n\texports.MeshDepthMaterial = MeshDepthMaterial;\n\texports.MeshDistanceMaterial = MeshDistanceMaterial;\n\texports.MeshFaceMaterial = MeshFaceMaterial;\n\texports.MeshLambertMaterial = MeshLambertMaterial;\n\texports.MeshMatcapMaterial = MeshMatcapMaterial;\n\texports.MeshNormalMaterial = MeshNormalMaterial;\n\texports.MeshPhongMaterial = MeshPhongMaterial;\n\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\n\texports.MeshStandardMaterial = MeshStandardMaterial;\n\texports.MeshToonMaterial = MeshToonMaterial;\n\texports.MinEquation = MinEquation;\n\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\n\texports.MixOperation = MixOperation;\n\texports.MultiMaterial = MultiMaterial;\n\texports.MultiplyBlending = MultiplyBlending;\n\texports.MultiplyOperation = MultiplyOperation;\n\texports.NearestFilter = NearestFilter;\n\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\n\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\n\texports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;\n\texports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;\n\texports.NeverDepth = NeverDepth;\n\texports.NeverStencilFunc = NeverStencilFunc;\n\texports.NoBlending = NoBlending;\n\texports.NoColors = NoColors;\n\texports.NoToneMapping = NoToneMapping;\n\texports.NormalAnimationBlendMode = NormalAnimationBlendMode;\n\texports.NormalBlending = NormalBlending;\n\texports.NotEqualDepth = NotEqualDepth;\n\texports.NotEqualStencilFunc = NotEqualStencilFunc;\n\texports.NumberKeyframeTrack = NumberKeyframeTrack;\n\texports.Object3D = Object3D;\n\texports.ObjectLoader = ObjectLoader;\n\texports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;\n\texports.OctahedronBufferGeometry = OctahedronGeometry;\n\texports.OctahedronGeometry = OctahedronGeometry;\n\texports.OneFactor = OneFactor;\n\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\n\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\n\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\n\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\n\texports.OrthographicCamera = OrthographicCamera;\n\texports.PCFShadowMap = PCFShadowMap;\n\texports.PCFSoftShadowMap = PCFSoftShadowMap;\n\texports.PMREMGenerator = PMREMGenerator;\n\texports.ParametricBufferGeometry = ParametricGeometry;\n\texports.ParametricGeometry = ParametricGeometry;\n\texports.Particle = Particle;\n\texports.ParticleBasicMaterial = ParticleBasicMaterial;\n\texports.ParticleSystem = ParticleSystem;\n\texports.ParticleSystemMaterial = ParticleSystemMaterial;\n\texports.Path = Path;\n\texports.PerspectiveCamera = PerspectiveCamera;\n\texports.Plane = Plane;\n\texports.PlaneBufferGeometry = PlaneGeometry;\n\texports.PlaneGeometry = PlaneGeometry;\n\texports.PlaneHelper = PlaneHelper;\n\texports.PointCloud = PointCloud;\n\texports.PointCloudMaterial = PointCloudMaterial;\n\texports.PointLight = PointLight;\n\texports.PointLightHelper = PointLightHelper;\n\texports.Points = Points;\n\texports.PointsMaterial = PointsMaterial;\n\texports.PolarGridHelper = PolarGridHelper;\n\texports.PolyhedronBufferGeometry = PolyhedronGeometry;\n\texports.PolyhedronGeometry = PolyhedronGeometry;\n\texports.PositionalAudio = PositionalAudio;\n\texports.PropertyBinding = PropertyBinding;\n\texports.PropertyMixer = PropertyMixer;\n\texports.QuadraticBezierCurve = QuadraticBezierCurve;\n\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\n\texports.Quaternion = Quaternion;\n\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\n\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\n\texports.REVISION = REVISION;\n\texports.RGBADepthPacking = RGBADepthPacking;\n\texports.RGBAFormat = RGBAFormat;\n\texports.RGBAIntegerFormat = RGBAIntegerFormat;\n\texports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;\n\texports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;\n\texports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;\n\texports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;\n\texports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;\n\texports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;\n\texports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;\n\texports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;\n\texports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;\n\texports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;\n\texports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;\n\texports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;\n\texports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;\n\texports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;\n\texports.RGBA_BPTC_Format = RGBA_BPTC_Format;\n\texports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;\n\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\n\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\n\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\n\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\n\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\n\texports.RGBDEncoding = RGBDEncoding;\n\texports.RGBEEncoding = RGBEEncoding;\n\texports.RGBEFormat = RGBEFormat;\n\texports.RGBFormat = RGBFormat;\n\texports.RGBIntegerFormat = RGBIntegerFormat;\n\texports.RGBM16Encoding = RGBM16Encoding;\n\texports.RGBM7Encoding = RGBM7Encoding;\n\texports.RGB_ETC1_Format = RGB_ETC1_Format;\n\texports.RGB_ETC2_Format = RGB_ETC2_Format;\n\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\n\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\n\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\n\texports.RGFormat = RGFormat;\n\texports.RGIntegerFormat = RGIntegerFormat;\n\texports.RawShaderMaterial = RawShaderMaterial;\n\texports.Ray = Ray;\n\texports.Raycaster = Raycaster;\n\texports.RectAreaLight = RectAreaLight;\n\texports.RedFormat = RedFormat;\n\texports.RedIntegerFormat = RedIntegerFormat;\n\texports.ReinhardToneMapping = ReinhardToneMapping;\n\texports.RepeatWrapping = RepeatWrapping;\n\texports.ReplaceStencilOp = ReplaceStencilOp;\n\texports.ReverseSubtractEquation = ReverseSubtractEquation;\n\texports.RingBufferGeometry = RingGeometry;\n\texports.RingGeometry = RingGeometry;\n\texports.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;\n\texports.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;\n\texports.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;\n\texports.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;\n\texports.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;\n\texports.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;\n\texports.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;\n\texports.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;\n\texports.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;\n\texports.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;\n\texports.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;\n\texports.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;\n\texports.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;\n\texports.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;\n\texports.Scene = Scene;\n\texports.SceneUtils = SceneUtils;\n\texports.ShaderChunk = ShaderChunk;\n\texports.ShaderLib = ShaderLib;\n\texports.ShaderMaterial = ShaderMaterial;\n\texports.ShadowMaterial = ShadowMaterial;\n\texports.Shape = Shape;\n\texports.ShapeBufferGeometry = ShapeGeometry;\n\texports.ShapeGeometry = ShapeGeometry;\n\texports.ShapePath = ShapePath;\n\texports.ShapeUtils = ShapeUtils;\n\texports.ShortType = ShortType;\n\texports.Skeleton = Skeleton;\n\texports.SkeletonHelper = SkeletonHelper;\n\texports.SkinnedMesh = SkinnedMesh;\n\texports.SmoothShading = SmoothShading;\n\texports.Sphere = Sphere;\n\texports.SphereBufferGeometry = SphereGeometry;\n\texports.SphereGeometry = SphereGeometry;\n\texports.Spherical = Spherical;\n\texports.SphericalHarmonics3 = SphericalHarmonics3;\n\texports.SplineCurve = SplineCurve;\n\texports.SpotLight = SpotLight;\n\texports.SpotLightHelper = SpotLightHelper;\n\texports.Sprite = Sprite;\n\texports.SpriteMaterial = SpriteMaterial;\n\texports.SrcAlphaFactor = SrcAlphaFactor;\n\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\n\texports.SrcColorFactor = SrcColorFactor;\n\texports.StaticCopyUsage = StaticCopyUsage;\n\texports.StaticDrawUsage = StaticDrawUsage;\n\texports.StaticReadUsage = StaticReadUsage;\n\texports.StereoCamera = StereoCamera;\n\texports.StreamCopyUsage = StreamCopyUsage;\n\texports.StreamDrawUsage = StreamDrawUsage;\n\texports.StreamReadUsage = StreamReadUsage;\n\texports.StringKeyframeTrack = StringKeyframeTrack;\n\texports.SubtractEquation = SubtractEquation;\n\texports.SubtractiveBlending = SubtractiveBlending;\n\texports.TOUCH = TOUCH;\n\texports.TangentSpaceNormalMap = TangentSpaceNormalMap;\n\texports.TetrahedronBufferGeometry = TetrahedronGeometry;\n\texports.TetrahedronGeometry = TetrahedronGeometry;\n\texports.TextBufferGeometry = TextGeometry;\n\texports.TextGeometry = TextGeometry;\n\texports.Texture = Texture;\n\texports.TextureLoader = TextureLoader;\n\texports.TorusBufferGeometry = TorusGeometry;\n\texports.TorusGeometry = TorusGeometry;\n\texports.TorusKnotBufferGeometry = TorusKnotGeometry;\n\texports.TorusKnotGeometry = TorusKnotGeometry;\n\texports.Triangle = Triangle;\n\texports.TriangleFanDrawMode = TriangleFanDrawMode;\n\texports.TriangleStripDrawMode = TriangleStripDrawMode;\n\texports.TrianglesDrawMode = TrianglesDrawMode;\n\texports.TubeBufferGeometry = TubeGeometry;\n\texports.TubeGeometry = TubeGeometry;\n\texports.UVMapping = UVMapping;\n\texports.Uint16Attribute = Uint16Attribute;\n\texports.Uint16BufferAttribute = Uint16BufferAttribute;\n\texports.Uint32Attribute = Uint32Attribute;\n\texports.Uint32BufferAttribute = Uint32BufferAttribute;\n\texports.Uint8Attribute = Uint8Attribute;\n\texports.Uint8BufferAttribute = Uint8BufferAttribute;\n\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\n\texports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;\n\texports.Uniform = Uniform;\n\texports.UniformsLib = UniformsLib;\n\texports.UniformsUtils = UniformsUtils;\n\texports.UnsignedByteType = UnsignedByteType;\n\texports.UnsignedInt248Type = UnsignedInt248Type;\n\texports.UnsignedIntType = UnsignedIntType;\n\texports.UnsignedShort4444Type = UnsignedShort4444Type;\n\texports.UnsignedShort5551Type = UnsignedShort5551Type;\n\texports.UnsignedShort565Type = UnsignedShort565Type;\n\texports.UnsignedShortType = UnsignedShortType;\n\texports.VSMShadowMap = VSMShadowMap;\n\texports.Vector2 = Vector2;\n\texports.Vector3 = Vector3;\n\texports.Vector4 = Vector4;\n\texports.VectorKeyframeTrack = VectorKeyframeTrack;\n\texports.Vertex = Vertex;\n\texports.VertexColors = VertexColors;\n\texports.VideoTexture = VideoTexture;\n\texports.WebGL1Renderer = WebGL1Renderer;\n\texports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;\n\texports.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;\n\texports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;\n\texports.WebGLRenderTarget = WebGLRenderTarget;\n\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\n\texports.WebGLRenderer = WebGLRenderer;\n\texports.WebGLUtils = WebGLUtils;\n\texports.WireframeGeometry = WireframeGeometry;\n\texports.WireframeHelper = WireframeHelper;\n\texports.WrapAroundEnding = WrapAroundEnding;\n\texports.XHRLoader = XHRLoader;\n\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\n\texports.ZeroFactor = ZeroFactor;\n\texports.ZeroSlopeEnding = ZeroSlopeEnding;\n\texports.ZeroStencilOp = ZeroStencilOp;\n\texports.sRGBEncoding = sRGBEncoding;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n",null,"module.exports = function( THREE ) {\n\t/**\n\t * @author qiao / https://github.com/qiao\n\t * @author mrdoob / http://mrdoob.com\n\t * @author alteredq / http://alteredqualia.com/\n\t * @author WestLangley / http://github.com/WestLangley\n\t * @author erich666 / http://erichaines.com\n\t */\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one finger move\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: three finter swipe\n\n\tfunction OrbitControls( object, domElement ) {\n\n\t\tthis.object = object;\n\n\t\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t\t// Set to false to disable this control\n\t\tthis.enabled = true;\n\n\t\t// \"target\" sets the location of focus, where the object orbits around\n\t\tthis.target = new THREE.Vector3();\n\n\t\t// How far you can dolly in and out ( PerspectiveCamera only )\n\t\tthis.minDistance = 0;\n\t\tthis.maxDistance = Infinity;\n\n\t\t// How far you can zoom in and out ( OrthographicCamera only )\n\t\tthis.minZoom = 0;\n\t\tthis.maxZoom = Infinity;\n\n\t\t// How far you can orbit vertically, upper and lower limits.\n\t\t// Range is 0 to Math.PI radians.\n\t\tthis.minPolarAngle = 0; // radians\n\t\tthis.maxPolarAngle = Math.PI; // radians\n\n\t\t// How far you can orbit horizontally, upper and lower limits.\n\t\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\t\tthis.minAzimuthAngle = - Infinity; // radians\n\t\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t\t// Set to true to enable damping (inertia)\n\t\t// If damping is enabled, you must call controls.update() in your animation loop\n\t\tthis.enableDamping = false;\n\t\tthis.dampingFactor = 0.25;\n\n\t\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t\t// Set to false to disable zooming\n\t\tthis.enableZoom = true;\n\t\tthis.zoomSpeed = 1.0;\n\n\t\t// Set to false to disable rotating\n\t\tthis.enableRotate = true;\n\t\tthis.rotateSpeed = 1.0;\n\n\t\t// Set to false to disable panning\n\t\tthis.enablePan = true;\n\t\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t\t// Set to true to automatically rotate around the target\n\t\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\t\tthis.autoRotate = false;\n\t\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t\t// Set to false to disable use of the keys\n\t\tthis.enableKeys = true;\n\n\t\t// The four arrow keys\n\t\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t\t// Mouse buttons\n\t\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\n\t\t// for reset\n\t\tthis.target0 = this.target.clone();\n\t\tthis.position0 = this.object.position.clone();\n\t\tthis.zoom0 = this.object.zoom;\n\n\t\t//\n\t\t// public methods\n\t\t//\n\n\t\tthis.getPolarAngle = function () {\n\n\t\t\treturn spherical.phi;\n\n\t\t};\n\n\t\tthis.getAzimuthalAngle = function () {\n\n\t\t\treturn spherical.theta;\n\n\t\t};\n\n\t\tthis.reset = function () {\n\n\t\t\tscope.target.copy( scope.target0 );\n\t\t\tscope.object.position.copy( scope.position0 );\n\t\t\tscope.object.zoom = scope.zoom0;\n\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tscope.dispatchEvent( changeEvent );\n\n\t\t\tscope.update();\n\n\t\t\tstate = STATE.NONE;\n\n\t\t};\n\n\t\t// this method is exposed, but perhaps it would be better if we can make it private...\n\t\tthis.update = function() {\n\n\t\t\tvar offset = new THREE.Vector3();\n\n\t\t\t// so camera.up is the orbit axis\n\t\t\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\n\t\t\tvar quatInverse = quat.clone().inverse();\n\n\t\t\tvar lastPosition = new THREE.Vector3();\n\t\t\tvar lastQuaternion = new THREE.Quaternion();\n\n\t\t\treturn function update () {\n\n\t\t\t\tvar position = scope.object.position;\n\n\t\t\t\toffset.copy( position ).sub( scope.target );\n\n\t\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\t\toffset.applyQuaternion( quat );\n\n\t\t\t\t// angle from z-axis around y-axis\n\t\t\t\tspherical.setFromVector3( offset );\n\n\t\t\t\tif ( scope.autoRotate && state === STATE.NONE ) {\n\n\t\t\t\t\trotateLeft( getAutoRotationAngle() );\n\n\t\t\t\t}\n\n\t\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t\t// restrict theta to be between desired limits\n\t\t\t\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\n\n\t\t\t\t// restrict phi to be between desired limits\n\t\t\t\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\n\n\t\t\t\tspherical.makeSafe();\n\n\n\t\t\t\tspherical.radius *= scale;\n\n\t\t\t\t// restrict radius to be between desired limits\n\t\t\t\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\n\n\t\t\t\t// move target to panned location\n\t\t\t\tscope.target.add( panOffset );\n\n\t\t\t\toffset.setFromSpherical( spherical );\n\n\t\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\t\toffset.applyQuaternion( quatInverse );\n\n\t\t\t\tposition.copy( scope.target ).add( offset );\n\n\t\t\t\tscope.object.lookAt( scope.target );\n\n\t\t\t\tif ( scope.enableDamping === true ) {\n\n\t\t\t\t\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\n\t\t\t\t\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsphericalDelta.set( 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tscale = 1;\n\t\t\t\tpanOffset.set( 0, 0, 0 );\n\n\t\t\t\t// update condition is:\n\t\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\t\tif ( zoomChanged ||\n\t\t\t\t\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\n\t\t\t\t\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\n\n\t\t\t\t\tscope.dispatchEvent( changeEvent );\n\n\t\t\t\t\tlastPosition.copy( scope.object.position );\n\t\t\t\t\tlastQuaternion.copy( scope.object.quaternion );\n\t\t\t\t\tzoomChanged = false;\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t}();\n\n\t\tthis.dispose = function() {\n\n\t\t\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\n\t\t\tscope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\n\t\t\tscope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\n\n\t\t\tscope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\n\t\t\tscope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\n\t\t\tscope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\n\n\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\twindow.removeEventListener( 'keydown', onKeyDown, false );\n\n\t\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n\t\t};\n\n\t\t//\n\t\t// internals\n\t\t//\n\n\t\tvar scope = this;\n\n\t\tvar changeEvent = { type: 'change' };\n\t\tvar startEvent = { type: 'start' };\n\t\tvar endEvent = { type: 'end' };\n\n\t\tvar STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };\n\n\t\tvar state = STATE.NONE;\n\n\t\tvar EPS = 0.000001;\n\n\t\t// current position in spherical coordinates\n\t\tvar spherical = new THREE.Spherical();\n\t\tvar sphericalDelta = new THREE.Spherical();\n\n\t\tvar scale = 1;\n\t\tvar panOffset = new THREE.Vector3();\n\t\tvar zoomChanged = false;\n\n\t\tvar rotateStart = new THREE.Vector2();\n\t\tvar rotateEnd = new THREE.Vector2();\n\t\tvar rotateDelta = new THREE.Vector2();\n\n\t\tvar panStart = new THREE.Vector2();\n\t\tvar panEnd = new THREE.Vector2();\n\t\tvar panDelta = new THREE.Vector2();\n\n\t\tvar dollyStart = new THREE.Vector2();\n\t\tvar dollyEnd = new THREE.Vector2();\n\t\tvar dollyDelta = new THREE.Vector2();\n\n\t\tfunction getAutoRotationAngle() {\n\n\t\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t\t}\n\n\t\tfunction getZoomScale() {\n\n\t\t\treturn Math.pow( 0.95, scope.zoomSpeed );\n\n\t\t}\n\n\t\tfunction rotateLeft( angle ) {\n\n\t\t\tsphericalDelta.theta -= angle;\n\n\t\t}\n\n\t\tfunction rotateUp( angle ) {\n\n\t\t\tsphericalDelta.phi -= angle;\n\n\t\t}\n\n\t\tvar panLeft = function() {\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\treturn function panLeft( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\n\t\t\t\tv.multiplyScalar( - distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\tvar panUp = function() {\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\treturn function panUp( distance, objectMatrix ) {\n\n\t\t\t\tv.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\n\t\t\t\tv.multiplyScalar( distance );\n\n\t\t\t\tpanOffset.add( v );\n\n\t\t\t};\n\n\t\t}();\n\n\t\t// deltaX and deltaY are in pixels; right and down are positive\n\t\tvar pan = function() {\n\n\t\t\tvar offset = new THREE.Vector3();\n\n\t\t\treturn function pan ( deltaX, deltaY ) {\n\n\t\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\t\t// perspective\n\t\t\t\t\tvar position = scope.object.position;\n\t\t\t\t\toffset.copy( position ).sub( scope.target );\n\t\t\t\t\tvar targetDistance = offset.length();\n\n\t\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\t\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\n\n\t\t\t\t\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\n\t\t\t\t\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\n\t\t\t\t\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\t\t// orthographic\n\t\t\t\t\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\n\t\t\t\t\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\n\t\t\t\t\tscope.enablePan = false;\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}();\n\n\t\tfunction dollyIn( dollyScale ) {\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tscale /= dollyScale;\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction dollyOut( dollyScale ) {\n\n\t\t\tif ( scope.object instanceof THREE.PerspectiveCamera ) {\n\n\t\t\t\tscale *= dollyScale;\n\n\t\t\t} else if ( scope.object instanceof THREE.OrthographicCamera ) {\n\n\t\t\t\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\n\t\t\t\tscope.enableZoom = false;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\t\t// event callbacks - update the object state\n\t\t//\n\n\t\tfunction handleMouseDownRotate( event ) {\n\n\t\t\t//console.log( 'handleMouseDownRotate' );\n\n\t\t\trotateStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownDolly( event ) {\n\n\t\t\t//console.log( 'handleMouseDownDolly' );\n\n\t\t\tdollyStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseDownPan( event ) {\n\n\t\t\t//console.log( 'handleMouseDownPan' );\n\n\t\t\tpanStart.set( event.clientX, event.clientY );\n\n\t\t}\n\n\t\tfunction handleMouseMoveRotate( event ) {\n\n\t\t\t//console.log( 'handleMouseMoveRotate' );\n\n\t\t\trotateEnd.set( event.clientX, event.clientY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMoveDolly( event ) {\n\n\t\t\t//console.log( 'handleMouseMoveDolly' );\n\n\t\t\tdollyEnd.set( event.clientX, event.clientY );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseMovePan( event ) {\n\n\t\t\t//console.log( 'handleMouseMovePan' );\n\n\t\t\tpanEnd.set( event.clientX, event.clientY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleMouseUp( event ) {\n\n\t\t\t//console.log( 'handleMouseUp' );\n\n\t\t}\n\n\t\tfunction handleMouseWheel( event ) {\n\n\t\t\t//console.log( 'handleMouseWheel' );\n\n\t\t\tif ( event.deltaY < 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t} else if ( event.deltaY > 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleKeyDown( event ) {\n\n\t\t\t//console.log( 'handleKeyDown' );\n\n\t\t\tswitch ( event.keyCode ) {\n\n\t\t\t\tcase scope.keys.UP:\n\t\t\t\t\tpan( 0, scope.keyPanSpeed );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\t\tpan( 0, - scope.keyPanSpeed );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.LEFT:\n\t\t\t\t\tpan( scope.keyPanSpeed, 0 );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.keys.RIGHT:\n\t\t\t\t\tpan( - scope.keyPanSpeed, 0 );\n\t\t\t\t\tscope.update();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction handleTouchStartRotate( event ) {\n\n\t\t\t//console.log( 'handleTouchStartRotate' );\n\n\t\t\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t}\n\n\t\tfunction handleTouchStartDolly( event ) {\n\n\t\t\t//console.log( 'handleTouchStartDolly' );\n\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyStart.set( 0, distance );\n\n\t\t}\n\n\t\tfunction handleTouchStartPan( event ) {\n\n\t\t\t//console.log( 'handleTouchStartPan' );\n\n\t\t\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t}\n\n\t\tfunction handleTouchMoveRotate( event ) {\n\n\t\t\t//console.log( 'handleTouchMoveRotate' );\n\n\t\t\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\t\t\trotateDelta.subVectors( rotateEnd, rotateStart );\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\t// rotating across whole screen goes 360 degrees around\n\t\t\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\n\n\t\t\t// rotating up and down along whole screen attempts to go 360, but limited to 180\n\t\t\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\n\n\t\t\trotateStart.copy( rotateEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleTouchMoveDolly( event ) {\n\n\t\t\t//console.log( 'handleTouchMoveDolly' );\n\n\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\n\t\t\tvar distance = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\tdollyEnd.set( 0, distance );\n\n\t\t\tdollyDelta.subVectors( dollyEnd, dollyStart );\n\n\t\t\tif ( dollyDelta.y > 0 ) {\n\n\t\t\t\tdollyOut( getZoomScale() );\n\n\t\t\t} else if ( dollyDelta.y < 0 ) {\n\n\t\t\t\tdollyIn( getZoomScale() );\n\n\t\t\t}\n\n\t\t\tdollyStart.copy( dollyEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleTouchMovePan( event ) {\n\n\t\t\t//console.log( 'handleTouchMovePan' );\n\n\t\t\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\n\n\t\t\tpanDelta.subVectors( panEnd, panStart );\n\n\t\t\tpan( panDelta.x, panDelta.y );\n\n\t\t\tpanStart.copy( panEnd );\n\n\t\t\tscope.update();\n\n\t\t}\n\n\t\tfunction handleTouchEnd( event ) {\n\n\t\t\t//console.log( 'handleTouchEnd' );\n\n\t\t}\n\n\t\t//\n\t\t// event handlers - FSM: listen for events and reset state\n\t\t//\n\n\t\tfunction onMouseDown( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tif ( event.button === scope.mouseButtons.ORBIT ) {\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\thandleMouseDownRotate( event );\n\n\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t} else if ( event.button === scope.mouseButtons.ZOOM ) {\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\thandleMouseDownDolly( event );\n\n\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t} else if ( event.button === scope.mouseButtons.PAN ) {\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\thandleMouseDownPan( event );\n\n\t\t\t\tstate = STATE.PAN;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\n\t\t\t\tdocument.addEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\t\tscope.dispatchEvent( startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\n\t\t\tif ( state === STATE.ROTATE ) {\n\n\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\thandleMouseMoveRotate( event );\n\n\t\t\t} else if ( state === STATE.DOLLY ) {\n\n\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\thandleMouseMoveDolly( event );\n\n\t\t\t} else if ( state === STATE.PAN ) {\n\n\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\thandleMouseMovePan( event );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onMouseUp( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\thandleMouseUp( event );\n\n\t\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\t\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\n\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onMouseWheel( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\thandleMouseWheel( event );\n\n\t\t\tscope.dispatchEvent( startEvent ); // not sure why these are here...\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t}\n\n\t\tfunction onKeyDown( event ) {\n\n\t\t\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\n\n\t\t\thandleKeyDown( event );\n\n\t\t}\n\n\t\tfunction onTouchStart( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tswitch ( event.touches.length ) {\n\n\t\t\t\tcase 1:\t// one-fingered touch: rotate\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\n\t\t\t\t\thandleTouchStartRotate( event );\n\n\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\t// two-fingered touch: dolly\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\n\t\t\t\t\thandleTouchStartDolly( event );\n\n\t\t\t\t\tstate = STATE.TOUCH_DOLLY;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\n\t\t\t\t\thandleTouchStartPan( event );\n\n\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t\tif ( state !== STATE.NONE ) {\n\n\t\t\t\tscope.dispatchEvent( startEvent );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchMove( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tswitch ( event.touches.length ) {\n\n\t\t\t\tcase 1: // one-fingered touch: rotate\n\n\t\t\t\t\tif ( scope.enableRotate === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\n\n\t\t\t\t\thandleTouchMoveRotate( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2: // two-fingered touch: dolly\n\n\t\t\t\t\tif ( scope.enableZoom === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\n\n\t\t\t\t\thandleTouchMoveDolly( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3: // three-fingered touch: pan\n\n\t\t\t\t\tif ( scope.enablePan === false ) return;\n\t\t\t\t\tif ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\n\n\t\t\t\t\thandleTouchMovePan( event );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onTouchEnd( event ) {\n\n\t\t\tif ( scope.enabled === false ) return;\n\n\t\t\thandleTouchEnd( event );\n\n\t\t\tscope.dispatchEvent( endEvent );\n\n\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tfunction onContextMenu( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t}\n\n\t\t//\n\n\t\tscope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\n\n\t\tscope.domElement.addEventListener( 'mousedown', onMouseDown, false );\n\t\tscope.domElement.addEventListener( 'wheel', onMouseWheel, false );\n\n\t\tscope.domElement.addEventListener( 'touchstart', onTouchStart, false );\n\t\tscope.domElement.addEventListener( 'touchend', onTouchEnd, false );\n\t\tscope.domElement.addEventListener( 'touchmove', onTouchMove, false );\n\n\t\twindow.addEventListener( 'keydown', onKeyDown, false );\n\n\t\t// force an update at start\n\n\t\tthis.update();\n\n\t};\n\n\tOrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n\tOrbitControls.prototype.constructor = OrbitControls;\n\n\tObject.defineProperties( OrbitControls.prototype, {\n\n\t\tcenter: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .center has been renamed to .target' );\n\t\t\t\treturn this.target;\n\n\t\t\t}\n\n\t\t},\n\n\t\t// backward compatibility\n\n\t\tnoZoom: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\treturn ! this.enableZoom;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\n\t\t\t\tthis.enableZoom = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoRotate: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\treturn ! this.enableRotate;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\n\t\t\t\tthis.enableRotate = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoPan: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\treturn ! this.enablePan;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\n\t\t\t\tthis.enablePan = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tnoKeys: {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\treturn ! this.enableKeys;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\n\t\t\t\tthis.enableKeys = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tstaticMoving : {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\treturn ! this.enableDamping;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\n\t\t\t\tthis.enableDamping = ! value;\n\n\t\t\t}\n\n\t\t},\n\n\t\tdynamicDampingFactor : {\n\n\t\t\tget: function () {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\treturn this.dampingFactor;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tconsole.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\n\t\t\t\tthis.dampingFactor = value;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn OrbitControls;\n};\n","\"use strict\";\n\nexports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {\n    default: a\n  };\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {\n    value: true\n  });\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    } // Skip duplicate re-exports when they have the same value.\n\n\n    if (key in dest && dest[key] === source[key]) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      }\n    });\n  });\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get\n  });\n};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"v1\", {\n  enumerable: true,\n  get: function () {\n    return _v.default;\n  }\n});\nObject.defineProperty(exports, \"v3\", {\n  enumerable: true,\n  get: function () {\n    return _v2.default;\n  }\n});\nObject.defineProperty(exports, \"v4\", {\n  enumerable: true,\n  get: function () {\n    return _v3.default;\n  }\n});\nObject.defineProperty(exports, \"v5\", {\n  enumerable: true,\n  get: function () {\n    return _v4.default;\n  }\n});\nObject.defineProperty(exports, \"NIL\", {\n  enumerable: true,\n  get: function () {\n    return _nil.default;\n  }\n});\nObject.defineProperty(exports, \"version\", {\n  enumerable: true,\n  get: function () {\n    return _version.default;\n  }\n});\nObject.defineProperty(exports, \"validate\", {\n  enumerable: true,\n  get: function () {\n    return _validate.default;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return _stringify.default;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function () {\n    return _parse.default;\n  }\n});\n\nvar _v = _interopRequireDefault(require(\"./v1.js\"));\n\nvar _v2 = _interopRequireDefault(require(\"./v3.js\"));\n\nvar _v3 = _interopRequireDefault(require(\"./v4.js\"));\n\nvar _v4 = _interopRequireDefault(require(\"./v5.js\"));\n\nvar _nil = _interopRequireDefault(require(\"./nil.js\"));\n\nvar _version = _interopRequireDefault(require(\"./version.js\"));\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng.default)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0, _stringify.default)(b);\n}\n\nvar _default = v1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rng;\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\n\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nvar _default = stringify;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regex = _interopRequireDefault(require(\"./regex.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex.default.test(uuid);\n}\n\nvar _default = validate;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _md = _interopRequireDefault(require(\"./md5.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v3 = (0, _v.default)('v3', 0x30, _md.default);\nvar _default = v3;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nexports.URL = exports.DNS = void 0;\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexports.DNS = DNS;\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexports.URL = URL;\n\nfunction _default(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0, _parse.default)(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0, _stringify.default)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parse(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nvar _default = parse;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  const output = [];\n  const length32 = input.length * 32;\n  const hexTab = '0123456789abcdef';\n\n  for (let i = 0; i < length32; i += 8) {\n    const x = input[i >> 5] >>> i % 32 & 0xff;\n    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  let a = 1732584193;\n  let b = -271733879;\n  let c = -1732584194;\n  let d = 271733878;\n\n  for (let i = 0; i < x.length; i += 16) {\n    const olda = a;\n    const oldb = b;\n    const oldc = c;\n    const oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  const length8 = input.length * 8;\n  const output = new Uint32Array(getOutputLength(length8));\n\n  for (let i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  const lsw = (x & 0xffff) + (y & 0xffff);\n  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nvar _default = md5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n\n  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0, _stringify.default)(rnds);\n}\n\nvar _default = v4;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _sha = _interopRequireDefault(require(\"./sha1.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v5 = (0, _v.default)('v5', 0x50, _sha.default);\nvar _default = v5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  const l = bytes.length / 4 + 2;\n  const N = Math.ceil(l / 16);\n  const M = new Array(N);\n\n  for (let i = 0; i < N; ++i) {\n    const arr = new Uint32Array(16);\n\n    for (let j = 0; j < 16; ++j) {\n      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n    }\n\n    M[i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (let i = 0; i < N; ++i) {\n    const W = new Uint32Array(80);\n\n    for (let t = 0; t < 16; ++t) {\n      W[t] = M[i][t];\n    }\n\n    for (let t = 16; t < 80; ++t) {\n      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n    }\n\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n    let e = H[4];\n\n    for (let t = 0; t < 80; ++t) {\n      const s = Math.floor(t / 20);\n      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nvar _default = sha1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = '00000000-0000-0000-0000-000000000000';\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction version(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\nvar _default = version;\nexports.default = _default;"],"names":["HMR_HOST","HMR_PORT","HMR_SECURE","HMR_ENV_HASH","module","bundle","HMR_BUNDLE_ID","OVERLAY_ID","OldModule","Module","moduleName","call","hot","data","hotData","_acceptCallbacks","_disposeCallbacks","accept","fn","push","dispose","undefined","checkedAssets","acceptedAssets","assetsToAccept","location","protocol","indexOf","hostname","port","parent","isParcelRequire","WebSocket","getHostname","getPort","test","ws","onmessage","event","JSON","parse","type","removeErrorOverlay","assets","filter","asset","envHash","handled","forEach","didAccept","hmrAcceptCheck","root","id","depsByBundle","console","clear","hmrApply","i","length","hmrAcceptRun","window","reload","ansiDiagnostic","diagnostics","ansi","stack","codeframe","error","message","hints","join","overlay","createErrorOverlay","html","document","body","appendChild","onerror","e","onclose","warn","getElementById","remove","log","createElement","errorHTML","diagnostic","map","hint","innerHTML","modules","parents","k","d","dep","Array","isArray","concat","getParents","link","newLink","cloneNode","onload","parentNode","removeChild","setAttribute","getAttribute","split","Date","now","insertBefore","nextSibling","cssTimeout","setTimeout","links","querySelectorAll","href","servedFromHMRServer","RegExp","absolute","origin","updateLink","reloadCSS","deps","Function","output","cached","cache","some","v","cb","assetsToAlsoAccept","apply","constructor","inGroup","Start","Update","time","BuildMesh","geometry","THREE","CylinderGeometry","rotateX","Math","degToRad","material","MeshNormalMaterial","mesh","Mesh","Agent","addEventListener","className","scene","options","name","Entity","Error","_id","_scene","Add","entities","Scene","cameraController","SetupScene","renderer","setAnimationLoop","ambientLight","AmbientLight","intensity","add","fog","Fog","entity","group","global","factory","exports","define","amd","globalThis","self","REVISION","MOUSE","LEFT","MIDDLE","RIGHT","ROTATE","DOLLY","PAN","TOUCH","DOLLY_PAN","DOLLY_ROTATE","CullFaceNone","CullFaceBack","CullFaceFront","CullFaceFrontBack","BasicShadowMap","PCFShadowMap","PCFSoftShadowMap","VSMShadowMap","FrontSide","BackSide","DoubleSide","FlatShading","SmoothShading","NoBlending","NormalBlending","AdditiveBlending","SubtractiveBlending","MultiplyBlending","CustomBlending","AddEquation","SubtractEquation","ReverseSubtractEquation","MinEquation","MaxEquation","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","OneMinusDstAlphaFactor","DstColorFactor","OneMinusDstColorFactor","SrcAlphaSaturateFactor","NeverDepth","AlwaysDepth","LessDepth","LessEqualDepth","EqualDepth","GreaterEqualDepth","GreaterDepth","NotEqualDepth","MultiplyOperation","MixOperation","AddOperation","NoToneMapping","LinearToneMapping","ReinhardToneMapping","CineonToneMapping","ACESFilmicToneMapping","CustomToneMapping","UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","RepeatWrapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipmapNearestFilter","NearestMipMapNearestFilter","NearestMipmapLinearFilter","NearestMipMapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipMapNearestFilter","LinearMipmapLinearFilter","LinearMipMapLinearFilter","UnsignedByteType","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","FloatType","HalfFloatType","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedShort565Type","UnsignedInt248Type","AlphaFormat","RGBFormat","RGBAFormat","LuminanceFormat","LuminanceAlphaFormat","RGBEFormat","DepthFormat","DepthStencilFormat","RedFormat","RedIntegerFormat","RGFormat","RGIntegerFormat","RGBIntegerFormat","RGBAIntegerFormat","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","RGB_ETC1_Format","RGB_ETC2_Format","RGBA_ETC2_EAC_Format","RGBA_ASTC_4x4_Format","RGBA_ASTC_5x4_Format","RGBA_ASTC_5x5_Format","RGBA_ASTC_6x5_Format","RGBA_ASTC_6x6_Format","RGBA_ASTC_8x5_Format","RGBA_ASTC_8x6_Format","RGBA_ASTC_8x8_Format","RGBA_ASTC_10x5_Format","RGBA_ASTC_10x6_Format","RGBA_ASTC_10x8_Format","RGBA_ASTC_10x10_Format","RGBA_ASTC_12x10_Format","RGBA_ASTC_12x12_Format","RGBA_BPTC_Format","SRGB8_ALPHA8_ASTC_4x4_Format","SRGB8_ALPHA8_ASTC_5x4_Format","SRGB8_ALPHA8_ASTC_5x5_Format","SRGB8_ALPHA8_ASTC_6x5_Format","SRGB8_ALPHA8_ASTC_6x6_Format","SRGB8_ALPHA8_ASTC_8x5_Format","SRGB8_ALPHA8_ASTC_8x6_Format","SRGB8_ALPHA8_ASTC_8x8_Format","SRGB8_ALPHA8_ASTC_10x5_Format","SRGB8_ALPHA8_ASTC_10x6_Format","SRGB8_ALPHA8_ASTC_10x8_Format","SRGB8_ALPHA8_ASTC_10x10_Format","SRGB8_ALPHA8_ASTC_12x10_Format","SRGB8_ALPHA8_ASTC_12x12_Format","LoopOnce","LoopRepeat","LoopPingPong","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","ZeroCurvatureEnding","ZeroSlopeEnding","WrapAroundEnding","NormalAnimationBlendMode","AdditiveAnimationBlendMode","TrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","LinearEncoding","sRGBEncoding","GammaEncoding","RGBEEncoding","LogLuvEncoding","RGBM7Encoding","RGBM16Encoding","RGBDEncoding","BasicDepthPacking","RGBADepthPacking","TangentSpaceNormalMap","ObjectSpaceNormalMap","ZeroStencilOp","KeepStencilOp","ReplaceStencilOp","IncrementStencilOp","DecrementStencilOp","IncrementWrapStencilOp","DecrementWrapStencilOp","InvertStencilOp","NeverStencilFunc","LessStencilFunc","EqualStencilFunc","LessEqualStencilFunc","GreaterStencilFunc","NotEqualStencilFunc","GreaterEqualStencilFunc","AlwaysStencilFunc","StaticDrawUsage","DynamicDrawUsage","StreamDrawUsage","StaticReadUsage","DynamicReadUsage","StreamReadUsage","StaticCopyUsage","DynamicCopyUsage","StreamCopyUsage","GLSL1","GLSL3","listener","_listeners","listeners","hasEventListener","removeEventListener","listenerArray","index","splice","dispatchEvent","target","array","slice","l","_lut","toString","_seed","DEG2RAD","PI","RAD2DEG","d0","random","d1","d2","d3","uuid","toUpperCase","value","min","max","n","m","x","a1","a2","b1","b2","y","t","lambda","dt","lerp","exp","abs","euclideanModulo","low","high","floor","range","s","degrees","radians","pow","ceil","LN2","q","a","b","c","order","cos","sin","c2","s2","c13","s13","c1_3","s1_3","c3_1","s3_1","set","MathUtils","Object","freeze","__proto__","generateUUID","clamp","mapLinear","inverseLerp","damp","pingpong","smoothstep","smootherstep","randInt","randFloat","randFloatSpread","seededRandom","radToDeg","isPowerOfTwo","ceilPowerOfTwo","floorPowerOfTwo","setQuaternionFromProperEuler","width","height","setScalar","scalar","setX","setY","setComponent","getComponent","clone","copy","w","addVectors","addScalar","addScaledVector","sub","subVectors","subScalar","multiply","multiplyScalar","divide","divideScalar","applyMatrix3","elements","clampScalar","minVal","maxVal","clampLength","round","roundToZero","negate","dot","cross","lengthSq","sqrt","manhattanLength","normalize","angle","atan2","distanceTo","distanceToSquared","dx","dy","manhattanDistanceTo","setLength","alpha","lerpVectors","v1","v2","equals","fromArray","offset","toArray","fromBufferAttribute","attribute","getX","getY","rotateAround","center","Vector2","prototype","isVector2","arguments","n11","n12","n13","n21","n22","n23","n31","n32","n33","te","identity","me","extractBasis","xAxis","yAxis","zAxis","setFromMatrix3Column","setFromMatrix4","multiplyMatrices","premultiply","ae","be","a11","a12","a13","a21","a22","a23","a31","a32","a33","b11","b12","b13","b21","b22","b23","b31","b32","b33","determinant","f","g","h","invert","t11","t12","t13","det","detInv","transpose","tmp","getNormalMatrix","matrix4","transposeIntoArray","r","setUvTransform","tx","ty","sx","sy","rotation","cx","cy","scale","rotate","theta","translate","matrix","Matrix3","isMatrix3","_canvas","getDataURL","image","src","HTMLCanvasElement","canvas","createElementNS","context","getContext","ImageData","putImageData","drawImage","toDataURL","textureId","EventDispatcher","Texture","DEFAULT_IMAGE","mapping","DEFAULT_MAPPING","wrapS","wrapT","magFilter","minFilter","format","anisotropy","encoding","defineProperty","mipmaps","internalFormat","repeat","matrixAutoUpdate","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","version","onUpdate","updateMatrix","source","toJSON","meta","isRootObject","textures","metadata","generator","wrap","images","url","isDataTexture","serializeImage","transformUv","uv","needsUpdate","isTexture","HTMLImageElement","ImageBitmap","ImageUtils","z","setZ","setW","applyMatrix4","setAxisAngleFromQuaternion","acos","setAxisAngleFromRotationMatrix","epsilon","epsilon2","m11","m12","m13","m21","m22","m23","m31","m32","m33","xx","yy","zz","xy","xz","yz","getZ","getW","Vector4","isVector4","depth","scissor","scissorTest","viewport","texture","depthBuffer","stencilBuffer","depthTexture","setTexture","setSize","WebGLRenderTarget","isWebGLRenderTarget","count","il","WebGLMultipleRenderTargets","isWebGLMultipleRenderTargets","samples","WebGLMultisampleRenderTarget","isWebGLMultisampleRenderTarget","_x","_y","_z","_w","slerp","qa","qb","qm","slerpQuaternions","slerpFlat","dst","dstOffset","src0","srcOffset0","src1","srcOffset1","x0","y0","z0","w0","x1","y1","z1","w1","dir","sqrSin","Number","EPSILON","len","tDir","multiplyQuaternionsFlat","_onChangeCallback","quaternion","setFromEuler","euler","update","isEuler","_order","c1","c3","s1","s3","setFromAxisAngle","axis","halfAngle","setFromRotationMatrix","trace","setFromUnitVectors","vFrom","vTo","angleTo","rotateTowards","step","conjugate","p","multiplyQuaternions","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","cosHalfTheta","sqrSinHalfTheta","sinHalfTheta","halfTheta","ratioA","ratioB","_onChange","callback","Quaternion","isQuaternion","multiplyVectors","applyEuler","applyQuaternion","_quaternion$4","applyAxisAngle","applyNormalMatrix","qx","qy","qz","qw","ix","iy","iz","iw","project","camera","matrixWorldInverse","projectionMatrix","unproject","projectionMatrixInverse","matrixWorld","transformDirection","crossVectors","ax","ay","az","bx","by","bz","projectOnVector","denominator","projectOnPlane","planeNormal","_vector$c","reflect","normal","dz","setFromSpherical","setFromSphericalCoords","radius","phi","sinPhiRadius","setFromCylindrical","setFromCylindricalCoords","setFromMatrixPosition","setFromMatrixScale","setFromMatrixColumn","sz","Vector3","isVector3","Infinity","setFromArray","minX","minY","minZ","maxX","maxY","maxZ","setFromBufferAttribute","setFromPoints","points","makeEmpty","expandByPoint","setFromCenterAndSize","size","halfSize","_vector$b","setFromObject","object","expandByObject","box","isEmpty","getCenter","getSize","point","expandByVector","vector","expandByScalar","updateWorldMatrix","boundingBox","computeBoundingBox","_box$3","union","children","containsPoint","containsBox","getParameter","intersectsBox","intersectsSphere","sphere","clampPoint","intersectsPlane","plane","constant","intersectsTriangle","triangle","_center","_extents","_v0$2","_v1$7","_v2$3","_f0","_f1","_f2","axes","satForAxes","_triangleNormal","distanceToPoint","clampedPoint","getBoundingSphere","intersect","_points","Box3","isBox3","_testAxis","v0","extents","j","p0","p1","p2","_box$2","_v1$6","_toFarthestPoint","_toPoint","optionalCenter","maxRadiusSq","radiusSum","deltaLengthSq","getBoundingBox","getMaxScaleOnAxis","missingRadiusHalf","_vector$a","_segCenter","_segDir","_diff","_edge1","_edge2","_normal$1","direction","ray","at","lookAt","recast","closestPointToPoint","directionDistance","distanceSqToPoint","distanceSqToSegment","optionalPointOnRay","optionalPointOnSegment","segExtent","a01","b0","s0","sqrDist","extDet","invDet","intersectSphere","tca","radius2","thc","t0","t1","distanceToPlane","intersectPlane","distToPoint","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","backfaceCulling","DdN","sign","DdQxE2","DdE1xQ","QdN","n14","n24","n34","n41","n42","n43","n44","Matrix4","copyPosition","setFromMatrix3","makeBasis","extractRotation","scaleX","_v1$5","scaleY","scaleZ","makeRotationFromEuler","af","bf","ce","cf","de","df","ac","ad","bc","bd","makeRotationFromQuaternion","compose","_zero","_one","eye","up","a14","a24","a34","a41","a42","a43","a44","b14","b24","b34","b41","b42","b43","b44","setPosition","t14","scaleXSq","scaleYSq","scaleZSq","makeTranslation","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","makeScale","makeShear","yx","zx","zy","position","x2","y2","z2","wx","wy","wz","decompose","_m1$2","invSX","invSY","invSZ","makePerspective","left","right","top","bottom","near","far","makeOrthographic","isMatrix4","_matrix$1","_quaternion$3","Euler","DefaultOrder","asin","setFromQuaternion","setFromVector3","reorder","newOrder","toVector3","optionalResult","RotationOrders","mask","channel","enable","enableAll","toggle","disable","disableAll","layers","_object3DId","_v1$4","_q1","_m1$1","_target","_position$3","_scale$2","_quaternion$2","_xAxis","_yAxis","_zAxis","_addedEvent","_removedEvent","Object3D","DefaultUp","onRotationChange","onQuaternionChange","defineProperties","configurable","enumerable","modelViewMatrix","normalMatrix","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","Layers","visible","castShadow","receiveShadow","frustumCulled","renderOrder","animations","userData","onBeforeRender","onAfterRender","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","rotateOnWorldAxis","rotateY","rotateZ","translateOnAxis","distance","translateX","translateY","translateZ","localToWorld","worldToLocal","isCamera","isLight","isObject3D","removeFromParent","attach","getObjectById","getObjectByProperty","getObjectByName","child","getWorldPosition","getWorldQuaternion","getWorldScale","getWorldDirection","raycast","traverse","traverseVisible","traverseAncestors","updateMatrixWorld","force","updateParents","updateChildren","geometries","materials","shapes","skeletons","stringify","isInstancedMesh","instanceMatrix","instanceColor","library","element","isMesh","isLine","isPoints","serialize","parameters","shape","isSkinnedMesh","bindMode","bindMatrix","skeleton","uuids","animation","extractFromCache","values","key","recursive","_vector1","_vector2$1","_normalMatrix","setComponents","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","intersectLine","line","delta","start","intersectsLine","startSign","endSign","end","coplanarPoint","optionalNormalMatrix","referencePoint","Plane","isPlane","_v0$1","_v1$3","_v2$2","_v3$1","_vab","_vac","_vbc","_vap","_vbp","_vcp","getNormal","targetLengthSq","getBarycoord","dot00","dot01","dot02","dot11","dot12","denom","invDenom","u","getUV","p3","uv1","uv2","uv3","isFrontFacing","setFromPointsAndIndices","i0","i1","i2","getArea","getMidpoint","Triangle","getPlane","d4","vc","d5","d6","vb","va","materialId","blending","side","vertexColors","opacity","transparent","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","depthFunc","depthTest","depthWrite","stencilWriteMask","stencilFunc","stencilRef","stencilFuncMask","stencilFail","stencilZFail","stencilZPass","stencilWrite","clippingPlanes","clipIntersection","clipShadows","shadowSide","colorWrite","precision","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","dithering","alphaTest","alphaToCoverage","premultipliedAlpha","toneMapped","onBuild","onBeforeCompile","customProgramCacheKey","setValues","newValue","flatShading","currentValue","isColor","isRoot","color","getHex","roughness","metalness","sheen","emissive","emissiveIntensity","specular","shininess","clearcoat","clearcoatRoughness","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","clearcoatNormalScale","matcap","alphaMap","lightMap","lightMapIntensity","aoMap","aoMapIntensity","bumpMap","bumpScale","normalMap","normalMapType","normalScale","displacementMap","displacementScale","displacementBias","roughnessMap","metalnessMap","emissiveMap","specularMap","envMap","combine","envMapIntensity","reflectivity","refractionRatio","gradientMap","transmission","transmissionMap","thickness","thicknessMap","attenuationDistance","attenuationColor","sizeAttenuation","linewidth","dashSize","gapSize","wireframe","wireframeLinewidth","wireframeLinecap","wireframeLinejoin","morphTargets","morphNormals","srcPlanes","dstPlanes","Material","isMaterial","_colorKeywords","_hslA","_hslB","setRGB","setHex","setStyle","hex","setHSL","hue2rgb","style","string","parseFloat","exec","components","parseInt","handleAlpha","charAt","setColorName","toLowerCase","copyGammaToLinear","gammaFactor","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","copySRGBToLinear","SRGBToLinear","copyLinearToSRGB","LinearToSRGB","convertSRGBToLinear","convertLinearToSRGB","getHexString","getHSL","hue","saturation","lightness","getStyle","offsetHSL","addColors","color1","color2","lerpColors","lerpHSL","normalized","Color","NAMES","MeshBasicMaterial","isMeshBasicMaterial","_vector$9","_vector2","itemSize","TypeError","usage","updateRange","onUploadCallback","setUsage","copyAt","index1","index2","copyArray","copyColorsArray","colors","copyVector2sArray","vectors","copyVector3sArray","copyVector4sArray","setXY","setXYZ","setXYZW","onUpload","BufferAttribute","isBufferAttribute","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float16BufferAttribute","isFloat16BufferAttribute","Float32Array","Float64Array","TYPED_ARRAYS","buffer","_m1","_obj","_offset","_box$1","_boxMorphTargets","_vector$8","attributes","morphAttributes","morphTargetsRelative","groups","boundingSphere","drawRange","getIndex","setIndex","arrayMax","Uint32BufferAttribute","Uint16BufferAttribute","deleteAttribute","hasAttribute","addGroup","materialIndex","clearGroups","setDrawRange","tangent","computeBoundingSphere","Float32BufferAttribute","morphAttributesPosition","isGLBufferAttribute","morphAttribute","isNaN","Sphere","jl","computeFaceNormals","computeTangents","indices","positions","normals","uvs","nVertices","tangents","tan1","tan2","vA","vB","vC","uvA","uvB","uvC","sdir","tdir","isFinite","handleTriangle","tmp2","n2","handleVertex","computeVertexNormals","positionAttribute","normalAttribute","pA","pB","pC","nA","nB","nC","ab","normalizeNormals","merge","isBufferGeometry","attribute1","attributeArray1","attribute2","attributeArray2","attributeOffset","toNonIndexed","array2","geometry2","BufferGeometry","newAttribute","convertBufferAttribute","morphArray","keys","hasMorphAttributes","attributeArray","_inverseMatrix$2","_ray$2","Ray","_sphere$3","_vA$1","_vB$1","_vC$1","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_uvA$1","_uvB$1","_uvC$1","_intersectionPoint","_intersectionPointWorld","updateMorphTargets","morphTargetInfluences","morphTargetDictionary","assign","ml","String","raycaster","intersects","intersection","morphPosition","groupMaterial","checkBufferGeometryIntersection","faceIndex","face","isGeometry","morphInfluences","influence","boneTransform","checkIntersection","widthSegments","heightSegments","depthSegments","scope","vertices","numberOfVertices","groupStart","buildPlane","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","groupCount","property","uniforms","merged","cloneUniforms","UniformsUtils","mergeUniforms","default_vertex","default_fragment","defines","vertexShader","fragmentShader","lights","clipping","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","index0AttributeName","uniformsNeedUpdate","glslVersion","uniform","ShaderMaterial","isShaderMaterial","Camera","fov","aspect","zoom","focus","view","filmGauge","filmOffset","updateProjectionMatrix","setFocalLength","focalLength","vExtentSlope","getFilmHeight","atan","getFocalLength","tan","getEffectiveFOV","getFilmWidth","setViewOffset","fullWidth","fullHeight","enabled","offsetX","offsetY","clearViewOffset","skew","PerspectiveCamera","isPerspectiveCamera","renderTarget","isWebGLCubeRenderTarget","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","currentXrEnabled","xr","currentRenderTarget","getRenderTarget","setRenderTarget","render","_needsFlipEnvMap","CubeTexture","isCubeTexture","dummy","isInteger","fromEquirectangularTexture","shader","tEquirect","BoxGeometry","currentMinFilter","CubeCamera","stencil","WebGLCubeRenderTarget","_sphere$2","_vector$7","p4","p5","planes","frustum","setFromProjectionMatrix","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","intersectsObject","intersectsSprite","sprite","negRadius","isAnimating","animationLoop","requestId","frame","requestAnimationFrame","onAnimationFrame","stop","cancelAnimationFrame","setContext","gl","capabilities","isWebGL2","buffers","WeakMap","bufferType","createBuffer","bindBuffer","bufferData","FLOAT","HALF_FLOAT","UNSIGNED_SHORT","SHORT","UNSIGNED_INT","INT","BYTE","UNSIGNED_BYTE","bytesPerElement","BYTES_PER_ELEMENT","bufferSubData","subarray","isInterleavedBufferAttribute","get","deleteBuffer","delete","elementSize","updateBuffer","width_half","height_half","segment_width","segment_height","alphamap_fragment","alphamap_pars_fragment","alphatest_fragment","aomap_fragment","aomap_pars_fragment","begin_vertex","beginnormal_vertex","bsdfs","bumpmap_pars_fragment","clipping_planes_fragment","clipping_planes_pars_fragment","clipping_planes_pars_vertex","clipping_planes_vertex","color_fragment","color_pars_fragment","color_pars_vertex","color_vertex","common","cube_uv_reflection_fragment","defaultnormal_vertex","displacementmap_pars_vertex","displacementmap_vertex","emissivemap_fragment","emissivemap_pars_fragment","encodings_fragment","encodings_pars_fragment","envmap_fragment","envmap_common_pars_fragment","envmap_pars_fragment","envmap_pars_vertex","envmap_vertex","fog_vertex","fog_pars_vertex","fog_fragment","fog_pars_fragment","gradientmap_pars_fragment","lightmap_fragment","lightmap_pars_fragment","lights_lambert_vertex","lights_pars_begin","envmap_physical_pars_fragment","lights_toon_fragment","lights_toon_pars_fragment","lights_phong_fragment","lights_phong_pars_fragment","lights_physical_fragment","lights_physical_pars_fragment","lights_fragment_begin","lights_fragment_maps","lights_fragment_end","logdepthbuf_fragment","logdepthbuf_pars_fragment","logdepthbuf_pars_vertex","logdepthbuf_vertex","map_fragment","map_pars_fragment","map_particle_fragment","map_particle_pars_fragment","metalnessmap_fragment","metalnessmap_pars_fragment","morphnormal_vertex","morphtarget_pars_vertex","morphtarget_vertex","normal_fragment_begin","normal_fragment_maps","normalmap_pars_fragment","clearcoat_normal_fragment_begin","clearcoat_normal_fragment_maps","clearcoat_pars_fragment","packing","premultiplied_alpha_fragment","project_vertex","dithering_fragment","dithering_pars_fragment","roughnessmap_fragment","roughnessmap_pars_fragment","shadowmap_pars_fragment","shadowmap_pars_vertex","shadowmap_vertex","shadowmask_pars_fragment","skinbase_vertex","skinning_pars_vertex","skinning_vertex","skinnormal_vertex","specularmap_fragment","specularmap_pars_fragment","tonemapping_fragment","tonemapping_pars_fragment","transmission_fragment","transmission_pars_fragment","uv_pars_fragment","uv_pars_vertex","uv_vertex","uv2_pars_fragment","uv2_pars_vertex","uv2_vertex","worldpos_vertex","background_frag","background_vert","cube_frag","cube_vert","depth_frag","depth_vert","distanceRGBA_frag","distanceRGBA_vert","equirect_frag","equirect_vert","linedashed_frag","linedashed_vert","meshbasic_frag","meshbasic_vert","meshlambert_frag","meshlambert_vert","meshmatcap_frag","meshmatcap_vert","meshtoon_frag","meshtoon_vert","meshphong_frag","meshphong_vert","meshphysical_frag","meshphysical_vert","normal_frag","normal_vert","points_frag","points_vert","shadow_frag","shadow_vert","sprite_frag","sprite_vert","ShaderChunk","UniformsLib","diffuse","uvTransform","uv2Transform","specularmap","envmap","flipEnvMap","maxMipLevel","aomap","lightmap","emissivemap","bumpmap","normalmap","displacementmap","roughnessmap","metalnessmap","gradientmap","fogDensity","fogNear","fogFar","fogColor","ambientLightColor","lightProbe","directionalLights","properties","directionalLightShadows","shadowBias","shadowNormalBias","shadowRadius","shadowMapSize","directionalShadowMap","directionalShadowMatrix","spotLights","coneCos","penumbraCos","decay","spotLightShadows","spotShadowMap","spotShadowMatrix","pointLights","pointLightShadows","shadowCameraNear","shadowCameraFar","pointShadowMap","pointShadowMatrix","hemisphereLights","skyColor","groundColor","rectAreaLights","ltc_1","ltc_2","ShaderLib","basic","lambert","phong","standard","toon","dashed","totalSize","background","t2D","cube","equirect","distanceRGBA","referencePosition","nearDistance","farDistance","shadow","physical","transmissionSamplerSize","transmissionSamplerMap","cubemaps","state","objects","clearColor","clearAlpha","planeMesh","boxMesh","currentBackground","currentBackgroundVersion","currentTonemapping","renderList","forceClear","isScene","session","getSession","environmentBlendMode","setClear","autoClear","autoClearColor","autoClearDepth","autoClearStencil","toneMapping","unshift","PlaneGeometry","getClearColor","setClearColor","getClearAlpha","setClearAlpha","maxVertexAttributes","MAX_VERTEX_ATTRIBS","extension","vaoAvailable","bindingStates","defaultState","createBindingState","currentState","program","updateBuffers","getBindingState","bindVertexArrayObject","saveCache","ELEMENT_ARRAY_BUFFER","setupVertexAttributes","createVertexArray","createVertexArrayOES","vao","bindVertexArray","bindVertexArrayOES","deleteVertexArray","deleteVertexArrayOES","programMap","stateMap","createVertexArrayObject","newAttributes","enabledAttributes","attributeDivisors","cachedAttributes","geometryAttributes","attributesNum","cachedAttribute","geometryAttribute","enableAttributeAndDivisor","meshPerAttribute","enableVertexAttribArray","disableVertexAttribArray","stride","vertexAttribIPointer","vertexAttribPointer","isInstancedBufferGeometry","initAttributes","programAttributes","getAttributes","materialDefaultAttributeValues","programAttribute","isInstancedInterleavedBuffer","_maxInstanceCount","enableAttribute","ARRAY_BUFFER","isInstancedBufferAttribute","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","disableUnusedAttributes","reset","geometryId","programId","deleteVertexArrayObject","resetDefaultState","setup","releaseStatesOfGeometry","releaseStatesOfProgram","info","mode","drawArrays","primcount","methodName","setMode","renderInstances","maxAnisotropy","has","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getShaderPrecisionFormat","VERTEX_SHADER","HIGH_FLOAT","FRAGMENT_SHADER","MEDIUM_FLOAT","WebGL2RenderingContext","WebGL2ComputeRenderingContext","maxPrecision","getMaxPrecision","logarithmicDepthBuffer","maxTextures","MAX_TEXTURE_IMAGE_UNITS","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","maxTextureSize","MAX_TEXTURE_SIZE","maxCubemapSize","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","maxVertexUniforms","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","vertexTextures","floatFragmentTextures","floatVertexTextures","maxSamples","MAX_SAMPLES","getMaxAnisotropy","globalState","numGlobalPlanes","localClippingEnabled","renderingShadows","viewNormalMatrix","numPlanes","numIntersection","init","enableLocalClipping","projectPlanes","beginShadows","endShadows","resetGlobalState","setState","useCache","materialProperties","nGlobal","lGlobal","dstArray","clippingState","skipTransform","nPlanes","flatSize","viewMatrix","i4","cubemap","mapTextureMapping","onTextureDispose","getExtension","wireframeAttributes","onGeometryDispose","memory","geometryIndex","geometryPosition","previousAttribute","currentAttribute","updateWireframeAttribute","getWireframeAttribute","drawElements","calls","triangles","lines","instanceCount","TRIANGLES","LINES","LINE_STRIP","LINE_LOOP","POINTS","programs","autoReset","influencesList","workInfluences","objectInfluences","influences","sort","absNumericalSort","MAX_SAFE_INTEGER","numericalSort","morphInfluencesSum","morphBaseInfluence","getUniforms","setValue","updateMap","buffergeometry","onInstancedMeshDispose","instancedMesh","wrapR","DataTexture2DArray","isDataTexture2DArray","DataTexture3D","isDataTexture3D","emptyTexture","emptyTexture2dArray","emptyTexture3d","emptyCubeTexture","arrayCacheF32","arrayCacheI32","mat4array","mat3array","mat2array","nBlocks","blockSize","firstElem","allocateTextureUnit","uniform1f","addr","uniform2f","arraysEqual","uniform2fv","uniform3f","uniform3fv","uniform4f","uniform4fv","uniformMatrix2fv","uniformMatrix3fv","uniformMatrix4fv","uniform1i","uniform2iv","uniform3iv","uniform4iv","uniform1ui","uniform2uiv","uniform3uiv","uniform4uiv","unit","safeSetTexture2D","setTexture3D","safeSetTextureCube","setTexture2DArray","setValueV1f","setValueV2f","setValueV3f","setValueV4f","setValueM2","setValueM3","setValueM4","setValueV1i","setValueV2i","setValueV3i","setValueV4i","setValueV1ui","setValueV2ui","setValueV3ui","setValueV4ui","setValueT1","setValueT3D1","setValueT6","setValueT2DArray1","uniform1fv","flatten","uniform1iv","uniform1uiv","units","allocTexUnits","setValueV1fArray","setValueV2fArray","setValueV3fArray","setValueV4fArray","setValueM2Array","setValueM3Array","setValueM4Array","setValueV1iArray","setValueV2iArray","setValueV3iArray","setValueV4iArray","setValueV1uiArray","setValueV2uiArray","setValueV3uiArray","setValueV4uiArray","setValueT1Array","setValueT6Array","activeInfo","getSingularSetter","getPureArraySetter","PureArrayUniform","updateCache","seq","StructuredUniform","RePathPart","container","uniformObject","path","pathLength","lastIndex","match","matchEnd","idIsIndex","subscript","addUniform","SingleUniform","next","getProgramParameter","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","parseUniform","WebGLUniforms","setOptional","upload","seqWithValue","createShader","shaderSource","compileShader","programIdCount","status","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","trim","getShaderSource","addLineNumbers","functionName","getEncodingComponents","toneMappingName","chunks","extensionDerivatives","envMapCubeUV","tangentSpaceNormalMap","shaderID","extensionFragDepth","rendererExtensionFragDepth","extensionDrawBuffers","rendererExtensionDrawBuffers","extensionShaderTextureLOD","rendererExtensionShaderTextureLod","filterEmptyLine","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","replace","numDirLights","numSpotLights","numRectAreaLights","numPointLights","numHemiLights","numDirLightShadows","numSpotLightShadows","numPointLightShadows","numClippingPlanes","numClipIntersection","includePattern","includeReplacer","include","resolveIncludes","deprecatedUnrollLoopPattern","unrollLoopPattern","loopReplacer","deprecatedLoopReplacer","snippet","precisionstring","shadowMapTypeDefine","shadowMapType","envMapTypeDefine","envMapMode","envMapModeDefine","envMapBlendingDefine","cacheKey","generateShadowMapTypeDefine","generateEnvMapTypeDefine","generateEnvMapModeDefine","generateEnvMapBlendingDefine","gammaFactorDefine","customExtensions","generateExtensions","customDefines","generateDefines","createProgram","prefixVertex","prefixFragment","versionString","isRawShaderMaterial","generatePrecision","shaderName","instancing","instancingColor","supportsVertexTextures","maxBones","useFog","fogExp2","objectSpaceNormalMap","vertexTangents","vertexAlphas","vertexUvs","uvsVertexOnly","skinning","useVertexTexture","doubleSided","flipSided","shadowMapEnabled","physicallyCorrectLights","getToneMappingFunction","getTexelDecodingFunction","mapEncoding","matcapEncoding","envMapEncoding","emissiveMapEncoding","lightMapEncoding","getTexelEncodingFunction","outputEncoding","depthPacking","replaceLightNums","replaceClippingPlaneNums","unrollLoops","vertexGlsl","fragmentGlsl","glVertexShader","WebGLShader","glFragmentShader","attachShader","bindAttribLocation","linkProgram","debug","checkShaderErrors","programLog","getProgramInfoLog","vertexLog","fragmentLog","runnable","haveDiagnostics","LINK_STATUS","vertexErrors","getShaderErrors","fragmentErrors","getError","VALIDATE_STATUS","prefix","deleteShader","cachedUniforms","fetchAttributeLocations","destroy","deleteProgram","usedTimes","shaderIDs","MeshDepthMaterial","MeshDistanceMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial","MeshStandardMaterial","MeshPhysicalMaterial","MeshMatcapMaterial","LineBasicMaterial","LineDashedMaterial","PointsMaterial","ShadowMaterial","SpriteMaterial","parameterNames","bones","nVertexUniforms","nVertexMatrices","shadows","environment","isMeshStandardMaterial","getMaxBones","getTextureEncodingFromMap","isFogExp2","directional","spot","rectArea","hemi","shadowMap","pl","preexistingProgram","WebGLProgram","pop","getParameters","getProgramCacheKey","acquireProgram","releaseProgram","groupOrder","renderItems","renderItemsIndex","opaque","transmissive","defaultProgram","renderItem","getNextRenderItem","customOpaqueSort","customTransparentSort","painterSortStable","reversePainterSortStable","finish","lists","renderCallDepth","list","WebGLRenderList","light","halfWidth","halfHeight","nextVersion","lightA","lightB","UniformsCache","shadowCache","ShadowUniformsCache","hash","directionalLength","pointLength","spotLength","rectAreaLength","hemiLength","numDirectionalShadows","numPointShadows","numSpotShadows","ambient","probe","directionalShadow","spotShadow","rectAreaLTC1","rectAreaLTC2","pointShadow","vector3","matrix42","shadowCastingLightsFirst","isAmbientLight","isLightProbe","sh","coefficients","isDirectionalLight","shadowUniforms","bias","normalBias","mapSize","isSpotLight","penumbra","isRectAreaLight","isPointLight","isHemisphereLight","LTC_FLOAT_1","LTC_FLOAT_2","LTC_HALF_1","LTC_HALF_2","setupView","WebGLLights","lightsArray","shadowsArray","shadowLight","setupLights","setupLightsView","pushLight","pushShadow","renderStates","renderState","WebGLRenderState","isMeshDepthMaterial","isMeshDistanceMaterial","vsm_frag","vsm_vert","_renderer","_objects","_capabilities","_frustum","Frustum","_shadowMapSize","_viewportSize","_viewport","_depthMaterials","_distanceMaterials","_materialCache","_maxTextureSize","shadowMaterialVertical","SAMPLE_RATE","HALF_SAMPLE_RATE","shadow_pass","resolution","shadowMaterialHorizontal","HORIZONTAL_PASS","fullScreenTri","fullScreenMesh","autoUpdate","activeCubeFace","getActiveCubeFace","activeMipmapLevel","getActiveMipmapLevel","_state","setBlending","setTest","setScissorTest","shadowFrameExtents","getFrameExtents","isPointLightShadow","pars","mapPass","viewportCount","getViewportCount","vp","getViewport","updateMatrices","getFrustum","renderObject","VSMPass","renderBufferDirect","useMorphing","result","getMaterialVariant","getDepthMaterialVariant","customMaterial","customDepthMaterial","getDistanceMaterialVariant","customDistanceMaterial","keyA","keyB","materialsForVariant","cachedMaterial","shadowCamera","kl","depthMaterial","getDepthMaterial","locked","currentColorMask","currentColorClear","setMask","colorMask","setLocked","lock","currentDepthMask","currentDepthFunc","currentDepthClear","DEPTH_TEST","depthMask","setFunc","NEVER","ALWAYS","LESS","LEQUAL","EQUAL","GEQUAL","GREATER","NOTEQUAL","clearDepth","currentStencilMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilClear","stencilTest","STENCIL_TEST","stencilMask","setOp","stencilOp","clearStencil","colorBuffer","ColorBuffer","DepthBuffer","StencilBuffer","enabledCapabilities","xrFramebuffer","currentBoundFramebuffers","currentProgram","currentBlendingEnabled","currentBlending","currentBlendEquation","currentBlendSrc","currentBlendDst","currentBlendEquationAlpha","currentBlendSrcAlpha","currentBlendDstAlpha","currentPremultipledAlpha","currentFlipSided","currentCullFace","currentLineWidth","currentPolygonOffsetFactor","currentPolygonOffsetUnits","MAX_COMBINED_TEXTURE_IMAGE_UNITS","lineWidthAvailable","glVersion","VERSION","currentTextureSlot","currentBoundTextures","scissorParam","SCISSOR_BOX","viewportParam","VIEWPORT","currentScissor","currentViewport","createTexture","bindTexture","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","texImage2D","RGBA","emptyTextures","TEXTURE_2D","TEXTURE_CUBE_MAP","TEXTURE_CUBE_MAP_POSITIVE_X","setFlipSided","setCullFace","CULL_FACE","framebuffer","bindFramebuffer","FRAMEBUFFER","DRAW_FRAMEBUFFER","useProgram","equationToGL","FUNC_ADD","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","MIN","MAX","MIN_EXT","MAX_EXT","factorToGL","ZERO","ONE","SRC_COLOR","SRC_ALPHA","SRC_ALPHA_SATURATE","DST_COLOR","DST_ALPHA","ONE_MINUS_SRC_COLOR","ONE_MINUS_SRC_ALPHA","ONE_MINUS_DST_COLOR","ONE_MINUS_DST_ALPHA","BLEND","blendFuncSeparate","blendFunc","blendEquationSeparate","frontFaceCW","setPolygonOffset","SAMPLE_ALPHA_TO_COVERAGE","frontFace","CW","CCW","cullFace","BACK","FRONT","FRONT_AND_BACK","lineWidth","factor","POLYGON_OFFSET_FILL","SCISSOR_TEST","webglSlot","TEXTURE0","activeTexture","webglType","webglTexture","boundTexture","compressedTexImage2D","texImage3D","KEEP","READ_FRAMEBUFFER","bindXRFramebuffer","setMaterial","setLineWidth","unbindTexture","_gl","utils","_videoTextures","useOffscreenCanvas","OffscreenCanvas","err","needsPowerOfTwo","needsNewCanvas","maxSize","createCanvas","supportsMips","generateMipmap","textureProperties","__maxMipLevel","log2","internalFormatName","glFormat","glType","RED","R32F","R16F","R8","RGB","RGB32F","RGB16F","RGB8","RGBA32F","RGBA16F","RGBA8","LINEAR","deallocateTexture","isVideoTexture","onRenderTargetDispose","deallocateRenderTarget","__webglInit","deleteTexture","__webglTexture","renderTargetProperties","deleteFramebuffer","__webglFramebuffer","__webglDepthbuffer","deleteRenderbuffer","__webglMultisampledFramebuffer","__webglColorRenderbuffer","__webglDepthRenderbuffer","attachmentProperties","textureUnits","textureUnit","slot","updateVideoTexture","__version","complete","uploadTexture","TEXTURE_2D_ARRAY","TEXTURE_3D","uploadCubeTexture","wrappingToGL","REPEAT","CLAMP_TO_EDGE","MIRRORED_REPEAT","filterToGL","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","textureType","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXTURE_WRAP_R","filterFallback","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","initTexture","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","UNPACK_COLORSPACE_CONVERSION_WEBGL","NONE","textureNeedsPowerOfTwo","isPowerOfTwo$1","resizeImage","convert","glInternalFormat","getInternalFormat","setTextureParameters","mipmap","isDepthTexture","DEPTH_COMPONENT","DEPTH_COMPONENT32F","DEPTH_COMPONENT24","DEPTH24_STENCIL8","DEPTH_COMPONENT16","DEPTH_STENCIL","isCompressedTexture","textureNeedsGenerateMipmaps","isCompressed","cubeImage","mipmapImage","attachment","textureTarget","framebufferTexture2D","renderbuffer","isMultisample","bindRenderbuffer","RENDERBUFFER","getRenderTargetSamples","renderbufferStorageMultisample","renderbufferStorage","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL_ATTACHMENT","isCube","setTexture2D","webglDepthTexture","setupDepthTexture","createRenderbuffer","setupRenderBufferStorage","isMultipleRenderTargets","isRenderTarget3D","createFramebuffer","COLOR_ATTACHMENT0","setupFrameBufferTexture","glTextureType","isTexture3D","setupDepthRenderbuffer","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","blitFramebuffer","warnedTexture2D","warnedTextureCube","setTextureCube","resetTextureUnits","setupRenderTarget","updateRenderTargetMipmap","updateMultisampleRenderTarget","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","HALF_FLOAT_OES","ALPHA","LUMINANCE","LUMINANCE_ALPHA","RED_INTEGER","RG","RG_INTEGER","RGB_INTEGER","RGBA_INTEGER","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","COMPRESSED_RGB_ETC1_WEBGL","COMPRESSED_RGB8_ETC2","COMPRESSED_RGBA8_ETC2_EAC","UNSIGNED_INT_24_8","UNSIGNED_INT_24_8_WEBGL","cameras","ArrayCamera","isArrayCamera","Group","isGroup","_moveEvent","_targetRay","_grip","_hand","getHandSpace","joints","inputState","pinching","getTargetRaySpace","hasLinearVelocity","linearVelocity","hasAngularVelocity","angularVelocity","getGripSpace","disconnect","inputSource","referenceSpace","inputPose","gripPose","handPose","targetRay","grip","hand","visibilityState","getPose","targetRaySpace","transform","inputjoint","jointPose","getJointPose","jointName","joint","jointRadius","indexTip","thumbTip","distanceToPinch","threshold","handedness","gripSpace","framebufferScaleFactor","referenceSpaceType","pose","controllers","inputSourcesMap","Map","cameraL","cameraR","cameraVR","_currentDepthNear","_currentDepthFar","cameraAutoUpdate","isPresenting","getController","controller","WebXRController","getControllerGrip","getHand","setFramebufferScaleFactor","setReferenceSpaceType","getReferenceSpace","setSession","onSessionEvent","onSessionEnd","onInputSourcesChange","getContextAttributes","xrCompatible","makeXRCompatible","layerInit","antialias","baseLayer","XRWebGLLayer","updateRenderState","requestReferenceSpace","inputSources","removed","added","cameraLPos","cameraRPos","ipd","projL","projR","topFov","bottomFov","leftFov","rightFov","zOffset","xOffset","near2","far2","left2","right2","top2","bottom2","updateCamera","depthNear","depthFar","setProjectionFromUnion","getCamera","onAnimationFrameCallback","getViewerPose","views","cameraVRNeedsUpdate","WebGLAnimation","isFog","density","pixelRatio","transmissionRenderTarget","refreshUniformsCommon","isMeshLambertMaterial","refreshUniformsLambert","isMeshToonMaterial","refreshUniformsToon","isMeshPhongMaterial","refreshUniformsPhong","isMeshPhysicalMaterial","refreshUniformsPhysical","refreshUniformsStandard","isMeshMatcapMaterial","refreshUniformsMatcap","refreshUniformsDepth","refreshUniformsDistance","isMeshNormalMaterial","refreshUniformsNormal","isLineBasicMaterial","refreshUniformsLine","isLineDashedMaterial","refreshUniformsDash","isPointsMaterial","refreshUniformsPoints","isSpriteMaterial","refreshUniformsSprites","isShadowMaterial","uvScaleMap","uv2ScaleMap","refreshFogUniforms","refreshMaterialUniforms","display","createCanvasElement","_context","_alpha","_depth","_stencil","_antialias","_premultipliedAlpha","_preserveDrawingBuffer","preserveDrawingBuffer","_powerPreference","powerPreference","_failIfMajorPerformanceCaveat","failIfMajorPerformanceCaveat","currentRenderList","currentRenderState","renderListStack","renderStateStack","domElement","sortObjects","toneMappingExposure","_this","_isContextLost","_currentActiveCubeFace","_currentActiveMipmapLevel","_currentRenderTarget","_currentMaterialId","_currentCamera","_currentViewport","_currentScissor","_currentScissorTest","_width","_height","_pixelRatio","_opaqueSort","_transparentSort","_scissor","_scissorTest","_currentDrawBuffers","_clippingEnabled","_localClippingEnabled","_transmissionRenderTarget","_projScreenMatrix","_vector3","_emptyScene","overrideMaterial","contextNames","contextAttributes","contextName","onContextLost","onContextRestore","isWebGL1Renderer","shift","programCache","renderLists","morphtargets","bufferRenderer","indexedBufferRenderer","WebGLExtensions","WebGLCapabilities","WebGLUtils","WebGLState","WebGLInfo","WebGLProperties","WebGLTextures","WebGLCubeMaps","WebGLAttributes","WebGLBindingStates","WebGLGeometries","WebGLObjects","WebGLMorphtargets","WebGLClipping","WebGLPrograms","WebGLMaterials","WebGLRenderLists","WebGLRenderStates","WebGLBackground","WebGLShadowMap","WebGLBufferRenderer","WebGLIndexedBufferRenderer","initGLContext","WebXRManager","forceContextLoss","loseContext","forceContextRestore","restoreContext","getPixelRatio","setPixelRatio","updateStyle","setViewport","getDrawingBufferSize","setDrawingBufferSize","getCurrentViewport","getScissor","setScissor","getScissorTest","boolean","setOpaqueSort","method","setTransparentSort","bits","onXRSessionStart","onXRSessionEnd","preventDefault","infoAutoReset","shadowMapAutoUpdate","shadowMapNeedsUpdate","onMaterialDispose","deallocateMaterial","releaseMaterialProgramReferences","renderBufferImmediate","hasPositions","hasNormals","hasUvs","hasColors","positionArray","DYNAMIC_DRAW","normalArray","uvArray","colorArray","setProgram","rangeFactor","dataCount","rangeStart","rangeCount","drawStart","drawEnd","drawCount","getTargetPixelRatio","isLineSegments","isLineLoop","isSprite","compile","material2","getProgram","projectObject","opaqueObjects","transmissiveObjects","transparentObjects","renderObjects","renderTransmissiveObjects","isLOD","isImmediateRenderObject","camera2","renderObjectImmediate","lightsStateVersion","programCacheKey","updateCommonMaterialProperties","needsLights","materialNeedsLights","progUniforms","uniformsList","needsProgramChange","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","uCamPos","cameraPosition","isOrthographicCamera","boneTexture","computeBoneTexture","boneTextureSize","markUniformsLightsNeedsUpdate","framebufferBound","drawBuffersWEBGL","layer","framebufferTextureLayer","readRenderTargetPixels","activeCubeFaceIndex","textureFormat","IMPLEMENTATION_COLOR_READ_FORMAT","halfFloatSupportedByExt","IMPLEMENTATION_COLOR_READ_TYPE","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","copyFramebufferToTexture","level","levelScale","copyTexImage2D","copyTextureToTexture","srcTexture","dstTexture","texSubImage2D","compressedTexSubImage2D","copyTextureToTexture3D","sourceBox","glTarget","unpackRowLen","UNPACK_ROW_LENGTH","unpackImageHeight","UNPACK_IMAGE_HEIGHT","unpackSkipPixels","UNPACK_SKIP_PIXELS","unpackSkipRows","UNPACK_SKIP_ROWS","unpackSkipImages","UNPACK_SKIP_IMAGES","texSubImage3D","resetState","__THREE_DEVTOOLS__","CustomEvent","detail","WebGLRenderer","WebGL1Renderer","FogExp2","arrayBuffers","_uuid","ib","InterleavedBuffer","isInterleavedBuffer","_vector$6","interleavedBuffer","interleavedBuffers","InterleavedBufferAttribute","_geometry","_intersectPoint","_worldScale","_mvPosition","_alignedPosition","_rotatedPosition","_viewWorldMatrix","_vA","_vB","_vC","_uvA","_uvB","_uvC","float32Array","transformVertex","Sprite","vertexPosition","mvPosition","_v1$2","_v2$1","_currentLevel","levels","addLevel","getCurrentLevel","getObjectForDistance","_basePosition","_skinIndex","_skinWeight","_vector$5","_matrix","bindMatrixInverse","bind","calculateInverses","normalizeSkinWeights","skinWeight","skinIndex","weight","boneIndex","boneInverses","SkinnedMesh","Bone","isBone","DataTexture","_offsetMatrix","_identityMatrix","boneMatrices","inverse","bone","Skeleton","getBoneByName","fromJSON","json","boneInverse","_instanceLocalMatrix","_instanceWorldMatrix","_instanceIntersects","_mesh","getColorAt","getMatrixAt","raycastTimes","instanceId","setColorAt","setMatrixAt","InstancedMesh","linecap","linejoin","_start$1","_end$1","_inverseMatrix$1","_ray$1","_sphere$1","computeLineDistances","lineDistances","params","Line","localThreshold","localThresholdSq","vStart","vEnd","interSegment","interRay","distSq","_start","_end","LineSegments","LineLoop","_inverseMatrix","_ray","_sphere","_position$2","Points","testPoint","rayPointDistanceSq","intersectPoint","distanceToRay","video","requestVideoFrameCallback","updateVideo","hasVideoFrameCallback","readyState","HAVE_CURRENT_DATA","VideoTexture","CompressedTexture","CanvasTexture","isCanvasTexture","DepthTexture","segments","thetaStart","thetaLength","vertex","segment","radiusTop","radiusBottom","radialSegments","openEnded","indexArray","generateTorso","generateCap","slope","indexRow","sinTheta","cosTheta","centerIndexStart","centerIndexEnd","vertexBuffer","uvBuffer","subdivide","applyRadius","generateUVs","getVertexByIndex","subdivideFace","cols","aj","bj","rows","pushVertex","azimuth","inclination","correctUVs","correctSeam","centroid","azi","correctUV","PolyhedronGeometry","_v0","_v1$1","_normal","_triangle","thresholdAngle","precisionPoints","thresholdDot","indexAttr","positionAttr","indexCount","indexArr","vertKeys","hashes","edgeData","jNext","vecHash0","vecHash1","reverseHash","index0","Earcut","triangulate","holeIndices","dim","hasHoles","outerLen","outerNode","linkedList","prev","invSize","eliminateHoles","earcutLinked","clockwise","last","signedArea","insertNode","removeNode","again","steiner","area","ear","pass","indexCurve","isEarHashed","isEar","filterPoints","cureLocalIntersections","splitEarcut","pointInTriangle","minTX","minTY","maxTX","maxTY","zOrder","prevZ","nextZ","locallyInside","isValidDiagonal","splitPolygon","queue","getLeftmost","compareX","eliminateHole","hole","findHoleBridge","hx","hy","mx","my","tanMin","sectorContainsSector","sortLinked","tail","numMerges","pSize","qSize","inSize","leftmost","px","py","intersectsPolygon","middleInside","q1","q2","o1","o2","o3","o4","onSegment","num","inside","Node","an","bp","sum","contour","isClockWise","pts","ShapeUtils","triangulateShape","holes","faces","removeDupEndPts","addContour","holeIndex","verticesArray","addShape","placeholder","curveSegments","steps","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","extrudePath","uvgen","UVGenerator","WorldUVGenerator","amount","extrudePts","extrudeByPath","splineTube","binormal","position2","getSpacedPoints","computeFrenetFrames","shapePoints","extractPoints","reverse","hl","ahole","pt","vec","vlen","flen","inPt","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","contourMovements","getBevelVec","holesMovements","oneHoleMovements","verticesMovements","bs","vert","scalePt2","binormals","buildLidFaces","buildSideFaces","f3","layeroffset","sidewalls","sl","slen1","slen2","f4","addVertex","nextIndex","generateTopUV","addUV","generateSideWallUV","vector2","toJSON$1","indexA","indexB","indexC","a_x","a_y","b_x","b_y","c_x","c_y","indexD","a_z","b_z","c_z","d_x","d_y","d_z","phiStart","phiLength","inverseSegments","base","n1","func","slices","stacks","EPS","pu","pv","sliceCount","innerRadius","outerRadius","thetaSegments","phiSegments","radiusStep","thetaSegmentLevel","indexOffset","shapeVertices","shapeHoles","shapeHole","thetaEnd","grid","verticesRow","uOffset","ExtrudeGeometry","text","font","isFont","generateShapes","tube","tubularSegments","arc","P1","P2","B","T","N","calculatePositionOnCurve","cu","su","quOverP","cs","closed","frames","P","generateBufferData","generateSegment","generateIndices","getPointAt","edge","edges","o","ol","edge1","edge2","Geometries","BoxBufferGeometry","CircleGeometry","CircleBufferGeometry","ConeGeometry","ConeBufferGeometry","CylinderBufferGeometry","DodecahedronGeometry","DodecahedronBufferGeometry","EdgesGeometry","ExtrudeBufferGeometry","IcosahedronGeometry","IcosahedronBufferGeometry","LatheGeometry","LatheBufferGeometry","OctahedronGeometry","OctahedronBufferGeometry","ParametricGeometry","ParametricBufferGeometry","PlaneBufferGeometry","PolyhedronBufferGeometry","RingGeometry","RingBufferGeometry","ShapeGeometry","ShapeBufferGeometry","SphereGeometry","SphereBufferGeometry","TetrahedronGeometry","TetrahedronBufferGeometry","TextGeometry","TextBufferGeometry","TorusGeometry","TorusBufferGeometry","TorusKnotGeometry","TorusKnotBufferGeometry","TubeGeometry","TubeBufferGeometry","WireframeGeometry","RawShaderMaterial","ior","Materials","AnimationUtils","arraySlice","from","to","isTypedArray","convertArray","forceClone","ArrayBuffer","isView","DataView","getKeyframeOrder","times","compareTime","sortedArray","nValues","srcOffset","flattenJSON","jsonKeys","valuePropertyName","subclip","sourceClip","startFrame","endFrame","fps","clip","tracks","track","valueSize","getValueSize","minStartTime","resetDuration","makeClipAdditive","targetClip","referenceFrame","referenceClip","numTracks","referenceTime","referenceTrack","referenceTrackType","ValueTypeName","targetTrack","find","referenceOffset","referenceValueSize","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","targetOffset","targetValueSize","referenceValue","startIndex","endIndex","interpolant","evaluate","resultBuffer","referenceQuat","numTimes","valueStart","valueEnd","blendMode","parameterPositions","sampleValues","sampleSize","_cachedIndex","settings","DefaultSettings_","pp","validate_interval","seek","linear_scan","forward_scan","giveUpAt","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","getSettings_","copySampleValue_","Interpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","endingStart","endingEnd","iPrev","iNext","tPrev","tNext","halfDt","o0","oP","oN","wP","wN","ppp","sP","sN","offset1","offset0","weight1","weight0","interpolation","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","trackType","getInterpolation","InterpolantFactoryMethodDiscrete","DiscreteInterpolant","InterpolantFactoryMethodLinear","LinearInterpolant","InterpolantFactoryMethodSmooth","CubicInterpolant","factoryMethod","timeOffset","timeScale","startTime","endTime","nKeys","validate","valid","prevTime","currTime","optimize","smoothInterpolation","writeIndex","keep","timeNext","offsetP","offsetN","readOffset","writeOffset","TypedKeyframeTrack","KeyframeTrack","BooleanKeyframeTrack","ColorKeyframeTrack","NumberKeyframeTrack","QuaternionLinearInterpolant","QuaternionKeyframeTrack","StringKeyframeTrack","VectorKeyframeTrack","duration","jsonTracks","frameTime","parseKeyframeTrack","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","findByName","objectOrClipArray","clipArray","CreateClipsFromMorphTargetSequences","animationToMorphTargets","pattern","morphTarget","parts","animationMorphTargets","clips","parseAnimation","addNonemptyTrack","trackName","animationKeys","propertyName","destTracks","clipName","hierarchyTracks","hierarchy","morphTargetNames","morphTargetName","animationKey","boneName","typeName","getTrackTypeForValueTypeName","Cache","files","file","onLoad","onProgress","onError","isLoading","itemsLoaded","itemsTotal","urlModifier","handlers","onStart","itemStart","itemEnd","itemError","resolveURL","setURLModifier","addHandler","regex","loader","removeHandler","getHandler","DefaultLoadingManager","LoadingManager","manager","crossOrigin","withCredentials","resourcePath","requestHeader","load","loadAsync","Promise","resolve","reject","setCrossOrigin","setWithCredentials","setPath","setResourcePath","setRequestHeader","loading","Loader","dataUriRegex","dataUriRegexResult","request","mimeType","isBase64","decodeURIComponent","atob","response","responseType","charCodeAt","Blob","parser","DOMParser","parseFromString","XMLHttpRequest","open","callbacks","overrideMimeType","header","send","setResponseType","setMimeType","FileLoader","AnimationClip","loaded","texDatas","mipmapCount","loadTexture","isCubemap","onImageLoad","onImageError","substr","urls","ImageLoader","texData","isJPEG","search","arcLengthDivisions","getPoint","optionalTarget","getUtoTmapping","getPoints","divisions","getLength","lengths","getLengths","cacheArcLengths","current","updateArcLengths","arcLengths","targetArcLength","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","t2","pt1","pt2","getTangentAt","mat","MAX_VALUE","tz","Curve","aX","aY","xRadius","yRadius","aStartAngle","aEndAngle","aClockwise","aRotation","twoPi","deltaAngle","samePoints","EllipseCurve","isEllipseCurve","aRadius","ArcCurve","isArcCurve","c0","initCatmullRom","x3","tension","initNonuniformCatmullRom","dt0","dt1","dt2","calc","t3","CubicPoly","pz","curveType","intPoint","CatmullRomCurve3","isCatmullRomCurve3","QuadraticBezierP0","QuadraticBezierP1","QuadraticBezierP2","CubicBezierP0","CubicBezierP1","CubicBezierP2","CubicBezierP3","v3","CubicBezier","CubicBezierCurve","isCubicBezierCurve","CubicBezierCurve3","isCubicBezierCurve3","LineCurve","isLineCurve","isLineCurve3","QuadraticBezier","QuadraticBezierCurve","isQuadraticBezierCurve","QuadraticBezierCurve3","isQuadraticBezierCurve3","CatmullRom","SplineCurve","isSplineCurve","Curves","LineCurve3","curves","autoClose","curve","closePath","startPoint","endPoint","curveLengths","getCurveLengths","diff","lens","cacheLengths","sums","CurvePath","currentPoint","moveTo","lineTo","quadraticCurveTo","aCPx","aCPy","bezierCurveTo","aCP1x","aCP1y","aCP2x","aCP2y","splineThru","npts","absarc","absellipse","ellipse","firstPoint","lastPoint","Path","getPointsHoles","holesPts","Light","HemisphereLight","_projScreenMatrix$1","_lightPositionWorld$1","_lookTarget$1","_frameExtents","_viewportCount","_viewports","shadowMatrix","viewportIndex","LightShadow","SpotLightShadow","isSpotLightShadow","power","SpotLight","_lightPositionWorld","_lookTarget","_cubeDirections","_cubeUps","PointLightShadow","PointLight","scaleW","scaleH","OrthographicCamera","DirectionalLightShadow","isDirectionalLightShadow","DirectionalLight","RectAreaLight","zero","getAt","coeff","getIrradianceAt","addScaledSH","getBasisAt","shBasis","SphericalHarmonics3","isSphericalHarmonics3","LightProbe","getTexture","shading","setTextures","decodeText","TextDecoder","decode","fromCharCode","escape","extractUrlBase","lastIndexOf","InstancedBufferGeometry","InstancedBufferAttribute","interleavedBufferMap","arrayBufferMap","getArrayBuffer","getTypedArray","arrayBuffer","typedArray","bufferAttribute","getInterleavedBuffer","bufferAttributeConstr","drawcalls","offsets","LoaderUtils","parseAnimations","parseShapes","parseGeometries","parseImages","parseTextures","parseMaterials","parseObject","parseSkeletons","bindSkeletons","hasImages","Shape","geometryShapes","bufferGeometryLoader","BufferGeometryLoader","details","MaterialLoader","loadImage","currentUrl","deserializedImage","deserializeImage","parseConstant","TEXTURE_MAPPING","TEXTURE_WRAPPING","TEXTURE_FILTER","getGeometry","getMaterial","LOD","objectAnimations","setTexturePath","createImageBitmap","fetch","setOptions","fetchOptions","credentials","headers","then","res","blob","colorSpaceConversion","imageBitmap","catch","ImageBitmapLoader","isImageBitmapLoader","subPaths","currentPath","toShapes","isCCW","noHoles","inSubpaths","tmpPath","tmpShape","inPolygon","polyLen","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","toShapesNoHoles","solid","holesFirst","betterShapeHoles","newShapes","newShapeHoles","mainIdx","tmpPoints","ambiguous","toChange","sIdx","sLen","sho","hIdx","ho","hole_unassigned","s2Idx","isPointInsidePolygon","froms","tos","tmpHoles","paths","createPaths","chars","line_height","yMax","yMin","underlineThickness","char","ret","createPath","glyph","glyphs","familyName","ShapePath","cpx","cpy","cpx1","cpy1","cpx2","cpy2","outline","_cachedOutline","action","ha","Font","substring","AudioContext","webkitAudioContext","bufferCopy","decodeAudioData","audioBuffer","sky","ground","HemisphereLightProbe","isHemisphereLightProbe","AmbientLightProbe","isAmbientLightProbe","_eyeRight","_eyeLeft","eyeSep","_cache","eyeSepHalf","eyeSepOnProjection","ymax","xmin","xmax","autoStart","oldTime","elapsedTime","running","getElapsedTime","getDelta","newTime","performance","_position$1","_quaternion$1","_scale$1","_orientation$1","gain","createGain","connect","destination","timeDelta","_clock","Clock","getInput","removeFilter","getFilter","setFilter","getMasterVolume","setMasterVolume","setTargetAtTime","currentTime","positionX","linearRampToValueAtTime","positionY","positionZ","forwardX","forwardY","forwardZ","upX","upY","upZ","setOrientation","autoplay","detune","loop","loopStart","loopEnd","playbackRate","isPlaying","hasPlaybackControl","sourceType","_startedAt","_progress","_connected","filters","getOutput","setNodeSource","audioNode","setMediaElementSource","mediaElement","createMediaElementSource","setMediaStreamSource","mediaStream","createMediaStreamSource","setBuffer","play","delay","createBufferSource","onended","onEnded","setDetune","setPlaybackRate","pause","getFilters","setFilters","getDetune","getPlaybackRate","getLoop","setLoop","setLoopStart","setLoopEnd","getVolume","setVolume","_position","_quaternion","_scale","_orientation","Audio","panner","createPanner","panningModel","getRefDistance","refDistance","setRefDistance","getRolloffFactor","rolloffFactor","setRolloffFactor","getDistanceModel","distanceModel","setDistanceModel","getMaxDistance","maxDistance","setMaxDistance","setDirectionalCone","coneInnerAngle","coneOuterAngle","coneOuterGain","orientationX","orientationY","orientationZ","audio","fftSize","analyser","createAnalyser","frequencyBinCount","getFrequencyData","getByteFrequencyData","getAverageFrequency","binding","mixFunction","mixFunctionAdditive","setIdentity","_slerp","_slerpAdditive","_setAdditiveIdentityQuaternion","_workIndex","_select","_setAdditiveIdentityOther","_lerp","_lerpAdditive","_setAdditiveIdentityNumeric","_mixBufferRegion","_mixBufferRegionAdditive","_setIdentity","_origIndex","_addIndex","cumulativeWeight","cumulativeWeightAdditive","useCount","referenceCount","accumulate","accuIndex","currentWeight","mix","accumulateAdditive","weightAdditive","originalValueOffset","saveOriginalState","getValue","restoreOriginalState","targetIndex","workOffset","_RESERVED_CHARS_RE","_reservedRe","_wordChar","_wordCharOrDot","_directoryRe","_nodeRe","_objectRe","_propertyRe","_trackRe","_supportedObjectNames","targetGroup","optionalParsedPath","parsedPath","PropertyBinding","parseTrackName","_targetGroup","_bindings","subscribe_","firstValidIndex","nCachedObjects_","bindings","unbind","rootNode","node","findNode","nodeName","_getValue_unbound","_setValue_unbound","create","isAnimationObjectGroup","Composite","sanitizeNodeName","matches","results","objectName","objectIndex","propertyIndex","lastDot","searchNodeSubtree","childNode","subTreeNode","_getValue_unavailable","_setValue_unavailable","_getValue_direct","_getValue_array","resolvedProperty","_getValue_arrayElement","_getValue_toArray","_setValue_direct","targetObject","_setValue_direct_setNeedsUpdate","_setValue_direct_setMatrixWorldNeedsUpdate","_setValue_array","dest","_setValue_array_setNeedsUpdate","_setValue_array_setMatrixWorldNeedsUpdate","_setValue_arrayElement","_setValue_arrayElement_setNeedsUpdate","_setValue_arrayElement_setMatrixWorldNeedsUpdate","_setValue_fromArray","_setValue_fromArray_setNeedsUpdate","_setValue_fromArray_setMatrixWorldNeedsUpdate","targetArray","sourceArray","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","ArrayElement","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","_indicesByUUID","_paths","_parsedPaths","_bindingsIndicesByPath","stats","total","inUse","bindingsPerObject","indicesByUUID","parsedPaths","nBindings","knownObject","nObjects","nCachedObjects","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","lastCachedIndex","firstActiveObject","firstActive","uncache","lastObject","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath","AnimationObjectGroup","mixer","localRoot","_mixer","_clip","_localRoot","nTracks","interpolants","interpolantSettings","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","_loopCount","_startTime","_effectiveTimeScale","_effectiveWeight","repetitions","paused","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","_activateAction","_deactivateAction","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setEffectiveWeight","getEffectiveWeight","fadeIn","_scheduleFading","fadeOut","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","halt","startTimeScale","endTimeScale","_lendControlInterpolant","timeScaleInterpolant","getMixer","getClip","getRoot","_root","_update","deltaTime","timeDirection","_updateWeight","timeRunning","_updateTimeScale","clipTime","_updateTime","propertyMixers","interpolantValue","loopCount","pingPong","_setEndings","handle_stop","loopDelta","pending","atStart","atEnd","weightNow","weightThen","_initMemoryManager","_accuIndex","_bindAction","prototypeAction","rootUuid","bindingsByRoot","_bindingsByRootAndName","bindingsByName","_addInactiveBinding","PropertyMixer","clipUuid","actionsForClip","_actionsByClip","knownActions","_addInactiveAction","_lendBinding","_lendAction","_takeBackBinding","_takeBackAction","_actions","_nActiveActions","_nActiveBindings","_controlInterpolants","_nActiveControlInterpolants","actions","controlInterpolants","actionsByClip","actionByRoot","_removeInactiveAction","lastInactiveAction","cacheIndex","knownActionsForClip","lastKnownAction","byClipCacheIndex","_removeInactiveBindingsForAction","_removeInactiveBinding","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","bindingByName","propBinding","lastInactiveBinding","firstInactiveBinding","lastActiveBinding","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","clipAction","optionalRoot","clipObject","existingAction","newAction","AnimationAction","stopAllAction","nActions","setTime","timeInSeconds","uncacheClip","actionsToRemove","uncacheRoot","uncacheAction","AnimationMixer","Uniform","InstancedInterleavedBuffer","setType","setItemSize","setCount","GLBufferAttribute","setFromCamera","coords","intersectObject","ascSort","intersectObjects","other","makeSafe","setFromCartesianCoords","_vector$4","Box2","isBox2","_startP","_startEnd","distanceSq","closestPointToPointParameter","clampToLine","startEnd2","startEnd_startP","ImmediateRenderObject","_vector$3","cone","coneLength","coneWidth","_vector$2","_boneMatrix","_matrixWorldInv","getBoneList","isSkeletonHelper","boneList","sphereSize","_vector$1","_color1","_color2","radials","circles","_v1","_v2","_v3","lightPlane","targetLine","_vector","_camera","pointMap","colorFrustum","colorCone","colorUp","colorTarget","colorCross","addLine","addPoint","setPoint","_box","positions2","_axis","_lineGeometry","_coneGeometry","headLength","headWidth","setDirection","setColor","_floatView","_int32View","toHalfFloat","val","LOD_MIN","LOD_MAX","SIZE_MAX","EXTRA_LOD_SIGMA","TOTAL_LODS","ENCODINGS","backgroundMaterial","backgroundBox","_flatCamera","_lodPlanes","_sizeLods","_sigmas","_createPlanes","_clearColor","_oldTarget","PHI","INV_PHI","_axisDirections","maxComponent","fExp","_pingPongRenderTarget","_blurMaterial","_getBlurShader","_equirectShader","_cubemapShader","_compileMaterial","fromScene","sigma","cubeUVRenderTarget","_allocateTargets","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","fromEquirectangular","equirectangular","_fromTexture","fromCubemap","compileCubemapShader","_getCubemapShader","compileEquirectangularShader","_getEquirectShader","outputTarget","_setViewport","_textureToCubeUV","_isLDR","_createRenderTarget","tmpMesh","cubeCamera","upSign","forwardSign","originalAutoClear","useSolidColor","convertLinearToRGBE","col","poleAxis","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","blurMaterial","STANDARD_DEVIATIONS","blurMesh","blurUniforms","pixels","radiansPerPixel","sigmaPixels","weights","outputSize","lod","sizeLod","texelSize","cubeFaces","positionSize","uvSize","faceIndexSize","coordinates","fill","shaderMaterial","_getCommonVertexShader","_getEncodings","LineStrip","LinePieces","NoColors","FaceColors","VertexColors","isMultiMaterial","Int8BufferAttribute","Uint8BufferAttribute","Uint8ClampedBufferAttribute","Int16BufferAttribute","Int32BufferAttribute","Float64BufferAttribute","construct","fromPoints","AxesHelper","BoxHelper","GridHelper","setColors","SkeletonHelper","Handlers","DataTextureLoader","empty","isIntersectionBox","isIntersectionSphere","setFromMatrix","Line3","flattenToArrayOffset","multiplyVector3","multiplyVector3Array","applyToBufferAttribute","applyToVector3Array","getInverse","extractPosition","getPosition","multiplyToArray","multiplyVector4","rotateAxis","crossVector","rotateByAxis","makeFrustum","isIntersectionLine","isIntersectionPlane","barycoordFromPoint","midpoint","prototypenormal","extractAllPoints","extrude","makeGeometry","fromAttribute","distanceToManhattan","lengthManhattan","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","getColumnFromMatrix","applyProjection","getChildByName","renderDepth","getWorldRotation","applyMatrix","eulerOrder","useQuaternion","setDrawMode","drawMode","initBones","setLens","onlyShadow","shadowCameraFov","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraVisible","shadowDarkness","shadowMapWidth","shadowMapHeight","dynamic","setDynamic","copyIndicesArray","setArray","addIndex","addAttribute","addDrawCall","clearDrawCalls","computeOffsets","removeAttribute","getArrays","addShapeList","wrapAround","overdraw","wrapRGB","clearTarget","animate","getCurrentRenderTarget","getPrecision","resetGLState","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","supportsInstancedArrays","enableScissorTest","initMaterial","addPrePlugin","addPostPlugin","updateShadowMap","setFaceCulling","allocTextureUnit","getActiveMipMapLevel","shadowMapCullFace","vr","gammaInput","gammaOutput","toneMappingWhitePoint","renderReverseSided","renderSingleSided","audioLoader","AudioLoader","AudioAnalyser","getData","updateCubeMap","TextureLoader","loadTextureCube","CubeTextureLoader","loadCompressedTexture","loadCompressedTextureCube","SceneUtils","createMultiMaterialObject","detach","revision","__THREE__","AnimationLoader","ArrowHelper","AudioListener","AxisHelper","BinaryTextureLoader","BoundingBoxHelper","Box3Helper","CameraHelper","CanvasRenderer","CompressedTextureLoader","Cylindrical","DataUtils","DirectionalLightHelper","DynamicBufferAttribute","EdgesHelper","Float32Attribute","Float64Attribute","FontLoader","HemisphereLightHelper","Int16Attribute","Int32Attribute","Int8Attribute","JSONLoader","LensFlare","MeshFaceMaterial","MultiMaterial","ObjectLoader","PMREMGenerator","Particle","ParticleBasicMaterial","ParticleSystem","ParticleSystemMaterial","PlaneHelper","PointCloud","PointCloudMaterial","PointLightHelper","PolarGridHelper","PositionalAudio","Raycaster","Spherical","SpotLightHelper","StereoCamera","Uint16Attribute","Uint32Attribute","Uint8Attribute","Uint8ClampedAttribute","Vertex","WebGLRenderTargetCube","WireframeHelper","XHRLoader","OrbitControls","AddRenderer","AddCamera","AddControls","HandleResize","innerWidth","innerHeight","controls","autoRotate","enableDamping","dampingFactor","clientWidth","clientHeight","devicePixelRatio"],"version":3,"file":"index.72166a09.js.map","sourceRoot":"/__parcel_source_root/"}